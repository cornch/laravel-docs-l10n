# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Taylor Otwell
# This file is distributed under the same license as the Laravel Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Laravel Documentation VERSION\n"
"POT-Creation-Date: 2021-09-13 00:06+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: docs/master/eloquent-relationships.md:1
#, markdown-text, no-wrap
msgid "Eloquent: Relationships"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Introduction](#introduction)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Defining Relationships](#defining-relationships)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[One To One](#one-to-one)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[One To Many](#one-to-many)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[One To Many (Inverse) / Belongs To](#one-to-many-inverse)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Has One Through](#has-one-through)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Has Many Through](#has-many-through)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Many To Many Relationships](#many-to-many)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Retrieving Intermediate Table "
"Columns](#retrieving-intermediate-table-columns)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Filtering Queries Via Intermediate Table "
"Columns](#filtering-queries-via-intermediate-table-columns)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Defining Custom Intermediate Table "
"Models](#defining-custom-intermediate-table-models)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Polymorphic Relationships](#polymorphic-relationships)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[One To One](#one-to-one-polymorphic-relations)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[One To Many](#one-to-many-polymorphic-relations)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Many To Many](#many-to-many-polymorphic-relations)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Custom Polymorphic Types](#custom-polymorphic-types)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Dynamic Relationships](#dynamic-relationships)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Querying Relations](#querying-relations)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Relationship Methods Vs. Dynamic "
"Properties](#relationship-methods-vs-dynamic-properties)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Querying Relationship Existence](#querying-relationship-existence)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Querying Relationship Absence](#querying-relationship-absence)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Querying Morph To Relationships](#querying-morph-to-relationships)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Aggregating Related Models](#aggregating-related-models)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Counting Related Models](#counting-related-models)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Other Aggregate Functions](#other-aggregate-functions)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Counting Related Models On Morph To "
"Relationships](#counting-related-models-on-morph-to-relationships)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Eager Loading](#eager-loading)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Constraining Eager Loads](#constraining-eager-loads)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Lazy Eager Loading](#lazy-eager-loading)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid ""
"[Inserting & Updating Related "
"Models](#inserting-and-updating-related-models)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[The `save` Method](#the-save-method)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[The `create` Method](#the-create-method)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Belongs To Relationships](#updating-belongs-to-relationships)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Many To Many Relationships](#updating-many-to-many-relationships)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/eloquent-relationships.md:38
#, markdown-text
msgid "[Touching Parent Timestamps](#touching-parent-timestamps)"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:40
#, markdown-text, no-wrap
msgid "<a name=\"introduction\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:40
#, markdown-text, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:43
#, markdown-text
msgid ""
"Database tables are often related to one another. For example, a blog post "
"may have many comments or an order could be related to the user who placed "
"it. Eloquent makes managing and working with these relationships easy, and "
"supports a variety of common relationships:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:54
#, markdown-text, no-wrap
msgid ""
"<div class=\"content-list\" markdown=\"1\">\n"
"- [One To One](#one-to-one)\n"
"- [One To Many](#one-to-many)\n"
"- [Many To Many](#many-to-many)\n"
"- [Has One Through](#has-one-through)\n"
"- [Has Many Through](#has-many-through)\n"
"- [One To One (Polymorphic)](#one-to-one-polymorphic-relations)\n"
"- [One To Many (Polymorphic)](#one-to-many-polymorphic-relations)\n"
"- [Many To Many (Polymorphic)](#many-to-many-polymorphic-relations)\n"
"</div>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:56
#, markdown-text, no-wrap
msgid "<a name=\"defining-relationships\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:56
#, markdown-text, no-wrap
msgid "Defining Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:59
#, markdown-text
msgid ""
"Eloquent relationships are defined as methods on your Eloquent model "
"classes. Since relationships also serve as powerful [query "
"builders](/docs/{{version}}/queries), defining relationships as methods "
"provides powerful method chaining and querying capabilities. For example, we "
"may chain additional query constraints on this `posts` relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:61
#: docs/master/eloquent-relationships.md:986
#, markdown-text, no-wrap
msgid "    $user->posts()->where('active', 1)->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:63
#, markdown-text
msgid ""
"But, before diving too deep into using relationships, let's learn how to "
"define each type of relationship supported by Eloquent."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:65
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:65
#, markdown-text, no-wrap
msgid "One To One"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:68
#, markdown-text
msgid ""
"A one-to-one relationship is a very basic type of database relationship. For "
"example, a `User` model might be associated with one `Phone` model. To "
"define this relationship, we will place a `phone` method on the `User` "
"model. The `phone` method should call the `hasOne` method and return its "
"result. The `hasOne` method is available to your model via the model's "
"`Illuminate\\Database\\Eloquent\\Model` base class:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:70
#: docs/master/eloquent-relationships.md:104
#: docs/master/eloquent-relationships.md:148
#: docs/master/eloquent-relationships.md:194
#: docs/master/eloquent-relationships.md:301
#: docs/master/eloquent-relationships.md:364
#: docs/master/eloquent-relationships.md:434
#: docs/master/eloquent-relationships.md:478
#: docs/master/eloquent-relationships.md:562
#: docs/master/eloquent-relationships.md:581
#: docs/master/eloquent-relationships.md:640
#: docs/master/eloquent-relationships.md:742
#: docs/master/eloquent-relationships.md:838
#: docs/master/eloquent-relationships.md:862
#: docs/master/eloquent-relationships.md:963
#: docs/master/eloquent-relationships.md:1276
#: docs/master/eloquent-relationships.md:1340
#: docs/master/eloquent-relationships.md:1384
#: docs/master/eloquent-relationships.md:1482
#: docs/master/eloquent-relationships.md:1680
#, markdown-text, no-wrap
msgid "    <?php\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:72
#: docs/master/eloquent-relationships.md:106
#: docs/master/eloquent-relationships.md:150
#: docs/master/eloquent-relationships.md:196
#: docs/master/eloquent-relationships.md:303
#: docs/master/eloquent-relationships.md:366
#: docs/master/eloquent-relationships.md:436
#: docs/master/eloquent-relationships.md:480
#: docs/master/eloquent-relationships.md:564
#: docs/master/eloquent-relationships.md:583
#: docs/master/eloquent-relationships.md:642
#: docs/master/eloquent-relationships.md:744
#: docs/master/eloquent-relationships.md:840
#: docs/master/eloquent-relationships.md:864
#: docs/master/eloquent-relationships.md:965
#: docs/master/eloquent-relationships.md:1278
#: docs/master/eloquent-relationships.md:1386
#: docs/master/eloquent-relationships.md:1682
#, markdown-text, no-wrap
msgid "    namespace App\\Models;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:74
#: docs/master/eloquent-relationships.md:108
#: docs/master/eloquent-relationships.md:152
#: docs/master/eloquent-relationships.md:198
#: docs/master/eloquent-relationships.md:305
#: docs/master/eloquent-relationships.md:368
#: docs/master/eloquent-relationships.md:438
#: docs/master/eloquent-relationships.md:482
#: docs/master/eloquent-relationships.md:566
#: docs/master/eloquent-relationships.md:644
#: docs/master/eloquent-relationships.md:746
#: docs/master/eloquent-relationships.md:842
#: docs/master/eloquent-relationships.md:866
#: docs/master/eloquent-relationships.md:967
#: docs/master/eloquent-relationships.md:1280
#: docs/master/eloquent-relationships.md:1342
#: docs/master/eloquent-relationships.md:1388
#: docs/master/eloquent-relationships.md:1484
#: docs/master/eloquent-relationships.md:1684
#, markdown-text, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Model;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:85
#, markdown-text, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the phone associated with the user.\n"
"         */\n"
"        public function phone()\n"
"        {\n"
"            return $this->hasOne(Phone::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:87
#, markdown-text
msgid ""
"The first argument passed to the `hasOne` method is the name of the related "
"model class. Once the relationship is defined, we may retrieve the related "
"record using Eloquent's dynamic properties. Dynamic properties allow you to "
"access relationship methods as if they were properties defined on the model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:89
#, markdown-text, no-wrap
msgid "    $phone = User::find(1)->phone;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:91
#, markdown-text
msgid ""
"Eloquent determines the foreign key of the relationship based on the parent "
"model name. In this case, the `Phone` model is automatically assumed to have "
"a `user_id` foreign key. If you wish to override this convention, you may "
"pass a second argument to the `hasOne` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:93
#, markdown-text, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:95
#, markdown-text
msgid ""
"Additionally, Eloquent assumes that the foreign key should have a value "
"matching the primary key column of the parent. In other words, Eloquent will "
"look for the value of the user's `id` column in the `user_id` column of the "
"`Phone` record. If you would like the relationship to use a primary key "
"value other than `id` or your model's `$primaryKey` property, you may pass a "
"third argument to the `hasOne` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:97
#, markdown-text, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:99
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:99
#: docs/master/eloquent-relationships.md:473
#: docs/master/eloquent-relationships.md:855
#, markdown-text, no-wrap
msgid "Defining The Inverse Of The Relationship"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:102
#, markdown-text
msgid ""
"So, we can access the `Phone` model from our `User` model. Next, let's "
"define a relationship on the `Phone` model that will let us access the user "
"that owns the phone. We can define the inverse of a `hasOne` relationship "
"using the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:119
#, markdown-text, no-wrap
msgid ""
"    class Phone extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user that owns the phone.\n"
"         */\n"
"        public function user()\n"
"        {\n"
"            return $this->belongsTo(User::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:121
#, markdown-text
msgid ""
"When invoking the `user` method, Eloquent will attempt to find a `User` "
"model that has an `id` which matches the `user_id` column on the `Phone` "
"model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:123
#, markdown-text
msgid ""
"Eloquent determines the foreign key name by examining the name of the "
"relationship method and suffixing the method name with `_id`. So, in this "
"case, Eloquent assumes that the `Phone` model has a `user_id` "
"column. However, if the foreign key on the `Phone` model is not `user_id`, "
"you may pass a custom key name as the second argument to the `belongsTo` "
"method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:131
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:133
#, markdown-text
msgid ""
"If the parent model does not use `id` as its primary key, or you wish to "
"find the associated model using a different column, you may pass a third "
"argument to the `belongsTo` method specifying the parent table's custom key:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:141
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:143
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:143
#, markdown-text, no-wrap
msgid "One To Many"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:146
#, markdown-text
msgid ""
"A one-to-many relationship is used to define relationships where a single "
"model is the parent to one or more child models. For example, a blog post "
"may have an infinite number of comments. Like all other Eloquent "
"relationships, one-to-many relationships are defined by defining a method on "
"your Eloquent model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:163
#, markdown-text, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the comments for the blog post.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->hasMany(Comment::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:165
#, markdown-text
msgid ""
"Remember, Eloquent will automatically determine the proper foreign key "
"column for the `Comment` model. By convention, Eloquent will take the "
"\"snake case\" name of the parent model and suffix it with `_id`. So, in "
"this example, Eloquent will assume the foreign key column on the `Comment` "
"model is `post_id`."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:167
#, markdown-text
msgid ""
"Once the relationship method has been defined, we can access the "
"[collection](/docs/{{version}}/eloquent-collections) of related comments by "
"accessing the `comments` property. Remember, since Eloquent provides "
"\"dynamic relationship properties\", we can access relationship methods as "
"if they were defined as properties on the model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:169
#: docs/master/eloquent-relationships.md:684
#: docs/master/eloquent-relationships.md:786
#: docs/master/eloquent-relationships.md:892
#: docs/master/eloquent-relationships.md:1047
#: docs/master/eloquent-relationships.md:1083
#: docs/master/eloquent-relationships.md:1164
#: docs/master/eloquent-relationships.md:1226
#: docs/master/eloquent-relationships.md:1563
#, markdown-text, no-wrap
msgid "    use App\\Models\\Post;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:171
#, markdown-text, no-wrap
msgid "    $comments = Post::find(1)->comments;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:175
#, markdown-text, no-wrap
msgid ""
"    foreach ($comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:177
#, markdown-text
msgid ""
"Since all relationships also serve as query builders, you may add further "
"constraints to the relationship query by calling the `comments` method and "
"continuing to chain conditions onto the query:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:181
#, markdown-text, no-wrap
msgid ""
"    $comment = Post::find(1)->comments()\n"
"                        ->where('title', 'foo')\n"
"                        ->first();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:183
#, markdown-text
msgid ""
"Like the `hasOne` method, you may also override the foreign and local keys "
"by passing additional arguments to the `hasMany` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:185
#, markdown-text, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:187
#, markdown-text, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:189
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many-inverse\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:189
#, markdown-text, no-wrap
msgid "One To Many (Inverse) / Belongs To"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:192
#, markdown-text
msgid ""
"Now that we can access all of a post's comments, let's define a relationship "
"to allow a comment to access its parent post. To define the inverse of a "
"`hasMany` relationship, define a relationship method on the child model "
"which calls the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:209
#, markdown-text, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post that owns the comment.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:211
#, markdown-text
msgid ""
"Once the relationship has been defined, we can retrieve a comment's parent "
"post by accessing the `post` \"dynamic relationship property\":"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:213
#: docs/master/eloquent-relationships.md:796
#, markdown-text, no-wrap
msgid "    use App\\Models\\Comment;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:215
#: docs/master/eloquent-relationships.md:798
#, markdown-text, no-wrap
msgid "    $comment = Comment::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:217
#, markdown-text, no-wrap
msgid "    return $comment->post->title;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:219
#, markdown-text
msgid ""
"In the example above, Eloquent will attempt to find a `Post` model that has "
"an `id` which matches the `post_id` column on the `Comment` model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:221
#, markdown-text
msgid ""
"Eloquent determines the default foreign key name by examining the name of "
"the relationship method and suffixing the method name with a `_` followed by "
"the name of the parent model's primary key column. So, in this example, "
"Eloquent will assume the `Post` model's foreign key on the `comments` table "
"is `post_id`."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:223
#, markdown-text
msgid ""
"However, if the foreign key for your relationship does not follow these "
"conventions, you may pass a custom foreign key name as the second argument "
"to the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:231
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:233
#, markdown-text
msgid ""
"If your parent model does not use `id` as its primary key, or you wish to "
"find the associated model using a different column, you may pass a third "
"argument to the `belongsTo` method specifying your parent table's custom "
"key:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:241
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:243
#, markdown-text, no-wrap
msgid "<a name=\"default-models\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:243
#, markdown-text, no-wrap
msgid "Default Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:246
#, markdown-text
msgid ""
"The `belongsTo`, `hasOne`, `hasOneThrough`, and `morphOne` relationships "
"allow you to define a default model that will be returned if the given "
"relationship is `null`. This pattern is often referred to as the [Null "
"Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern) and can "
"help remove conditional checks in your code. In the following example, the "
"`user` relation will return an empty `App\\Models\\User` model if no user is "
"attached to the `Post` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:254
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:256
#, markdown-text
msgid ""
"To populate the default model with attributes, you may pass an array or "
"closure to the `withDefault` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:266
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault([\n"
"            'name' => 'Guest Author',\n"
"        ]);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:276
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault(function ($user, "
"$post) {\n"
"            $user->name = 'Guest Author';\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:278
#, markdown-text, no-wrap
msgid "<a name=\"has-one-through\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:278
#, markdown-text, no-wrap
msgid "Has One Through"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:281
#, markdown-text
msgid ""
"The \"has-one-through\" relationship defines a one-to-one relationship with "
"another model. However, this relationship indicates that the declaring model "
"can be matched with one instance of another model by proceeding _through_ a "
"third model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:283
#, markdown-text
msgid ""
"For example, in a vehicle repair shop application, each `Mechanic` model may "
"be associated with one `Car` model, and each `Car` model may be associated "
"with one `Owner` model. While the mechanic and the owner have no direct "
"relationship within the database, the mechanic can access the owner "
"_through_ the `Car` model. Let's look at the tables necessary to define this "
"relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:287
#, markdown-text, no-wrap
msgid ""
"    mechanics\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:292
#, markdown-text, no-wrap
msgid ""
"    cars\n"
"        id - integer\n"
"        model - string\n"
"        mechanic_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:297
#, markdown-text, no-wrap
msgid ""
"    owners\n"
"        id - integer\n"
"        name - string\n"
"        car_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:299
#, markdown-text
msgid ""
"Now that we have examined the table structure for the relationship, let's "
"define the relationship on the `Mechanic` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:316
#, markdown-text, no-wrap
msgid ""
"    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(Owner::class, Car::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:318
#, markdown-text
msgid ""
"The first argument passed to the `hasOneThrough` method is the name of the "
"final model we wish to access, while the second argument is the name of the "
"intermediate model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:320
#, markdown-text, no-wrap
msgid "<a name=\"has-one-through-key-conventions\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:320
#: docs/master/eloquent-relationships.md:385
#: docs/master/eloquent-relationships.md:700
#, markdown-text, no-wrap
msgid "Key Conventions"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:323
#, markdown-text
msgid ""
"Typical Eloquent foreign key conventions will be used when performing the "
"relationship's queries. If you would like to customize the keys of the "
"relationship, you may pass them as the third and fourth arguments to the "
"`hasOneThrough` method. The third argument is the name of the foreign key on "
"the intermediate model. The fourth argument is the name of the foreign key "
"on the final model. The fifth argument is the local key, while the sixth "
"argument is the local key of the intermediate model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:341
#, markdown-text, no-wrap
msgid ""
"    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(\n"
"                Owner::class,\n"
"                Car::class,\n"
"                'mechanic_id', // Foreign key on the cars table...\n"
"                'car_id', // Foreign key on the owners table...\n"
"                'id', // Local key on the mechanics table...\n"
"                'id' // Local key on the cars table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:343
#, markdown-text, no-wrap
msgid "<a name=\"has-many-through\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:343
#, markdown-text, no-wrap
msgid "Has Many Through"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:346
#, markdown-text
msgid ""
"The \"has-many-through\" relationship provides a convenient way to access "
"distant relations via an intermediate relation. For example, let's assume we "
"are building a deployment platform like [Laravel "
"Vapor](https://vapor.laravel.com). A `Project` model might access many "
"`Deployment` models through an intermediate `Environment` model. Using this "
"example, you could easily gather all deployments for a given "
"environment. Let's look at the tables required to define this relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:350
#, markdown-text, no-wrap
msgid ""
"    projects\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:355
#, markdown-text, no-wrap
msgid ""
"    environments\n"
"        id - integer\n"
"        project_id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:360
#, markdown-text, no-wrap
msgid ""
"    deployments\n"
"        id - integer\n"
"        environment_id - integer\n"
"        commit_hash - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:362
#, markdown-text
msgid ""
"Now that we have examined the table structure for the relationship, let's "
"define the relationship on the `Project` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:379
#, markdown-text, no-wrap
msgid ""
"    class Project extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the deployments for the project.\n"
"         */\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(Deployment::class, "
"Environment::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:381
#, markdown-text
msgid ""
"The first argument passed to the `hasManyThrough` method is the name of the "
"final model we wish to access, while the second argument is the name of the "
"intermediate model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:383
#, markdown-text, no-wrap
msgid ""
"Though the `Deployment` model's table does not contain a `project_id` "
"column, the `hasManyThrough` relation provides access to a project's "
"deployments via `$project->deployments`. To retrieve these models, Eloquent "
"inspects the `project_id` column on the intermediate `Environment` model's "
"table. After finding the relevant environment IDs, they are used to query "
"the `Deployment` model's table.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:385
#, markdown-text, no-wrap
msgid "<a name=\"has-many-through-key-conventions\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:388
#, markdown-text
msgid ""
"Typical Eloquent foreign key conventions will be used when performing the "
"relationship's queries. If you would like to customize the keys of the "
"relationship, you may pass them as the third and fourth arguments to the "
"`hasManyThrough` method. The third argument is the name of the foreign key "
"on the intermediate model. The fourth argument is the name of the foreign "
"key on the final model. The fifth argument is the local key, while the sixth "
"argument is the local key of the intermediate model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:403
#, markdown-text, no-wrap
msgid ""
"    class Project extends Model\n"
"    {\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(\n"
"                Deployment::class,\n"
"                Environment::class,\n"
"                'project_id', // Foreign key on the environments table...\n"
"                'environment_id', // Foreign key on the deployments "
"table...\n"
"                'id', // Local key on the projects table...\n"
"                'id' // Local key on the environments table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:405
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:405
#: docs/master/eloquent-relationships.md:1603
#, markdown-text, no-wrap
msgid "Many To Many Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:408
#, markdown-text
msgid ""
"Many-to-many relations are slightly more complicated than `hasOne` and "
"`hasMany` relationships. An example of a many-to-many relationship is a user "
"that has many roles and those roles are also shared by other users in the "
"application. For example, a user may be assigned the role of \"Author\" and "
"\"Editor\"; however, those roles may also be assigned to other users as "
"well. So, a user has many roles and a role has many users."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:410
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-table-structure\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:410
#: docs/master/eloquent-relationships.md:614
#: docs/master/eloquent-relationships.md:716
#: docs/master/eloquent-relationships.md:807
#, markdown-text, no-wrap
msgid "Table Structure"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:413
#, markdown-text
msgid ""
"To define this relationship, three database tables are needed: `users`, "
"`roles`, and `role_user`. The `role_user` table is derived from the "
"alphabetical order of the related model names and contains `user_id` and "
"`role_id` columns. This table is used as an intermediate table linking the "
"users and roles."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:415
#, markdown-text
msgid ""
"Remember, since a role can belong to many users, we cannot simply place a "
"`user_id` column on the `roles` table. This would mean that a role could "
"only belong to a single user. In order to provide support for roles being "
"assigned to multiple users, the `role_user` table is needed. We can "
"summarize the relationship's table structure like so:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:419
#: docs/master/eloquent-relationships.md:625
#, markdown-text, no-wrap
msgid ""
"    users\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:423
#, markdown-text, no-wrap
msgid ""
"    roles\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:427
#, markdown-text, no-wrap
msgid ""
"    role_user\n"
"        user_id - integer\n"
"        role_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:429
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-model-structure\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:429
#: docs/master/eloquent-relationships.md:635
#: docs/master/eloquent-relationships.md:737
#: docs/master/eloquent-relationships.md:831
#, markdown-text, no-wrap
msgid "Model Structure"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:432
#, markdown-text
msgid ""
"Many-to-many relationships are defined by writing a method that returns the "
"result of the `belongsToMany` method. The `belongsToMany` method is provided "
"by the `Illuminate\\Database\\Eloquent\\Model` base class that is used by "
"all of your application's Eloquent models. For example, let's define a "
"`roles` method on our `User` model. The first argument passed to this method "
"is the name of the related model class:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:449
#, markdown-text, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * The roles that belong to the user.\n"
"         */\n"
"        public function roles()\n"
"        {\n"
"            return $this->belongsToMany(Role::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:451
#, markdown-text
msgid ""
"Once the relationship is defined, you may access the user's roles using the "
"`roles` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:453
#: docs/master/eloquent-relationships.md:502
#: docs/master/eloquent-relationships.md:982
#: docs/master/eloquent-relationships.md:1032
#: docs/master/eloquent-relationships.md:1417
#: docs/master/eloquent-relationships.md:1611
#, markdown-text, no-wrap
msgid "    use App\\Models\\User;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:455
#: docs/master/eloquent-relationships.md:504
#: docs/master/eloquent-relationships.md:984
#: docs/master/eloquent-relationships.md:1034
#: docs/master/eloquent-relationships.md:1613
#: docs/master/eloquent-relationships.md:1631
#: docs/master/eloquent-relationships.md:1667
#, markdown-text, no-wrap
msgid "    $user = User::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:459
#, markdown-text, no-wrap
msgid ""
"    foreach ($user->roles as $role) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:461
#, markdown-text
msgid ""
"Since all relationships also serve as query builders, you may add further "
"constraints to the relationship query by calling the `roles` method and "
"continuing to chain conditions onto the query:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:463
#, markdown-text, no-wrap
msgid "    $roles = User::find(1)->roles()->orderBy('name')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:465
#, markdown-text
msgid ""
"To determine the table name of the relationship's intermediate table, "
"Eloquent will join the two related model names in alphabetical "
"order. However, you are free to override this convention. You may do so by "
"passing a second argument to the `belongsToMany` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:467
#, markdown-text, no-wrap
msgid "    return $this->belongsToMany(Role::class, 'role_user');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:469
#, markdown-text
msgid ""
"In addition to customizing the name of the intermediate table, you may also "
"customize the column names of the keys on the table by passing additional "
"arguments to the `belongsToMany` method. The third argument is the foreign "
"key name of the model on which you are defining the relationship, while the "
"fourth argument is the foreign key name of the model that you are joining "
"to:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:471
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class, 'role_user', 'user_id', "
"'role_id');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:473
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:476
#, markdown-text
msgid ""
"To define the \"inverse\" of a many-to-many relationship, you should define "
"a method on the related model which also returns the result of the "
"`belongsToMany` method. To complete our user / role example, let's define "
"the `users` method on the `Role` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:493
#, markdown-text, no-wrap
msgid ""
"    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:495
#, markdown-text
msgid ""
"As you can see, the relationship is defined exactly the same as its `User` "
"model counterpart with the exception of referencing the `App\\Models\\User` "
"model. Since we're reusing the `belongsToMany` method, all of the usual "
"table and key customization options are available when defining the "
"\"inverse\" of many-to-many relationships."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:497
#, markdown-text, no-wrap
msgid "<a name=\"retrieving-intermediate-table-columns\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:497
#, markdown-text, no-wrap
msgid "Retrieving Intermediate Table Columns"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:500
#, markdown-text
msgid ""
"As you have already learned, working with many-to-many relations requires "
"the presence of an intermediate table. Eloquent provides some very helpful "
"ways of interacting with this table. For example, let's assume our `User` "
"model has many `Role` models that it is related to. After accessing this "
"relationship, we may access the intermediate table using the `pivot` "
"attribute on the models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:508
#, markdown-text, no-wrap
msgid ""
"    foreach ($user->roles as $role) {\n"
"        echo $role->pivot->created_at;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:510
#, markdown-text
msgid ""
"Notice that each `Role` model we retrieve is automatically assigned a "
"`pivot` attribute. This attribute contains a model representing the "
"intermediate table."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:512
#, markdown-text
msgid ""
"By default, only the model keys will be present on the `pivot` model. If "
"your intermediate table contains extra attributes, you must specify them "
"when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:514
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)->withPivot('active', "
"'created_by');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:516
#, markdown-text
msgid ""
"If you would like your intermediate table to have `created_at` and "
"`updated_at` timestamps that are automatically maintained by Eloquent, call "
"the `withTimestamps` method when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:518
#, markdown-text, no-wrap
msgid "    return $this->belongsToMany(Role::class)->withTimestamps();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:520
#, markdown-text, no-wrap
msgid ""
"> {note} Intermediate tables that utilize Eloquent's automatically "
"maintained timestamps are required to have both `created_at` and "
"`updated_at` timestamp columns.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:522
#, markdown-text, no-wrap
msgid "<a name=\"customizing-the-pivot-attribute-name\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:522
#, markdown-text, no-wrap
msgid "Customizing The `pivot` Attribute Name"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:525
#, markdown-text
msgid ""
"As noted previously, attributes from the intermediate table may be accessed "
"on models via the `pivot` attribute. However, you are free to customize the "
"name of this attribute to better reflect its purpose within your "
"application."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:527
#, markdown-text
msgid ""
"For example, if your application contains users that may subscribe to "
"podcasts, you likely have a many-to-many relationship between users and "
"podcasts. If this is the case, you may wish to rename your intermediate "
"table attribute to `subscription` instead of `pivot`. This can be done using "
"the `as` method when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:531
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscription')\n"
"                    ->withTimestamps();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:533
#, markdown-text
msgid ""
"Once the custom intermediate table attribute has been specified, you may "
"access the intermediate table data using the customized name:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:535
#, markdown-text, no-wrap
msgid "    $users = User::with('podcasts')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:539
#, markdown-text, no-wrap
msgid ""
"    foreach ($users->flatMap->podcasts as $podcast) {\n"
"        echo $podcast->subscription->created_at;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:541
#, markdown-text, no-wrap
msgid "<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:541
#, markdown-text, no-wrap
msgid "Filtering Queries Via Intermediate Table Columns"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:544
#, markdown-text
msgid ""
"You can also filter the results returned by `belongsToMany` relationship "
"queries using the `wherePivot`, `wherePivotIn`, and `wherePivotNotIn` "
"methods when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:547
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivot('approved', 1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:550
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotIn('priority', [1, 2]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:553
#, markdown-text, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotNotIn('priority', [1, 2]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:555
#, markdown-text, no-wrap
msgid "<a name=\"defining-custom-intermediate-table-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:555
#, markdown-text, no-wrap
msgid "Defining Custom Intermediate Table Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:558
#, markdown-text
msgid ""
"If you would like to define a custom model to represent the intermediate "
"table of your many-to-many relationship, you may call the `using` method "
"when defining the relationship. Custom pivot models give you the opportunity "
"to define additional methods on the pivot model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:560
#, markdown-text
msgid ""
"Custom many-to-many pivot models should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\Pivot` class while custom "
"polymorphic many-to-many pivot models should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` class. For example, "
"we may define a `Role` model which uses a custom `RoleUser` pivot model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:577
#, markdown-text, no-wrap
msgid ""
"    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return "
"$this->belongsToMany(User::class)->using(RoleUser::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:579
#, markdown-text
msgid ""
"When defining the `RoleUser` model, you should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\Pivot` class:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:585
#, markdown-text, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:590
#, markdown-text, no-wrap
msgid ""
"    class RoleUser extends Pivot\n"
"    {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:592
#, markdown-text, no-wrap
msgid ""
"> {note} Pivot models may not use the `SoftDeletes` trait. If you need to "
"soft delete pivot records consider converting your pivot model to an actual "
"Eloquent model.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:594
#, markdown-text, no-wrap
msgid "<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:594
#, markdown-text, no-wrap
msgid "Custom Pivot Models And Incrementing IDs"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:597
#, markdown-text
msgid ""
"If you have defined a many-to-many relationship that uses a custom pivot "
"model, and that pivot model has an auto-incrementing primary key, you should "
"ensure your custom pivot model class defines an `incrementing` property that "
"is set to `true`."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:604
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Indicates if the IDs are auto-incrementing.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $incrementing = true;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:606
#, markdown-text, no-wrap
msgid "<a name=\"polymorphic-relationships\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:606
#, markdown-text, no-wrap
msgid "Polymorphic Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:609
#, markdown-text
msgid ""
"A polymorphic relationship allows the child model to belong to more than one "
"type of model using a single association. For example, imagine you are "
"building an application that allows users to share blog posts and videos. a "
"`Comment` model might belong to both the `Post` and `Video` models."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:611
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:611
#, markdown-text, no-wrap
msgid "One To One (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:614
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:617
#, markdown-text
msgid ""
"A one-to-one polymorphic relation is similar to a typical one-to-one "
"relation; however, the child model can belong to more than one type of model "
"using a single association. For example, a blog `Post` and a `User` may "
"share a polymorphic relation to an `Image` model. Using a one-to-one "
"polymorphic relation allows you to have a single table of unique images that "
"may be associated with posts and users. First, let's examine the table "
"structure:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:621
#: docs/master/eloquent-relationships.md:814
#, markdown-text, no-wrap
msgid ""
"    posts\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:631
#, markdown-text, no-wrap
msgid ""
"    images\n"
"        id - integer\n"
"        url - string\n"
"        imageable_id - integer\n"
"        imageable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:633
#, markdown-text
msgid ""
"Note the `imageable_id` and `imageable_type` columns on the `images` "
"table. The `imageable_id` column will contain the ID value of the post or "
"user, while the `imageable_type` column will contain the class name of the "
"parent model. The `imageable_type` column is used by Eloquent to determine "
"which \"type\" of parent model to return when accessing the `imageable` "
"relation. In this case, the column would contain either `App\\Models\\Post` "
"or `App\\Models\\User`."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:635
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:638
#: docs/master/eloquent-relationships.md:740
#, markdown-text
msgid "Next, let's examine the model definitions needed to build this relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:655
#, markdown-text, no-wrap
msgid ""
"    class Image extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent imageable model (user or post).\n"
"         */\n"
"        public function imageable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:666
#, markdown-text, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:677
#, markdown-text, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:679
#, markdown-text, no-wrap
msgid "<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:679
#: docs/master/eloquent-relationships.md:781
#: docs/master/eloquent-relationships.md:887
#, markdown-text, no-wrap
msgid "Retrieving The Relationship"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:682
#, markdown-text
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your models. For example, to retrieve the image for a "
"post, we can access the `image` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:686
#: docs/master/eloquent-relationships.md:788
#: docs/master/eloquent-relationships.md:894
#: docs/master/eloquent-relationships.md:1522
#: docs/master/eloquent-relationships.md:1530
#: docs/master/eloquent-relationships.md:1551
#: docs/master/eloquent-relationships.md:1565
#: docs/master/eloquent-relationships.md:1573
#, markdown-text, no-wrap
msgid "    $post = Post::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:688
#, markdown-text, no-wrap
msgid "    $image = $post->image;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:690
#, markdown-text
msgid ""
"You may retrieve the parent of the polymorphic model by accessing the name "
"of the method that performs the call to `morphTo`. In this case, that is the "
"`imageable` method on the `Image` model. So, we will access that method as a "
"dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:692
#, markdown-text, no-wrap
msgid "    use App\\Models\\Image;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:694
#, markdown-text, no-wrap
msgid "    $image = Image::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:696
#, markdown-text, no-wrap
msgid "    $imageable = $image->imageable;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:698
#, markdown-text
msgid ""
"The `imageable` relation on the `Image` model will return either a `Post` or "
"`User` instance, depending on which type of model owns the image."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:700
#, markdown-text, no-wrap
msgid "<a name=\"morph-one-to-one-key-conventions\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:703
#, markdown-text
msgid ""
"If necessary, you may specify the name of the \"id\" and \"type\" columns "
"utilized by your polymorphic child model. If you do so, ensure that you "
"always pass the name of the relationship as the first argument to the "
"`morphTo` method. Typically, this value should match the method name, so you "
"may use PHP's `__FUNCTION__` constant:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:711
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the model that the image belongs to.\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo(__FUNCTION__, 'imageable_type', "
"'imageable_id');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:713
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:713
#, markdown-text, no-wrap
msgid "One To Many (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:716
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:719
#, markdown-text
msgid ""
"A one-to-many polymorphic relation is similar to a typical one-to-many "
"relation; however, the child model can belong to more than one type of model "
"using a single association. For example, imagine users of your application "
"can \"comment\" on posts and videos. Using polymorphic relationships, you "
"may use a single `comments` table to contain comments for both posts and "
"videos. First, let's examine the table structure required to build this "
"relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:724
#, markdown-text, no-wrap
msgid ""
"    posts\n"
"        id - integer\n"
"        title - string\n"
"        body - text\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:729
#, markdown-text, no-wrap
msgid ""
"    videos\n"
"        id - integer\n"
"        title - string\n"
"        url - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:735
#, markdown-text, no-wrap
msgid ""
"    comments\n"
"        id - integer\n"
"        body - text\n"
"        commentable_id - integer\n"
"        commentable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:737
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:757
#, markdown-text, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent commentable model (post or video).\n"
"         */\n"
"        public function commentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:768
#, markdown-text, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the post's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:779
#, markdown-text, no-wrap
msgid ""
"    class Video extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the video's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:781
#, markdown-text, no-wrap
msgid "<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:784
#, markdown-text
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your model's dynamic relationship properties. For example, "
"to access all of the comments for a post, we can use the `comments` dynamic "
"property:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:792
#, markdown-text, no-wrap
msgid ""
"    foreach ($post->comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:794
#, markdown-text
msgid ""
"You may also retrieve the parent of a polymorphic child model by accessing "
"the name of the method that performs the call to `morphTo`. In this case, "
"that is the `commentable` method on the `Comment` model. So, we will access "
"that method as a dynamic relationship property in order to access the "
"comment's parent model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:800
#, markdown-text, no-wrap
msgid "    $commentable = $comment->commentable;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:802
#, markdown-text
msgid ""
"The `commentable` relation on the `Comment` model will return either a "
"`Post` or `Video` instance, depending on which type of model is the "
"comment's parent."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:804
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:804
#, markdown-text, no-wrap
msgid "Many To Many (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:807
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:810
#, markdown-text
msgid ""
"Many-to-many polymorphic relations are slightly more complicated than "
"\"morph one\" and \"morph many\" relationships. For example, a `Post` model "
"and `Video` model could share a polymorphic relation to a `Tag` model. Using "
"a many-to-many polymorphic relation in this situation would allow your "
"application to have a single table of unique tags that may be associated "
"with posts or videos. First, let's examine the table structure required to "
"build this relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:818
#, markdown-text, no-wrap
msgid ""
"    videos\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:822
#, markdown-text, no-wrap
msgid ""
"    tags\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:827
#, markdown-text, no-wrap
msgid ""
"    taggables\n"
"        tag_id - integer\n"
"        taggable_id - integer\n"
"        taggable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:829
#, markdown-text, no-wrap
msgid ""
"> {tip} Before diving into polymorphic many-to-many relationships, you may "
"benefit from reading the documentation on typical [many-to-many "
"relationships](#many-to-many).\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:831
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:834
#, markdown-text
msgid ""
"Next, we're ready to define the relationships on the models. The `Post` and "
"`Video` models will both contain a `tags` method that calls the "
"`morphToMany` method provided by the base Eloquent model class."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:836
#, markdown-text
msgid ""
"The `morphToMany` method accepts the name of the related model as well as "
"the \"relationship name\". Based on the name we assigned to our intermediate "
"table name and the keys it contains, we will refer to the relationship as "
"\"taggable\":"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:853
#, markdown-text, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the tags for the post.\n"
"         */\n"
"        public function tags()\n"
"        {\n"
"            return $this->morphToMany(Tag::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:855
#, markdown-text, no-wrap
msgid ""
"<a "
"name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:858
#, markdown-text
msgid ""
"Next, on the `Tag` model, you should define a method for each of its "
"possible parent models. So, in this example, we will define a `posts` method "
"and a `videos` method. Both of these methods should return the result of the "
"`morphedByMany` method."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:860
#, markdown-text
msgid ""
"The `morphedByMany` method accepts the name of the related model as well as "
"the \"relationship name\". Based on the name we assigned to our intermediate "
"table name and the keys it contains, we will refer to the relationship as "
"\"taggable\":"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:876
#, markdown-text, no-wrap
msgid ""
"    class Tag extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts that are assigned this tag.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->morphedByMany(Post::class, 'taggable');\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:885
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Get all of the videos that are assigned this tag.\n"
"         */\n"
"        public function videos()\n"
"        {\n"
"            return $this->morphedByMany(Video::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:887
#, markdown-text, no-wrap
msgid "<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:890
#, markdown-text
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your models. For example, to access all of the tags for a "
"post, you may use the `tags` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:898
#, markdown-text, no-wrap
msgid ""
"    foreach ($post->tags as $tag) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:900
#, markdown-text
msgid ""
"You may retrieve the parent of a polymorphic relation from the polymorphic "
"child model by accessing the name of the method that performs the call to "
"`morphedByMany`. In this case, that is the `posts` or `videos` methods on "
"the `Tag` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:902
#, markdown-text, no-wrap
msgid "    use App\\Models\\Tag;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:904
#, markdown-text, no-wrap
msgid "    $tag = Tag::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:908
#, markdown-text, no-wrap
msgid ""
"    foreach ($tag->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:912
#, markdown-text, no-wrap
msgid ""
"    foreach ($tag->videos as $video) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:914
#, markdown-text, no-wrap
msgid "<a name=\"custom-polymorphic-types\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:914
#, markdown-text, no-wrap
msgid "Custom Polymorphic Types"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:917
#, markdown-text
msgid ""
"By default, Laravel will use the fully qualified class name to store the "
"\"type\" of the related model. For instance, given the one-to-many "
"relationship example above where a `Comment` model may belong to a `Post` or "
"a `Video` model, the default `commentable_type` would be either "
"`App\\Models\\Post` or `App\\Models\\Video`, respectively. However, you may "
"wish to decouple these values from your application's internal structure."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:919
#, markdown-text
msgid ""
"For example, instead of using the model names as the \"type\", we may use "
"simple strings such as `post` and `video`. By doing so, the polymorphic "
"\"type\" column values in our database will remain valid even if the models "
"are renamed:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:921
#: docs/master/eloquent-relationships.md:932
#, markdown-text, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:926
#, markdown-text, no-wrap
msgid ""
"    Relation::morphMap([\n"
"        'post' => 'App\\Models\\Post',\n"
"        'video' => 'App\\Models\\Video',\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:928
#, markdown-text
msgid ""
"You may register the `morphMap` in the `boot` function of your "
"`App\\Providers\\AppServiceProvider` class or create a separate service "
"provider if you wish."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:930
#, markdown-text
msgid ""
"You may determine the morph alias of a given model at runtime using the "
"model's `getMorphClass` method. Conversely, you may determine the "
"fully-qualified class name associated with a morph alias using the "
"`Relation::getMorphedModel` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:934
#, markdown-text, no-wrap
msgid "    $alias = $post->getMorphClass();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:936
#, markdown-text, no-wrap
msgid "    $class = Relation::getMorphedModel($alias);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:938
#, markdown-text, no-wrap
msgid ""
"> {note} When adding a \"morph map\" to your existing application, every "
"morphable `*_type` column value in your database that still contains a "
"fully-qualified class will need to be converted to its \"map\" name.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:940
#, markdown-text, no-wrap
msgid "<a name=\"dynamic-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:940
#, markdown-text, no-wrap
msgid "Dynamic Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:943
#, markdown-text
msgid ""
"You may use the `resolveRelationUsing` method to define relations between "
"Eloquent models at runtime. While not typically recommended for normal "
"application development, this may occasionally be useful when developing "
"Laravel packages."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:945
#, markdown-text
msgid ""
"The `resolveRelationshipUsing` method accepts the desired relationship name "
"as its first argument. The second argument passed to the method should be a "
"closure that accepts the model instance and returns a valid Eloquent "
"relationship definition. Typically, you should configure dynamic "
"relationships within the boot method of a [service "
"provider](/docs/{{version}}/providers):"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:948
#, markdown-text, no-wrap
msgid ""
"    use App\\Models\\Order;\n"
"    use App\\Models\\Customer;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:952
#, markdown-text, no-wrap
msgid ""
"    Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"        return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:954
#, markdown-text, no-wrap
msgid ""
"> {note} When defining dynamic relationships, always provide explicit key "
"name arguments to the Eloquent relationship methods.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:956
#, markdown-text, no-wrap
msgid "<a name=\"querying-relations\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:956
#, markdown-text, no-wrap
msgid "Querying Relations"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:959
#, markdown-text
msgid ""
"Since all Eloquent relationships are defined via methods, you may call those "
"methods to obtain an instance of the relationship without actually executing "
"a query to load the related models. In addition, all types of Eloquent "
"relationships also serve as [query builders](/docs/{{version}}/queries), "
"allowing you to continue to chain constraints onto the relationship query "
"before finally executing the SQL query against your database."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:961
#, markdown-text
msgid ""
"For example, imagine a blog application in which a `User` model has many "
"associated `Post` models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:978
#, markdown-text, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts for the user.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->hasMany(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:980
#, markdown-text
msgid ""
"You may query the `posts` relationship and add additional constraints to the "
"relationship like so:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:988
#, markdown-text
msgid ""
"You are able to use any of the Laravel [query "
"builder's](/docs/{{version}}/queries) methods on the relationship, so be "
"sure to explore the query builder documentation to learn about all of the "
"methods that are available to you."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:990
#, markdown-text, no-wrap
msgid "<a name=\"chaining-orwhere-clauses-after-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:990
#, markdown-text, no-wrap
msgid "Chaining `orWhere` Clauses After Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:993
#, markdown-text
msgid ""
"As demonstrated in the example above, you are free to add additional "
"constraints to relationships when querying them. However, use caution when "
"chaining `orWhere` clauses onto a relationship, as the `orWhere` clauses "
"will be logically grouped at the same level as the relationship constraint:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:998
#, markdown-text, no-wrap
msgid ""
"    $user->posts()\n"
"            ->where('active', 1)\n"
"            ->orWhere('votes', '>=', 100)\n"
"            ->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1000
#, markdown-text
msgid ""
"The example above will generate the following SQL. As you can see, the `or` "
"clause instructs the query to return _any_ user with greater than 100 "
"votes. The query is no longer constrained to a specific user:"
msgstr ""

#. type: Fenced code block (sql)
#: docs/master/eloquent-relationships.md:1001
#, no-wrap
msgid ""
"select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1008
#, markdown-text
msgid ""
"In most situations, you should use [logical "
"groups](/docs/{{version}}/queries#logical-grouping) to group the conditional "
"checks between parentheses:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1010
#: docs/master/eloquent-relationships.md:1064
#: docs/master/eloquent-relationships.md:1089
#: docs/master/eloquent-relationships.md:1097
#: docs/master/eloquent-relationships.md:1133
#: docs/master/eloquent-relationships.md:1150
#: docs/master/eloquent-relationships.md:1174
#: docs/master/eloquent-relationships.md:1185
#, markdown-text, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1017
#, markdown-text, no-wrap
msgid ""
"    $user->posts()\n"
"            ->where(function (Builder $query) {\n"
"                return $query->where('active', 1)\n"
"                             ->orWhere('votes', '>=', 100);\n"
"            })\n"
"            ->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1019
#, markdown-text
msgid ""
"The example above will produce the following SQL. Note that the logical "
"grouping has properly grouped the constraints and the query remains "
"constrained to a specific user:"
msgstr ""

#. type: Fenced code block (sql)
#: docs/master/eloquent-relationships.md:1020
#, no-wrap
msgid ""
"select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1027
#, markdown-text, no-wrap
msgid "<a name=\"relationship-methods-vs-dynamic-properties\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1027
#, markdown-text, no-wrap
msgid "Relationship Methods Vs. Dynamic Properties"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1030
#, markdown-text
msgid ""
"If you do not need to add additional constraints to an Eloquent relationship "
"query, you may access the relationship as if it were a property. For "
"example, continuing to use our `User` and `Post` example models, we may "
"access all of a user's posts like so:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1038
#, markdown-text, no-wrap
msgid ""
"    foreach ($user->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1040
#, markdown-text
msgid ""
"Dynamic relationship properties perform \"lazy loading\", meaning they will "
"only load their relationship data when you actually access them. Because of "
"this, developers often use [eager loading](#eager-loading) to pre-load "
"relationships they know will be accessed after loading the model. Eager "
"loading provides a significant reduction in SQL queries that must be "
"executed to load a model's relations."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1042
#, markdown-text, no-wrap
msgid "<a name=\"querying-relationship-existence\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1042
#, markdown-text, no-wrap
msgid "Querying Relationship Existence"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1045
#, markdown-text
msgid ""
"When retrieving model records, you may wish to limit your results based on "
"the existence of a relationship. For example, imagine you want to retrieve "
"all blog posts that have at least one comment. To do so, you may pass the "
"name of the relationship to the `has` and `orHas` methods:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1050
#, markdown-text, no-wrap
msgid ""
"    // Retrieve all posts that have at least one comment...\n"
"    $posts = Post::has('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1052
#, markdown-text
msgid ""
"You may also specify an operator and count value to further customize the "
"query:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1055
#, markdown-text, no-wrap
msgid ""
"    // Retrieve all posts that have three or more comments...\n"
"    $posts = Post::has('comments', '>=', 3)->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1057
#, markdown-text
msgid ""
"Nested `has` statements may be constructed using \"dot\" notation. For "
"example, you may retrieve all posts that have at least one comment that has "
"at least one image:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1060
#, markdown-text, no-wrap
msgid ""
"    // Retrieve posts that have at least one comment with images...\n"
"    $posts = Post::has('comments.images')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1062
#, markdown-text
msgid ""
"If you need even more power, you may use the `whereHas` and `orWhereHas` "
"methods to define additional query constraints on your `has` queries, such "
"as inspecting the content of a comment:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1069
#, markdown-text, no-wrap
msgid ""
"    // Retrieve posts with at least one comment containing words like "
"code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1074
#, markdown-text, no-wrap
msgid ""
"    // Retrieve posts with at least ten comments containing words like "
"code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }, '>=', 10)->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1076
#, markdown-text, no-wrap
msgid ""
"> {note} Eloquent does not currently support querying for relationship "
"existence across databases. The relationships must exist within the same "
"database.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1078
#, markdown-text, no-wrap
msgid "<a name=\"querying-relationship-absence\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1078
#, markdown-text, no-wrap
msgid "Querying Relationship Absence"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1081
#, markdown-text
msgid ""
"When retrieving model records, you may wish to limit your results based on "
"the absence of a relationship. For example, imagine you want to retrieve all "
"blog posts that **don't** have any comments. To do so, you may pass the name "
"of the relationship to the `doesntHave` and `orDoesntHave` methods:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1085
#, markdown-text, no-wrap
msgid "    $posts = Post::doesntHave('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1087
#, markdown-text
msgid ""
"If you need even more power, you may use the `whereDoesntHave` and "
"`orWhereDoesntHave` methods to add additional query constraints to your "
"`doesntHave` queries, such as inspecting the content of a comment:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1093
#, markdown-text, no-wrap
msgid ""
"    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1095
#, markdown-text
msgid ""
"You may use \"dot\" notation to execute a query against a nested "
"relationship. For example, the following query will retrieve all posts that "
"do not have comments; however, posts that have comments from authors that "
"are not banned will be included in the results:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1101
#, markdown-text, no-wrap
msgid ""
"    $posts = Post::whereDoesntHave('comments.author', function (Builder "
"$query) {\n"
"        $query->where('banned', 0);\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1103
#, markdown-text, no-wrap
msgid "<a name=\"querying-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1103
#, markdown-text, no-wrap
msgid "Querying Morph To Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1106
#, markdown-text
msgid ""
"To query the existence of \"morph to\" relationships, you may use the "
"`whereHasMorph` and `whereDoesntHaveMorph` methods. These methods accept the "
"name of the relationship as their first argument. Next, the methods accept "
"the names of the related models that you wish to include in the "
"query. Finally, you may provide a closure which customizes the relationship "
"query:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1111
#, markdown-text, no-wrap
msgid ""
"    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
"    use App\\Models\\Video;\n"
"    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1120
#, markdown-text, no-wrap
msgid ""
"    // Retrieve comments associated to posts or videos with a title like "
"code%...\n"
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1129
#, markdown-text, no-wrap
msgid ""
"    // Retrieve comments associated to posts with a title not like "
"code%...\n"
"    $comments = Comment::whereDoesntHaveMorph(\n"
"        'commentable',\n"
"        Post::class,\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1131
#, markdown-text
msgid ""
"You may occasionally need to add query constraints based on the \"type\" of "
"the related polymorphic model. The closure passed to the `whereHasMorph` "
"method may receive a `$type` value as its second argument. This argument "
"allows you to inspect the \"type\" of the query that is being built:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1139
#, markdown-text, no-wrap
msgid ""
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query, $type) {\n"
"            $column = $type === Post::class ? 'content' : 'title';\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1143
#, markdown-text, no-wrap
msgid ""
"            $query->where($column, 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1145
#, markdown-text, no-wrap
msgid "<a name=\"querying-all-morph-to-related-models\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1145
#, markdown-text, no-wrap
msgid "Querying All Related Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1148
#, markdown-text
msgid ""
"Instead of passing an array of possible polymorphic models, you may provide "
"`*` as a wildcard value. This will instruct Laravel to retrieve all of the "
"possible polymorphic types from the database. Laravel will execute an "
"additional query in order to perform this operation:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1154
#, markdown-text, no-wrap
msgid ""
"    $comments = Comment::whereHasMorph('commentable', '*', function (Builder "
"$query) {\n"
"        $query->where('title', 'like', 'foo%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1156
#, markdown-text, no-wrap
msgid "<a name=\"aggregating-related-models\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:1156
#, markdown-text, no-wrap
msgid "Aggregating Related Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1159
#, markdown-text, no-wrap
msgid "<a name=\"counting-related-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1159
#, markdown-text, no-wrap
msgid "Counting Related Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1162
#, markdown-text
msgid ""
"Sometimes you may want to count the number of related models for a given "
"relationship without actually loading the models. To accomplish this, you "
"may use the `withCount` method. The `withCount` method which will place a "
"`{relation}_count` attribute on the resulting models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1166
#, markdown-text, no-wrap
msgid "    $posts = Post::withCount('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1170
#, markdown-text, no-wrap
msgid ""
"    foreach ($posts as $post) {\n"
"        echo $post->comments_count;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1172
#, markdown-text
msgid ""
"By passing an array to the `withCount` method, you may add the \"counts\" "
"for multiple relations as well as add additional constraints to the queries:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1178
#, markdown-text, no-wrap
msgid ""
"    $posts = Post::withCount(['votes', 'comments' => function (Builder "
"$query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1181
#, markdown-text, no-wrap
msgid ""
"    echo $posts[0]->votes_count;\n"
"    echo $posts[0]->comments_count;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1183
#, markdown-text
msgid ""
"You may also alias the relationship count result, allowing multiple counts "
"on the same relationship:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1192
#, markdown-text, no-wrap
msgid ""
"    $posts = Post::withCount([\n"
"        'comments',\n"
"        'comments as pending_comments_count' => function (Builder $query) "
"{\n"
"            $query->where('approved', false);\n"
"        },\n"
"    ])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1195
#, markdown-text, no-wrap
msgid ""
"    echo $posts[0]->comments_count;\n"
"    echo $posts[0]->pending_comments_count;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1197
#, markdown-text, no-wrap
msgid "<a name=\"deferred-count-loading\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1197
#: docs/master/eloquent-relationships.md:1259
#, markdown-text, no-wrap
msgid "Deferred Count Loading"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1200
#, markdown-text
msgid ""
"Using the `loadCount` method, you may load a relationship count after the "
"parent model has already been retrieved:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1202
#, markdown-text, no-wrap
msgid "    $book = Book::first();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1204
#, markdown-text, no-wrap
msgid "    $book->loadCount('genres');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1206
#, markdown-text
msgid ""
"If you need to set additional query constraints on the count query, you may "
"pass an array keyed by the relationships you wish to count. The array values "
"should be closures which receive the query builder instance:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1210
#, markdown-text, no-wrap
msgid ""
"    $book->loadCount(['reviews' => function ($query) {\n"
"        $query->where('rating', 5);\n"
"    }])\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1212
#, markdown-text, no-wrap
msgid "<a name=\"relationship-counting-and-custom-select-statements\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1212
#, markdown-text, no-wrap
msgid "Relationship Counting & Custom Select Statements"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1215
#, markdown-text
msgid ""
"If you're combining `withCount` with a `select` statement, ensure that you "
"call `withCount` after the `select` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1219
#, markdown-text, no-wrap
msgid ""
"    $posts = Post::select(['title', 'body'])\n"
"                    ->withCount('comments')\n"
"                    ->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1221
#, markdown-text, no-wrap
msgid "<a name=\"other-aggregate-functions\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1221
#, markdown-text, no-wrap
msgid "Other Aggregate Functions"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1224
#, markdown-text
msgid ""
"In addition to the `withCount` method, Eloquent provides `withMin`, "
"`withMax`, `withAvg`, and `withSum` methods. These methods will place a "
"`{relation}_{function}_{column}` attribute on your resulting models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1228
#, markdown-text, no-wrap
msgid "    $posts = Post::withSum('comments', 'votes')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1232
#, markdown-text, no-wrap
msgid ""
"    foreach ($posts as $post) {\n"
"        echo $post->comments_sum_votes;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1234
#, markdown-text
msgid ""
"Like the `loadCount` method, deferred versions of these methods are also "
"available. These additional aggregate operations may be performed on "
"Eloquent models that have already been retrieved:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1236
#, markdown-text, no-wrap
msgid "    $post = Post::first();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1238
#, markdown-text, no-wrap
msgid "    $post->loadSum('comments', 'votes');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1240
#, markdown-text, no-wrap
msgid "<a name=\"counting-related-models-on-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1240
#, markdown-text, no-wrap
msgid "Counting Related Models On Morph To Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1243
#, markdown-text
msgid ""
"If you would like to eager load a \"morph to\" relationship, as well as "
"related model counts for the various entities that may be returned by that "
"relationship, you may utilize the `with` method in combination with the "
"`morphTo` relationship's `morphWithCount` method."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1245
#, markdown-text
msgid ""
"In this example, let's assume that `Photo` and `Post` models may create "
"`ActivityFeed` models. We will assume the `ActivityFeed` model defines a "
"\"morph to\" relationship named `parentable` that allows us to retrieve the "
"parent `Photo` or `Post` model for a given `ActivityFeed` "
"instance. Additionally, let's assume that `Photo` models \"have many\" `Tag` "
"models and `Post` models \"have many\" `Comment` models."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1247
#, markdown-text
msgid ""
"Now, let's imagine we want to retrieve `ActivityFeed` instances and eager "
"load the `parentable` parent models for each `ActivityFeed` instance. In "
"addition, we want to retrieve the number of tags that are associated with "
"each parent photo and the number of comments that are associated with each "
"parent post:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1249
#: docs/master/eloquent-relationships.md:1359
#, markdown-text, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1257
#, markdown-text, no-wrap
msgid ""
"    $activities = ActivityFeed::with([\n"
"        'parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWithCount([\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['comments'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1259
#, markdown-text, no-wrap
msgid "<a name=\"morph-to-deferred-count-loading\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1262
#, markdown-text
msgid ""
"Let's assume we have already retrieved a set of `ActivityFeed` models and "
"now we would like to load the nested relationship counts for the various "
"`parentable` models associated with the activity feeds. You may use the "
"`loadMorphCount` method to accomplish this:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1264
#, markdown-text, no-wrap
msgid "    $activities = ActivityFeed::with('parentable')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1269
#, markdown-text, no-wrap
msgid ""
"    $activities->loadMorphCount('parentable', [\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['comments'],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1271
#, markdown-text, no-wrap
msgid "<a name=\"eager-loading\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:1271
#, markdown-text, no-wrap
msgid "Eager Loading"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1274
#, markdown-text
msgid ""
"When accessing Eloquent relationships as properties, the related models are "
"\"lazy loaded\". This means the relationship data is not actually loaded "
"until you first access the property. However, Eloquent can \"eager load\" "
"relationships at the time you query the parent model. Eager loading "
"alleviates the \"N + 1\" query problem. To illustrate the N + 1 query "
"problem, consider a `Book` model that \"belongs to\" to an `Author` model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1291
#, markdown-text, no-wrap
msgid ""
"    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1293
#, markdown-text
msgid "Now, let's retrieve all books and their authors:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1295
#: docs/master/eloquent-relationships.md:1457
#, markdown-text, no-wrap
msgid "    use App\\Models\\Book;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1297
#: docs/master/eloquent-relationships.md:1459
#, markdown-text, no-wrap
msgid "    $books = Book::all();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1301
#: docs/master/eloquent-relationships.md:1311
#, markdown-text, no-wrap
msgid ""
"    foreach ($books as $book) {\n"
"        echo $book->author->name;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1303
#, markdown-text
msgid ""
"This loop will execute one query to retrieve all of the books within the "
"database table, then another query for each book in order to retrieve the "
"book's author. So, if we have 25 books, the code above would run 26 queries: "
"one for the original book, and 25 additional queries to retrieve the author "
"of each book."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1305
#, markdown-text
msgid ""
"Thankfully, we can use eager loading to reduce this operation to just two "
"queries. When building a query, you may specify which relationships should "
"be eager loaded using the `with` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1307
#, markdown-text, no-wrap
msgid "    $books = Book::with('author')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1313
#, markdown-text
msgid ""
"For this operation, only two queries will be executed - one query to "
"retrieve all of the books and one query to retrieve all of the authors for "
"all of the books:"
msgstr ""

#. type: Fenced code block (sql)
#: docs/master/eloquent-relationships.md:1314
#, no-wrap
msgid ""
"select * from books\n"
"\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1321
#, markdown-text, no-wrap
msgid "<a name=\"eager-loading-multiple-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1321
#, markdown-text, no-wrap
msgid "Eager Loading Multiple Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1324
#, markdown-text
msgid ""
"Sometimes you may need to eager load several different relationships. To do "
"so, just pass an array of relationships to the `with` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1326
#, markdown-text, no-wrap
msgid "    $books = Book::with(['author', 'publisher'])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1328
#, markdown-text, no-wrap
msgid "<a name=\"nested-eager-loading\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1328
#, markdown-text, no-wrap
msgid "Nested Eager Loading"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1331
#, markdown-text
msgid ""
"To eager a relationship's relationships, you may use \"dot\" syntax. For "
"example, let's eager load all of the book's authors and all of the author's "
"personal contacts:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1333
#, markdown-text, no-wrap
msgid "    $books = Book::with('author.contacts')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1335
#, markdown-text, no-wrap
msgid "<a name=\"nested-eager-loading-morphto-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1335
#, markdown-text, no-wrap
msgid "Nested Eager Loading `morphTo` Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1338
#, markdown-text
msgid ""
"If you would like to eager load a `morphTo` relationship, as well as nested "
"relationships on the various entities that may be returned by that "
"relationship, you may use the `with` method in combination with the "
"`morphTo` relationship's `morphWith` method. To help illustrate this method, "
"let's consider the following model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1353
#: docs/master/eloquent-relationships.md:1495
#, markdown-text, no-wrap
msgid ""
"    class ActivityFeed extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent of the activity feed record.\n"
"         */\n"
"        public function parentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1355
#: docs/master/eloquent-relationships.md:1497
#, markdown-text
msgid ""
"In this example, let's assume `Event`, `Photo`, and `Post` models may create "
"`ActivityFeed` models. Additionally, let's assume that `Event` models belong "
"to a `Calendar` model, `Photo` models are associated with `Tag` models, and "
"`Post` models belong to an `Author` model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1357
#: docs/master/eloquent-relationships.md:1499
#, markdown-text
msgid ""
"Using these model definitions and relationships, we may retrieve "
"`ActivityFeed` model instances and eager load all `parentable` models and "
"their respective nested relationships:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1368
#, markdown-text, no-wrap
msgid ""
"    $activities = ActivityFeed::query()\n"
"        ->with(['parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWith([\n"
"                Event::class => ['calendar'],\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['author'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1370
#, markdown-text, no-wrap
msgid "<a name=\"eager-loading-specific-columns\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1370
#, markdown-text, no-wrap
msgid "Eager Loading Specific Columns"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1373
#, markdown-text
msgid ""
"You may not always need every column from the relationships you are "
"retrieving. For this reason, Eloquent allows you to specify which columns of "
"the relationship you would like to retrieve:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1375
#, markdown-text, no-wrap
msgid "    $books = Book::with('author:id,name')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1377
#, markdown-text, no-wrap
msgid ""
"> {note} When using this feature, you should always include the `id` column "
"and any relevant foreign key columns in the list of columns you wish to "
"retrieve.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1379
#, markdown-text, no-wrap
msgid "<a name=\"eager-loading-by-default\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1379
#, markdown-text, no-wrap
msgid "Eager Loading By Default"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1382
#, markdown-text
msgid ""
"Sometimes you might want to always load some relationships when retrieving a "
"model. To accomplish this, you may define a `$with` property on the model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1397
#, markdown-text, no-wrap
msgid ""
"    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * The relationships that should always be loaded.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $with = ['author'];\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1406
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1408
#, markdown-text
msgid ""
"If you would like to remove an item from the `$with` property for a single "
"query, you may use the `without` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1410
#, markdown-text, no-wrap
msgid "    $books = Book::without('author')->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1412
#, markdown-text, no-wrap
msgid "<a name=\"constraining-eager-loads\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1412
#, markdown-text, no-wrap
msgid "Constraining Eager Loads"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1415
#, markdown-text
msgid ""
"Sometimes you may wish to eager load a relationship but also specify "
"additional query conditions for the eager loading query. You can accomplish "
"this by passing an array of relationships to the `with` method where the "
"array key is a relationship name and the array value is a closure that adds "
"additional constraints to the eager loading query:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1421
#, markdown-text, no-wrap
msgid ""
"    $users = User::with(['posts' => function ($query) {\n"
"        $query->where('title', 'like', '%code%');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1423
#, markdown-text
msgid ""
"In this example, Eloquent will only eager load posts where the post's "
"`title` column contains the word `code`. You may call other [query "
"builder](/docs/{{version}}/queries) methods to further customize the eager "
"loading operation:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1427
#, markdown-text, no-wrap
msgid ""
"    $users = User::with(['posts' => function ($query) {\n"
"        $query->orderBy('created_at', 'desc');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1429
#, markdown-text, no-wrap
msgid ""
"> {note} The `limit` and `take` query builder methods may not be used when "
"constraining eager loads.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1431
#, markdown-text, no-wrap
msgid "<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1431
#, markdown-text, no-wrap
msgid "Constraining Eager Loading Of `morphTo` Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1434
#, markdown-text
msgid ""
"If you are eager loading a `morphTo` relationship, Eloquent will run "
"multiple queries to fetch each type of related model. You may add additional "
"constraints to each of these queries using the `MorphTo` relation's "
"`constrain` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1437
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Database\\Eloquent\\Builder;\n"
"    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1448
#, markdown-text, no-wrap
msgid ""
"    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) "
"{\n"
"        $morphTo->constrain([\n"
"            Post::class => function (Builder $query) {\n"
"                $query->whereNull('hidden_at');\n"
"            },\n"
"            Video::class => function (Builder $query) {\n"
"                $query->where('type', 'educational');\n"
"            },\n"
"        ]);\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1450
#, markdown-text
msgid ""
"In this example, Eloquent will only eager load posts that have not been "
"hidden and videos have a `type` value of \"educational\"."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1452
#, markdown-text, no-wrap
msgid "<a name=\"lazy-eager-loading\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1452
#, markdown-text, no-wrap
msgid "Lazy Eager Loading"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1455
#, markdown-text
msgid ""
"Sometimes you may need to eager load a relationship after the parent model "
"has already been retrieved. For example, this may be useful if you need to "
"dynamically decide whether to load related models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1463
#, markdown-text, no-wrap
msgid ""
"    if ($someCondition) {\n"
"        $books->load('author', 'publisher');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1465
#, markdown-text
msgid ""
"If you need to set additional query constraints on the eager loading query, "
"you may pass an array keyed by the relationships you wish to load. The array "
"values should be closure instances which receive the query instance:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1469
#, markdown-text, no-wrap
msgid ""
"    $author->load(['books' => function ($query) {\n"
"        $query->orderBy('published_date', 'asc');\n"
"    }]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1471
#, markdown-text
msgid ""
"To load a relationship only when it has not already been loaded, use the "
"`loadMissing` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1473
#, markdown-text, no-wrap
msgid "    $book->loadMissing('author');\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1475
#, markdown-text, no-wrap
msgid "<a name=\"nested-lazy-eager-loading-morphto\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1475
#, markdown-text, no-wrap
msgid "Nested Lazy Eager Loading & `morphTo`"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1478
#, markdown-text
msgid ""
"If you would like to eager load a `morphTo` relationship, as well as nested "
"relationships on the various entities that may be returned by that "
"relationship, you may use the `loadMorph` method."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1480
#, markdown-text
msgid ""
"This method accepts the name of the `morphTo` relationship as its first "
"argument, and an array of model / relationship pairs as its second "
"argument. To help illustrate this method, let's consider the following "
"model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1507
#, markdown-text, no-wrap
msgid ""
"    $activities = ActivityFeed::with('parentable')\n"
"        ->get()\n"
"        ->loadMorph('parentable', [\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1509
#, markdown-text, no-wrap
msgid "<a name=\"inserting-and-updating-related-models\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:1509
#, markdown-text, no-wrap
msgid "Inserting & Updating Related Models"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1512
#, markdown-text, no-wrap
msgid "<a name=\"the-save-method\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1512
#, markdown-text, no-wrap
msgid "The `save` Method"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1515
#, markdown-text
msgid ""
"Eloquent provides convenient methods for adding new models to "
"relationships. For example, perhaps you need to add a new comment to a "
"post. Instead of manually setting the `post_id` attribute on the `Comment` "
"model you may insert the comment using the relationship's `save` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1518
#, markdown-text, no-wrap
msgid ""
"    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1520
#, markdown-text, no-wrap
msgid "    $comment = new Comment(['message' => 'A new comment.']);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1524
#: docs/master/eloquent-relationships.md:1539
#, markdown-text, no-wrap
msgid "    $post->comments()->save($comment);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1526
#, markdown-text
msgid ""
"Note that we did not access the `comments` relationship as a dynamic "
"property. Instead, we called the `comments` method to obtain an instance of "
"the relationship. The `save` method will automatically add the appropriate "
"`post_id` value to the new `Comment` model."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1528
#, markdown-text
msgid ""
"If you need to save multiple related models, you may use the `saveMany` "
"method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1535
#, markdown-text, no-wrap
msgid ""
"    $post->comments()->saveMany([\n"
"        new Comment(['message' => 'A new comment.']),\n"
"        new Comment(['message' => 'Another new comment.']),\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1537
#, markdown-text
msgid ""
"The `save` and `saveMany` methods will not add the new models to any "
"in-memory relationships that are already loaded onto the parent model. If "
"you plan on accessing the relationship after using the `save` or `saveMany` "
"methods, you may wish to use the `refresh` method to reload the model and "
"its relationships:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1541
#, markdown-text, no-wrap
msgid "    $post->refresh();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1544
#, markdown-text, no-wrap
msgid ""
"    // All comments, including the newly saved comment...\n"
"    $post->comments;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1546
#, markdown-text, no-wrap
msgid "<a name=\"the-push-method\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1546
#, markdown-text, no-wrap
msgid "Recursively Saving Models & Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1549
#, markdown-text
msgid ""
"If you would like to `save` your model and all of its associated "
"relationships, you may use the `push` method. In this example, the `Post` "
"model will be saved as well as its comments and the comment's authors:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1554
#, markdown-text, no-wrap
msgid ""
"    $post->comments[0]->message = 'Message';\n"
"    $post->comments[0]->author->name = 'Author Name';\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1556
#, markdown-text, no-wrap
msgid "    $post->push();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1558
#, markdown-text, no-wrap
msgid "<a name=\"the-create-method\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1558
#, markdown-text, no-wrap
msgid "The `create` Method"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1561
#, markdown-text
msgid ""
"In addition to the `save` and `saveMany` methods, you may also use the "
"`create` method, which accepts an array of attributes, creates a model, and "
"inserts it into the database. The difference between `save` and `create` is "
"that `save` accepts a full Eloquent model instance while `create` accepts a "
"plain PHP `array`. The newly created model will be returned by the `create` "
"method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1569
#, markdown-text, no-wrap
msgid ""
"    $comment = $post->comments()->create([\n"
"        'message' => 'A new comment.',\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1571
#, markdown-text
msgid "You may use the `createMany` method to create multiple related models:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1578
#, markdown-text, no-wrap
msgid ""
"    $post->comments()->createMany([\n"
"        ['message' => 'A new comment.'],\n"
"        ['message' => 'Another new comment.'],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1580
#, markdown-text
msgid ""
"You may also use the `findOrNew`, `firstOrNew`, `firstOrCreate`, and "
"`updateOrCreate` methods to [create and update models on "
"relationships](https://laravel.com/docs/{{version}}/eloquent#upserts)."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1582
#, markdown-text, no-wrap
msgid ""
"> {tip} Before using the `create` method, be sure to review the [mass "
"assignment](/docs/{{version}}/eloquent#mass-assignment) documentation.\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1584
#, markdown-text, no-wrap
msgid "<a name=\"updating-belongs-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/eloquent-relationships.md:1584
#, markdown-text, no-wrap
msgid "Belongs To Relationships"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1587
#, markdown-text
msgid ""
"If you would like to assign a child model to a new parent model, you may use "
"the `associate` method. In this example, the `User` model defines a "
"`belongsTo` relationship to the `Account` model. This `associate` method "
"will set the foreign key on the child model:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1589
#, markdown-text, no-wrap
msgid "    use App\\Models\\Account;\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1591
#, markdown-text, no-wrap
msgid "    $account = Account::find(10);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1593
#, markdown-text, no-wrap
msgid "    $user->account()->associate($account);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1595
#: docs/master/eloquent-relationships.md:1601
#, markdown-text, no-wrap
msgid "    $user->save();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1597
#, markdown-text
msgid ""
"To remove a parent model from a child model, you may use the `dissociate` "
"method. This method will set the relationship's foreign key to `null`:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1599
#, markdown-text, no-wrap
msgid "    $user->account()->dissociate();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1603
#, markdown-text, no-wrap
msgid "<a name=\"updating-many-to-many-relationships\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1606
#, markdown-text, no-wrap
msgid "<a name=\"attaching-detaching\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1606
#, markdown-text, no-wrap
msgid "Attaching / Detaching"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1609
#, markdown-text
msgid ""
"Eloquent also provides methods to make working with many-to-many "
"relationships more convenient. For example, let's imagine a user can have "
"many roles and a role can have many users. You may use the `attach` method "
"to attach a role to a user by inserting a record in the relationship's "
"intermediate table:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1615
#, markdown-text, no-wrap
msgid "    $user->roles()->attach($roleId);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1617
#, markdown-text
msgid ""
"When attaching a relationship to a model, you may also pass an array of "
"additional data to be inserted into the intermediate table:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1619
#, markdown-text, no-wrap
msgid "    $user->roles()->attach($roleId, ['expires' => $expires]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1621
#, markdown-text
msgid ""
"Sometimes it may be necessary to remove a role from a user. To remove a "
"many-to-many relationship record, use the `detach` method. The `detach` "
"method will delete the appropriate record out of the intermediate table; "
"however, both models will remain in the database:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1624
#, markdown-text, no-wrap
msgid ""
"    // Detach a single role from the user...\n"
"    $user->roles()->detach($roleId);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1627
#, markdown-text, no-wrap
msgid ""
"    // Detach all roles from the user...\n"
"    $user->roles()->detach();\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1629
#, markdown-text
msgid "For convenience, `attach` and `detach` also accept arrays of IDs as input:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1633
#, markdown-text, no-wrap
msgid "    $user->roles()->detach([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1638
#, markdown-text, no-wrap
msgid ""
"    $user->roles()->attach([\n"
"        1 => ['expires' => $expires],\n"
"        2 => ['expires' => $expires],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1640
#, markdown-text, no-wrap
msgid "<a name=\"syncing-associations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1640
#, markdown-text, no-wrap
msgid "Syncing Associations"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1643
#, markdown-text
msgid ""
"You may also use the `sync` method to construct many-to-many "
"associations. The `sync` method accepts an array of IDs to place on the "
"intermediate table. Any IDs that are not in the given array will be removed "
"from the intermediate table. So, after this operation is complete, only the "
"IDs in the given array will exist in the intermediate table:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1645
#, markdown-text, no-wrap
msgid "    $user->roles()->sync([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1647
#, markdown-text
msgid "You may also pass additional intermediate table values with the IDs:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1649
#, markdown-text, no-wrap
msgid "    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1651
#, markdown-text
msgid ""
"If you do not want to detach existing IDs that are missing from the given "
"array, you may use the `syncWithoutDetaching` method:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1653
#, markdown-text, no-wrap
msgid "    $user->roles()->syncWithoutDetaching([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1655
#, markdown-text, no-wrap
msgid "<a name=\"toggling-associations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1655
#, markdown-text, no-wrap
msgid "Toggling Associations"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1658
#, markdown-text
msgid ""
"The many-to-many relationship also provides a `toggle` method which "
"\"toggles\" the attachment status of the given related model IDs. If the "
"given ID is currently attached, it will be detached. Likewise, if it is "
"currently detached, it will be attached:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1660
#, markdown-text, no-wrap
msgid "    $user->roles()->toggle([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1662
#, markdown-text, no-wrap
msgid "<a name=\"updating-a-record-on-the-intermediate-table\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/eloquent-relationships.md:1662
#, markdown-text, no-wrap
msgid "Updating A Record On The Intermediate Table"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1665
#, markdown-text
msgid ""
"If you need to update an existing row in your relationship's intermediate "
"table, you may use the `updateExistingPivot` method. This method accepts the "
"intermediate record foreign key and an array of attributes to update:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1671
#, markdown-text, no-wrap
msgid ""
"    $user->roles()->updateExistingPivot($roleId, [\n"
"        'active' => false,\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1673
#, markdown-text, no-wrap
msgid "<a name=\"touching-parent-timestamps\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/eloquent-relationships.md:1673
#, markdown-text, no-wrap
msgid "Touching Parent Timestamps"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1676
#, markdown-text
msgid ""
"When a model defines a `belongsTo` or `belongsToMany` relationship to "
"another model, such as a `Comment` which belongs to a `Post`, it is "
"sometimes helpful to update the parent's timestamp when the child model is "
"updated."
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1678
#, markdown-text
msgid ""
"For example, when a `Comment` model is updated, you may want to "
"automatically \"touch\" the `updated_at` timestamp of the owning `Post` so "
"that it is set to the current date and time. To accomplish this, you may add "
"a `touches` property to your child model containing the names of the "
"relationships that should have their `updated_at` timestamps updated when "
"the child model is updated:"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1693
#, markdown-text, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * All of the relationships to be touched.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $touches = ['post'];\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1702
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Get the post that the comment belongs to.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/eloquent-relationships.md:1703
#, markdown-text, no-wrap
msgid ""
"> {note} Parent model timestamps will only be updated if the child model is "
"updated using Eloquent's `save` method.\n"
msgstr ""
