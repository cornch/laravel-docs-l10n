msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/queues.pot\n"
"X-Crowdin-File-ID: 125\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2022-02-19 15:51\n"

#: docs/8.x/queues.md:block 1 (header)
msgid "Queues"
msgstr "佇列 - Queue"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Connections Vs. Queues](#connections-vs-queues)"
msgstr "[連線 Vs. 佇列](#connections-vs-queues)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Driver Notes & Prerequisites](#driver-prerequisites)"
msgstr "[Driver 注意事項與前置需求](#driver-prerequisites)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Creating Jobs](#creating-jobs)"
msgstr "[建立 Job](#creating-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Generating Job Classes](#generating-job-classes)"
msgstr "[產生 Job 類別](#generating-job-classes)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Class Structure](#class-structure)"
msgstr "[類別架構](#class-structure)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Unique Jobs](#unique-jobs)"
msgstr "[不重複 Job](#unique-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Job Middleware](#job-middleware)"
msgstr "[Job Middleware](#job-middleware)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Rate Limiting](#rate-limiting)"
msgstr "[頻率限制](#rate-limiting)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Preventing Job Overlaps](#preventing-job-overlaps)"
msgstr "[避免 Job 重疊](#preventing-job-overlaps)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Throttling Exceptions](#throttling-exceptions)"
msgstr "[頻率限制的 Exception](#throttling-exceptions)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Dispatching Jobs](#dispatching-jobs)"
msgstr "[分派 Job](#dispatching-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Delayed Dispatching](#delayed-dispatching)"
msgstr "[延遲分派](#delayed-dispatching)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Synchronous Dispatching](#synchronous-dispatching)"
msgstr "[同步分派](#synchronous-dispatching)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Jobs & Database Transactions](#jobs-and-database-transactions)"
msgstr "[Job 與資料庫 Transaction](#jobs-and-database-transactions)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Job Chaining](#job-chaining)"
msgstr "[串聯 Job](#job-chaining)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Customizing The Queue & Connection](#customizing-the-queue-and-connection)"
msgstr "[自訂佇列與連線](#customizing-the-queue-and-connection)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Specifying Max Job Attempts / Timeout Values](#max-job-attempts-and-timeout)"
msgstr "[指定 Job 最大嘗試次數與逾時](#max-job-attempts-and-timeout)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Error Handling](#error-handling)"
msgstr "[錯誤處理](#error-handling)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Job Batching](#job-batching)"
msgstr "[批次 Job](#job-batching)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Defining Batchable Jobs](#defining-batchable-jobs)"
msgstr "[定義批次 Job](#defining-batchable-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Dispatching Batches](#dispatching-batches)"
msgstr "[分派批次](#dispatching-batches)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Adding Jobs To Batches](#adding-jobs-to-batches)"
msgstr "[將 Job 加入批次中](#adding-jobs-to-batches)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Inspecting Batches](#inspecting-batches)"
msgstr "[檢查批次](#inspecting-batches)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Cancelling Batches](#cancelling-batches)"
msgstr "[取消批次](#cancelling-batches)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Batch Failures](#batch-failures)"
msgstr "[批次執行失敗](#batch-failures)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Pruning Batches](#pruning-batches)"
msgstr "[修剪批次](#pruning-batches)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Queueing Closures](#queueing-closures)"
msgstr "[將閉包放入佇列](#queueing-closures)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Running The Queue Worker](#running-the-queue-worker)"
msgstr "[執行 Queue Worker](#running-the-queue-worker)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[The `queue:work` Command](#the-queue-work-command)"
msgstr "[`queue:work` 指令](#the-queue-work-command)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Queue Priorities](#queue-priorities)"
msgstr "[佇列的優先度](#queue-priorities)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Queue Workers & Deployment](#queue-workers-and-deployment)"
msgstr "[Queue Worker 與部署](#queue-workers-and-deployment)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Job Expirations & Timeouts](#job-expirations-and-timeouts)"
msgstr "[Job 的實效性與逾時](#job-expirations-and-timeouts)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Supervisor Configuration](#supervisor-configuration)"
msgstr "[Supervisor 組態設定](#supervisor-configuration)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Dealing With Failed Jobs](#dealing-with-failed-jobs)"
msgstr "[處理失敗的 Job](#dealing-with-failed-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Cleaning Up After Failed Jobs](#cleaning-up-after-failed-jobs)"
msgstr "[在 Job 失敗後進行清理](#cleaning-up-after-failed-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Retrying Failed Jobs](#retrying-failed-jobs)"
msgstr "[重試失敗的 Job](#retrying-failed-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Ignoring Missing Models](#ignoring-missing-models)"
msgstr "[忽略不存在的 Model](#ignoring-missing-models)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Pruning Failed Jobs](#pruning-failed-jobs)"
msgstr "[修剪失敗的 Job](#pruning-failed-jobs)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Storing Failed Jobs In DynamoDB](#storing-failed-jobs-in-dynamodb)"
msgstr "[在 DynamoDB 中保存失敗的 Job](#storing-failed-jobs-in-dynamodb)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Disabling Failed Job Storage](#disabling-failed-job-storage)"
msgstr "[禁用失敗 Job 的保存](#disabling-failed-job-storage)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Failed Job Events](#failed-job-events)"
msgstr "[失敗 Job 事件](#failed-job-events)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Clearing Jobs From Queues](#clearing-jobs-from-queues)"
msgstr "[在佇列中清除 Job](#clearing-jobs-from-queues)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Monitoring Your Queues](#monitoring-your-queues)"
msgstr "[監控佇列](#monitoring-your-queues)"

#: docs/8.x/queues.md:block 2 (unordered list)
msgid "[Job Events](#job-events)"
msgstr "[Job 事件](#job-events)"

#: docs/8.x/queues.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/8.x/queues.md:block 5 (paragraph)
msgid "While building your web application, you may have some tasks, such as parsing and storing an uploaded CSV file, that take too long to perform during a typical web request. Thankfully, Laravel allows you to easily create queued jobs that may be processed in the background. By moving time intensive tasks to a queue, your application can respond to web requests with blazing speed and provide a better user experience to your customers."
msgstr "在製作 Web App 時，有些任務若在 Web Request 中進行會花費太多時間，如解析 CSV 檔並上傳。所幸，在 Laravel 中，要建立在背景執行的佇列任務非常輕鬆。只要將需要花費時間的任務移到佇列中執行，就能加速網站對 Request 的回應速度，並提供更好的使用者經驗給客戶。"

#: docs/8.x/queues.md:block 6 (paragraph)
msgid "Laravel queues provide a unified queueing API across a variety of different queue backends, such as [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), or even a relational database."
msgstr "Laravel 的佇列為各種不同的佇列後端都提供了統一的 API。這些後端包括 [Amazon SQS](https://aws.amazon.com/sqs/)、[Redis](https://redis.io)、甚至是關聯式資料庫。"

#: docs/8.x/queues.md:block 7 (paragraph)
msgid "Laravel's queue configuration options are stored in your application's `config/queue.php` configuration file. In this file, you will find connection configurations for each of the queue drivers that are included with the framework, including the database, [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), and [Beanstalkd](https://beanstalkd.github.io/) drivers, as well as a synchronous driver that will execute jobs immediately (for use during local development). A `null` queue driver is also included which discards queued jobs."
msgstr "Laravel 的佇列設定選項保存在專案的 `config/queue.php` 設定檔中。在這個檔案內，可以看到供各個 Laravel 內建佇列 Driver 使用的連線設定，包含資料庫、[Amazon SQS](https://aws.amazon.com/sqs/)、[Redis](https://redis.io)、[Beanstalkd](https://beanstalkd.github.io/) 等 Driver，還包括一個會即時執行任務的同步佇列 (用於本機開發)。還包含一個 `null` 佇列，用於忽略佇列任務。"

#: docs/8.x/queues.md:block 8 (quote)
msgid "{tip} Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full [Horizon documentation](/docs/{{version}}/horizon) for more information."
msgstr "{tip} Laravel 現在還提供 Horizon。Horizon 是為 Redis 佇列提供的一個一個漂亮面板。更多資訊請參考完整的 [Horizon 說明文件](/docs/{{version}}/horizon)。"

#: docs/8.x/queues.md:block 10 (header)
msgid "Connections Vs. Queues"
msgstr "連線 Vs. 佇列"

#: docs/8.x/queues.md:block 11 (paragraph)
msgid "Before getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your `config/queue.php` configuration file, there is a `connections` configuration array. This option defines the connections to backend queue services such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs."
msgstr "在開始使用 Laravel 佇列前，我們需要先瞭解「^[連線](Connection)」與「^[佇列](Queue)」的差別。在 `config/queue.php` 設定檔中有個 `connections` 設定陣列。該選項用於定義連到後端佇列服務的連線，後端佇列服務就是像 Amazon SQS、Beanstalk、Redis 等。不過，一個佇列連線可以有多個「佇列」，我們可以將這些不同的佇列想成是幾個不同堆疊的佇列任務。"

#: docs/8.x/queues.md:block 12 (paragraph)
msgid "Note that each connection configuration example in the `queue` configuration file contains a `queue` attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the `queue` attribute of the connection configuration:"
msgstr "可以注意到範例 `queue` 設定檔中的各個範例連線設定中都包含了一個 `queue` 屬性。這個 `queue` 屬性指定的，就是當我們將任務傳給這個連線時預設會被分派的佇列。換句話說，若我們在分派任務時沒有顯式定義要分派到哪個佇列上，這個任務就會被分派到連線設定中 `queue` 屬性所定義的佇列上："

#: docs/8.x/queues.md:block 13 (code)
msgid "use App\\Jobs\\ProcessPodcast;\n\n"
"// This job is sent to the default connection's default queue...\n"
"ProcessPodcast::dispatch();\n\n"
"// This job is sent to the default connection's \"emails\" queue...\n"
"ProcessPodcast::dispatch()->onQueue('emails');\n"
msgstr "use App\\Jobs\\ProcessPodcast;\n\n"
"// 這個任務會被送到預設連線的預設佇列上...\n"
"ProcessPodcast::dispatch();\n\n"
"// 這個任務會被送到預設連線的「emails」佇列上...\n"
"ProcessPodcast::dispatch()->onQueue('emails');\n"

#: docs/8.x/queues.md:block 14 (paragraph)
msgid "Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a `high` queue, you may run a worker that gives them higher processing priority:"
msgstr "有的程式沒有要將任務推送到不同佇列的需求，這些程式只需要有單一佇列就好了。不過，因為 Laravel 的 Queue Worker 可調整各個 Queue 的優先處理等級，因此如果想要調整不同任務的優先處理順序，把任務推送到不同佇列就很有用。就來來說，我們如果把任務推送到 `high` 佇列，我們就可以執行一個 Worker 來讓這個佇列以更高優先級處理："

#: docs/8.x/queues.md:block 15 (code)
msgid "php artisan queue:work --queue=high,default\n"
msgstr "php artisan queue:work --queue=high,default\n"

#: docs/8.x/queues.md:block 17 (header)
msgid "Driver Notes & Prerequisites"
msgstr "Driver 注意事項與前置需求"

#: docs/8.x/queues.md:block 19 (header)
msgid "Database"
msgstr "Database"

#: docs/8.x/queues.md:block 20 (paragraph)
msgid "In order to use the `database` queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the `queue:table` Artisan command. Once the migration has been created, you may migrate your database using the `migrate` command:"
msgstr "若要使用 `database` 佇列 Driver，我們需要先有一個用來存放任務的資料庫資料表。若要產生一個用於建立這個資料表的 Migration，請執行 `queue:table` Artisan 指令。建立好 Migration 後，就可以使用 `migrate` 指令來 Migrate 資料庫："

#: docs/8.x/queues.md:block 21 (code)
msgid "php artisan queue:table\n\n"
"php artisan migrate\n"
msgstr "php artisan queue:table\n\n"
"php artisan migrate\n"

#: docs/8.x/queues.md:block 22 (paragraph)
msgid "Finally, don't forget to instruct your application to use the `database` driver by updating the `QUEUE_CONNECTION` variable in your application's `.env` file:"
msgstr "最後，別忘了更新專案 `.env` 檔中的 `QUEUE_CONNECTION` 變數來讓專案使用 `database` Driver："

#: docs/8.x/queues.md:block 23 (code)
msgid "QUEUE_CONNECTION=database\n"
msgstr "QUEUE_CONNECTION=database\n"

#: docs/8.x/queues.md:block 25 (header)
msgid "Redis"
msgstr "Redis"

#: docs/8.x/queues.md:block 26 (paragraph)
msgid "In order to use the `redis` queue driver, you should configure a Redis database connection in your `config/database.php` configuration file."
msgstr "若要使用 `redis` 佇列 Driver，請在 `config/database.php` 設定檔中設定 Redis 資料庫連線。"

#: docs/8.x/queues.md:block 27 (paragraph)
msgid "**Redis Cluster**"
msgstr "**Redis Cluster**"

#: docs/8.x/queues.md:block 28 (paragraph)
msgid "If your Redis queue connection uses a Redis Cluster, your queue names must contain a [key hash tag](https://redis.io/topics/cluster-spec#keys-hash-tags). This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:"
msgstr "若 Redis 佇列要使用 Redis Cluster，則設定的佇列名稱必須包含一個 [Key Hash Tag](https://redis.io/topics/cluster-spec#keys-hash-tags)。必須加上 Key Hash Tag，這樣才能確保給定佇列中所有的 Redis 索引鍵都有被放在相同的 Hash Slot 中："

#: docs/8.x/queues.md:block 29 (code)
msgid "'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => '{default}',\n"
"    'retry_after' => 90,\n"
"],\n"
msgstr "'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => '{default}',\n"
"    'retry_after' => 90,\n"
"],\n"

#: docs/8.x/queues.md:block 30 (paragraph)
msgid "**Blocking**"
msgstr "**Blocking**"

#: docs/8.x/queues.md:block 31 (paragraph)
msgid "When using the Redis queue, you may use the `block_for` configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database."
msgstr "在使用 Redis 佇列時，可使用 `block_for` 設定選項來指定 Redis Driver 在迭代 Worker 迴圈並重新讀取 Redis 資料庫來等新 Job 進來時要等待多久。"

#: docs/8.x/queues.md:block 32 (paragraph)
msgid "Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to `5` to indicate that the driver should block for five seconds while waiting for a job to become available:"
msgstr "可依據佇列的負載來調整這個值，以避免不斷讀取 Redis 資料庫來尋找新任務，會比較有效率。舉例來說，我們可以將其設為 `5`，表示 Redis Driver 在等待新任務出現時應先等待 5 秒再查詢 Redis 資料庫："

#: docs/8.x/queues.md:block 33 (code)
msgid "'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => 'default',\n"
"    'retry_after' => 90,\n"
"    'block_for' => 5,\n"
"],\n"
msgstr "'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => 'default',\n"
"    'retry_after' => 90,\n"
"    'block_for' => 5,\n"
"],\n"

#: docs/8.x/queues.md:block 34 (quote)
msgid "{note} Setting `block_for` to `0` will cause queue workers to block indefinitely until a job is available. This will also prevent signals such as `SIGTERM` from being handled until the next job has been processed."
msgstr "{note} 將 `block_for` 設為 `0` 會導致 Queue Worker 在新 Job 出現前一直 Block。也會導致在處理下一個 Job 前都無法處理如 `SIGTERM` 等^[訊號](Signal)。"

#: docs/8.x/queues.md:block 36 (header)
msgid "Other Driver Prerequisites"
msgstr "其他 Driver 的前置要求"

#: docs/8.x/queues.md:block 37 (paragraph)
msgid "The following dependencies are needed for the listed queue drivers. These dependencies may be installed via the Composer package manager:"
msgstr "下列 Queue Driver 還需要一些相依性套件。可以使用 Composer 套件管理員來安裝這些相依性套件："

#: docs/8.x/queues.md:block 39 (unordered list)
msgid "Amazon SQS: `aws/aws-sdk-php ~3.0`"
msgstr "Amazon SQS: `aws/aws-sdk-php ~3.0`"

#: docs/8.x/queues.md:block 39 (unordered list)
msgid "Beanstalkd: `pda/pheanstalk ~4.0`"
msgstr "Beanstalkd: `pda/pheanstalk ~4.0`"

#: docs/8.x/queues.md:block 39 (unordered list)
msgid "Redis: `predis/predis ~1.0` or phpredis PHP extension"
msgstr "Redis: `predis/predis ~1.0` 或 phpredis PHP 擴充套件"

#: docs/8.x/queues.md:block 42 (header)
msgid "Creating Jobs"
msgstr "建立 Job"

#: docs/8.x/queues.md:block 44 (header)
msgid "Generating Job Classes"
msgstr "產生 Job 類別"

#: docs/8.x/queues.md:block 45 (paragraph)
msgid "By default, all of the queueable jobs for your application are stored in the `app/Jobs` directory. If the `app/Jobs` directory doesn't exist, it will be created when you run the `make:job` Artisan command:"
msgstr "預設情況下，專案中所有可放入佇列的任務都存放在 `app/Jobs` 目錄內。若 `app/Jobs` 目錄不存在，則執行 `make:jobs` Artisan 指令時會建立該目錄："

#: docs/8.x/queues.md:block 46 (code)
msgid "php artisan make:job ProcessPodcast\n"
msgstr "php artisan make:job ProcessPodcast\n"

#: docs/8.x/queues.md:block 47 (paragraph)
msgid "The generated class will implement the `Illuminate\\Contracts\\Queue\\ShouldQueue` interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously."
msgstr "產生的類別會實作 `Illuminate\\Contracts\\Queue\\ShouldQueue` 介面，這樣 Laravel 就知道該 Job 要被推入佇列並以非同步方式執行。"

#: docs/8.x/queues.md:block 48 (quote)
msgid "{tip} Job stubs may be customized using [stub publishing](/docs/{{version}}/artisan#stub-customization)."
msgstr "{tip} 可以[安裝 Stub](/docs/{{version}}/artisan#stub-customization) 來自訂 Job 的 Stub。"

#: docs/8.x/queues.md:block 50 (header)
msgid "Class Structure"
msgstr "類別架構"

#: docs/8.x/queues.md:block 51 (paragraph)
msgid "Job classes are very simple, normally containing only a `handle` method that is invoked when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:"
msgstr "Job 類別非常簡單，通常只包含了一個 `handle` 方法，會在佇列處理 Job 時叫用。要開始使用 Job，我們先來看一個範例 Job 類別。在這個範例中，我們先假裝時我們在管理一個 Podcast 上架服務，我們需要在上架前處理上傳的 Podcast 檔案："

#: docs/8.x/queues.md:block 52 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Models\\Podcast\n"
"     */\n"
"    protected $podcast;\n\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Jobs;\n\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Models\\Podcast\n"
"     */\n"
"    protected $podcast;\n\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}\n"

#: docs/8.x/queues.md:block 53 (paragraph)
msgid "In this example, note that we were able to pass an [Eloquent model](/docs/{{version}}/eloquent) directly into the queued job's constructor. Because of the `SerializesModels` trait that the job is using, Eloquent models and their loaded relationships will be gracefully serialized and unserialized when the job is processing."
msgstr "在這個範例中，可以看到我們直接將 [Eloquent Model] 傳入佇列任務的 ^[Constructor](建構函式) 中。由於該任務有使用 `SerializesModels` Trait，所以 Eloquent Model 與已載入的關聯 Model 都會被序列化處理，並在處理任務時反序列化。"

#: docs/8.x/queues.md:block 54 (paragraph)
msgid "If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance and its loaded relationships from the database. This approach to model serialization allows for much smaller job payloads to be sent to your queue driver."
msgstr "若佇列任務的 Constructor 中接受 Eloquent Model，則只有 Model 的^[識別元](Identifier)會被序列化進佇列中。實際要處理任務時，佇列系統會自動從資料庫中重新取得完整的 Model 實體以及已載入的關聯。通過這種序列化 Model 的做法，我們就能縮小傳入佇列 Driver 的任務^[承載](Payload)。"

#: docs/8.x/queues.md:block 56 (header)
msgid "`handle` Method Dependency Injection"
msgstr "`handle` 方法的相依性插入"

#: docs/8.x/queues.md:block 57 (paragraph)
msgid "The `handle` method is invoked when the job is processed by the queue. Note that we are able to type-hint dependencies on the `handle` method of the job. The Laravel [service container](/docs/{{version}}/container) automatically injects these dependencies."
msgstr "佇列在處理任務時會叫用該任務的 `handle` 方法。請注意，我們可以在任務的 `handle` 方法上^[型別提示](Type-Hint)任何相依性項目。Laravel [Service Container](/docs/{{version}}/container) 會自動插入這些相依性。"

#: docs/8.x/queues.md:block 58 (paragraph)
msgid "If you would like to take total control over how the container injects dependencies into the `handle` method, you may use the container's `bindMethod` method. The `bindMethod` method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the `handle` method however you wish. Typically, you should call this method from the `boot` method of your `App\\Providers\\AppServiceProvider` [service provider](/docs/{{version}}/providers):"
msgstr "若想完整控制 Container 要如何插入這些相依性到 `handle` 方法，可使用 Container 的 `bindMethod` 方法。`bindMethod` 方法接收一個回呼，該回呼則接收該任務與 Container。我們可以在這個回呼中自行叫用 `handle` 方法。一般來說，我們應該從 `App\\Providers\\AppServiceProvider` [Service Provider](/docs/{{version}}/providers) 的 `boot` 方法中叫用這個方法："

#: docs/8.x/queues.md:block 59 (code)
msgid "use App\\Jobs\\ProcessPodcast;\n"
"use App\\Services\\AudioProcessor;\n\n"
"$this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {\n"
"    return $job->handle($app->make(AudioProcessor::class));\n"
"});\n"
msgstr "use App\\Jobs\\ProcessPodcast;\n"
"use App\\Services\\AudioProcessor;\n\n"
"$this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {\n"
"    return $job->handle($app->make(AudioProcessor::class));\n"
"});\n"

#: docs/8.x/queues.md:block 60 (quote)
msgid "{note} Binary data, such as raw image contents, should be passed through the `base64_encode` function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue."
msgstr "{note} 二進位資料，如圖片等，應在傳入佇列任務前先使用 `base64_encode` 函式進行編碼。若未進行編碼，則這些資料在放入佇列時可能無法正確被序列化為 JSON。"

#: docs/8.x/queues.md:block 62 (header)
msgid "Queued Relationships"
msgstr "佇列中的關聯"

#: docs/8.x/queues.md:block 63 (paragraph)
msgid "Because loaded relationships also get serialized, the serialized job string can sometimes become quite large. To prevent relations from being serialized, you can call the `withoutRelations` method on the model when setting a property value. This method will return an instance of the model without its loaded relationships:"
msgstr "由於 Model 上已載入的關聯也會被序列化，因此序列化的任務字串有時候會變得很大。若要防止關聯被序列化，可在設定屬性值時在 Model 上呼叫 `withoutRelations` 方法。該方法會回傳該 Model 不含已載入關聯的實體："

#: docs/8.x/queues.md:block 64 (code)
msgid "/**\n"
" * Create a new job instance.\n"
" *\n"
" * @param  \\App\\Models\\Podcast  $podcast\n"
" * @return void\n"
" */\n"
"public function __construct(Podcast $podcast)\n"
"{\n"
"    $this->podcast = $podcast->withoutRelations();\n"
"}\n"
msgstr "/**\n"
" * Create a new job instance.\n"
" *\n"
" * @param  \\App\\Models\\Podcast  $podcast\n"
" * @return void\n"
" */\n"
"public function __construct(Podcast $podcast)\n"
"{\n"
"    $this->podcast = $podcast->withoutRelations();\n"
"}\n"

#: docs/8.x/queues.md:block 65 (paragraph)
msgid "Furthermore, when a job is deserialized and model relationships are re-retrieved from the database, they will be retrieved in their entirety. Any previous relationship constraints that were applied before the model was serialized during the job queueing process will not be applied when the job is deserialized. Therefore, if you wish to work with a subset of a given relationship, you should re-constrain that relationship within your queued job."
msgstr "此外，當任務被反序列化，然後 Model 關聯被從資料庫中重新取出時，這些關聯的資料會以完整的關聯取出。這表示，若在 Model 被任務佇列序列化前有對關聯套用任何查詢條件，在反序列化時，這些條件都不會被套用。因此，若只想處理給定關聯中的一部分，應在佇列任務中重新套用這些查詢條件。"

#: docs/8.x/queues.md:block 67 (header)
msgid "Unique Jobs"
msgstr "不重複 Job"

#: docs/8.x/queues.md:block 68 (quote)
msgid "{note} Unique jobs require a cache driver that supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support atomic locks. In addition, unique job constraints do not apply to jobs within batches."
msgstr ""

#: docs/8.x/queues.md:block 69 (paragraph)
msgid "Sometimes, you may want to ensure that only one instance of a specific job is on the queue at any point in time. You may do so by implementing the `ShouldBeUnique` interface on your job class. This interface does not require you to define any additional methods on your class:"
msgstr ""

#: docs/8.x/queues.md:block 70 (code)
msgid "<?php\n\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    ...\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 71 (paragraph)
msgid "In the example above, the `UpdateSearchIndex` job is unique. So, the job will not be dispatched if another instance of the job is already on the queue and has not finished processing."
msgstr ""

#: docs/8.x/queues.md:block 72 (paragraph)
msgid "In certain cases, you may want to define a specific \"key\" that makes the job unique or you may want to specify a timeout beyond which the job no longer stays unique. To accomplish this, you may define `uniqueId` and `uniqueFor` properties or methods on your job class:"
msgstr ""

#: docs/8.x/queues.md:block 73 (code)
msgid "<?php\n\n"
"use App\\Product;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    /**\n"
"     * The product instance.\n"
"     *\n"
"     * @var \\App\\Product\n"
"     */\n"
"    public $product;\n\n"
"    /**\n"
"     * The number of seconds after which the job's unique lock will be released.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $uniqueFor = 3600;\n\n"
"    /**\n"
"     * The unique ID of the job.\n"
"     *\n"
"     * @return string\n"
"     */\n"
"    public function uniqueId()\n"
"    {\n"
"        return $this->product->id;\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 74 (paragraph)
msgid "In the example above, the `UpdateSearchIndex` job is unique by a product ID. So, any new dispatches of the job with the same product ID will be ignored until the existing job has completed processing. In addition, if the existing job is not processed within one hour, the unique lock will be released and another job with the same unique key can be dispatched to the queue."
msgstr ""

#: docs/8.x/queues.md:block 76 (header)
msgid "Keeping Jobs Unique Until Processing Begins"
msgstr ""

#: docs/8.x/queues.md:block 77 (paragraph)
msgid "By default, unique jobs are \"unlocked\" after a job completes processing or fails all of its retry attempts. However, there may be situations where you would like your job to unlock immediately before it is processed. To accomplish this, your job should implement the `ShouldBeUniqueUntilProcessing` contract instead of the `ShouldBeUnique` contract:"
msgstr ""

#: docs/8.x/queues.md:block 78 (code)
msgid "<?php\n\n"
"use App\\Product;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\n\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing\n"
"{\n"
"    // ...\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 80 (header)
msgid "Unique Job Locks"
msgstr ""

#: docs/8.x/queues.md:block 81 (paragraph)
msgid "Behind the scenes, when a `ShouldBeUnique` job is dispatched, Laravel attempts to acquire a [lock](/docs/{{version}}/cache#atomic-locks) with the `uniqueId` key. If the lock is not acquired, the job is not dispatched. This lock is released when the job completes processing or fails all of its retry attempts. By default, Laravel will use the default cache driver to obtain this lock. However, if you wish to use another driver for acquiring the lock, you may define a `uniqueVia` method that returns the cache driver that should be used:"
msgstr ""

#: docs/8.x/queues.md:block 82 (code)
msgid "use Illuminate\\Support\\Facades\\Cache;\n\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    ...\n\n"
"    /**\n"
"     * Get the cache driver for the unique job lock.\n"
"     *\n"
"     * @return \\Illuminate\\Contracts\\Cache\\Repository\n"
"     */\n"
"    public function uniqueVia()\n"
"    {\n"
"        return Cache::driver('redis');\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 83 (quote)
msgid "{tip} If you only need to limit the concurrent processing of a job, use the [`WithoutOverlapping`](/docs/{{version}}/queues#preventing-job-overlaps) job middleware instead."
msgstr ""

#: docs/8.x/queues.md:block 85 (header)
msgid "Job Middleware"
msgstr ""

#: docs/8.x/queues.md:block 86 (paragraph)
msgid "Job middleware allow you to wrap custom logic around the execution of queued jobs, reducing boilerplate in the jobs themselves. For example, consider the following `handle` method which leverages Laravel's Redis rate limiting features to allow only one job to process every five seconds:"
msgstr ""

#: docs/8.x/queues.md:block 87 (code)
msgid "use Illuminate\\Support\\Facades\\Redis;\n\n"
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {\n"
"        info('Lock obtained...');\n\n"
"        // Handle job...\n"
"    }, function () {\n"
"        // Could not obtain lock...\n\n"
"        return $this->release(5);\n"
"    });\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 88 (paragraph)
msgid "While this code is valid, the implementation of the `handle` method becomes noisy since it is cluttered with Redis rate limiting logic. In addition, this rate limiting logic must be duplicated for any other jobs that we want to rate limit."
msgstr ""

#: docs/8.x/queues.md:block 89 (paragraph)
msgid "Instead of rate limiting in the handle method, we could define a job middleware that handles rate limiting. Laravel does not have a default location for job middleware, so you are welcome to place job middleware anywhere in your application. In this example, we will place the middleware in an `app/Jobs/Middleware` directory:"
msgstr ""

#: docs/8.x/queues.md:block 90 (code)
msgid "<?php\n\n"
"namespace App\\Jobs\\Middleware;\n\n"
"use Illuminate\\Support\\Facades\\Redis;\n\n"
"class RateLimited\n"
"{\n"
"    /**\n"
"     * Process the queued job.\n"
"     *\n"
"     * @param  mixed  $job\n"
"     * @param  callable  $next\n"
"     * @return mixed\n"
"     */\n"
"    public function handle($job, $next)\n"
"    {\n"
"        Redis::throttle('key')\n"
"                ->block(0)->allow(1)->every(5)\n"
"                ->then(function () use ($job, $next) {\n"
"                    // Lock obtained...\n\n"
"                    $next($job);\n"
"                }, function () use ($job) {\n"
"                    // Could not obtain lock...\n\n"
"                    $job->release(5);\n"
"                });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 91 (paragraph)
msgid "As you can see, like [route middleware](/docs/{{version}}/middleware), job middleware receive the job being processed and a callback that should be invoked to continue processing the job."
msgstr ""

#: docs/8.x/queues.md:block 92 (paragraph)
msgid "After creating job middleware, they may be attached to a job by returning them from the job's `middleware` method. This method does not exist on jobs scaffolded by the `make:job` Artisan command, so you will need to manually add it to your job class:"
msgstr ""

#: docs/8.x/queues.md:block 93 (code)
msgid "use App\\Jobs\\Middleware\\RateLimited;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new RateLimited];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 94 (quote)
msgid "{tip} Job middleware can also be assigned to queueable event listeners, mailables, and notifications."
msgstr ""

#: docs/8.x/queues.md:block 96 (header)
msgid "Rate Limiting"
msgstr ""

#: docs/8.x/queues.md:block 97 (paragraph)
msgid "Although we just demonstrated how to write your own rate limiting job middleware, Laravel actually includes a rate limiting middleware that you may utilize to rate limit jobs. Like [route rate limiters](/docs/{{version}}/routing#defining-rate-limiters), job rate limiters are defined using the `RateLimiter` facade's `for` method."
msgstr ""

#: docs/8.x/queues.md:block 98 (paragraph)
msgid "For example, you may wish to allow users to backup their data once per hour while imposing no such limit on premium customers. To accomplish this, you may define a `RateLimiter` in the `boot` method of your `AppServiceProvider`:"
msgstr ""

#: docs/8.x/queues.md:block 99 (code)
msgid "use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"use Illuminate\\Support\\Facades\\RateLimiter;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    RateLimiter::for('backups', function ($job) {\n"
"        return $job->user->vipCustomer()\n"
"                    ? Limit::none()\n"
"                    : Limit::perHour(1)->by($job->user->id);\n"
"    });\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 100 (paragraph)
msgid "In the example above, we defined an hourly rate limit; however, you may easily define a rate limit based on minutes using the `perMinute` method. In addition, you may pass any value you wish to the `by` method of the rate limit; however, this value is most often used to segment rate limits by customer:"
msgstr ""

#: docs/8.x/queues.md:block 101 (code)
msgid "return Limit::perMinute(50)->by($job->user->id);\n"
msgstr ""

#: docs/8.x/queues.md:block 102 (paragraph)
msgid "Once you have defined your rate limit, you may attach the rate limiter to your backup job using the `Illuminate\\Queue\\Middleware\\RateLimited` middleware. Each time the job exceeds the rate limit, this middleware will release the job back to the queue with an appropriate delay based on the rate limit duration."
msgstr ""

#: docs/8.x/queues.md:block 103 (code)
msgid "use Illuminate\\Queue\\Middleware\\RateLimited;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new RateLimited('backups')];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 104 (paragraph)
msgid "Releasing a rate limited job back onto the queue will still increment the job's total number of `attempts`. You may wish to tune your `tries` and `maxExceptions` properties on your job class accordingly. Or, you may wish to use the [`retryUntil` method](#time-based-attempts) to define the amount of time until the job should no longer be attempted."
msgstr ""

#: docs/8.x/queues.md:block 105 (paragraph)
msgid "If you do not want a job to be retried when it is rate limited, you may use the `dontRelease` method:"
msgstr ""

#: docs/8.x/queues.md:block 106 (code)
msgid "/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new RateLimited('backups'))->dontRelease()];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 107 (quote)
msgid "{tip} If you are using Redis, you may use the `Illuminate\\Queue\\Middleware\\RateLimitedWithRedis` middleware, which is fine-tuned for Redis and more efficient than the basic rate limiting middleware."
msgstr ""

#: docs/8.x/queues.md:block 109 (header)
msgid "Preventing Job Overlaps"
msgstr ""

#: docs/8.x/queues.md:block 110 (paragraph)
msgid "Laravel includes an `Illuminate\\Queue\\Middleware\\WithoutOverlapping` middleware that allows you to prevent job overlaps based on an arbitrary key. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time."
msgstr ""

#: docs/8.x/queues.md:block 111 (paragraph)
msgid "For example, let's imagine you have a queued job that updates a user's credit score and you want to prevent credit score update job overlaps for the same user ID. To accomplish this, you can return the `WithoutOverlapping` middleware from your job's `middleware` method:"
msgstr ""

#: docs/8.x/queues.md:block 112 (code)
msgid "use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new WithoutOverlapping($this->user->id)];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 113 (paragraph)
msgid "Any overlapping jobs will be released back to the queue. You may also specify the number of seconds that must elapse before the released job will be attempted again:"
msgstr ""

#: docs/8.x/queues.md:block 114 (code)
msgid "/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 115 (paragraph)
msgid "If you wish to immediately delete any overlapping jobs so that they will not be retried, you may use the `dontRelease` method:"
msgstr ""

#: docs/8.x/queues.md:block 116 (code)
msgid "/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->dontRelease()];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 117 (paragraph)
msgid "The `WithoutOverlapping` middleware is powered by Laravel's atomic lock feature. Sometimes, your job may unexpectedly fail or timeout in such a way that the lock is not released. Therefore, you may explicitly define a lock expiration time using the `expireAfter` method. For example, the example below will instruct Laravel to release the `WithoutOverlapping` lock three minutes after the job has started processing:"
msgstr ""

#: docs/8.x/queues.md:block 118 (code)
msgid "/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 119 (quote)
msgid "{note} The `WithoutOverlapping` middleware requires a cache driver that supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support atomic locks."
msgstr ""

#: docs/8.x/queues.md:block 121 (header)
msgid "Throttling Exceptions"
msgstr ""

#: docs/8.x/queues.md:block 122 (paragraph)
msgid "Laravel includes a `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` middleware that allows you to throttle exceptions. Once the job throws a given number of exceptions, all further attempts to execute the job are delayed until a specified time interval lapses. This middleware is particularly useful for jobs that interact with third-party services that are unstable."
msgstr ""

#: docs/8.x/queues.md:block 123 (paragraph)
msgid "For example, let's imagine a queued job that interacts with a third-party API that begins throwing exceptions. To throttle exceptions, you can return the `ThrottlesExceptions` middleware from your job's `middleware` method. Typically, this middleware should be paired with a job that implements [time based attempts](#time-based-attempts):"
msgstr ""

#: docs/8.x/queues.md:block 124 (code)
msgid "use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new ThrottlesExceptions(10, 5)];\n"
"}\n\n"
"/**\n"
" * Determine the time at which the job should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(5);\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 125 (paragraph)
msgid "The first constructor argument accepted by the middleware is the number of exceptions the job can throw before being throttled, while the second constructor argument is the number of minutes that should elapse before the job is attempted again once it has been throttled. In the code example above, if the job throws 10 exceptions within 5 minutes, we will wait 5 minutes before attempting the job again."
msgstr ""

#: docs/8.x/queues.md:block 126 (paragraph)
msgid "When a job throws an exception but the exception threshold has not yet been reached, the job will typically be retried immediately. However, you may specify the number of minutes such a job should be delayed by calling the `backoff` method when attaching the middleware to the job:"
msgstr ""

#: docs/8.x/queues.md:block 127 (code)
msgid "use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 5))->backoff(5)];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 128 (paragraph)
msgid "Internally, this middleware uses Laravel's cache system to implement rate limiting, and the job's class name is utilized as the cache \"key\". You may override this key by calling the `by` method when attaching the middleware to your job. This may be useful if you have multiple jobs interacting with the same third-party service and you would like them to share a common throttling \"bucket\":"
msgstr ""

#: docs/8.x/queues.md:block 129 (code)
msgid "use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10))->by('key')];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 130 (quote)
msgid "{tip} If you are using Redis, you may use the `Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis` middleware, which is fine-tuned for Redis and more efficient than the basic exception throttling middleware."
msgstr ""

#: docs/8.x/queues.md:block 132 (header)
msgid "Dispatching Jobs"
msgstr ""

#: docs/8.x/queues.md:block 133 (paragraph)
msgid "Once you have written your job class, you may dispatch it using the `dispatch` method on the job itself. The arguments passed to the `dispatch` method will be given to the job's constructor:"
msgstr ""

#: docs/8.x/queues.md:block 134 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n\n"
"        // ...\n\n"
"        ProcessPodcast::dispatch($podcast);\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 135 (paragraph)
msgid "If you would like to conditionally dispatch a job, you may use the `dispatchIf` and `dispatchUnless` methods:"
msgstr ""

#: docs/8.x/queues.md:block 136 (code)
msgid "ProcessPodcast::dispatchIf($accountActive, $podcast);\n\n"
"ProcessPodcast::dispatchUnless($accountSuspended, $podcast);\n"
msgstr ""

#: docs/8.x/queues.md:block 138 (header)
msgid "Delayed Dispatching"
msgstr ""

#: docs/8.x/queues.md:block 139 (paragraph)
msgid "If you would like to specify that a job should not be immediately available for processing by a queue worker, you may use the `delay` method when dispatching the job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:"
msgstr ""

#: docs/8.x/queues.md:block 140 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n\n"
"        // ...\n\n"
"        ProcessPodcast::dispatch($podcast)\n"
"                    ->delay(now()->addMinutes(10));\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 141 (quote)
msgid "{note} The Amazon SQS queue service has a maximum delay time of 15 minutes."
msgstr ""

#: docs/8.x/queues.md:block 143 (header)
msgid "Dispatching After The Response Is Sent To Browser"
msgstr ""

#: docs/8.x/queues.md:block 144 (paragraph)
msgid "Alternatively, the `dispatchAfterResponse` method delays dispatching a job until after the HTTP response is sent to the user's browser. This will still allow the user to begin using the application even though a queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an email. Since they are processed within the current HTTP request, jobs dispatched in this fashion do not require a queue worker to be running in order for them to be processed:"
msgstr ""

#: docs/8.x/queues.md:block 145 (code)
msgid "use App\\Jobs\\SendNotification;\n\n"
"SendNotification::dispatchAfterResponse();\n"
msgstr ""

#: docs/8.x/queues.md:block 146 (paragraph)
msgid "You may also `dispatch` a closure and chain the `afterResponse` method onto the `dispatch` helper to execute a closure after the HTTP response has been sent to the browser:"
msgstr ""

#: docs/8.x/queues.md:block 147 (code)
msgid "use App\\Mail\\WelcomeMessage;\n"
"use Illuminate\\Support\\Facades\\Mail;\n\n"
"dispatch(function () {\n"
"    Mail::to('taylor@example.com')->send(new WelcomeMessage);\n"
"})->afterResponse();\n"
msgstr ""

#: docs/8.x/queues.md:block 149 (header)
msgid "Synchronous Dispatching"
msgstr ""

#: docs/8.x/queues.md:block 150 (paragraph)
msgid "If you would like to dispatch a job immediately (synchronously), you may use the `dispatchSync` method. When using this method, the job will not be queued and will be executed immediately within the current process:"
msgstr ""

#: docs/8.x/queues.md:block 151 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n\n"
"        // Create podcast...\n\n"
"        ProcessPodcast::dispatchSync($podcast);\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 153 (header)
msgid "Jobs & Database Transactions"
msgstr ""

#: docs/8.x/queues.md:block 154 (paragraph)
msgid "While it is perfectly fine to dispatch jobs within database transactions, you should take special care to ensure that your job will actually be able to execute successfully. When dispatching a job within a transaction, it is possible that the job will be processed by a worker before the transaction has committed. When this happens, any updates you have made to models or database records during the database transaction may not yet be reflected in the database. In addition, any models or database records created within the transaction may not exist in the database."
msgstr ""

#: docs/8.x/queues.md:block 155 (paragraph)
msgid "Thankfully, Laravel provides several methods of working around this problem. First, you may set the `after_commit` connection option in your queue connection's configuration array:"
msgstr ""

#: docs/8.x/queues.md:block 156 (code)
msgid "'redis' => [\n"
"    'driver' => 'redis',\n"
"    // ...\n"
"    'after_commit' => true,\n"
"],\n"
msgstr ""

#: docs/8.x/queues.md:block 157 (paragraph)
msgid "When the `after_commit` option is `true`, you may dispatch jobs within database transactions; however, Laravel will wait until all open database transactions have been committed before actually dispatching the job. Of course, if no database transactions are currently open, the job will be dispatched immediately."
msgstr ""

#: docs/8.x/queues.md:block 158 (paragraph)
msgid "If a transaction is rolled back due to an exception that occurs during the transaction, the dispatched jobs that were dispatched during that transaction will be discarded."
msgstr ""

#: docs/8.x/queues.md:block 159 (quote)
msgid "{tip} Setting the `after_commit` configuration option to `true` will also cause any queued event listeners, mailables, notifications, and broadcast events to be dispatched after all open database transactions have been committed."
msgstr ""

#: docs/8.x/queues.md:block 161 (header)
msgid "Specifying Commit Dispatch Behavior Inline"
msgstr ""

#: docs/8.x/queues.md:block 162 (paragraph)
msgid "If you do not set the `after_commit` queue connection configuration option to `true`, you may still indicate that a specific job should be dispatched after all open database transactions have been committed. To accomplish this, you may chain the `afterCommit` method onto your dispatch operation:"
msgstr ""

#: docs/8.x/queues.md:block 163 (code)
msgid "use App\\Jobs\\ProcessPodcast;\n\n"
"ProcessPodcast::dispatch($podcast)->afterCommit();\n"
msgstr ""

#: docs/8.x/queues.md:block 164 (paragraph)
msgid "Likewise, if the `after_commit` configuration option is set to `true`, you may indicate that a specific job should be dispatched immediately without waiting for any open database transactions to commit:"
msgstr ""

#: docs/8.x/queues.md:block 165 (code)
msgid "ProcessPodcast::dispatch($podcast)->beforeCommit();\n"
msgstr ""

#: docs/8.x/queues.md:block 167 (header)
msgid "Job Chaining"
msgstr ""

#: docs/8.x/queues.md:block 168 (paragraph)
msgid "Job chaining allows you to specify a list of queued jobs that should be run in sequence after the primary job has executed successfully. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the `chain` method provided by the `Bus` facade. Laravel's command bus is a lower level component that queued job dispatching is built on top of:"
msgstr ""

#: docs/8.x/queues.md:block 169 (code)
msgid "use App\\Jobs\\OptimizePodcast;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Jobs\\ReleasePodcast;\n"
"use Illuminate\\Support\\Facades\\Bus;\n\n"
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 170 (paragraph)
msgid "In addition to chaining job class instances, you may also chain closures:"
msgstr ""

#: docs/8.x/queues.md:block 171 (code)
msgid "Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    function () {\n"
"        Podcast::update(...);\n"
"    },\n"
"])->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 172 (quote)
msgid "{note} Deleting jobs using the `$this->delete()` method within the job will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails."
msgstr ""

#: docs/8.x/queues.md:block 174 (header)
msgid "Chain Connection & Queue"
msgstr ""

#: docs/8.x/queues.md:block 175 (paragraph)
msgid "If you would like to specify the connection and queue that should be used for the chained jobs, you may use the `onConnection` and `onQueue` methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue:"
msgstr ""

#: docs/8.x/queues.md:block 176 (code)
msgid "Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->onConnection('redis')->onQueue('podcasts')->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 178 (header)
msgid "Chain Failures"
msgstr ""

#: docs/8.x/queues.md:block 179 (paragraph)
msgid "When chaining jobs, you may use the `catch` method to specify a closure that should be invoked if a job within the chain fails. The given callback will receive the `Throwable` instance that caused the job failure:"
msgstr ""

#: docs/8.x/queues.md:block 180 (code)
msgid "use Illuminate\\Support\\Facades\\Bus;\n"
"use Throwable;\n\n"
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->catch(function (Throwable $e) {\n"
"    // A job within the chain has failed...\n"
"})->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 182 (header)
msgid "Customizing The Queue & Connection"
msgstr ""

#: docs/8.x/queues.md:block 184 (header)
msgid "Dispatching To A Particular Queue"
msgstr ""

#: docs/8.x/queues.md:block 185 (paragraph)
msgid "By pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the `onQueue` method when dispatching the job:"
msgstr ""

#: docs/8.x/queues.md:block 186 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n\n"
"        // Create podcast...\n\n"
"        ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 187 (paragraph)
msgid "Alternatively, you may specify the job's queue by calling the `onQueue` method within the job's constructor:"
msgstr ""

#: docs/8.x/queues.md:block 188 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onQueue('processing');\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 190 (header)
msgid "Dispatching To A Particular Connection"
msgstr ""

#: docs/8.x/queues.md:block 191 (paragraph)
msgid "If your application interacts with multiple queue connections, you may specify which connection to push a job to using the `onConnection` method:"
msgstr ""

#: docs/8.x/queues.md:block 192 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n\n"
"        // Create podcast...\n\n"
"        ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 193 (paragraph)
msgid "You may chain the `onConnection` and `onQueue` methods together to specify the connection and the queue for a job:"
msgstr ""

#: docs/8.x/queues.md:block 194 (code)
msgid "ProcessPodcast::dispatch($podcast)\n"
"              ->onConnection('sqs')\n"
"              ->onQueue('processing');\n"
msgstr ""

#: docs/8.x/queues.md:block 195 (paragraph)
msgid "Alternatively, you may specify the job's connection by calling the `onConnection` method within the job's constructor:"
msgstr ""

#: docs/8.x/queues.md:block 196 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onConnection('sqs');\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 198 (header)
msgid "Specifying Max Job Attempts / Timeout Values"
msgstr ""

#: docs/8.x/queues.md:block 200 (header)
msgid "Max Attempts"
msgstr ""

#: docs/8.x/queues.md:block 201 (paragraph)
msgid "If one of your queued jobs is encountering an error, you likely do not want it to keep retrying indefinitely. Therefore, Laravel provides various ways to specify how many times or for how long a job may be attempted."
msgstr ""

#: docs/8.x/queues.md:block 202 (paragraph)
msgid "One approach to specifying the maximum number of times a job may be attempted is via the `--tries` switch on the Artisan command line. This will apply to all jobs processed by the worker unless the job being processed specifies a more specific number of times it may be attempted:"
msgstr ""

#: docs/8.x/queues.md:block 203 (code)
msgid "php artisan queue:work --tries=3\n"
msgstr ""

#: docs/8.x/queues.md:block 204 (paragraph)
msgid "If a job exceeds its maximum number of attempts, it will be considered a \"failed\" job. For more information on handling failed jobs, consult the [failed job documentation](#dealing-with-failed-jobs)."
msgstr ""

#: docs/8.x/queues.md:block 205 (paragraph)
msgid "You may take a more granular approach by defining the maximum number of times a job may be attempted on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the `--tries` value provided on the command line:"
msgstr ""

#: docs/8.x/queues.md:block 206 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of times the job may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 5;\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 208 (header)
msgid "Time Based Attempts"
msgstr ""

#: docs/8.x/queues.md:block 209 (paragraph)
msgid "As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should no longer be attempted. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should no longer be attempted, add a `retryUntil` method to your job class. This method should return a `DateTime` instance:"
msgstr ""

#: docs/8.x/queues.md:block 210 (code)
msgid "/**\n"
" * Determine the time at which the job should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(10);\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 211 (quote)
msgid "{tip} You may also define a `tries` property or `retryUntil` method on your [queued event listeners](/docs/{{version}}/events#queued-event-listeners)."
msgstr ""

#: docs/8.x/queues.md:block 213 (header)
msgid "Max Exceptions"
msgstr ""

#: docs/8.x/queues.md:block 214 (paragraph)
msgid "Sometimes you may wish to specify that a job may be attempted many times, but should fail if the retries are triggered by a given number of unhandled exceptions (as opposed to being released by the `release` method directly). To accomplish this, you may define a `maxExceptions` property on your job class:"
msgstr ""

#: docs/8.x/queues.md:block 215 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"use Illuminate\\Support\\Facades\\Redis;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of times the job may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 25;\n\n"
"    /**\n"
"     * The maximum number of unhandled exceptions to allow before failing.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $maxExceptions = 3;\n\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        Redis::throttle('key')->allow(10)->every(60)->then(function () {\n"
"            // Lock obtained, process the podcast...\n"
"        }, function () {\n"
"            // Unable to obtain lock...\n"
"            return $this->release(10);\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 216 (paragraph)
msgid "In this example, the job is released for ten seconds if the application is unable to obtain a Redis lock and will continue to be retried up to 25 times. However, the job will fail if three unhandled exceptions are thrown by the job."
msgstr ""

#: docs/8.x/queues.md:block 218 (header)
msgid "Timeout"
msgstr ""

#: docs/8.x/queues.md:block 219 (quote)
msgid "{note} The `pcntl` PHP extension must be installed in order to specify job timeouts."
msgstr ""

#: docs/8.x/queues.md:block 220 (paragraph)
msgid "Often, you know roughly how long you expect your queued jobs to take. For this reason, Laravel allows you to specify a \"timeout\" value. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration)."
msgstr ""

#: docs/8.x/queues.md:block 221 (paragraph)
msgid "The maximum number of seconds that jobs can run may be specified using the `--timeout` switch on the Artisan command line:"
msgstr ""

#: docs/8.x/queues.md:block 222 (code)
msgid "php artisan queue:work --timeout=30\n"
msgstr ""

#: docs/8.x/queues.md:block 223 (paragraph)
msgid "If the job exceeds its maximum attempts by continually timing out, it will be marked as failed."
msgstr ""

#: docs/8.x/queues.md:block 224 (paragraph)
msgid "You may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:"
msgstr ""

#: docs/8.x/queues.md:block 225 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of seconds the job can run before timing out.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $timeout = 120;\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 226 (paragraph)
msgid "Sometimes, IO blocking processes such as sockets or outgoing HTTP connections may not respect your specified timeout. Therefore, when using these features, you should always attempt to specify a timeout using their APIs as well. For example, when using Guzzle, you should always specify a connection and request timeout value."
msgstr ""

#: docs/8.x/queues.md:block 228 (header)
msgid "Failing On Timeout"
msgstr ""

#: docs/8.x/queues.md:block 229 (paragraph)
msgid "If you would like to indicate that a job should be marked as [failed](#dealing-with-failed-jobs) on timeout, you may define the `$failOnTimeout` property on the job class:"
msgstr ""

#: docs/8.x/queues.md:block 230 (code)
msgid "/**\n"
" * Indicate if the job should be marked as failed on timeout.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $failOnTimeout = true;\n"
msgstr ""

#: docs/8.x/queues.md:block 232 (header)
msgid "Error Handling"
msgstr ""

#: docs/8.x/queues.md:block 233 (paragraph)
msgid "If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the `--tries` switch used on the `queue:work` Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker [can be found below](#running-the-queue-worker)."
msgstr ""

#: docs/8.x/queues.md:block 235 (header)
msgid "Manually Releasing A Job"
msgstr ""

#: docs/8.x/queues.md:block 236 (paragraph)
msgid "Sometimes you may wish to manually release a job back onto the queue so that it can be attempted again at a later time. You may accomplish this by calling the `release` method:"
msgstr ""

#: docs/8.x/queues.md:block 237 (code)
msgid "/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    // ...\n\n"
"    $this->release();\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 238 (paragraph)
msgid "By default, the `release` method will release the job back onto the queue for immediate processing. However, by passing an integer to the `release` method you may instruct the queue to not make the job available for processing until a given number of seconds has elapsed:"
msgstr ""

#: docs/8.x/queues.md:block 239 (code)
msgid "$this->release(10);\n"
msgstr ""

#: docs/8.x/queues.md:block 241 (header)
msgid "Manually Failing A Job"
msgstr ""

#: docs/8.x/queues.md:block 242 (paragraph)
msgid "Occasionally you may need to manually mark a job as \"failed\". To do so, you may call the `fail` method:"
msgstr ""

#: docs/8.x/queues.md:block 243 (code)
msgid "/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    // ...\n\n"
"    $this->fail();\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 244 (paragraph)
msgid "If you would like to mark your job as failed because of an exception that you have caught, you may pass the exception to the `fail` method:"
msgstr ""

#: docs/8.x/queues.md:block 245 (code)
msgid "$this->fail($exception);\n"
msgstr ""

#: docs/8.x/queues.md:block 246 (quote)
msgid "{tip} For more information on failed jobs, check out the [documentation on dealing with job failures](#dealing-with-failed-jobs)."
msgstr ""

#: docs/8.x/queues.md:block 248 (header)
msgid "Job Batching"
msgstr ""

#: docs/8.x/queues.md:block 249 (paragraph)
msgid "Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table to contain meta information about your job batches, such as their completion percentage. This migration may be generated using the `queue:batches-table` Artisan command:"
msgstr ""

#: docs/8.x/queues.md:block 250 (code)
msgid "php artisan queue:batches-table\n\n"
"php artisan migrate\n"
msgstr ""

#: docs/8.x/queues.md:block 252 (header)
msgid "Defining Batchable Jobs"
msgstr ""

#: docs/8.x/queues.md:block 253 (paragraph)
msgid "To define a batchable job, you should [create a queueable job](#creating-jobs) as normal; however, you should add the `Illuminate\\Bus\\Batchable` trait to the job class. This trait provides access to a `batch` method which may be used to retrieve the current batch that the job is executing within:"
msgstr ""

#: docs/8.x/queues.md:block 254 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"use Illuminate\\Bus\\Batchable;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class ImportCsv implements ShouldQueue\n"
"{\n"
"    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            // Determine if the batch has been cancelled...\n\n"
"            return;\n"
"        }\n\n"
"        // Import a portion of the CSV file...\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 256 (header)
msgid "Dispatching Batches"
msgstr ""

#: docs/8.x/queues.md:block 257 (paragraph)
msgid "To dispatch a batch of jobs, you should use the `batch` method of the `Bus` facade. Of course, batching is primarily useful when combined with completion callbacks. So, you may use the `then`, `catch`, and `finally` methods to define completion callbacks for the batch. Each of these callbacks will receive an `Illuminate\\Bus\\Batch` instance when they are invoked. In this example, we will imagine we are queueing a batch of jobs that each process a given number of rows from a CSV file:"
msgstr ""

#: docs/8.x/queues.md:block 258 (code)
msgid "use App\\Jobs\\ImportCsv;\n"
"use Illuminate\\Bus\\Batch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Throwable;\n\n"
"$batch = Bus::batch([\n"
"    new ImportCsv(1, 100),\n"
"    new ImportCsv(101, 200),\n"
"    new ImportCsv(201, 300),\n"
"    new ImportCsv(301, 400),\n"
"    new ImportCsv(401, 500),\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->catch(function (Batch $batch, Throwable $e) {\n"
"    // First batch job failure detected...\n"
"})->finally(function (Batch $batch) {\n"
"    // The batch has finished executing...\n"
"})->dispatch();\n\n"
"return $batch->id;\n"
msgstr ""

#: docs/8.x/queues.md:block 259 (paragraph)
msgid "The batch's ID, which may be accessed via the `$batch->id` property, may be used to [query the Laravel command bus](#inspecting-batches) for information about the batch after it has been dispatched."
msgstr ""

#: docs/8.x/queues.md:block 260 (quote)
msgid "{note} Since batch callbacks are serialized and executed at a later time by the Laravel queue, you should not use the `$this` variable within the callbacks."
msgstr ""

#: docs/8.x/queues.md:block 262 (header)
msgid "Naming Batches"
msgstr ""

#: docs/8.x/queues.md:block 263 (paragraph)
msgid "Some tools such as Laravel Horizon and Laravel Telescope may provide more user-friendly debug information for batches if batches are named. To assign an arbitrary name to a batch, you may call the `name` method while defining the batch:"
msgstr ""

#: docs/8.x/queues.md:block 264 (code)
msgid "$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->name('Import CSV')->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 266 (header)
msgid "Batch Connection & Queue"
msgstr ""

#: docs/8.x/queues.md:block 267 (paragraph)
msgid "If you would like to specify the connection and queue that should be used for the batched jobs, you may use the `onConnection` and `onQueue` methods. All batched jobs must execute within the same connection and queue:"
msgstr ""

#: docs/8.x/queues.md:block 268 (code)
msgid "$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->onConnection('redis')->onQueue('imports')->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 270 (header)
msgid "Chains Within Batches"
msgstr ""

#: docs/8.x/queues.md:block 271 (paragraph)
msgid "You may define a set of [chained jobs](#job-chaining) within a batch by placing the chained jobs within an array. For example, we may execute two job chains in parallel and execute a callback when both job chains have finished processing:"
msgstr ""

#: docs/8.x/queues.md:block 272 (code)
msgid "use App\\Jobs\\ReleasePodcast;\n"
"use App\\Jobs\\SendPodcastReleaseNotification;\n"
"use Illuminate\\Bus\\Batch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n\n"
"Bus::batch([\n"
"    [\n"
"        new ReleasePodcast(1),\n"
"        new SendPodcastReleaseNotification(1),\n"
"    ],\n"
"    [\n"
"        new ReleasePodcast(2),\n"
"        new SendPodcastReleaseNotification(2),\n"
"    ],\n"
"])->then(function (Batch $batch) {\n"
"    // ...\n"
"})->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 274 (header)
msgid "Adding Jobs To Batches"
msgstr ""

#: docs/8.x/queues.md:block 275 (paragraph)
msgid "Sometimes it may be useful to add additional jobs to a batch from within a batched job. This pattern can be useful when you need to batch thousands of jobs which may take too long to dispatch during a web request. So, instead, you may wish to dispatch an initial batch of \"loader\" jobs that hydrate the batch with even more jobs:"
msgstr ""

#: docs/8.x/queues.md:block 276 (code)
msgid "$batch = Bus::batch([\n"
"    new LoadImportBatch,\n"
"    new LoadImportBatch,\n"
"    new LoadImportBatch,\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->name('Import Contacts')->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 277 (paragraph)
msgid "In this example, we will use the `LoadImportBatch` job to hydrate the batch with additional jobs. To accomplish this, we may use the `add` method on the batch instance that may be accessed via the job's `batch` method:"
msgstr ""

#: docs/8.x/queues.md:block 278 (code)
msgid "use App\\Jobs\\ImportContacts;\n"
"use Illuminate\\Support\\Collection;\n\n"
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n\n"
"    $this->batch()->add(Collection::times(1000, function () {\n"
"        return new ImportContacts;\n"
"    }));\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 279 (quote)
msgid "{note} You may only add jobs to a batch from within a job that belongs to the same batch."
msgstr ""

#: docs/8.x/queues.md:block 281 (header)
msgid "Inspecting Batches"
msgstr ""

#: docs/8.x/queues.md:block 282 (paragraph)
msgid "The `Illuminate\\Bus\\Batch` instance that is provided to batch completion callbacks has a variety of properties and methods to assist you in interacting with and inspecting a given batch of jobs:"
msgstr ""

#: docs/8.x/queues.md:block 283 (code)
msgid "// The UUID of the batch...\n"
"$batch->id;\n\n"
"// The name of the batch (if applicable)...\n"
"$batch->name;\n\n"
"// The number of jobs assigned to the batch...\n"
"$batch->totalJobs;\n\n"
"// The number of jobs that have not been processed by the queue...\n"
"$batch->pendingJobs;\n\n"
"// The number of jobs that have failed...\n"
"$batch->failedJobs;\n\n"
"// The number of jobs that have been processed thus far...\n"
"$batch->processedJobs();\n\n"
"// The completion percentage of the batch (0-100)...\n"
"$batch->progress();\n\n"
"// Indicates if the batch has finished executing...\n"
"$batch->finished();\n\n"
"// Cancel the execution of the batch...\n"
"$batch->cancel();\n\n"
"// Indicates if the batch has been cancelled...\n"
"$batch->cancelled();\n"
msgstr ""

#: docs/8.x/queues.md:block 285 (header)
msgid "Returning Batches From Routes"
msgstr ""

#: docs/8.x/queues.md:block 286 (paragraph)
msgid "All `Illuminate\\Bus\\Batch` instances are JSON serializable, meaning you can return them directly from one of your application's routes to retrieve a JSON payload containing information about the batch, including its completion progress. This makes it convenient to display information about the batch's completion progress in your application's UI."
msgstr ""

#: docs/8.x/queues.md:block 287 (paragraph)
msgid "To retrieve a batch by its ID, you may use the `Bus` facade's `findBatch` method:"
msgstr ""

#: docs/8.x/queues.md:block 288 (code)
msgid "use Illuminate\\Support\\Facades\\Bus;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"Route::get('/batch/{batchId}', function (string $batchId) {\n"
"    return Bus::findBatch($batchId);\n"
"});\n"
msgstr ""

#: docs/8.x/queues.md:block 290 (header)
msgid "Cancelling Batches"
msgstr ""

#: docs/8.x/queues.md:block 291 (paragraph)
msgid "Sometimes you may need to cancel a given batch's execution. This can be accomplished by calling the `cancel` method on the `Illuminate\\Bus\\Batch` instance:"
msgstr ""

#: docs/8.x/queues.md:block 292 (code)
msgid "/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->user->exceedsImportLimit()) {\n"
"        return $this->batch()->cancel();\n"
"    }\n\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 293 (paragraph)
msgid "As you may have noticed in previous examples, batched jobs should typically check to see if the batch has been cancelled at the beginning of their `handle` method:"
msgstr ""

#: docs/8.x/queues.md:block 294 (code)
msgid "/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n\n"
"    // Continue processing...\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 296 (header)
msgid "Batch Failures"
msgstr ""

#: docs/8.x/queues.md:block 297 (paragraph)
msgid "When a batched job fails, the `catch` callback (if assigned) will be invoked. This callback is only invoked for the first job that fails within the batch."
msgstr ""

#: docs/8.x/queues.md:block 299 (header)
msgid "Allowing Failures"
msgstr ""

#: docs/8.x/queues.md:block 300 (paragraph)
msgid "When a job within a batch fails, Laravel will automatically mark the batch as \"cancelled\". If you wish, you may disable this behavior so that a job failure does not automatically mark the batch as cancelled. This may be accomplished by calling the `allowFailures` method while dispatching the batch:"
msgstr ""

#: docs/8.x/queues.md:block 301 (code)
msgid "$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->allowFailures()->dispatch();\n"
msgstr ""

#: docs/8.x/queues.md:block 303 (header)
msgid "Retrying Failed Batch Jobs"
msgstr ""

#: docs/8.x/queues.md:block 304 (paragraph)
msgid "For convenience, Laravel provides a `queue:retry-batch` Artisan command that allows you to easily retry all of the failed jobs for a given batch. The `queue:retry-batch` command accepts the UUID of the batch whose failed jobs should be retried:"
msgstr ""

#: docs/8.x/queues.md:block 305 (code)
msgid "php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5\n"
msgstr ""

#: docs/8.x/queues.md:block 307 (header)
msgid "Pruning Batches"
msgstr ""

#: docs/8.x/queues.md:block 308 (paragraph)
msgid "Without pruning, the `job_batches` table can accumulate records very quickly. To mitigate this, you should [schedule](/docs/{{version}}/scheduling) the `queue:prune-batches` Artisan command to run daily:"
msgstr ""

#: docs/8.x/queues.md:block 309 (code)
msgid "$schedule->command('queue:prune-batches')->daily();\n"
msgstr ""

#: docs/8.x/queues.md:block 310 (paragraph)
msgid "By default, all finished batches that are more than 24 hours old will be pruned. You may use the `hours` option when calling the command to determine how long to retain batch data. For example, the following command will delete all batches that finished over 48 hours ago:"
msgstr ""

#: docs/8.x/queues.md:block 311 (code)
msgid "$schedule->command('queue:prune-batches --hours=48')->daily();\n"
msgstr ""

#: docs/8.x/queues.md:block 312 (paragraph)
msgid "Sometimes, your `jobs_batches` table may accumulate batch records for batches that never completed successfully, such as batches where a job failed and that job was never retried successfully. You may instruct the `queue:prune-batches` command to prune these unfinished batch records using the `unfinished` option:"
msgstr ""

#: docs/8.x/queues.md:block 313 (code)
msgid "$schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();\n"
msgstr ""

#: docs/8.x/queues.md:block 315 (header)
msgid "Queueing Closures"
msgstr ""

#: docs/8.x/queues.md:block 316 (paragraph)
msgid "Instead of dispatching a job class to the queue, you may also dispatch a closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle. When dispatching closures to the queue, the closure's code content is cryptographically signed so that it can not be modified in transit:"
msgstr ""

#: docs/8.x/queues.md:block 317 (code)
msgid "$podcast = App\\Podcast::find(1);\n\n"
"dispatch(function () use ($podcast) {\n"
"    $podcast->publish();\n"
"});\n"
msgstr ""

#: docs/8.x/queues.md:block 318 (paragraph)
msgid "Using the `catch` method, you may provide a closure that should be executed if the queued closure fails to complete successfully after exhausting all of your queue's [configured retry attempts](#max-job-attempts-and-timeout):"
msgstr ""

#: docs/8.x/queues.md:block 319 (code)
msgid "use Throwable;\n\n"
"dispatch(function () use ($podcast) {\n"
"    $podcast->publish();\n"
"})->catch(function (Throwable $e) {\n"
"    // This job has failed...\n"
"});\n"
msgstr ""

#: docs/8.x/queues.md:block 321 (header)
msgid "Running The Queue Worker"
msgstr ""

#: docs/8.x/queues.md:block 323 (header)
msgid "The `queue:work` Command"
msgstr ""

#: docs/8.x/queues.md:block 324 (paragraph)
msgid "Laravel includes an Artisan command that will start a queue worker and process new jobs as they are pushed onto the queue. You may run the worker using the `queue:work` Artisan command. Note that once the `queue:work` command has started, it will continue to run until it is manually stopped or you close your terminal:"
msgstr ""

#: docs/8.x/queues.md:block 325 (code)
msgid "php artisan queue:work\n"
msgstr ""

#: docs/8.x/queues.md:block 326 (quote)
msgid "{tip} To keep the `queue:work` process running permanently in the background, you should use a process monitor such as [Supervisor](#supervisor-configuration) to ensure that the queue worker does not stop running."
msgstr ""

#: docs/8.x/queues.md:block 327 (paragraph)
msgid "Remember, queue workers, are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to [restart your queue workers](#queue-workers-and-deployment). In addition, remember that any static state created or modified by your application will not be automatically reset between jobs."
msgstr ""

#: docs/8.x/queues.md:block 328 (paragraph)
msgid "Alternatively, you may run the `queue:listen` command. When using the `queue:listen` command, you don't have to manually restart the worker when you want to reload your updated code or reset the application state; however, this command is significantly less efficient than the `queue:work` command:"
msgstr ""

#: docs/8.x/queues.md:block 329 (code)
msgid "php artisan queue:listen\n"
msgstr ""

#: docs/8.x/queues.md:block 331 (header)
msgid "Running Multiple Queue Workers"
msgstr ""

#: docs/8.x/queues.md:block 332 (paragraph)
msgid "To assign multiple workers to a queue and process jobs concurrently, you should simply start multiple `queue:work` processes. This can either be done locally via multiple tabs in your terminal or in production using your process manager's configuration settings. [When using Supervisor](#supervisor-configuration), you may use the `numprocs` configuration value."
msgstr ""

#: docs/8.x/queues.md:block 334 (header)
msgid "Specifying The Connection & Queue"
msgstr ""

#: docs/8.x/queues.md:block 335 (paragraph)
msgid "You may also specify which queue connection the worker should utilize. The connection name passed to the `work` command should correspond to one of the connections defined in your `config/queue.php` configuration file:"
msgstr ""

#: docs/8.x/queues.md:block 336 (code)
msgid "php artisan queue:work redis\n"
msgstr ""

#: docs/8.x/queues.md:block 337 (paragraph)
msgid "By default, the `queue:work` command only processes jobs for the default queue on a given connection. However, you may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an `emails` queue on your `redis` queue connection, you may issue the following command to start a worker that only processes that queue:"
msgstr ""

#: docs/8.x/queues.md:block 338 (code)
msgid "php artisan queue:work redis --queue=emails\n"
msgstr ""

#: docs/8.x/queues.md:block 340 (header)
msgid "Processing A Specified Number Of Jobs"
msgstr ""

#: docs/8.x/queues.md:block 341 (paragraph)
msgid "The `--once` option may be used to instruct the worker to only process a single job from the queue:"
msgstr ""

#: docs/8.x/queues.md:block 342 (code)
msgid "php artisan queue:work --once\n"
msgstr ""

#: docs/8.x/queues.md:block 343 (paragraph)
msgid "The `--max-jobs` option may be used to instruct the worker to process the given number of jobs and then exit. This option may be useful when combined with [Supervisor](#supervisor-configuration) so that your workers are automatically restarted after processing a given number of jobs, releasing any memory they may have accumulated:"
msgstr ""

#: docs/8.x/queues.md:block 344 (code)
msgid "php artisan queue:work --max-jobs=1000\n"
msgstr ""

#: docs/8.x/queues.md:block 346 (header)
msgid "Processing All Queued Jobs & Then Exiting"
msgstr ""

#: docs/8.x/queues.md:block 347 (paragraph)
msgid "The `--stop-when-empty` option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when processing Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty:"
msgstr ""

#: docs/8.x/queues.md:block 348 (code)
msgid "php artisan queue:work --stop-when-empty\n"
msgstr ""

#: docs/8.x/queues.md:block 350 (header)
msgid "Processing Jobs For A Given Number Of Seconds"
msgstr ""

#: docs/8.x/queues.md:block 351 (paragraph)
msgid "The `--max-time` option may be used to instruct the worker to process jobs for the given number of seconds and then exit. This option may be useful when combined with [Supervisor](#supervisor-configuration) so that your workers are automatically restarted after processing jobs for a given amount of time, releasing any memory they may have accumulated:"
msgstr ""

#: docs/8.x/queues.md:block 352 (code)
msgid "// Process jobs for one hour and then exit...\n"
"php artisan queue:work --max-time=3600\n"
msgstr ""

#: docs/8.x/queues.md:block 354 (header)
msgid "Worker Sleep Duration"
msgstr ""

#: docs/8.x/queues.md:block 355 (paragraph)
msgid "When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the `sleep` option determines how many seconds the worker will \"sleep\" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again."
msgstr ""

#: docs/8.x/queues.md:block 356 (code)
msgid "php artisan queue:work --sleep=3\n"
msgstr ""

#: docs/8.x/queues.md:block 358 (header)
msgid "Resource Considerations"
msgstr ""

#: docs/8.x/queues.md:block 359 (paragraph)
msgid "Daemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should release any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with `imagedestroy` when you are done processing the image."
msgstr ""

#: docs/8.x/queues.md:block 361 (header)
msgid "Queue Priorities"
msgstr ""

#: docs/8.x/queues.md:block 362 (paragraph)
msgid "Sometimes you may wish to prioritize how your queues are processed. For example, in your `config/queue.php` configuration file, you may set the default `queue` for your `redis` connection to `low`. However, occasionally you may wish to push a job to a `high` priority queue like so:"
msgstr ""

#: docs/8.x/queues.md:block 363 (code)
msgid "dispatch((new Job)->onQueue('high'));\n"
msgstr ""

#: docs/8.x/queues.md:block 364 (paragraph)
msgid "To start a worker that verifies that all of the `high` queue jobs are processed before continuing to any jobs on the `low` queue, pass a comma-delimited list of queue names to the `work` command:"
msgstr ""

#: docs/8.x/queues.md:block 365 (code)
msgid "php artisan queue:work --queue=high,low\n"
msgstr ""

#: docs/8.x/queues.md:block 367 (header)
msgid "Queue Workers & Deployment"
msgstr ""

#: docs/8.x/queues.md:block 368 (paragraph)
msgid "Since queue workers are long-lived processes, they will not notice changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the `queue:restart` command:"
msgstr ""

#: docs/8.x/queues.md:block 369 (code)
msgid "php artisan queue:restart\n"
msgstr ""

#: docs/8.x/queues.md:block 370 (paragraph)
msgid "This command will instruct all queue workers to gracefully exit after they finish processing their current job so that no existing jobs are lost. Since the queue workers will exit when the `queue:restart` command is executed, you should be running a process manager such as [Supervisor](#supervisor-configuration) to automatically restart the queue workers."
msgstr ""

#: docs/8.x/queues.md:block 371 (quote)
msgid "{tip} The queue uses the [cache](/docs/{{version}}/cache) to store restart signals, so you should verify that a cache driver is properly configured for your application before using this feature."
msgstr ""

#: docs/8.x/queues.md:block 373 (header)
msgid "Job Expirations & Timeouts"
msgstr ""

#: docs/8.x/queues.md:block 375 (header)
msgid "Job Expiration"
msgstr ""

#: docs/8.x/queues.md:block 376 (paragraph)
msgid "In your `config/queue.php` configuration file, each queue connection defines a `retry_after` option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of `retry_after` is set to `90`, the job will be released back onto the queue if it has been processing for 90 seconds without being released or deleted. Typically, you should set the `retry_after` value to the maximum number of seconds your jobs should reasonably take to complete processing."
msgstr ""

#: docs/8.x/queues.md:block 377 (quote)
msgid "{note} The only queue connection which does not contain a `retry_after` value is Amazon SQS. SQS will retry the job based on the [Default Visibility Timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) which is managed within the AWS console."
msgstr ""

#: docs/8.x/queues.md:block 379 (header)
msgid "Worker Timeouts"
msgstr ""

#: docs/8.x/queues.md:block 380 (paragraph)
msgid "The `queue:work` Artisan command exposes a `--timeout` option. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration):"
msgstr ""

#: docs/8.x/queues.md:block 381 (code)
msgid "php artisan queue:work --timeout=60\n"
msgstr ""

#: docs/8.x/queues.md:block 382 (paragraph)
msgid "The `retry_after` configuration option and the `--timeout` CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once."
msgstr ""

#: docs/8.x/queues.md:block 383 (quote)
msgid "{note} The `--timeout` value should always be at least several seconds shorter than your `retry_after` configuration value. This will ensure that a worker processing a frozen job is always terminated before the job is retried. If your `--timeout` option is longer than your `retry_after` configuration value, your jobs may be processed twice."
msgstr ""

#: docs/8.x/queues.md:block 385 (header)
msgid "Supervisor Configuration"
msgstr ""

#: docs/8.x/queues.md:block 386 (paragraph)
msgid "In production, you need a way to keep your `queue:work` processes running. A `queue:work` process may stop running for a variety of reasons, such as an exceeded worker timeout or the execution of the `queue:restart` command."
msgstr ""

#: docs/8.x/queues.md:block 387 (paragraph)
msgid "For this reason, you need to configure a process monitor that can detect when your `queue:work` processes exit and automatically restart them. In addition, process monitors can allow you to specify how many `queue:work` processes you would like to run concurrently. Supervisor is a process monitor commonly used in Linux environments and we will discuss how to configure it in the following documentation."
msgstr ""

#: docs/8.x/queues.md:block 389 (header)
msgid "Installing Supervisor"
msgstr ""

#: docs/8.x/queues.md:block 390 (paragraph)
msgid "Supervisor is a process monitor for the Linux operating system, and will automatically restart your `queue:work` processes if they fail. To install Supervisor on Ubuntu, you may use the following command:"
msgstr ""

#: docs/8.x/queues.md:block 391 (code)
msgid "sudo apt-get install supervisor\n"
msgstr ""

#: docs/8.x/queues.md:block 392 (quote)
msgid "{tip} If configuring and managing Supervisor yourself sounds overwhelming, consider using [Laravel Forge](https://forge.laravel.com), which will automatically install and configure Supervisor for your production Laravel projects."
msgstr ""

#: docs/8.x/queues.md:block 394 (header)
msgid "Configuring Supervisor"
msgstr ""

#: docs/8.x/queues.md:block 395 (paragraph)
msgid "Supervisor configuration files are typically stored in the `/etc/supervisor/conf.d` directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a `laravel-worker.conf` file that starts and monitors `queue:work` processes:"
msgstr ""

#: docs/8.x/queues.md:block 396 (code)
msgid "[program:laravel-worker]\n"
"process_name=%(program_name)s_%(process_num)02d\n"
"command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600\n"
"autostart=true\n"
"autorestart=true\n"
"stopasgroup=true\n"
"killasgroup=true\n"
"user=forge\n"
"numprocs=8\n"
"redirect_stderr=true\n"
"stdout_logfile=/home/forge/app.com/worker.log\n"
"stopwaitsecs=3600\n"
msgstr ""

#: docs/8.x/queues.md:block 397 (paragraph)
msgid "In this example, the `numprocs` directive will instruct Supervisor to run eight `queue:work` processes and monitor all of them, automatically restarting them if they fail. You should change the `command` directive of the configuration to reflect your desired queue connection and worker options."
msgstr ""

#: docs/8.x/queues.md:block 398 (quote)
msgid "{note} You should ensure that the value of `stopwaitsecs` is greater than the number of seconds consumed by your longest running job. Otherwise, Supervisor may kill the job before it is finished processing."
msgstr ""

#: docs/8.x/queues.md:block 400 (header)
msgid "Starting Supervisor"
msgstr ""

#: docs/8.x/queues.md:block 401 (paragraph)
msgid "Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:"
msgstr ""

#: docs/8.x/queues.md:block 402 (code)
msgid "sudo supervisorctl reread\n\n"
"sudo supervisorctl update\n\n"
"sudo supervisorctl start laravel-worker:*\n"
msgstr ""

#: docs/8.x/queues.md:block 403 (paragraph)
msgid "For more information on Supervisor, consult the [Supervisor documentation](http://supervisord.org/index.html)."
msgstr ""

#: docs/8.x/queues.md:block 405 (header)
msgid "Dealing With Failed Jobs"
msgstr ""

#: docs/8.x/queues.md:block 406 (paragraph)
msgid "Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to [specify the maximum number of times a job should be attempted](#max-job-attempts-and-timeout). After a job has exceeded this number of attempts, it will be inserted into the `failed_jobs` database table. Of course, we will need to create that table if it does not already exist. To create a migration for the `failed_jobs` table, you may use the `queue:failed-table` command:"
msgstr ""

#: docs/8.x/queues.md:block 407 (code)
msgid "php artisan queue:failed-table\n\n"
"php artisan migrate\n"
msgstr ""

#: docs/8.x/queues.md:block 408 (paragraph)
msgid "When running a [queue worker](#running-the-queue-worker) process, you may specify the maximum number of times a job should be attempted using the `--tries` switch on the `queue:work` command. If you do not specify a value for the `--tries` option, jobs will only be attempted once or as many times as specified by the job class' `$tries` property:"
msgstr ""

#: docs/8.x/queues.md:block 409 (code)
msgid "php artisan queue:work redis --tries=3\n"
msgstr ""

#: docs/8.x/queues.md:block 410 (paragraph)
msgid "Using the `--backoff` option, you may specify how many seconds Laravel should wait before retrying a job that has encountered an exception. By default, a job is immediately released back onto the queue so that it may be attempted again:"
msgstr ""

#: docs/8.x/queues.md:block 411 (code)
msgid "php artisan queue:work redis --tries=3 --backoff=3\n"
msgstr ""

#: docs/8.x/queues.md:block 412 (paragraph)
msgid "If you would like to configure how many seconds Laravel should wait before retrying a job that has encountered an exception on a per-job basis, you may do so by defining a `backoff` property on your job class:"
msgstr ""

#: docs/8.x/queues.md:block 413 (code)
msgid "/**\n"
" * The number of seconds to wait before retrying the job.\n"
" *\n"
" * @var int\n"
" */\n"
"public $backoff = 3;\n"
msgstr ""

#: docs/8.x/queues.md:block 414 (paragraph)
msgid "If you require more complex logic for determining the job's backoff time, you may define a `backoff` method on your job class:"
msgstr ""

#: docs/8.x/queues.md:block 415 (code)
msgid "/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*\n"
"* @return int\n"
"*/\n"
"public function backoff()\n"
"{\n"
"    return 3;\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 416 (paragraph)
msgid "You may easily configure \"exponential\" backoffs by returning an array of backoff values from the `backoff` method. In this example, the retry delay will be 1 second for the first retry, 5 seconds for the second retry, and 10 seconds for the third retry:"
msgstr ""

#: docs/8.x/queues.md:block 417 (code)
msgid "/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*\n"
"* @return array\n"
"*/\n"
"public function backoff()\n"
"{\n"
"    return [1, 5, 10];\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 419 (header)
msgid "Cleaning Up After Failed Jobs"
msgstr ""

#: docs/8.x/queues.md:block 420 (paragraph)
msgid "When a particular job fails, you may want to send an alert to your users or revert any actions that were partially completed by the job. To accomplish this, you may define a `failed` method on your job class. The `Throwable` instance that caused the job to fail will be passed to the `failed` method:"
msgstr ""

#: docs/8.x/queues.md:block 421 (code)
msgid "<?php\n\n"
"namespace App\\Jobs;\n\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"use Throwable;\n\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue, Queueable, SerializesModels;\n\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Podcast\n"
"     */\n"
"    protected $podcast;\n\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  \\App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n\n"
"    /**\n"
"     * Handle a job failure.\n"
"     *\n"
"     * @param  \\Throwable  $exception\n"
"     * @return void\n"
"     */\n"
"    public function failed(Throwable $exception)\n"
"    {\n"
"        // Send user notification of failure, etc...\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 422 (quote)
msgid "{note} A new instance of the job is instantiated before invoking the `failed` method; therefore, any class property modifications that may have occurred within the `handle` method will be lost."
msgstr ""

#: docs/8.x/queues.md:block 424 (header)
msgid "Retrying Failed Jobs"
msgstr ""

#: docs/8.x/queues.md:block 425 (paragraph)
msgid "To view all of the failed jobs that have been inserted into your `failed_jobs` database table, you may use the `queue:failed` Artisan command:"
msgstr ""

#: docs/8.x/queues.md:block 426 (code)
msgid "php artisan queue:failed\n"
msgstr ""

#: docs/8.x/queues.md:block 427 (paragraph)
msgid "The `queue:failed` command will list the job ID, connection, queue, failure time, and other information about the job. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece`, issue the following command:"
msgstr ""

#: docs/8.x/queues.md:block 428 (code)
msgid "php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece\n"
msgstr ""

#: docs/8.x/queues.md:block 429 (paragraph)
msgid "If necessary, you may pass multiple IDs to the command:"
msgstr ""

#: docs/8.x/queues.md:block 430 (code)
msgid "php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d\n"
msgstr ""

#: docs/8.x/queues.md:block 431 (paragraph)
msgid "You may also retry all of the failed jobs for a particular queue:"
msgstr ""

#: docs/8.x/queues.md:block 432 (code)
msgid "php artisan queue:retry --queue=name\n"
msgstr ""

#: docs/8.x/queues.md:block 433 (paragraph)
msgid "To retry all of your failed jobs, execute the `queue:retry` command and pass `all` as the ID:"
msgstr ""

#: docs/8.x/queues.md:block 434 (code)
msgid "php artisan queue:retry all\n"
msgstr ""

#: docs/8.x/queues.md:block 435 (paragraph)
msgid "If you would like to delete a failed job, you may use the `queue:forget` command:"
msgstr ""

#: docs/8.x/queues.md:block 436 (code)
msgid "php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d\n"
msgstr ""

#: docs/8.x/queues.md:block 437 (quote)
msgid "{tip} When using [Horizon](/docs/{{version}}/horizon), you should use the `horizon:forget` command to delete a failed job instead of the `queue:forget` command."
msgstr ""

#: docs/8.x/queues.md:block 438 (paragraph)
msgid "To delete all of your failed jobs from the `failed_jobs` table, you may use the `queue:flush` command:"
msgstr ""

#: docs/8.x/queues.md:block 439 (code)
msgid "php artisan queue:flush\n"
msgstr ""

#: docs/8.x/queues.md:block 441 (header)
msgid "Ignoring Missing Models"
msgstr ""

#: docs/8.x/queues.md:block 442 (paragraph)
msgid "When injecting an Eloquent model into a job, the model is automatically serialized before being placed on the queue and re-retrieved from the database when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a `ModelNotFoundException`."
msgstr ""

#: docs/8.x/queues.md:block 443 (paragraph)
msgid "For convenience, you may choose to automatically delete jobs with missing models by setting your job's `deleteWhenMissingModels` property to `true`. When this property is set to `true`, Laravel will quietly discard the job without raising an exception:"
msgstr ""

#: docs/8.x/queues.md:block 444 (code)
msgid "/**\n"
" * Delete the job if its models no longer exist.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $deleteWhenMissingModels = true;\n"
msgstr ""

#: docs/8.x/queues.md:block 446 (header)
msgid "Pruning Failed Jobs"
msgstr ""

#: docs/8.x/queues.md:block 447 (paragraph)
msgid "You may delete all of the records in your application's `failed_jobs` table by invoking the `queue:prune-failed` Artisan command:"
msgstr ""

#: docs/8.x/queues.md:block 448 (code)
msgid "php artisan queue:prune-failed\n"
msgstr ""

#: docs/8.x/queues.md:block 449 (paragraph)
msgid "If you provide the `--hours` option to the command, only the failed job records that were inserted within the last N number of hours will be retained. For example, the following command will delete all of the failed job records that were inserted more than 48 hours ago:"
msgstr ""

#: docs/8.x/queues.md:block 450 (code)
msgid "php artisan queue:prune-failed --hours=48\n"
msgstr ""

#: docs/8.x/queues.md:block 452 (header)
msgid "Storing Failed Jobs In DynamoDB"
msgstr ""

#: docs/8.x/queues.md:block 453 (paragraph)
msgid "Laravel also provides support for storing your failed job records in [DynamoDB](https://aws.amazon.com/dynamodb) instead of a relational database table. However, you must create a DynamoDB table to store all of the failed job records. Typically, this table should be named `failed_jobs`, but you should name the table based on the value of the `queue.failed.table` configuration value within your application's `queue` configuration file."
msgstr ""

#: docs/8.x/queues.md:block 454 (paragraph)
msgid "The `failed_jobs` table should have a string primary partition key named `application` and a string primary sort key named `uuid`. The `application` portion of the key will contain your application's name as defined by the `name` configuration value within your application's `app` configuration file. Since the application name is part of the DynamoDB table's key, you can use the same table to store failed jobs for multiple Laravel applications."
msgstr ""

#: docs/8.x/queues.md:block 455 (paragraph)
msgid "In addition, ensure that you install the AWS SDK so that your Laravel application can communicate with Amazon DynamoDB:"
msgstr ""

#: docs/8.x/queues.md:block 456 (code)
msgid "composer require aws/aws-sdk-php\n"
msgstr ""

#: docs/8.x/queues.md:block 457 (paragraph)
msgid "Next, set the `queue.failed.driver` configuration option's value to `dynamodb`. In addition, you should define `key`, `secret`, and `region` configuration options within the failed job configuration array. These options will be used to authenticate with AWS. When using the `dynamodb` driver, the `queue.failed.database` configuration option is unnecessary:"
msgstr ""

#: docs/8.x/queues.md:block 458 (code)
msgid "'failed' => [\n"
"    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'failed_jobs',\n"
"],\n"
msgstr ""

#: docs/8.x/queues.md:block 460 (header)
msgid "Disabling Failed Job Storage"
msgstr ""

#: docs/8.x/queues.md:block 461 (paragraph)
msgid "You may instruct Laravel to discard failed jobs without storing them by setting the `queue.failed.driver` configuration option's value to `null`. Typically, this may be accomplished via the `QUEUE_FAILED_DRIVER` environment variable:"
msgstr ""

#: docs/8.x/queues.md:block 462 (code)
msgid "QUEUE_FAILED_DRIVER=null\n"
msgstr ""

#: docs/8.x/queues.md:block 464 (header)
msgid "Failed Job Events"
msgstr ""

#: docs/8.x/queues.md:block 465 (paragraph)
msgid "If you would like to register an event listener that will be invoked when a job fails, you may use the `Queue` facade's `failing` method. For example, we may attach a closure to this event from the `boot` method of the `AppServiceProvider` that is included with Laravel:"
msgstr ""

#: docs/8.x/queues.md:block 466 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobFailed;\n\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function register()\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        Queue::failing(function (JobFailed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->exception\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 468 (header)
msgid "Clearing Jobs From Queues"
msgstr ""

#: docs/8.x/queues.md:block 469 (quote)
msgid "{tip} When using [Horizon](/docs/{{version}}/horizon), you should use the `horizon:clear` command to clear jobs from the queue instead of the `queue:clear` command."
msgstr ""

#: docs/8.x/queues.md:block 470 (paragraph)
msgid "If you would like to delete all jobs from the default queue of the default connection, you may do so using the `queue:clear` Artisan command:"
msgstr ""

#: docs/8.x/queues.md:block 471 (code)
msgid "php artisan queue:clear\n"
msgstr ""

#: docs/8.x/queues.md:block 472 (paragraph)
msgid "You may also provide the `connection` argument and `queue` option to delete jobs from a specific connection and queue:"
msgstr ""

#: docs/8.x/queues.md:block 473 (code)
msgid "php artisan queue:clear redis --queue=emails\n"
msgstr ""

#: docs/8.x/queues.md:block 474 (quote)
msgid "{note} Clearing jobs from queues is only available for the SQS, Redis, and database queue drivers. In addition, the SQS message deletion process takes up to 60 seconds, so jobs sent to the SQS queue up to 60 seconds after you clear the queue might also be deleted."
msgstr ""

#: docs/8.x/queues.md:block 476 (header)
msgid "Monitoring Your Queues"
msgstr ""

#: docs/8.x/queues.md:block 477 (paragraph)
msgid "If your queue receives a sudden influx of jobs, it could become overwhelmed, leading to a long wait time for jobs to complete. If you wish, Laravel can alert you when your queue job count exceeds a specified threshold."
msgstr ""

#: docs/8.x/queues.md:block 478 (paragraph)
msgid "To get started, you should schedule the `queue:monitor` command to [run every minute](/docs/{{version}}/scheduling). The command accepts the names of the queues you wish to monitor as well as your desired job count threshold:"
msgstr ""

#: docs/8.x/queues.md:block 479 (code)
msgid "php artisan queue:monitor redis:default,redis:deployments --max=100\n"
msgstr ""

#: docs/8.x/queues.md:block 480 (paragraph)
msgid "Scheduling this command alone is not enough to trigger a notification alerting you of the queue's overwhelmed status. When the command encounters a queue that has a job count exceeding your threshold, an `Illuminate\\Queue\\Events\\QueueBusy` event will be dispatched. You may listen for this event within your application's `EventServiceProvider` in order to send a notification to you or your development team:"
msgstr ""

#: docs/8.x/queues.md:block 481 (code)
msgid "use App\\Notifications\\QueueHasLongWaitTime;\n"
"use Illuminate\\Queue\\Events\\QueueBusy;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Support\\Facades\\Notification;\n\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(function (QueueBusy $event) {\n"
"        Notification::route('mail', 'dev@example.com')\n"
"                ->notify(new QueueHasLongWaitTime(\n"
"                    $event->connection,\n"
"                    $event->queue,\n"
"                    $event->size\n"
"                ));\n"
"    });\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 483 (header)
msgid "Job Events"
msgstr ""

#: docs/8.x/queues.md:block 484 (paragraph)
msgid "Using the `before` and `after` methods on the `Queue` [facade](/docs/{{version}}/facades), you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from the `boot` method of a [service provider](/docs/{{version}}/providers). For example, we may use the `AppServiceProvider` that is included with Laravel:"
msgstr ""

#: docs/8.x/queues.md:block 485 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobProcessed;\n"
"use Illuminate\\Queue\\Events\\JobProcessing;\n\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function register()\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        Queue::before(function (JobProcessing $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n\n"
"        Queue::after(function (JobProcessed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/queues.md:block 486 (paragraph)
msgid "Using the `looping` method on the `Queue` [facade](/docs/{{version}}/facades), you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a closure to rollback any transactions that were left open by a previously failed job:"
msgstr ""

#: docs/8.x/queues.md:block 487 (code)
msgid "use Illuminate\\Support\\Facades\\DB;\n"
"use Illuminate\\Support\\Facades\\Queue;\n\n"
"Queue::looping(function () {\n"
"    while (DB::transactionLevel() > 0) {\n"
"        DB::rollBack();\n"
"    }\n"
"});\n"
msgstr ""

#: docs/9.x/queues.md:block 154 (paragraph)
msgid "While it is perfectly fine to dispatch jobs within database transactions, you should take special care to ensure that your job will actually be able to execute successfully. When dispatching a job within a transaction, it is possible that the job will be processed by a worker before the parent transaction has committed. When this happens, any updates you have made to models or database records during the database transaction(s) may not yet be reflected in the database. In addition, any models or database records created within the transaction(s) may not exist in the database."
msgstr ""

#: docs/9.x/queues.md:block 157 (paragraph)
msgid "When the `after_commit` option is `true`, you may dispatch jobs within database transactions; however, Laravel will wait until the open parent database transactions have been committed before actually dispatching the job. Of course, if no database transactions are currently open, the job will be dispatched immediately."
msgstr ""

#: docs/9.x/queues.md:block 158 (paragraph)
msgid "If a transaction is rolled back due to an exception that occurs during the transaction, the jobs that were dispatched during that transaction will be discarded."
msgstr ""

#: docs/9.x/queues.md:block 352 (code)
msgid "# Process jobs for one hour and then exit...\n"
"php artisan queue:work --max-time=3600\n"
msgstr ""

