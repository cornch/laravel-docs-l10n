msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/broadcasting.pot\n"
"X-Crowdin-File-ID: 19\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2022-02-13 09:29\n"

#: docs/8.x/broadcasting.md:block 1 (header)
msgid "Broadcasting"
msgstr "廣播 - Broadcast"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Server Side Installation](#server-side-installation)"
msgstr "[伺服器端安裝](#server-side-installation)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Configuration](#configuration)"
msgstr "[組態設定](#configuration)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Pusher Channels](#pusher-channels)"
msgstr "[Pusher Channels](#pusher-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Ably](#ably)"
msgstr "[Ably](#ably)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Open Source Alternatives](#open-source-alternatives)"
msgstr "[開放原始碼替代](#open-source-alternatives)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Client Side Installation](#client-side-installation)"
msgstr "[用戶端安裝](#client-side-installation)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Pusher Channels](#client-pusher-channels)"
msgstr "[Pusher Channels](#client-pusher-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Ably](#client-ably)"
msgstr "[Ably](#client-ably)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Concept Overview](#concept-overview)"
msgstr "[概念概覽](#concept-overview)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Using An Example Application](#using-example-application)"
msgstr "[使用現有的應用程式](#using-example-application)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Defining Broadcast Events](#defining-broadcast-events)"
msgstr "[定義 Broadcast 事件](#defining-broadcast-events)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcast Name](#broadcast-name)"
msgstr "[Broadcast 名稱](#broadcast-name)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcast Data](#broadcast-data)"
msgstr "[Broadcast 資料](#broadcast-data)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcast Queue](#broadcast-queue)"
msgstr "[Broadcast 佇列](#broadcast-queue)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcast Conditions](#broadcast-conditions)"
msgstr "[Broadcast 條件](#broadcast-conditions)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcasting & Database Transactions](#broadcasting-and-database-transactions)"
msgstr "[Broadcast 與資料庫 Transaction](#broadcasting-and-database-transactions)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Authorizing Channels](#authorizing-channels)"
msgstr "[授權頻道](#authorizing-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Defining Authorization Routes](#defining-authorization-routes)"
msgstr "[定義授權路由](#defining-authorization-routes)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Defining Authorization Callbacks](#defining-authorization-callbacks)"
msgstr "[定義授權回呼](#defining-authorization-callbacks)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Defining Channel Classes](#defining-channel-classes)"
msgstr "[定義頻道類別](#defining-channel-classes)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcasting Events](#broadcasting-events)"
msgstr "[Broadcast 事件](#broadcasting-events)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Only To Others](#only-to-others)"
msgstr "[僅限其他](#only-to-others)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Customizing The Connection](#customizing-the-connection)"
msgstr "[自訂連線](#customizing-the-connection)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Receiving Broadcasts](#receiving-broadcasts)"
msgstr "[接收 Broadcast](#receiving-broadcasts)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Listening For Events](#listening-for-events)"
msgstr "[監聽事件](#listening-for-events)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Leaving A Channel](#leaving-a-channel)"
msgstr "[離開頻道](#leaving-a-channel)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Namespaces](#namespaces)"
msgstr "[Namespace](#namespaces)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Presence Channels](#presence-channels)"
msgstr "[Presence 頻道](#presence-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Authorizing Presence Channels](#authorizing-presence-channels)"
msgstr "[授權 Precense 頻道](#authorizing-presence-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Joining Presence Channels](#joining-presence-channels)"
msgstr "[加入 Presence 頻道](#joining-presence-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Broadcasting To Presence Channels](#broadcasting-to-presence-channels)"
msgstr "[廣播至 Presence 頻道](#broadcasting-to-presence-channels)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Model Broadcasting](#model-broadcasting)"
msgstr "[廣播 Model](#model-broadcasting)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Model Broadcasting Conventions](#model-broadcasting-conventions)"
msgstr "[廣播 Model 的慣例](#model-broadcasting-conventions)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Listening For Model Broadcasts](#listening-for-model-broadcasts)"
msgstr "[監聽 Model Broadcast](#listening-for-model-broadcasts)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Client Events](#client-events)"
msgstr "[用戶端事件](#client-events)"

#: docs/8.x/broadcasting.md:block 2 (unordered list)
msgid "[Notifications](#notifications)"
msgstr "[通知](#notifications)"

#: docs/8.x/broadcasting.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/8.x/broadcasting.md:block 5 (paragraph)
msgid "In many modern web applications, WebSockets are used to implement realtime, live-updating user interfaces. When some data is updated on the server, a message is typically sent over a WebSocket connection to be handled by the client. WebSockets provide a more efficient alternative to continually polling your application's server for data changes that should be reflected in your UI."
msgstr "在許多現代 Web App 中，都使用了 WebSocket 來提供即時更新的 UI。當某個資料在伺服器上被更新，通常會通過 WebSocket 連線來將一個訊息傳送給用戶端做處理。比起不斷從伺服器上拉取資料並反應到 UI 上，WebSocket 提供是更有效率的方案。"

#: docs/8.x/broadcasting.md:block 6 (paragraph)
msgid "For example, imagine your application is able to export a user's data to a CSV file and email it to them. However, creating this CSV file takes several minutes so you choose to create and mail the CSV within a [queued job](/docs/{{version}}/queues). When the CSV has been created and mailed to the user, we can use event broadcasting to dispatch a `App\\Events\\UserDataExported` event that is received by our application's JavaScript. Once the event is received, we can display a message to the user that their CSV has been emailed to them without them ever needing to refresh the page."
msgstr "舉例來說，假設我們的 App 可以將使用者資料匯出為 CSV 檔並以電子郵件寄出。不過，建立 CSV 檔需要數分鐘的事件，因此我們選擇將建立與寄送 CSV 檔的程式放在[佇列任務](/docs/{{version}}/queues)中。當 CSV 當建立完畢並寄給使用者後，我們可以使用「事件廣播」來將 `App\\Events\\UserDataExported` 事件分派給應用程式的 JavaScript。收到事件後，使用者就能在不重新整理的情況下看到一個訊息，表示我們已將 CSV 檔寄送出去。"

#: docs/8.x/broadcasting.md:block 7 (paragraph)
msgid "To assist you in building these types of features, Laravel makes it easy to \"broadcast\" your server-side Laravel [events](/docs/{{version}}/events) over a WebSocket connection. Broadcasting your Laravel events allows you to share the same event names and data between your server-side Laravel application and your client-side JavaScript application."
msgstr "為了協助你製作這種類型的功能，Laravel 讓你能簡單地將伺服器端 Laravel [事件](/docs/{{version}}/events)通過 WebSocket 連線來「廣播」出去。通過廣播 Laravel 事件，就可以在伺服器端 Laravel 程式與用戶端 JavaScript 程式間共享相同的事件名稱與資料。"

#: docs/8.x/broadcasting.md:block 8 (paragraph)
msgid "The core concepts behind broadcasting are simple: clients connect to named channels on the frontend, while your Laravel application broadcasts events to these channels on the backend. These events can contain any additional data you wish to make available to the frontend."
msgstr "「廣播」背後的核心概念很簡單：用戶端會在前端連線到一個有名稱的頻道，而後端 Laravel 網站則會將事件廣播給這些頻道。這些事件可以包含任何你想讓前端存取的額外資料。"

#: docs/8.x/broadcasting.md:block 10 (header)
msgid "Supported Drivers"
msgstr "支援的 Driver"

#: docs/8.x/broadcasting.md:block 11 (paragraph)
msgid "By default, Laravel includes two server-side broadcasting drivers for you to choose from: [Pusher Channels](https://pusher.com/channels) and [Ably](https://ably.io). However, community driven packages such as [laravel-websockets](https://beyondco.de/docs/laravel-websockets/getting-started/introduction) and [soketi](https://docs.soketi.app/) provide additional broadcasting drivers that do not require commercial broadcasting providers."
msgstr "預設情況下，Laravel 包含了兩個伺服器端廣播 Driver 可供選擇：[Pusher Channels](https://pusher.com/channels) 與 [Ably](https://ably.io)。不過，也有如 [laravel-websockets](https://beyondco.de/docs/laravel-websockets/getting-started/introduction) 與 [soketi](https://docs.soketi.app/) 這樣由社群開發的套件提供不需要商業 Broadcast Provider 的額外 Broadcast Driver。"

#: docs/8.x/broadcasting.md:block 12 (quote)
msgid "{tip} Before diving into event broadcasting, make sure you have read Laravel's documentation on [events and listeners](/docs/{{version}}/events)."
msgstr "{tip} 在深入探討事件廣播前，請先確保你已閱讀有關 [事件與監聽程式](/docs/{{version}}/events)的 Laravel 說明文件。"

#: docs/8.x/broadcasting.md:block 14 (header)
msgid "Server Side Installation"
msgstr "伺服器端安裝"

#: docs/8.x/broadcasting.md:block 15 (paragraph)
msgid "To get started using Laravel's event broadcasting, we need to do some configuration within the Laravel application as well as install a few packages."
msgstr "若要開始使用 Laravel 的事件廣播，我們需要在 Laravel 專案中做一些設定以及安裝一些套件。"

#: docs/8.x/broadcasting.md:block 16 (paragraph)
msgid "Event broadcasting is accomplished by a server-side broadcasting driver that broadcasts your Laravel events so that Laravel Echo (a JavaScript library) can receive them within the browser client. Don't worry - we'll walk through each part of the installation process step-by-step."
msgstr "事件廣播是通過伺服器端的廣播 Driver 將 Laravel 事件廣播出去，讓 Laravel Echo (一個 JavaScript 套件) 可以在瀏覽器用戶端內接收這個事件。別擔心 —— 我們會一步一步地介紹安裝過程的每一部分。"

#: docs/8.x/broadcasting.md:block 18 (header)
msgid "Configuration"
msgstr "組態設定"

#: docs/8.x/broadcasting.md:block 19 (paragraph)
msgid "All of your application's event broadcasting configuration is stored in the `config/broadcasting.php` configuration file. Laravel supports several broadcast drivers out of the box: [Pusher Channels](https://pusher.com/channels), [Redis](/docs/{{version}}/redis), and a `log` driver for local development and debugging. Additionally, a `null` driver is included which allows you to totally disable broadcasting during testing. A configuration example is included for each of these drivers in the `config/broadcasting.php` configuration file."
msgstr "專案中，所有關於事件廣播的組態設定都放在 `config/boradcasting.php` 組態設定檔中。Laravel 內建支援多個 Broadcast Driver：[Pusher Channels](https://pusher.com/channels)、[Redis](/docs/{{version}}/redis)、以及一個用於本機開發與除錯的 `log` Driver。此外，也包含了一個可以在測試期間完全禁用廣播的 `null` Driver。`config/boradcasting.php` 組態設定中包含了各個 Driver 的組態設定範例。"

#: docs/8.x/broadcasting.md:block 21 (header)
msgid "Broadcast Service Provider"
msgstr "Broadcast Service Provider"

#: docs/8.x/broadcasting.md:block 22 (paragraph)
msgid "Before broadcasting any events, you will first need to register the `App\\Providers\\BroadcastServiceProvider`. In new Laravel applications, you only need to uncomment this provider in the `providers` array of your `config/app.php` configuration file. This `BroadcastServiceProvider` contains the code necessary to register the broadcast authorization routes and callbacks."
msgstr "在廣播任何事件以前，需要先註冊 `App\\Providers\\BroadcastServiceProvider`。在新安裝的 Laravel 專案中，只需要在 `config/app.php` 組態設定檔內的 `providers` 陣列中取消註解這個 Provider 即可。這個 `BroadcastServiceProvider` 包含了要註冊廣播授權路由以及回呼所需的程式碼。"

#: docs/8.x/broadcasting.md:block 24 (header)
msgid "Queue Configuration"
msgstr "設定佇列"

#: docs/8.x/broadcasting.md:block 25 (paragraph)
msgid "You will also need to configure and run a [queue worker](/docs/{{version}}/queues). All event broadcasting is done via queued jobs so that the response time of your application is not seriously affected by events being broadcast."
msgstr "也需要註冊並執行一個[佇列背景工作角色](/docs/{{version}}/queues)。所有的事件廣播都是通過佇列任務來完成的，這樣一來在事件被廣播的過程所需的事件才不會對網站的回應時間有太大的影響。"

#: docs/8.x/broadcasting.md:block 27 (header)
msgid "Pusher Channels"
msgstr "Pusher Channels"

#: docs/8.x/broadcasting.md:block 28 (paragraph)
msgid "If you plan to broadcast your events using [Pusher Channels](https://pusher.com/channels), you should install the Pusher Channels PHP SDK using the Composer package manager:"
msgstr "若有打算要使用 [Pusher Channels](https://pusher.com/channels)，那麼應通過 Composer 套件管理員來安裝 Pusher Channels 的 PHP SDK："

#: docs/8.x/broadcasting.md:block 29 (code)
msgid "composer require pusher/pusher-php-server\n"
msgstr "composer require pusher/pusher-php-server\n"

#: docs/8.x/broadcasting.md:block 30 (paragraph)
msgid "Next, you should configure your Pusher Channels credentials in the `config/broadcasting.php` configuration file. An example Pusher Channels configuration is already included in this file, allowing you to quickly specify your key, secret, and application ID. Typically, these values should be set via the `PUSHER_APP_KEY`, `PUSHER_APP_SECRET`, and `PUSHER_APP_ID` [environment variables](/docs/{{version}}/configuration#environment-configuration):"
msgstr "接著，應在 `config/broadcasting.php` 組態設定檔中設定 Pusher Channels 的憑證。該檔案中已經有包含了一個範例的 Pusher Channels 設定，讓你可以快速指定你的 Key, Secret 以及 Application ID。通常來說，這些值應該要通過 `PUSHER_APP_KEY`, `PUSHER_APP_SECRET` 與 `PUSHER_APP_ID` [環境變數](/docs/{{version}}/configuration#environment-configuration) 來設定："

#: docs/8.x/broadcasting.md:block 31 (code)
msgid "PUSHER_APP_ID=your-pusher-app-id\n"
"PUSHER_APP_KEY=your-pusher-key\n"
"PUSHER_APP_SECRET=your-pusher-secret\n"
"PUSHER_APP_CLUSTER=mt1\n"
msgstr "PUSHER_APP_ID=your-pusher-app-id\n"
"PUSHER_APP_KEY=your-pusher-key\n"
"PUSHER_APP_SECRET=your-pusher-secret\n"
"PUSHER_APP_CLUSTER=mt1\n"

#: docs/8.x/broadcasting.md:block 32 (paragraph)
msgid "The `config/broadcasting.php` file's `pusher` configuration also allows you to specify additional `options` that are supported by Channels, such as the cluster."
msgstr "`config/broadcasting.php` 檔的 `pusher` 設定能讓你指定 Channels 所支援的額外選項 `options`，如簇集 (Cluster)。"

#: docs/8.x/broadcasting.md:block 33 (paragraph)
msgid "Next, you will need to change your broadcast driver to `pusher` in your `.env` file:"
msgstr "接著，需要在 `.env` 檔中更改你的 Broadcast Driver 為 `pusher`："

#: docs/8.x/broadcasting.md:block 34 (code)
msgid "BROADCAST_DRIVER=pusher\n"
msgstr "BROADCAST_DRIVER=pusher\n"

#: docs/8.x/broadcasting.md:block 35 (paragraph)
msgid "Finally, you are ready to install and configure [Laravel Echo](#client-side-installation), which will receive the broadcast events on the client-side."
msgstr "最後，就可以安裝並設定 [Laravel Echo](#client-side-installable)。Laravel Echo 會在用戶端上接收廣播事件。"

#: docs/8.x/broadcasting.md:block 37 (header)
msgid "Open Source Pusher Alternatives"
msgstr "開放原始碼的 Pusher 替代"

#: docs/8.x/broadcasting.md:block 38 (paragraph)
msgid "The [laravel-websockets](https://github.com/beyondcode/laravel-websockets) and [soketi](https://docs.soketi.app/) packages provide Pusher compatible WebSocket servers for Laravel. These packages allow you to leverage the full power of Laravel broadcasting without a commercial WebSocket provider. For more information on installing and using these packages, please consult our documentation on [open source alternatives](#open-source-alternatives)."
msgstr "[laravel-websockets](https://github.com/beyondcode/laravel-websockets) 與 [soketi](https://docs.soketi.app/) 套件提供了用於 Laravel 的 Pusher 相同 WebSocket 伺服器。使用這些套件就能在不依賴商業 WebSocket Provider 的情況下使用完整的 Laravel Broadcasting 功能。有關安裝這些套件的更多資訊，請參考我們的[開放原始碼替代](#open-source-alternatives)說明文件。"

#: docs/8.x/broadcasting.md:block 40 (header)
msgid "Ably"
msgstr "Ably"

#: docs/8.x/broadcasting.md:block 41 (paragraph)
msgid "If you plan to broadcast your events using [Ably](https://ably.io), you should install the Ably PHP SDK using the Composer package manager:"
msgstr "若有打算要使用 [Ably](https://ably.io)，那麼應通過 Composer 套件管理員來安裝 Ably 的 PHP SDK："

#: docs/8.x/broadcasting.md:block 42 (code)
msgid "composer require ably/ably-php\n"
msgstr "composer require ably/ably-php\n"

#: docs/8.x/broadcasting.md:block 43 (paragraph)
msgid "Next, you should configure your Ably credentials in the `config/broadcasting.php` configuration file. An example Ably configuration is already included in this file, allowing you to quickly specify your key. Typically, this value should be set via the `ABLY_KEY` [environment variable](/docs/{{version}}/configuration#environment-configuration):"
msgstr "接著，應在 `config/broadcasting.php` 組態設定檔中設定 Pusher Channels 的憑證。該檔案中已經有包含了一個範例的 Ably 設定，讓你可以快速指定你的金鑰。通常來說，這個值應該要通過 `ABLY_KEY` [環境變數](/docs/{{version}}/configuration#environment-configuration) 來設定："

#: docs/8.x/broadcasting.md:block 44 (code)
msgid "ABLY_KEY=your-ably-key\n"
msgstr "ABLY_KEY=your-ably-key\n"

#: docs/8.x/broadcasting.md:block 45 (paragraph)
msgid "Next, you will need to change your broadcast driver to `ably` in your `.env` file:"
msgstr "接著，需要在 `.env` 檔中更改你的 Broadcast Driver 為 `ably`："

#: docs/8.x/broadcasting.md:block 46 (code)
msgid "BROADCAST_DRIVER=ably\n"
msgstr "BROADCAST_DRIVER=ably\n"

#: docs/8.x/broadcasting.md:block 49 (header)
msgid "Open Source Alternatives"
msgstr "開放原始碼替代"

#: docs/8.x/broadcasting.md:block 51 (header)
msgid "PHP"
msgstr "PHP"

#: docs/8.x/broadcasting.md:block 52 (paragraph)
msgid "The [laravel-websockets](https://github.com/beyondcode/laravel-websockets) package is a pure PHP, Pusher compatible WebSocket package for Laravel. This package allows you to leverage the full power of Laravel broadcasting without a commercial WebSocket provider. For more information on installing and using this package, please consult its [official documentation](https://beyondco.de/docs/laravel-websockets)."
msgstr "[laravel-websockets](https://github.com/beyondcode/laravel-websockets) 套件是一個純 PHP、適用於 Laravel 的 Pusher 相容 WebSocket 套件。這個套件能讓你使用 Laravel 廣播的全部功能，而無需商業 WebSocket Provider。有關安裝與使用該套件的更多資訊，請參考其[官方說明文件](https://beyondco.de/docs/laravel-websockets)。"

#: docs/8.x/broadcasting.md:block 54 (header)
msgid "Node"
msgstr "Node"

#: docs/8.x/broadcasting.md:block 55 (paragraph)
msgid "[Soketi](https://github.com/soketi/soketi) is a Node based, Pusher compatible WebSocket server for Laravel. Under the hood, Soketi utilizes µWebSockets.js for extreme scalability and speed. This package allows you to leverage the full power of Laravel broadcasting without a commercial WebSocket provider. For more information on installing and using this package, please consult its [official documentation](https://docs.soketi.app/)."
msgstr "[Soketi](https://github.com/soketi/soketi) 套件是一個基於 Node、適用於 Laravel 的 Pusher 相容 WebSocket 伺服器。從底層來看，Soketi 使用了 µWebSockets.js 來獲得最佳可擴充性與速度。Sketi 能讓你在不需仰賴商業 WebSocket Provider 的情況下使用 Laravel 廣播的全部功能。有關安裝與使用 Sketi 的更多資訊，請參考其[官方說明文件](https://docs.soketi.app)。"

#: docs/8.x/broadcasting.md:block 57 (header)
msgid "Client Side Installation"
msgstr "用戶端安裝"

#: docs/8.x/broadcasting.md:block 60 (paragraph)
msgid "[Laravel Echo](https://github.com/laravel/echo) is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by your server-side broadcasting driver. You may install Echo via the NPM package manager. In this example, we will also install the `pusher-js` package since we will be using the Pusher Channels broadcaster:"
msgstr "[Laravel Echo](https://github.com/laravel/echo) 是一個 JavaScript 套件，能讓你免於煩惱如何訂閱頻道與監聽來自伺服器端 Broadcasting Driver 的事件廣播。我們可以通過 NPM 套件管理員來安裝 Echo。在這個例子中，因為我們會使用 Pusher Channels Boradcaster，因此我們也會安裝 `pusher-js`："

#: docs/8.x/broadcasting.md:block 61 (code)
msgid "npm install --save-dev laravel-echo pusher-js\n"
msgstr "npm install --save-dev laravel-echo pusher-js\n"

#: docs/8.x/broadcasting.md:block 62 (paragraph)
msgid "Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the `resources/js/bootstrap.js` file that is included with the Laravel framework. By default, an example Echo configuration is already included in this file - you simply need to uncomment it:"
msgstr "安裝好 Echo 後，就可以在網站的 JavaScript 中建立一個新的 Echo 實體。要建立新 Echo 實體最好的地方就是在 Laravel 附帶的 `resources/js/bootstrap.js` 檔案最尾端。預設情況下，這個檔案內已經包含了一個範例的 Echo 設定，只需要將其取消註解即可："

#: docs/8.x/broadcasting.md:block 63 (code)
msgid "import Echo from 'laravel-echo';\n\n"
"window.Pusher = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: process.env.MIX_PUSHER_APP_KEY,\n"
"    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n"
"    forceTLS: true\n"
"});\n"
msgstr "import Echo from 'laravel-echo';\n\n"
"window.Pusher = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: process.env.MIX_PUSHER_APP_KEY,\n"
"    cluster: process.env.MIX_PUSHER_APP_CLUSTER,\n"
"    forceTLS: true\n"
"});\n"

#: docs/8.x/broadcasting.md:block 64 (paragraph)
msgid "Once you have uncommented and adjusted the Echo configuration according to your needs, you may compile your application's assets:"
msgstr "取消註解並依照需求調整好 Echo 設定後，就可以編譯專案素材："

#: docs/8.x/broadcasting.md:block 65 (code)
msgid "npm run dev\n"
msgstr "npm run dev\n"

#: docs/8.x/broadcasting.md:block 66 (quote)
msgid "{tip} To learn more about compiling your application's JavaScript assets, please consult the documentation on [Laravel Mix](/docs/{{version}}/mix)."
msgstr ""

#: docs/8.x/broadcasting.md:block 68 (header)
msgid "Using An Existing Client Instance"
msgstr "使用現有的用戶端實體"

#: docs/8.x/broadcasting.md:block 69 (paragraph)
msgid "If you already have a pre-configured Pusher Channels client instance that you would like Echo to utilize, you may pass it to Echo via the `client` configuration option:"
msgstr "若已經有預先設定好的 Pusher Channels 用戶端實體，並想讓 Echo 使用的話，可以將其傳入 Echo 的 `client` 設定選項："

#: docs/8.x/broadcasting.md:block 70 (code)
msgid "import Echo from 'laravel-echo';\n\n"
"const client = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: 'your-pusher-channels-key',\n"
"    client: client\n"
"});\n"
msgstr "import Echo from 'laravel-echo';\n\n"
"const client = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: 'your-pusher-channels-key',\n"
"    client: client\n"
"});\n"

#: docs/8.x/broadcasting.md:block 73 (paragraph)
msgid "[Laravel Echo](https://github.com/laravel/echo) is a JavaScript library that makes it painless to subscribe to channels and listen for events broadcast by your server-side broadcasting driver. You may install Echo via the NPM package manager. In this example, we will also install the `pusher-js` package."
msgstr "[Laravel Echo](https://github.com/laravel/echo) 是一個 JavaScript 套件，能讓你免於煩惱如何訂閱頻道與監聽來自伺服器端 Broadcasting Driver 的事件廣播。我們可以通過 NPM 套件管理員來安裝 Echo。在這個例子中，我們也會安裝 `pusher-js`："

#: docs/8.x/broadcasting.md:block 74 (paragraph)
msgid "You may wonder why we would install the `pusher-js` JavaScript library even though we are using Ably to broadcast our events. Thankfully, Ably includes a Pusher compatibility mode which lets us use the Pusher protocol when listening for events in our client-side application:"
msgstr "你可能會很困惑，為什麼我們明明是要用 Ably 來廣播事件，卻安裝了 `pusher-js` JavaScript 函式庫。謝天謝地，Ably 有個 Pusher 相容模式，可以讓我們在用戶端程式內監聽事件的時候使用 Pusher 協定："

#: docs/8.x/broadcasting.md:block 76 (paragraph)
msgid "**Before continuing, you should enable Pusher protocol support in your Ably application settings. You may enable this feature within the \"Protocol Adapter Settings\" portion of your Ably application's settings dashboard.**"
msgstr ""

#: docs/8.x/broadcasting.md:block 77 (paragraph)
msgid "Once Echo is installed, you are ready to create a fresh Echo instance in your application's JavaScript. A great place to do this is at the bottom of the `resources/js/bootstrap.js` file that is included with the Laravel framework. By default, an example Echo configuration is already included in this file; however, the default configuration in the `bootstrap.js` file is intended for Pusher. You may copy the configuration below to transition your configuration to Ably:"
msgstr "安裝好 Echo 後，就可以在網站的 JavaScript 中建立一個新的 Echo 實體。要建立新 Echo 實體最好的地方就是在 Laravel 附帶的 `resources/js/bootstrap.js` 檔案最尾端。預設情況下，這個檔案內已經包含了一個範例的 Echo 設定。不過，`bootstrap.js` 檔案中預設的範例是給 Pusher 用的。可以複製下列設定來將你的設定檔改成使用 Ably："

#: docs/8.x/broadcasting.md:block 78 (code)
msgid "import Echo from 'laravel-echo';\n\n"
"window.Pusher = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: process.env.MIX_ABLY_PUBLIC_KEY,\n"
"    wsHost: 'realtime-pusher.ably.io',\n"
"    wsPort: 443,\n"
"    disableStats: true,\n"
"    encrypted: true,\n"
"});\n"
msgstr "import Echo from 'laravel-echo';\n\n"
"window.Pusher = require('pusher-js');\n\n"
"window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    key: process.env.MIX_ABLY_PUBLIC_KEY,\n"
"    wsHost: 'realtime-pusher.ably.io',\n"
"    wsPort: 443,\n"
"    disableStats: true,\n"
"    encrypted: true,\n"
"});\n"

#: docs/8.x/broadcasting.md:block 79 (paragraph)
msgid "Note that our Ably Echo configuration references a `MIX_ABLY_PUBLIC_KEY` environment variable. This variable's value should be your Ably public key. Your public key is the portion of your Ably key that occurs before the `:` character."
msgstr "請注意，Ably Echo 組態設定中參考了 `MIX_ABLY_PUBLIC_KEY` 環境變數。這個環境變數應為 Ably 的公開金鑰。公開金鑰就是 Ably 金鑰中出現在 `:` 字元之前的部分。"

#: docs/8.x/broadcasting.md:block 84 (header)
msgid "Concept Overview"
msgstr "概念概覽"

#: docs/8.x/broadcasting.md:block 85 (paragraph)
msgid "Laravel's event broadcasting allows you to broadcast your server-side Laravel events to your client-side JavaScript application using a driver-based approach to WebSockets. Currently, Laravel ships with [Pusher Channels](https://pusher.com/channels) and [Ably](https://ably.io) drivers. The events may be easily consumed on the client-side using the [Laravel Echo](#client-side-installation) JavaScript package."
msgstr "Laravel 的事件廣播功能能讓你以基於 Driver 的方法來將伺服器端的 Laravel 事件通過 WebSockets 廣播到用戶端 JavaScript 上。目前，Laravel 隨附了 [Pusher Channels](https://pusher.com/channels) 與 [Ably](https://ably.io) 兩個 Driver。可以在用戶端使用 [Laravel Echo](#client-side-installation) JavaScript 套件來輕鬆取得事件。"

#: docs/8.x/broadcasting.md:block 86 (paragraph)
msgid "Events are broadcast over \"channels\", which may be specified as public or private. Any visitor to your application may subscribe to a public channel without any authentication or authorization; however, in order to subscribe to a private channel, a user must be authenticated and authorized to listen on that channel."
msgstr "事件是通過「頻道 (Channel)」進行廣播的，頻道可以被設為公共或私有。任何網站的瀏覽者都可以在不登入或經過授權的情況下訂閱公開頻道。不過，如果要訂閱私有頻道，就必須要登入並經過授權才可以監聽該頻道。"

#: docs/8.x/broadcasting.md:block 87 (quote)
msgid "{tip} If you would like to explore open source alternatives to Pusher, check out the [open source alternatives](#open-source-alternatives)."
msgstr ""

#: docs/8.x/broadcasting.md:block 89 (header)
msgid "Using An Example Application"
msgstr "使用範例專案"

#: docs/8.x/broadcasting.md:block 90 (paragraph)
msgid "Before diving into each component of event broadcasting, let's take a high level overview using an e-commerce store as an example."
msgstr "在深入探討事件廣播的各個元件之前，我們先來用網路商店當作例子，以高階的角度來個概覽。"

#: docs/8.x/broadcasting.md:block 91 (paragraph)
msgid "In our application, let's assume we have a page that allows users to view the shipping status for their orders. Let's also assume that a `OrderShipmentStatusUpdated` event is fired when a shipping status update is processed by the application:"
msgstr "在我們的專案中，先來假設有個能讓使用者檢視訂單配送狀態的頁面。另外，也假設當網站處理到配送狀態更新的時候會觸發 `OrderShipmentStatusUpdated` 事件："

#: docs/8.x/broadcasting.md:block 92 (code)
msgid "use App\\Events\\OrderShipmentStatusUpdated;\n\n"
"OrderShipmentStatusUpdated::dispatch($order);\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 94 (header)
msgid "The `ShouldBroadcast` Interface"
msgstr "`ShouldBroadcast` 介面"

#: docs/8.x/broadcasting.md:block 95 (paragraph)
msgid "When a user is viewing one of their orders, we don't want them to have to refresh the page to view status updates. Instead, we want to broadcast the updates to the application as they are created. So, we need to mark the `OrderShipmentStatusUpdated` event with the `ShouldBroadcast` interface. This will instruct Laravel to broadcast the event when it is fired:"
msgstr "我們並不希望使用者在檢視某個訂單的時候還需要重新整理整個頁面才能看到狀態更新；我們希望在訂單更新建立的時候就能廣播給專案。因此，我們需要將 `OrderShipmentStatusUpdated` 事件標上 `ShouldBroadcast` 介面。通過加上該介面，就能告訴 Laravel 要在該事件被觸發時將其廣播出去："

#: docs/8.x/broadcasting.md:block 96 (code)
msgid "<?php\n\n"
"namespace App\\Events;\n\n"
"use App\\Order;\n"
"use Illuminate\\Broadcasting\\Channel;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Broadcasting\\PresenceChannel;\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class OrderShipmentStatusUpdated implements ShouldBroadcast\n"
"{\n"
"    /**\n"
"     * The order instance.\n"
"     *\n"
"     * @var \\App\\Order\n"
"     */\n"
"    public $order;\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 97 (paragraph)
msgid "The `ShouldBroadcast` interface requires our event to define a `broadcastOn` method. This method is responsible for returning the channels that the event should broadcast on. An empty stub of this method is already defined on generated event classes, so we only need to fill in its details. We only want the creator of the order to be able to view status updates, so we will broadcast the event on a private channel that is tied to the order:"
msgstr "`ShouldBroadcast` 介面需要我們在事件中定義一個 `broadcastOn` 方法。這個方法需要回傳該事件廣播的頻道。產生的事件類別當中已經棒我們加上了一個空白的 Stub，因此我們只需要填寫詳情就好了。我們只希望建立該訂單的使用者檢視狀態更新，因此我們會將事件放在該訂單的私有頻道上廣播："

#: docs/8.x/broadcasting.md:block 98 (code)
msgid "/**\n"
" * Get the channels the event should broadcast on.\n"
" *\n"
" * @return \\Illuminate\\Broadcasting\\PrivateChannel\n"
" */\n"
"public function broadcastOn()\n"
"{\n"
"    return new PrivateChannel('orders.'.$this->order->id);\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 100 (header)
msgid "Authorizing Channels"
msgstr "授權頻道"

#: docs/8.x/broadcasting.md:block 101 (paragraph)
msgid "Remember, users must be authorized to listen on private channels. We may define our channel authorization rules in our application's `routes/channels.php` file. In this example, we need to verify that any user attempting to listen on the private `orders.1` channel is actually the creator of the order:"
msgstr "請記得，使用者必須要經過授權才能監聽私有頻道。我們可以在 `routes/channels.php` 檔中定義頻道權限規則。在此例子中，我們需要認證嘗試監聽私有頻道 `orders.1` 的使用者是否為該訂單實際的建立人："

#: docs/8.x/broadcasting.md:block 102 (code)
msgid "use App\\Models\\Order;\n\n"
"Broadcast::channel('orders.{orderId}', function ($user, $orderId) {\n"
"    return $user->id === Order::findOrNew($orderId)->user_id;\n"
"});\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 103 (paragraph)
msgid "The `channel` method accepts two arguments: the name of the channel and a callback which returns `true` or `false` indicating whether the user is authorized to listen on the channel."
msgstr "`channel` 方法接收 2 個引數：頻道的名稱，以及會回傳 `true` 與 `false` 的回呼。這個回呼用來判斷使用者是否已授權監聽此頻道。"

#: docs/8.x/broadcasting.md:block 104 (paragraph)
msgid "All authorization callbacks receive the currently authenticated user as their first argument and any additional wildcard parameters as their subsequent arguments. In this example, we are using the `{orderId}` placeholder to indicate that the \"ID\" portion of the channel name is a wildcard."
msgstr "所有的授權回呼都會收到目前登入使用者作為其第一個引數，而接下來的引數則是其他額外的萬用字元參數。在這個例子中，我們使用了 `{orderId}` 預留位置來標示頻道名稱中的「ID」部分是萬用字元。"

#: docs/8.x/broadcasting.md:block 106 (header)
msgid "Listening For Event Broadcasts"
msgstr "監聽事件廣播"

#: docs/8.x/broadcasting.md:block 107 (paragraph)
msgid "Next, all that remains is to listen for the event in our JavaScript application. We can do this using [Laravel Echo](#client-side-installation). First, we'll use the `private` method to subscribe to the private channel. Then, we may use the `listen` method to listen for the `OrderShipmentStatusUpdated` event. By default, all of the event's public properties will be included on the broadcast event:"
msgstr "接著，剩下的工作就是在 JavaScript 程式碼內監聽事件了。我們可以使用 [Laravel Echo](#client-side-installation)。首先，我們要先用 `private` 方法來監聽私有頻道。接著，可以監聽「`listen`」`OrderShipmentStatusUpdated` 事件。預設情況下，該事件的所有公共屬性都會被包含在廣播事件內："

#: docs/8.x/broadcasting.md:block 108 (code)
msgid "Echo.private(`orders.${orderId}`)\n"
"    .listen('OrderShipmentStatusUpdated', (e) => {\n"
"        console.log(e.order);\n"
"    });\n"
msgstr "Echo.private(`orders.${orderId}`)\n"
"    .listen('OrderShipmentStatusUpdated', (e) => {\n"
"        console.log(e.order);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 110 (header)
msgid "Defining Broadcast Events"
msgstr "定義廣播事件"

#: docs/8.x/broadcasting.md:block 111 (paragraph)
msgid "To inform Laravel that a given event should be broadcast, you must implement the `Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast` interface on the event class. This interface is already imported into all event classes generated by the framework so you may easily add it to any of your events."
msgstr "為了告訴 Laravel 應廣播某個給定的事件，我們必須要在事件類別上實作 `Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast` 介面。在所有產生出來的事件類別上，框架已經幫你引入這個介面了，因此你可以輕鬆地將該介面加至任何事件上。"

#: docs/8.x/broadcasting.md:block 112 (paragraph)
msgid "The `ShouldBroadcast` interface requires you to implement a single method: `broadcastOn`. The `broadcastOn` method should return a channel or array of channels that the event should broadcast on. The channels should be instances of `Channel`, `PrivateChannel`, or `PresenceChannel`. Instances of `Channel` represent public channels that any user may subscribe to, while `PrivateChannels` and `PresenceChannels` represent private channels that require [channel authorization](#authorizing-channels):"
msgstr "`ShouldBroadcast` 介面只要求實作單一方法：`broadcastOn`。`broadcastOn` 方法應回傳一個頻道，或是一個包含頻道的陣列。這些頻道是事件要進行廣播的頻道。頻道應為 `Channel`, `PrivateChannel` 或 `PresenceChannel` 的實體。`Channel` 的實體代表任何使用者都能監聽的公共頻道，而 `PrivateChannel` 與 `PresenceChannels` 代表需要進行[頻道授權](#authorizing-channels)的私有頻道："

#: docs/8.x/broadcasting.md:block 113 (code)
msgid "<?php\n\n"
"namespace App\\Events;\n\n"
"use App\\Models\\User;\n"
"use Illuminate\\Broadcasting\\Channel;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Broadcasting\\PresenceChannel;\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class ServerCreated implements ShouldBroadcast\n"
"{\n"
"    use SerializesModels;\n\n"
"    /**\n"
"     * The user that created the server.\n"
"     *\n"
"     * @var \\App\\Models\\User\n"
"     */\n"
"    public $user;\n\n"
"    /**\n"
"     * Create a new event instance.\n"
"     *\n"
"     * @param  \\App\\Models\\User  $user\n"
"     * @return void\n"
"     */\n"
"    public function __construct(User $user)\n"
"    {\n"
"        $this->user = $user;\n"
"    }\n\n"
"    /**\n"
"     * Get the channels the event should broadcast on.\n"
"     *\n"
"     * @return Channel|array\n"
"     */\n"
"    public function broadcastOn()\n"
"    {\n"
"        return new PrivateChannel('user.'.$this->user->id);\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 114 (paragraph)
msgid "After implementing the `ShouldBroadcast` interface, you only need to [fire the event](/docs/{{version}}/events) as you normally would. Once the event has been fired, a [queued job](/docs/{{version}}/queues) will automatically broadcast the event using your specified broadcast driver."
msgstr "實作完 `ShouldBroadcast` 介面後，只需要像平常一樣[觸發事件](/docs/{{version}}/events)即可。事件被觸發後，[佇列任務](/docs/{{version}}/queues)會自動通過指定的 Broadcast Driver 來廣播事件。"

#: docs/8.x/broadcasting.md:block 116 (header)
msgid "Broadcast Name"
msgstr "Broadcast 名稱"

#: docs/8.x/broadcasting.md:block 117 (paragraph)
msgid "By default, Laravel will broadcast the event using the event's class name. However, you may customize the broadcast name by defining a `broadcastAs` method on the event:"
msgstr "預設情況下，Laravel 會使用事件的類別名來進行廣播。不過，也可以在事件上定義 `broadcastAs` 方法來自訂 Broadcast 名稱："

#: docs/8.x/broadcasting.md:block 118 (code)
msgid "/**\n"
" * The event's broadcast name.\n"
" *\n"
" * @return string\n"
" */\n"
"public function broadcastAs()\n"
"{\n"
"    return 'server.created';\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 119 (paragraph)
msgid "If you customize the broadcast name using the `broadcastAs` method, you should make sure to register your listener with a leading `.` character. This will instruct Echo to not prepend the application's namespace to the event:"
msgstr "若使用 `broadcastAs` 方法來自訂 Broadcast 名稱，則應確保註冊監聽程式時有加上前置 `.` 字元。加上該前置字元可用來告訴 Echo 不要在事件前方加上專案的命名空間："

#: docs/8.x/broadcasting.md:block 120 (code)
msgid ".listen('.server.created', function (e) {\n"
"    ....\n"
"});\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 122 (header)
msgid "Broadcast Data"
msgstr "Broadcast 資料"

#: docs/8.x/broadcasting.md:block 123 (paragraph)
msgid "When an event is broadcast, all of its `public` properties are automatically serialized and broadcast as the event's payload, allowing you to access any of its public data from your JavaScript application. So, for example, if your event has a single public `$user` property that contains an Eloquent model, the event's broadcast payload would be:"
msgstr "廣播事件時，事件所有的 `public` 屬性都會被自動序列化，並作為事件的 Payload 進行廣播，讓你能在 JavaScript 程式碼中存取事件的所有公共資料。因此，舉例來說，假設我們的事件有一個 public `$user` 屬性，其中包含了 Eloquent Model，那麼事件的 Broadcast Payload 會是："

#: docs/8.x/broadcasting.md:block 124 (code)
msgid "{\n"
"    \"user\": {\n"
"        \"id\": 1,\n"
"        \"name\": \"Patrick Stewart\"\n"
"        ...\n"
"    }\n"
"}\n"
msgstr "{\n"
"    \"user\": {\n"
"        \"id\": 1,\n"
"        \"name\": \"Patrick Stewart\"\n"
"        ...\n"
"    }\n"
"}\n"

#: docs/8.x/broadcasting.md:block 125 (paragraph)
msgid "However, if you wish to have more fine-grained control over your broadcast payload, you may add a `broadcastWith` method to your event. This method should return the array of data that you wish to broadcast as the event payload:"
msgstr "不過，若想對 Broadcast Payload 進一步地控制，可以在事件內加上一個 `broadcastWith` 方法。這個方法應回傳一個陣列，包含要作為事件 Payload 使用的資料："

#: docs/8.x/broadcasting.md:block 126 (code)
msgid "/**\n"
" * Get the data to broadcast.\n"
" *\n"
" * @return array\n"
" */\n"
"public function broadcastWith()\n"
"{\n"
"    return ['id' => $this->user->id];\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 128 (header)
msgid "Broadcast Queue"
msgstr "Broadcast 佇列"

#: docs/8.x/broadcasting.md:block 129 (paragraph)
msgid "By default, each broadcast event is placed on the default queue for the default queue connection specified in your `queue.php` configuration file. You may customize the queue connection and name used by the broadcaster by defining `connection` and `queue` properties on your event class:"
msgstr "預設情況下，所有的廣播事件都會使用 `queue.php` 組態設定檔中的預設佇列連連。可以通過在事件類別內定義 `queue` 屬性來自訂 Broadcaster 要使用的佇列連線名稱："

#: docs/8.x/broadcasting.md:block 130 (code)
msgid "/**\n"
" * The name of the queue connection to use when broadcasting the event.\n"
" *\n"
" * @var string\n"
" */\n"
"public $connection = 'redis';\n\n"
"/**\n"
" * The name of the queue on which to place the broadcasting job.\n"
" *\n"
" * @var string\n"
" */\n"
"public $queue = 'default';\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 131 (paragraph)
msgid "Alternatively, you may customize the queue name by defining a `broadcastQueue` method on your event:"
msgstr "或者，你也可以通過在事件中定義 `broadcastQueue` 方法來自訂佇列名稱："

#: docs/8.x/broadcasting.md:block 132 (code)
msgid "/**\n"
" * The name of the queue on which to place the broadcasting job.\n"
" *\n"
" * @return string\n"
" */\n"
"public function broadcastQueue()\n"
"{\n"
"    return 'default';\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 133 (paragraph)
msgid "If you would like to broadcast your event using the `sync` queue instead of the default queue driver, you can implement the `ShouldBroadcastNow` interface instead of `ShouldBroadcast`:"
msgstr "若像使用 `sync` 佇列來代替預設的佇列 Driver，可以使用 `ShouldBroadcastNow` 來代替 `ShouldBroadcast` 進行實作："

#: docs/8.x/broadcasting.md:block 134 (code)
msgid "<?php\n\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcastNow;\n\n"
"class OrderShipmentStatusUpdated implements ShouldBroadcastNow\n"
"{\n"
"    //\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 136 (header)
msgid "Broadcast Conditions"
msgstr "Broadcast 條件"

#: docs/8.x/broadcasting.md:block 137 (paragraph)
msgid "Sometimes you want to broadcast your event only if a given condition is true. You may define these conditions by adding a `broadcastWhen` method to your event class:"
msgstr "有時候我們可能只想在滿足給定條件的時候才廣播事件。可以通過在事件類別上新增 `broadcastWhen` 方法來在其中定義這些條件："

#: docs/8.x/broadcasting.md:block 138 (code)
msgid "/**\n"
" * Determine if this event should broadcast.\n"
" *\n"
" * @return bool\n"
" */\n"
"public function broadcastWhen()\n"
"{\n"
"    return $this->order->value > 100;\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 140 (header)
msgid "Broadcasting & Database Transactions"
msgstr "Broadcast 與資料庫 Transaction"

#: docs/8.x/broadcasting.md:block 141 (paragraph)
msgid "When broadcast events are dispatched within database transactions, they may be processed by the queue before the database transaction has committed. When this happens, any updates you have made to models or database records during the database transaction may not yet be reflected in the database. In addition, any models or database records created within the transaction may not exist in the database. If your event depends on these models, unexpected errors can occur when the job that broadcasts the event is processed."
msgstr "當廣播事件是在資料庫 Transaction 內分派的時候，這個事件可能會在資料庫 Transaction 被 Commit 前被佇列進行處理了。發生這種情況時，在資料庫 Transaction 期間對 Model 或資料庫記錄所做出的更新可能都還未反應到資料庫內。另外，所有在 Transaction 期間新增的 Model 或資料庫記錄也可能還未出現在資料庫內。若事件有依賴這些 Model 的話，在處理廣播事件的任務時可能會出現未預期的錯誤。"

#: docs/8.x/broadcasting.md:block 142 (paragraph)
msgid "If your queue connection's `after_commit` configuration option is set to `false`, you may still indicate that a particular broadcast event should be dispatched after all open database transactions have been committed by defining an `$afterCommit` property on the event class:"
msgstr "若佇列連線的 `after_commit` 設定選項是 `false`，那麼就可以通過在事件類別上定義 `$afterCommit` 屬性來標示出特定的廣播事件應在資料庫 Transaction 被 Commit 後才可進行分派："

#: docs/8.x/broadcasting.md:block 143 (code)
msgid "<?php\n\n"
"namespace App\\Events;\n\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class ServerCreated implements ShouldBroadcast\n"
"{\n"
"    use SerializesModels;\n\n"
"    public $afterCommit = true;\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 144 (quote)
msgid "{tip} To learn more about working around these issues, please review the documentation regarding [queued jobs and database transactions](/docs/{{version}}/queues#jobs-and-database-transactions)."
msgstr ""

#: docs/8.x/broadcasting.md:block 147 (paragraph)
msgid "Private channels require you to authorize that the currently authenticated user can actually listen on the channel. This is accomplished by making an HTTP request to your Laravel application with the channel name and allowing your application to determine if the user can listen on that channel. When using [Laravel Echo](#client-side-installation), the HTTP request to authorize subscriptions to private channels will be made automatically; however, you do need to define the proper routes to respond to these requests."
msgstr "使用私有頻道，則需要將目前已登入的使用者授權為可監聽該頻道。要授權使用者，需要向 Laravel 端傳送一個包含頻道名稱的 HTTP 請求來讓網站判斷使用者能否監聽該頻道。使用 [Laravel Echo](#client-side-installation) 時，會自動建立用於授權訂閱私有頻道的 HTTP 請求。不過，我們還是需要定義適當的路由來回應這些請求。"

#: docs/8.x/broadcasting.md:block 149 (header)
msgid "Defining Authorization Routes"
msgstr "定義授權路由"

#: docs/8.x/broadcasting.md:block 150 (paragraph)
msgid "Thankfully, Laravel makes it easy to define the routes to respond to channel authorization requests. In the `App\\Providers\\BroadcastServiceProvider` included with your Laravel application, you will see a call to the `Broadcast::routes` method. This method will register the `/broadcasting/auth` route to handle authorization requests:"
msgstr "好佳在，在 Laravel 中定義回應頻道授權請求的路由非常容易。在 Laravel 中隨附的 `App\\Providers\\BroadcastServiceProvider` 內，可以看到一個 `Broadcast::routes` 方法的呼叫。這個方法會註冊 `/broadcasting/auth` 路由來處理授權請求："

#: docs/8.x/broadcasting.md:block 151 (code)
msgid "Broadcast::routes();\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 152 (paragraph)
msgid "The `Broadcast::routes` method will automatically place its routes within the `web` middleware group; however, you may pass an array of route attributes to the method if you would like to customize the assigned attributes:"
msgstr "`Broadcast::routes` 方法會自動將其中的路由放置於 `web` Middleware 群組內。不過，若想自訂指派的屬性，也可以傳入包含路由屬性的陣列："

#: docs/8.x/broadcasting.md:block 153 (code)
msgid "Broadcast::routes($attributes);\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 155 (header)
msgid "Customizing The Authorization Endpoint"
msgstr "自訂授權 Endpoint"

#: docs/8.x/broadcasting.md:block 156 (paragraph)
msgid "By default, Echo will use the `/broadcasting/auth` endpoint to authorize channel access. However, you may specify your own authorization endpoint by passing the `authEndpoint` configuration option to your Echo instance:"
msgstr "預設情況下，Echo 會使用 `/broadcasting/auth` Endpoint 來授權頻道存取。不過，也可以通過將 `authEndpoint` 設定選項傳給 Echo 實體來指定你自己的授權 Endpoint："

#: docs/8.x/broadcasting.md:block 157 (code)
msgid "window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    // ...\n"
"    authEndpoint: '/custom/endpoint/auth'\n"
"});\n"
msgstr "window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    // ...\n"
"    authEndpoint: '/custom/endpoint/auth'\n"
"});\n"

#: docs/8.x/broadcasting.md:block 159 (header)
msgid "Customizing The Authorization Request"
msgstr "自訂授權 Endpoint"

#: docs/8.x/broadcasting.md:block 160 (paragraph)
msgid "You can customize how Laravel Echo performs authorization requests by providing a custom authorizer when initializing Echo:"
msgstr "我們可以自訂 Laravel Echo 要如何執行授權請求。只需要在初始化 Echo 時提供一個自訂授權程式即可："

#: docs/8.x/broadcasting.md:block 161 (code)
msgid "window.Echo = new Echo({\n"
"    // ...\n"
"    authorizer: (channel, options) => {\n"
"        return {\n"
"            authorize: (socketId, callback) => {\n"
"                axios.post('/api/broadcasting/auth', {\n"
"                    socket_id: socketId,\n"
"                    channel_name: channel.name\n"
"                })\n"
"                .then(response => {\n"
"                    callback(false, response.data);\n"
"                })\n"
"                .catch(error => {\n"
"                    callback(true, error);\n"
"                });\n"
"            }\n"
"        };\n"
"    },\n"
"})\n"
msgstr "window.Echo = new Echo({\n"
"    // ...\n"
"    authorizer: (channel, options) => {\n"
"        return {\n"
"            authorize: (socketId, callback) => {\n"
"                axios.post('/api/broadcasting/auth', {\n"
"                    socket_id: socketId,\n"
"                    channel_name: channel.name\n"
"                })\n"
"                .then(response => {\n"
"                    callback(false, response.data);\n"
"                })\n"
"                .catch(error => {\n"
"                    callback(true, error);\n"
"                });\n"
"            }\n"
"        };\n"
"    },\n"
"})\n"

#: docs/8.x/broadcasting.md:block 163 (header)
msgid "Defining Authorization Callbacks"
msgstr "定義授權回呼"

#: docs/8.x/broadcasting.md:block 164 (paragraph)
msgid "Next, we need to define the logic that will actually determine if the currently authenticated user can listen to a given channel. This is done in the `routes/channels.php` file that is included with your application. In this file, you may use the `Broadcast::channel` method to register channel authorization callbacks:"
msgstr "接著，我們需要定義實際上用來判斷目前登入使用者是否能監聽給定頻道的邏輯。這個定義放在專案內`routes/channels.php` 檔案中。在這個檔案中，可以使用 `Broadcast::channel` 方法來註冊頻道授權回呼："

#: docs/8.x/broadcasting.md:block 165 (code)
msgid "Broadcast::channel('orders.{orderId}', function ($user, $orderId) {\n"
"    return $user->id === Order::findOrNew($orderId)->user_id;\n"
"});\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 169 (header)
msgid "Authorization Callback Model Binding"
msgstr "授權回呼的 Model "

#: docs/8.x/broadcasting.md:block 170 (paragraph)
msgid "Just like HTTP routes, channel routes may also take advantage of implicit and explicit [route model binding](/docs/{{version}}/routing#route-model-binding). For example, instead of receiving a string or numeric order ID, you may request an actual `Order` model instance:"
msgstr "就像 HTTP 路由一樣，頻道路由也能使用顯式或隱式[路由 Model ](/docs/{{version}}/routing#route-model-binding)的功能。舉例來說，可以不接收字串或數字的 Order ID，而要求實際的 `Order` Model 實體："

#: docs/8.x/broadcasting.md:block 171 (code)
msgid "use App\\Models\\Order;\n\n"
"Broadcast::channel('orders.{order}', function ($user, Order $order) {\n"
"    return $user->id === $order->user_id;\n"
"});\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 172 (quote)
msgid "{note} Unlike HTTP route model binding, channel model binding does not support automatic [implicit model binding scoping](/docs/{{version}}/routing#implicit-model-binding-scoping). However, this is rarely a problem because most channels can be scoped based on a single model's unique, primary key."
msgstr ""

#: docs/8.x/broadcasting.md:block 174 (header)
msgid "Authorization Callback Authentication"
msgstr "授權回呼認證"

#: docs/8.x/broadcasting.md:block 175 (paragraph)
msgid "Private and presence broadcast channels authenticate the current user via your application's default authentication guard. If the user is not authenticated, channel authorization is automatically denied and the authorization callback is never executed. However, you may assign multiple, custom guards that should authenticate the incoming request if necessary:"
msgstr "私有與 Presence 廣播頻道會通過專案預設的認證 Guard 來認證目前的使用者。若使用者未登入，則頻道認證會自動拒絕，且授權回呼永遠不會被執行。不過，若有需要，也可以指定多個自訂 Guard 來認證連入請求："

#: docs/8.x/broadcasting.md:block 176 (code)
msgid "Broadcast::channel('channel', function () {\n"
"    // ...\n"
"}, ['guards' => ['web', 'admin']]);\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 178 (header)
msgid "Defining Channel Classes"
msgstr "定義 Channel 類別"

#: docs/8.x/broadcasting.md:block 179 (paragraph)
msgid "If your application is consuming many different channels, your `routes/channels.php` file could become bulky. So, instead of using closures to authorize channels, you may use channel classes. To generate a channel class, use the `make:channel` Artisan command. This command will place a new channel class in the `App/Broadcasting` directory."
msgstr "若你的專案會使用到許多不同的頻道，則 `routes/channels.php` 可能會變得很肥大。因此，比起使用閉包來授權頻道，我們可以改用頻道類別。要建立頻道類別，請使用 `make:channel` Artisan 指令。這個指令會在 `app/Broadcasting` 目錄內放置一個新的頻道類別。"

#: docs/8.x/broadcasting.md:block 180 (code)
msgid "php artisan make:channel OrderChannel\n"
msgstr "php artisan make:channel OrderChannel\n"

#: docs/8.x/broadcasting.md:block 181 (paragraph)
msgid "Next, register your channel in your `routes/channels.php` file:"
msgstr "接著，在 `routes/channels.php` 檔案內註冊頻道："

#: docs/8.x/broadcasting.md:block 182 (code)
msgid "use App\\Broadcasting\\OrderChannel;\n\n"
"Broadcast::channel('orders.{order}', OrderChannel::class);\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 183 (paragraph)
msgid "Finally, you may place the authorization logic for your channel in the channel class' `join` method. This `join` method will house the same logic you would have typically placed in your channel authorization closure. You may also take advantage of channel model binding:"
msgstr "最後，可以將頻道的授權邏輯放在頻道類別的 `join` 方法內。這個 `join` 方法用來放置與平常放在頻道授權閉包相同的邏輯。也可以使用頻道 Model 綁定："

#: docs/8.x/broadcasting.md:block 184 (code)
msgid "<?php\n\n"
"namespace App\\Broadcasting;\n\n"
"use App\\Models\\Order;\n"
"use App\\Models\\User;\n\n"
"class OrderChannel\n"
"{\n"
"    /**\n"
"     * Create a new channel instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Authenticate the user's access to the channel.\n"
"     *\n"
"     * @param  \\App\\Models\\User  $user\n"
"     * @param  \\App\\Models\\Order  $order\n"
"     * @return array|bool\n"
"     */\n"
"    public function join(User $user, Order $order)\n"
"    {\n"
"        return $user->id === $order->user_id;\n"
"    }\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 185 (quote)
msgid "{tip} Like many other classes in Laravel, channel classes will automatically be resolved by the [service container](/docs/{{version}}/container). So, you may type-hint any dependencies required by your channel in its constructor."
msgstr ""

#: docs/8.x/broadcasting.md:block 187 (header)
msgid "Broadcasting Events"
msgstr "廣播事件"

#: docs/8.x/broadcasting.md:block 188 (paragraph)
msgid "Once you have defined an event and marked it with the `ShouldBroadcast` interface, you only need to fire the event using the event's dispatch method. The event dispatcher will notice that the event is marked with the `ShouldBroadcast` interface and will queue the event for broadcasting:"
msgstr "定義好事件並將其以 `ShouldBroadcast` 介面進行標示後，我們只需要使用 dispatch 方法來觸發事件即可。事件觸發程式會注意到這個事件有被標註為 `ShouldBroadcast` 介面，並將事件放入佇列以進行廣播："

#: docs/8.x/broadcasting.md:block 191 (header)
msgid "Only To Others"
msgstr "僅限其他"

#: docs/8.x/broadcasting.md:block 192 (paragraph)
msgid "When building an application that utilizes event broadcasting, you may occasionally need to broadcast an event to all subscribers to a given channel except for the current user. You may accomplish this using the `broadcast` helper and the `toOthers` method:"
msgstr "在建立一個有使用到事件廣播的專案時，我們可能會需要將某個事件廣播給除了目前使用者以外的所有頻道訂閱者。可以通過 `broadcast` 輔助函式以及 `toOthers` 方法來完成："

#: docs/8.x/broadcasting.md:block 193 (code)
msgid "use App\\Events\\OrderShipmentStatusUpdated;\n\n"
"broadcast(new OrderShipmentStatusUpdated($update))->toOthers();\n"
msgstr "use App\\Events\\OrderShipmentStatusUpdated;\n\n"
"broadcast(new OrderShipmentStatusUpdated($update))->toOthers();\n"

#: docs/8.x/broadcasting.md:block 194 (paragraph)
msgid "To better understand when you may want to use the `toOthers` method, let's imagine a task list application where a user may create a new task by entering a task name. To create a task, your application might make a request to a `/task` URL which broadcasts the task's creation and returns a JSON representation of the new task. When your JavaScript application receives the response from the end-point, it might directly insert the new task into its task list like so:"
msgstr "為了幫助你更容易理解什麼時候會需要用到 `toOthers` 方法，我們來假設有個任務清單 App。在這個 App 中，使用者可以輸入任務名稱來新增任務。為了建立任務，這個 App 可能會向 `/task` URL 發起一個請求，該請求會將任務的建立廣播出去，並回傳代表新任務的 JSON。當 JavaScript 端從這個 End-point 收到回覆後，就可以直接將新任務插入到任務清單內。像這樣："

#: docs/8.x/broadcasting.md:block 195 (code)
msgid "axios.post('/task', task)\n"
"    .then((response) => {\n"
"        this.tasks.push(response.data);\n"
"    });\n"
msgstr "axios.post('/task', task)\n"
"    .then((response) => {\n"
"        this.tasks.push(response.data);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 196 (paragraph)
msgid "However, remember that we also broadcast the task's creation. If your JavaScript application is also listening for this event in order to add tasks to the task list, you will have duplicate tasks in your list: one from the end-point and one from the broadcast. You may solve this by using the `toOthers` method to instruct the broadcaster to not broadcast the event to the current user."
msgstr "不過，提醒一下，我們也會將任務的建立廣播出去。如果 JavaScript 端也會監聽這個事件來將任務新增到任務清單上，那麼列表上就會有重複的任務：一個是從 End-point 回傳回來的，另一個則是從監聽事件來的。我們可以通過使用 `toOthers` 方法來告訴廣播程式不要將該事件廣播給目前的使用者。"

#: docs/8.x/broadcasting.md:block 197 (quote)
msgid "{note} Your event must use the `Illuminate\\Broadcasting\\InteractsWithSockets` trait in order to call the `toOthers` method."
msgstr "{note} 若要呼叫 `toOthers` 方法，該事件必須要 use `Illuminate\\Broadcasting\\InteractsWithSockets` Trait。"

#: docs/8.x/broadcasting.md:block 200 (paragraph)
msgid "When you initialize a Laravel Echo instance, a socket ID is assigned to the connection. If you are using a global [Axios](https://github.com/mzabriskie/axios) instance to make HTTP requests from your JavaScript application, the socket ID will automatically be attached to every outgoing request as a `X-Socket-ID` header. Then, when you call the `toOthers` method, Laravel will extract the socket ID from the header and instruct the broadcaster to not broadcast to any connections with that socket ID."
msgstr "初始化 Laravel Echo 實體時，會指派一個 Socket ID 給這個連線。若是使用全域的 [Axios](https://github.com/mzabriskie/axios) 實體來在 JavaScript 端建立 HTTP 連線，則 Socket ID 會以 `X-Socket-ID` 標頭被自動附加到每個外連請求上。接著，當呼叫 `toOthers` 方法時，Laravel 會從標頭內拆出這個 Socket ID，並告知廣播程式不要廣播給有該 Socket ID 的連線。"

#: docs/8.x/broadcasting.md:block 201 (paragraph)
msgid "If you are not using a global Axios instance, you will need to manually configure your JavaScript application to send the `X-Socket-ID` header with all outgoing requests. You may retrieve the socket ID using the `Echo.socketId` method:"
msgstr "若你未使用全域 Axios 實體，則需要手動設定 JavaScript 端來在所有外連請求上傳送 `X-Socket-ID` 標頭。可以通過 `Echo.socketId` 方法來取得 Socket ID："

#: docs/8.x/broadcasting.md:block 202 (code)
msgid "var socketId = Echo.socketId();\n"
msgstr "var socketId = Echo.socketId();\n"

#: docs/8.x/broadcasting.md:block 204 (header)
msgid "Customizing The Connection"
msgstr "自訂連線"

#: docs/8.x/broadcasting.md:block 205 (paragraph)
msgid "If your application interacts with multiple broadcast connections and you want to broadcast an event using a broadcaster other than your default, you may specify which connection to push an event to using the `via` method:"
msgstr "若你的專案與許多不同的廣播連線互動時，如果我們想使用預設廣播程式以外的特定廣播程式來廣播事件，則可以使用 `via` 方法來指定要將事件推送給哪個連線："

#: docs/8.x/broadcasting.md:block 206 (code)
msgid "use App\\Events\\OrderShipmentStatusUpdated;\n\n"
"broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');\n"
msgstr "use App\\Events\\OrderShipmentStatusUpdated;\n\n"
"broadcast(new OrderShipmentStatusUpdated($update))->via('pusher');\n"

#: docs/8.x/broadcasting.md:block 207 (paragraph)
msgid "Alternatively, you may specify the event's broadcast connection by calling the `broadcastVia` method within the event's constructor. However, before doing so, you should ensure that the event class uses the `InteractsWithBroadcasting` trait:"
msgstr "或者，也可以通過在事件的建構函式 (Constructor) 內呼叫 `broadcastVia` 方法來指定事件的廣播連線。不過，這麼做的時候，請先確保這個事件類別有使用 `InteractsWithBroadcasting` Trait："

#: docs/8.x/broadcasting.md:block 208 (code)
msgid "<?php\n\n"
"namespace App\\Events;\n\n"
"use Illuminate\\Broadcasting\\Channel;\n"
"use Illuminate\\Broadcasting\\InteractsWithBroadcasting;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Broadcasting\\PresenceChannel;\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class OrderShipmentStatusUpdated implements ShouldBroadcast\n"
"{\n"
"    use InteractsWithBroadcasting;\n\n"
"    /**\n"
"     * Create a new event instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->broadcastVia('pusher');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Events;\n\n"
"use Illuminate\\Broadcasting\\Channel;\n"
"use Illuminate\\Broadcasting\\InteractsWithBroadcasting;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Broadcasting\\PresenceChannel;\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Contracts\\Broadcasting\\ShouldBroadcast;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class OrderShipmentStatusUpdated implements ShouldBroadcast\n"
"{\n"
"    use InteractsWithBroadcasting;\n\n"
"    /**\n"
"     * Create a new event instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->broadcastVia('pusher');\n"
"    }\n"
"}\n"

#: docs/8.x/broadcasting.md:block 210 (header)
msgid "Receiving Broadcasts"
msgstr "接收廣播"

#: docs/8.x/broadcasting.md:block 212 (header)
msgid "Listening For Events"
msgstr "監聽事件"

#: docs/8.x/broadcasting.md:block 213 (paragraph)
msgid "Once you have [installed and instantiated Laravel Echo](#client-side-installation), you are ready to start listening for events that are broadcast from your Laravel application. First, use the `channel` method to retrieve an instance of a channel, then call the `listen` method to listen for a specified event:"
msgstr "[安裝並設定好 Laravel Echo](#client-side-installation) 後，就可以開始監聽來自 Laravel 端廣播的事件了。首先，使用 `channel` 方法來取得頻道的實體，然後呼叫 `listen` 方法來監聽某個特定的事件："

#: docs/8.x/broadcasting.md:block 214 (code)
msgid "Echo.channel(`orders.${this.order.id}`)\n"
"    .listen('OrderShipmentStatusUpdated', (e) => {\n"
"        console.log(e.order.name);\n"
"    });\n"
msgstr "Echo.channel(`orders.${this.order.id}`)\n"
"    .listen('OrderShipmentStatusUpdated', (e) => {\n"
"        console.log(e.order.name);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 215 (paragraph)
msgid "If you would like to listen for events on a private channel, use the `private` method instead. You may continue to chain calls to the `listen` method to listen for multiple events on a single channel:"
msgstr "若想監聽私有頻道，可使用 `private` 方法來代替。可以繼續在 `listen` 方法後方串上其他的呼叫來在單一頻道上監聽多個事件："

#: docs/8.x/broadcasting.md:block 216 (code)
msgid "Echo.private(`orders.${this.order.id}`)\n"
"    .listen(...)\n"
"    .listen(...)\n"
"    .listen(...);\n"
msgstr "Echo.private(`orders.${this.order.id}`)\n"
"    .listen(...)\n"
"    .listen(...)\n"
"    .listen(...);\n"

#: docs/8.x/broadcasting.md:block 218 (header)
msgid "Stop Listening For Events"
msgstr "停止監聽事件"

#: docs/8.x/broadcasting.md:block 219 (paragraph)
msgid "If you would like to stop listening to a given event without [leaving the channel](#leaving-a-channel), you may use the `stopListening` method:"
msgstr "若想在不[離開頻道](#leaving-a-channel)的情況下停止監聽給定的事件，可以使用 `stopListening` 方法："

#: docs/8.x/broadcasting.md:block 220 (code)
msgid "Echo.private(`orders.${this.order.id}`)\n"
"    .stopListening('OrderShipmentStatusUpdated')\n"
msgstr "Echo.private(`orders.${this.order.id}`)\n"
"    .stopListening('OrderShipmentStatusUpdated')\n"

#: docs/8.x/broadcasting.md:block 222 (header)
msgid "Leaving A Channel"
msgstr "離開頻道"

#: docs/8.x/broadcasting.md:block 223 (paragraph)
msgid "To leave a channel, you may call the `leaveChannel` method on your Echo instance:"
msgstr "若要離開頻道，可以在 Echo 實體上呼叫 `leaveChannel` 方法："

#: docs/8.x/broadcasting.md:block 224 (code)
msgid "Echo.leaveChannel(`orders.${this.order.id}`);\n"
msgstr "Echo.leaveChannel(`orders.${this.order.id}`);\n"

#: docs/8.x/broadcasting.md:block 225 (paragraph)
msgid "If you would like to leave a channel and also its associated private and presence channels, you may call the `leave` method:"
msgstr "若要離開頻道以及其關聯的私有與 Presence 頻道，可以呼叫 `leave` 方法："

#: docs/8.x/broadcasting.md:block 226 (code)
msgid "Echo.leave(`orders.${this.order.id}`);\n"
msgstr "Echo.leave(`orders.${this.order.id}`);\n"

#: docs/8.x/broadcasting.md:block 228 (header)
msgid "Namespaces"
msgstr "命名空間 (Namespace)"

#: docs/8.x/broadcasting.md:block 229 (paragraph)
msgid "You may have noticed in the examples above that we did not specify the full `App\\Events` namespace for the event classes. This is because Echo will automatically assume the events are located in the `App\\Events` namespace. However, you may configure the root namespace when you instantiate Echo by passing a `namespace` configuration option:"
msgstr "你可能已經注意到，我們並沒有為事件類別指定完整的 `App\\Events` 命名空間。這是因為，Echo 會自動假設事件都放在 `App\\Events` 命名空間下。不過，我們可以在初始化 Echo 時傳入 `namespace` 組態設定選項來設定要使用的根命名空間："

#: docs/8.x/broadcasting.md:block 230 (code)
msgid "window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    // ...\n"
"    namespace: 'App.Other.Namespace'\n"
"});\n"
msgstr "window.Echo = new Echo({\n"
"    broadcaster: 'pusher',\n"
"    // ...\n"
"    namespace: 'App.Other.Namespace'\n"
"});\n"

#: docs/8.x/broadcasting.md:block 231 (paragraph)
msgid "Alternatively, you may prefix event classes with a `.` when subscribing to them using Echo. This will allow you to always specify the fully-qualified class name:"
msgstr "除了在初始化時設定以外，也可以在使用 Echo 訂閱事件時在事件類別的名稱前加上一個前置 `.`。這樣一來，就可以隨時使用完整的類別名稱："

#: docs/8.x/broadcasting.md:block 232 (code)
msgid "Echo.channel('orders')\n"
"    .listen('.Namespace\\\\Event\\\\Class', (e) => {\n"
"        //\n"
"    });\n"
msgstr "Echo.channel('orders')\n"
"    .listen('.Namespace\\\\Event\\\\Class', (e) => {\n"
"        //\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 234 (header)
msgid "Presence Channels"
msgstr "Presence 頻道"

#: docs/8.x/broadcasting.md:block 235 (paragraph)
msgid "Presence channels build on the security of private channels while exposing the additional feature of awareness of who is subscribed to the channel. This makes it easy to build powerful, collaborative application features such as notifying users when another user is viewing the same page or listing the inhabitants of a chat room."
msgstr "Presence 頻道擁有私有頻道的安全性，且會提供該頻道的訂閱者等額外資訊。這樣一來便能輕鬆地建立強大的協作 App 功能，如提示目前使用者由其他人正在檢視相同頁面，或是列出聊天室中的使用者狀態。"

#: docs/8.x/broadcasting.md:block 237 (header)
msgid "Authorizing Presence Channels"
msgstr "授權 Presence 頻道"

#: docs/8.x/broadcasting.md:block 238 (paragraph)
msgid "All presence channels are also private channels; therefore, users must be [authorized to access them](#authorizing-channels). However, when defining authorization callbacks for presence channels, you will not return `true` if the user is authorized to join the channel. Instead, you should return an array of data about the user."
msgstr "所有的 Presence 頻道也同時是私有頻道。因此，使用者必須要[經過授權以存取頻道](#authorizing-channels)。不過，在為 Presence 頻道定義授權回呼時，若要授權使用者加入頻道，則不應回傳 `true`，而應回傳包含有關其他使用者資訊的陣列。"

#: docs/8.x/broadcasting.md:block 239 (paragraph)
msgid "The data returned by the authorization callback will be made available to the presence channel event listeners in your JavaScript application. If the user is not authorized to join the presence channel, you should return `false` or `null`:"
msgstr "由授權回呼回傳的資料可以在 JavaScript 端中的 Presence 頻道事件監聽程式中使用。若使用者未被授權加入 Presence 頻道，則應回傳 `false` 或 `null`："

#: docs/8.x/broadcasting.md:block 240 (code)
msgid "Broadcast::channel('chat.{roomId}', function ($user, $roomId) {\n"
"    if ($user->canJoinRoom($roomId)) {\n"
"        return ['id' => $user->id, 'name' => $user->name];\n"
"    }\n"
"});\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 242 (header)
msgid "Joining Presence Channels"
msgstr "加入 Presence 頻道"

#: docs/8.x/broadcasting.md:block 243 (paragraph)
msgid "To join a presence channel, you may use Echo's `join` method. The `join` method will return a `PresenceChannel` implementation which, along with exposing the `listen` method, allows you to subscribe to the `here`, `joining`, and `leaving` events."
msgstr "若要加入 Presence 頻道，可以使用 Echo 的 `join` 方法。`join` 方法會與所暴露的 `listen` 方法一起回傳一個 `PresenceChannel` 的實作，這樣一來你就能訂閱 `here`, `joining` 以及 `leaving` 事件。"

#: docs/8.x/broadcasting.md:block 244 (code)
msgid "Echo.join(`chat.${roomId}`)\n"
"    .here((users) => {\n"
"        //\n"
"    })\n"
"    .joining((user) => {\n"
"        console.log(user.name);\n"
"    })\n"
"    .leaving((user) => {\n"
"        console.log(user.name);\n"
"    })\n"
"    .error((error) => {\n"
"        console.error(error);\n"
"    });\n"
msgstr "Echo.join(`chat.${roomId}`)\n"
"    .here((users) => {\n"
"        //\n"
"    })\n"
"    .joining((user) => {\n"
"        console.log(user.name);\n"
"    })\n"
"    .leaving((user) => {\n"
"        console.log(user.name);\n"
"    })\n"
"    .error((error) => {\n"
"        console.error(error);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 245 (paragraph)
msgid "The `here` callback will be executed immediately once the channel is joined successfully, and will receive an array containing the user information for all of the other users currently subscribed to the channel. The `joining` method will be executed when a new user joins a channel, while the `leaving` method will be executed when a user leaves the channel. The `error` method will be executed when the authentication endpoint returns a HTTP status code other than 200 or if there is a problem parsing the returned JSON."
msgstr "`here` 回呼會在成功加入頻道後被立即執行，並會收到包含所有其他目前訂閱該頻道的使用者資訊。`joining` 方法會在有新使用者加入頻道時被執行，而 `leaving` 則會在有使用者離開時被執行。`error` 方法會在認證 Endpoint 回傳除了 200 以外的 HTTP 狀態時、或是解析回傳的 JSON 時有問題時被執行。"

#: docs/8.x/broadcasting.md:block 247 (header)
msgid "Broadcasting To Presence Channels"
msgstr "廣播至 Presence 頻道"

#: docs/8.x/broadcasting.md:block 248 (paragraph)
msgid "Presence channels may receive events just like public or private channels. Using the example of a chatroom, we may want to broadcast `NewMessage` events to the room's presence channel. To do so, we'll return an instance of `PresenceChannel` from the event's `broadcastOn` method:"
msgstr "Presence 頻道可以像公用或私有頻道一樣接收事件。以聊天室為例，我們可能像廣播 `NewMessage` 事件至聊天室的 Presence 頻道。為此，我們可以在事件的 `broadcastOn` 方法內回傳一個 `PresenceChannel` 的實體："

#: docs/8.x/broadcasting.md:block 249 (code)
msgid "/**\n"
" * Get the channels the event should broadcast on.\n"
" *\n"
" * @return Channel|array\n"
" */\n"
"public function broadcastOn()\n"
"{\n"
"    return new PresenceChannel('room.'.$this->message->room_id);\n"
"}\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 250 (paragraph)
msgid "As with other events, you may use the `broadcast` helper and the `toOthers` method to exclude the current user from receiving the broadcast:"
msgstr "與其他事件一樣，可以使用 `broadcast` 輔助函式與 `toOthers` 方法來排除目前使用者接收該 Broadcast："

#: docs/8.x/broadcasting.md:block 251 (code)
msgid "broadcast(new NewMessage($message));\n\n"
"broadcast(new NewMessage($message))->toOthers();\n"
msgstr ""

#: docs/8.x/broadcasting.md:block 252 (paragraph)
msgid "As typical of other types of events, you may listen for events sent to presence channels using Echo's `listen` method:"
msgstr "與其他一般的事件一樣，也可以使用 Echo 的 `listen` 方法來監聽傳送到 Presence 頻道的事件："

#: docs/8.x/broadcasting.md:block 253 (code)
msgid "Echo.join(`chat.${roomId}`)\n"
"    .here(...)\n"
"    .joining(...)\n"
"    .leaving(...)\n"
"    .listen('NewMessage', (e) => {\n"
"        //\n"
"    });\n"
msgstr "Echo.join(`chat.${roomId}`)\n"
"    .here(...)\n"
"    .joining(...)\n"
"    .leaving(...)\n"
"    .listen('NewMessage', (e) => {\n"
"        //\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 255 (header)
msgid "Model Broadcasting"
msgstr "Model 廣播"

#: docs/8.x/broadcasting.md:block 256 (quote)
msgid "{note} Before reading the following documentation about model broadcasting, we recommend you become familiar with the general concepts of Laravel's model broadcasting services as well as how to manually create and listen to broadcast events."
msgstr ""

#: docs/8.x/broadcasting.md:block 257 (paragraph)
msgid "It is common to broadcast events when your application's [Eloquent models](/docs/{{version}}/eloquent) are created, updated, or deleted. Of course, this can easily be accomplished by manually [defining custom events for Eloquent model state changes](/docs/{{version}}/eloquent#events) and marking those events with the `ShouldBroadcast` interface."
msgstr "在專案的 [Eloquent Model](/docs/{{version}}/eloquent) 被建立、更新、或刪除時，我們常常會廣播事件。當然，我們可以手動[為 Eloquent Model 的狀態更改定義自訂事件](/docs/{{version}}/eloquent#events)並將這些事件標記為 `ShouldBroadcast` 來輕鬆達成："

#: docs/8.x/broadcasting.md:block 258 (paragraph)
msgid "However, if you are not using these events for any other purposes in your application, it can be cumbersome to create event classes for the sole purpose of broadcasting them. To remedy this, Laravel allows you to indicate that an Eloquent model should automatically broadcast its state changes."
msgstr "不過，我們讓事件在專案中負責其他功能，那麼如果只建立一個用來廣播的事件就很麻煩。為了解決這個問題，再 Laravel 中，我們可以讓 Eloquent Model 自動將其狀態更改廣播出去："

#: docs/8.x/broadcasting.md:block 259 (paragraph)
msgid "To get started, your Eloquent model should use the `Illuminate\\Database\\Eloquent\\BroadcastsEvents` trait. In addition, the model should define a `broadcastsOn` method, which will return an array of channels that the model's events should broadcast on:"
msgstr "要開始設定自動廣播，應在 Eloquent Model 上使用 `Illuminate\\Database\\Eloquent\\BroadcastsEvents` Trait。此外，該 Model 應定義一個 `broadcastsOn` 方法，並在其中回傳一組包含頻道名稱的陣列，以供 Model 事件廣播："

#: docs/8.x/broadcasting.md:block 260 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Database\\Eloquent\\BroadcastsEvents;\n"
"use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    use BroadcastsEvents, HasFactory;\n\n"
"    /**\n"
"     * Get the user that the post belongs to.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class);\n"
"    }\n\n"
"    /**\n"
"     * Get the channels that model events should broadcast on.\n"
"     *\n"
"     * @param  string  $event\n"
"     * @return \\Illuminate\\Broadcasting\\Channel|array\n"
"     */\n"
"    public function broadcastOn($event)\n"
"    {\n"
"        return [$this, $this->user];\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Broadcasting\\PrivateChannel;\n"
"use Illuminate\\Database\\Eloquent\\BroadcastsEvents;\n"
"use Illuminate\\Database\\Eloquent\\Factories\\HasFactory;\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    use BroadcastsEvents, HasFactory;\n\n"
"    /**\n"
"     * Get the user that the post belongs to.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class);\n"
"    }\n\n"
"    /**\n"
"     * Get the channels that model events should broadcast on.\n"
"     *\n"
"     * @param  string  $event\n"
"     * @return \\Illuminate\\Broadcasting\\Channel|array\n"
"     */\n"
"    public function broadcastOn($event)\n"
"    {\n"
"        return [$this, $this->user];\n"
"    }\n"
"}\n"

#: docs/8.x/broadcasting.md:block 261 (paragraph)
msgid "Once your model includes this trait and defines its broadcast channels, it will begin automatically broadcasting events when a model instance is created, updated, deleted, trashed, or restored."
msgstr "再 Model 中包含該 Trait 並定義好廣播頻道後，當 Model 實體被建立、更新、刪除、軟刪除、或是取消軟刪除後自動廣播事件。"

#: docs/8.x/broadcasting.md:block 262 (paragraph)
msgid "In addition, you may have noticed that the `broadcastOn` method receives a string `$event` argument. This argument contains the type of event that has occurred on the model and will have a value of `created`, `updated`, `deleted`, `trashed`, or `restored`. By inspecting the value of this variable, you may determine which channels (if any) the model should broadcast to for a particular event:"
msgstr "此外，讀者可能已經發現，`broadcastOn` 方法接收了一個字串的 `$event` 引述。這個引述包含了 Model 上所發生的事件，其值為 `created`, `updated`, `deleted`, `trashed`, 或 `restored`。只要檢查這個變數的值，就可以用來判斷對於特定事件要廣播道哪個頻道（若有的話）："

#: docs/8.x/broadcasting.md:block 263 (code)
msgid "/**\n"
" * Get the channels that model events should broadcast on.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Broadcasting\\Channel|array\n"
" */\n"
"public function broadcastOn($event)\n"
"{\n"
"    return match ($event) {\n"
"        'deleted' => [],\n"
"        default => [$this, $this->user],\n"
"    };\n"
"}\n"
msgstr "/**\n"
" * Get the channels that model events should broadcast on.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Broadcasting\\Channel|array\n"
" */\n"
"public function broadcastOn($event)\n"
"{\n"
"    return match ($event) {\n"
"        'deleted' => [],\n"
"        default => [$this, $this->user],\n"
"    };\n"
"}\n"

#: docs/8.x/broadcasting.md:block 265 (header)
msgid "Customizing Model Broadcasting Event Creation"
msgstr "自訂 Model 廣播的事件建立"

#: docs/8.x/broadcasting.md:block 266 (paragraph)
msgid "Occasionally, you may wish to customize how Laravel creates the underlying model broadcasting event. You may accomplish this by defining a `newBroadcastableEvent` method on your Eloquent model. This method should return an `Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred` instance:"
msgstr "有時候，我們可能會想自訂 Laravel 要如何建立 Model 廣播時使用的事件。為此，我們可以通過在 Eloquent Model 上定義一個 `newBroadcastableEvent` 來達成。該方法應回傳 `Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred` 實體："

#: docs/8.x/broadcasting.md:block 267 (code)
msgid "use Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n\n"
"/**\n"
" * Create a new broadcastable model event for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n"
" */\n"
"protected function newBroadcastableEvent($event)\n"
"{\n"
"    return (new BroadcastableModelEventOccurred(\n"
"        $this, $event\n"
"    ))->dontBroadcastToCurrentUser();\n"
"}\n"
msgstr "use Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n\n"
"/**\n"
" * Create a new broadcastable model event for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n"
" */\n"
"protected function newBroadcastableEvent($event)\n"
"{\n"
"    return (new BroadcastableModelEventOccurred(\n"
"        $this, $event\n"
"    ))->dontBroadcastToCurrentUser();\n"
"}\n"

#: docs/8.x/broadcasting.md:block 269 (header)
msgid "Model Broadcasting Conventions"
msgstr "Model 廣播慣例"

#: docs/8.x/broadcasting.md:block 271 (header)
msgid "Channel Conventions"
msgstr "頻道慣例"

#: docs/8.x/broadcasting.md:block 272 (paragraph)
msgid "As you may have noticed, the `broadcastOn` method in the model example above did not return `Channel` instances. Instead, Eloquent models were returned directly. If an Eloquent model instance is returned by your model's `broadcastOn` method (or is contained in an array returned by the method), Laravel will automatically instantiate a private channel instance for the model using the model's class name and primary key identifier as the channel name."
msgstr "讀者可能已經發現，在上方的 Model 範例中，`broadcastOn` 方法並沒有回傳 `Channel` 實體，而是直接回傳 Eloquent Model。若 Model 的 `broadcastOn` 方法回傳的是 Model 實體 (或是包含 Model 實體的陣列)，則 Laravel 會使用該 Model 的類別名稱與主索引鍵識別元作為頻道名稱，自動為該 Model 初始化一個私人頻道。"

#: docs/8.x/broadcasting.md:block 273 (paragraph)
msgid "So, an `App\\Models\\User` model with an `id` of `1` would be converted into a `Illuminate\\Broadcasting\\PrivateChannel` instance with a name of `App.Models.User.1`. Of course, in addition to returning Eloquent model instances from your model's `broadcastOn` method, you may return complete `Channel` instances in order to have full control over the model's channel names:"
msgstr "因此，`id` 為 `1` 的 `App\\Models\\User` Model 會被轉換為一個名稱是 `App.Models.User.1` 的 `Illuminate\\Broadcasting\\PrivateChannel` 實體。當然，除了從 Model 的 `broadcastOn` 方法內回傳 Eloquent Model 實體外，也可以回傳一個完整的 `Channel` 實體來取得對 Model 的頻道名稱的完整控制權："

#: docs/8.x/broadcasting.md:block 274 (code)
msgid "use Illuminate\\Broadcasting\\PrivateChannel;\n\n"
"/**\n"
" * Get the channels that model events should broadcast on.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Broadcasting\\Channel|array\n"
" */\n"
"public function broadcastOn($event)\n"
"{\n"
"    return [new PrivateChannel('user.'.$this->id)];\n"
"}\n"
msgstr "use Illuminate\\Broadcasting\\PrivateChannel;\n\n"
"/**\n"
" * Get the channels that model events should broadcast on.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Broadcasting\\Channel|array\n"
" */\n"
"public function broadcastOn($event)\n"
"{\n"
"    return [new PrivateChannel('user.'.$this->id)];\n"
"}\n"

#: docs/8.x/broadcasting.md:block 275 (paragraph)
msgid "If you plan to explicitly return a channel instance from your model's `broadcastOn` method, you may pass an Eloquent model instance to the channel's constructor. When doing so, Laravel will use the model channel conventions discussed above to convert the Eloquent model into a channel name string:"
msgstr "若有打算要從 Model 的 `broadcastOn` 方法內明顯回傳頻道實體，則可以將 Eloquent Model 實體傳入該頻道的建構函式。這樣一來，Laravel 就可以通過剛才提到的 Model 頻道慣例來將 Eloquent Model 轉換為頻道名稱字串："

#: docs/8.x/broadcasting.md:block 276 (code)
msgid "return [new Channel($this->user)];\n"
msgstr "return [new Channel($this->user)];\n"

#: docs/8.x/broadcasting.md:block 277 (paragraph)
msgid "If you need to determine the channel name of a model, you may call the `broadcastChannel` method on any model instance. For example, this method returns the string `App.Models.User.1` for a `App\\Models\\User` model with an `id` of `1`:"
msgstr "若想判斷某個 Model 的頻道名稱，可以在任何 Model 實體上呼叫 `broadcastChannel` 方法。舉例來說，對於一個 `id` 為 `1` 的 `App\\Models\\User` Model，該方法會回傳一個字串 `App.Models.User.1`："

#: docs/8.x/broadcasting.md:block 278 (code)
msgid "$user->broadcastChannel()\n"
msgstr "$user->broadcastChannel()\n"

#: docs/8.x/broadcasting.md:block 280 (header)
msgid "Event Conventions"
msgstr "事件慣例"

#: docs/8.x/broadcasting.md:block 281 (paragraph)
msgid "Since model broadcast events are not associated with an \"actual\" event within your application's `App\\Events` directory, they are assigned a name and a payload based on conventions. Laravel's convention is to broadcast the event using the class name of the model (not including the namespace) and the name of the model event that triggered the broadcast."
msgstr "由於 Model 廣播事件並不與專案的 `App\\Events` 目錄內的「真實」事件有關，這些事件只會依據慣例來指派名稱與 Payload (裝載)。Laravel 的慣例就是使用 Model 的類別名稱 (不含 Namespace) 與觸發廣播的 Model 事件來廣播。"

#: docs/8.x/broadcasting.md:block 282 (paragraph)
msgid "So, for example, an update to the `App\\Models\\Post` model would broadcast an event to your client-side application as `PostUpdated` with the following payload:"
msgstr "因此，對 `App\\Models\\Post` Model 進行更新，會將 `PostUpdated` 事件與下列 Payload 廣播到用戶端："

#: docs/8.x/broadcasting.md:block 283 (code)
msgid "{\n"
"    \"model\": {\n"
"        \"id\": 1,\n"
"        \"title\": \"My first post\"\n"
"        ...\n"
"    },\n"
"    ...\n"
"    \"socket\": \"someSocketId\",\n"
"}\n"
msgstr "{\n"
"    \"model\": {\n"
"        \"id\": 1,\n"
"        \"title\": \"My first post\"\n"
"        ...\n"
"    },\n"
"    ...\n"
"    \"socket\": \"someSocketId\",\n"
"}\n"

#: docs/8.x/broadcasting.md:block 284 (paragraph)
msgid "The deletion of the `App\\Models\\User` model would broadcast an event named `UserDeleted`."
msgstr "刪除 `App\\Models\\Post` Model 時廣播的事件名稱會是 `UserDeleted`。"

#: docs/8.x/broadcasting.md:block 285 (paragraph)
msgid "If you would like, you may define a custom broadcast name and payload by adding a `broadcastAs` and `broadcastWith` method to your model. These methods receive the name of the model event / operation that is occurring, allowing you to customize the event's name and payload for each model operation. If `null` is returned from the `broadcastAs` method, Laravel will use the model broadcasting event name conventions discussed above when broadcasting the event:"
msgstr "若有需要，也可以通過在 Model 中新增一個 `broadcastAs` 與 `broadcastWith` 方法來自訂廣播的名稱與 Payload。這些方法會收到目前發生的 Model 事件或動作，好讓我們能為不同的 Model 動作自訂事件名稱與 Payload。若在 `broadcastAs` 方法中回傳 `null`，則 Laravel 會使用上方討論過的 Model 廣播事件名稱的慣例來廣播這個事件："

#: docs/8.x/broadcasting.md:block 286 (code)
msgid "/**\n"
" * The model event's broadcast name.\n"
" *\n"
" * @param  string  $event\n"
" * @return string|null\n"
" */\n"
"public function broadcastAs($event)\n"
"{\n"
"    return match ($event) {\n"
"        'created' => 'post.created',\n"
"        default => null,\n"
"    };\n"
"}\n\n"
"/**\n"
" * Get the data to broadcast for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return array\n"
" */\n"
"public function broadcastWith($event)\n"
"{\n"
"    return match ($event) {\n"
"        'created' => ['title' => $this->title],\n"
"        default => ['model' => $this],\n"
"    };\n"
"}\n"
msgstr "/**\n"
" * The model event's broadcast name.\n"
" *\n"
" * @param  string  $event\n"
" * @return string|null\n"
" */\n"
"public function broadcastAs($event)\n"
"{\n"
"    return match ($event) {\n"
"        'created' => 'post.created',\n"
"        default => null,\n"
"    };\n"
"}\n\n"
"/**\n"
" * Get the data to broadcast for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return array\n"
" */\n"
"public function broadcastWith($event)\n"
"{\n"
"    return match ($event) {\n"
"        'created' => ['title' => $this->title],\n"
"        default => ['model' => $this],\n"
"    };\n"
"}\n"

#: docs/8.x/broadcasting.md:block 288 (header)
msgid "Listening For Model Broadcasts"
msgstr "監聽 Model 廣播"

#: docs/8.x/broadcasting.md:block 289 (paragraph)
msgid "Once you have added the `BroadcastsEvents` trait to your model and defined your model's `broadcastOn` method, you are ready to start listening for broadcasted model events within your client-side application. Before getting started, you may wish to consult the complete documentation on [listening for events](#listening-for-events)."
msgstr "在 Model 中新增好 `BroadcastsEvents` Trait 並定義好 Model 的 `broadcastOn` 方法後，就可以開始在用戶端中監聽廣播出來的 Model 事件了。在開始前，建議你先閱讀有關[監聽事件](#listening-for-events)的完整說明文件。"

#: docs/8.x/broadcasting.md:block 290 (paragraph)
msgid "First, use the `private` method to retrieve an instance of a channel, then call the `listen` method to listen for a specified event. Typically, the channel name given to the `private` method should correspond to Laravel's [model broadcasting conventions](#model-broadcasting-conventions)."
msgstr "首先，使用 `private` 方法來取得 Channel 實體，然後呼叫 `listen` 方法來監聽特定的事件。一般來說，傳給 `private` 方法的頻道名稱應與 Laravel 的 [Model 廣播慣例](#model-broadcasting-conventions)相對應。"

#: docs/8.x/broadcasting.md:block 291 (paragraph)
msgid "Once you have obtained a channel instance, you may use the `listen` method to listen for a particular event. Since model broadcast events are not associated with an \"actual\" event within your application's `App\\Events` directory, the [event name](#model-broadcasting-event-conventions) must be prefixed with a `.` to indicate it does not belong to a particular namespace. Each model broadcast event has a `model` property which contains all of the broadcastable properties of the model:"
msgstr "取得 Channel 實體後，就可以使用 `listen` 方法來監聽特定的事件。由於 Model 廣播事件並不與專案中 `App\\Events` 目錄下的「真實事件」互相關聯，因此，[事件名稱](#model-broadcasting-event-conventions)前應加上一個 `.` 字元，以標識其不屬於特定的命名空間。每個 Model 廣播事件都有一個 `model` 屬性，其中包含了 Model 中所有可廣播的屬性："

#: docs/8.x/broadcasting.md:block 292 (code)
msgid "Echo.private(`App.Models.User.${this.user.id}`)\n"
"    .listen('.PostUpdated', (e) => {\n"
"        console.log(e.model);\n"
"    });\n"
msgstr "Echo.private(`App.Models.User.${this.user.id}`)\n"
"    .listen('.PostUpdated', (e) => {\n"
"        console.log(e.model);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 294 (header)
msgid "Client Events"
msgstr "用戶端事件"

#: docs/8.x/broadcasting.md:block 295 (quote)
msgid "{tip} When using [Pusher Channels](https://pusher.com/channels), you must enable the \"Client Events\" option in the \"App Settings\" section of your [application dashboard](https://dashboard.pusher.com/) in order to send client events."
msgstr ""

#: docs/8.x/broadcasting.md:block 296 (paragraph)
msgid "Sometimes you may wish to broadcast an event to other connected clients without hitting your Laravel application at all. This can be particularly useful for things like \"typing\" notifications, where you want to alert users of your application that another user is typing a message on a given screen."
msgstr "有時候我們可能會想將事件直接廣播給其他連線的用戶端，而不經由 Laravel 端。特別像是如顯示「正在輸入」等通知時，我們只是想告訴使用者網站內的其他使用者正在特定畫面上輸入。"

#: docs/8.x/broadcasting.md:block 297 (paragraph)
msgid "To broadcast client events, you may use Echo's `whisper` method:"
msgstr "若要廣播用戶端事件，可以使用 Echo 的 `whisper` 方法："

#: docs/8.x/broadcasting.md:block 298 (code)
msgid "Echo.private(`chat.${roomId}`)\n"
"    .whisper('typing', {\n"
"        name: this.user.name\n"
"    });\n"
msgstr "Echo.private(`chat.${roomId}`)\n"
"    .whisper('typing', {\n"
"        name: this.user.name\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 299 (paragraph)
msgid "To listen for client events, you may use the `listenForWhisper` method:"
msgstr "若要監聽用戶端事件，可以使用 `listenForWhisper` 方法："

#: docs/8.x/broadcasting.md:block 300 (code)
msgid "Echo.private(`chat.${roomId}`)\n"
"    .listenForWhisper('typing', (e) => {\n"
"        console.log(e.name);\n"
"    });\n"
msgstr "Echo.private(`chat.${roomId}`)\n"
"    .listenForWhisper('typing', (e) => {\n"
"        console.log(e.name);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 302 (header)
msgid "Notifications"
msgstr "通知"

#: docs/8.x/broadcasting.md:block 303 (paragraph)
msgid "By pairing event broadcasting with [notifications](/docs/{{version}}/notifications), your JavaScript application may receive new notifications as they occur without needing to refresh the page. Before getting started, be sure to read over the documentation on using [the broadcast notification channel](/docs/{{version}}/notifications#broadcast-notifications)."
msgstr "只要將事件廣播與 [通知](/docs/{{version}}/notifications) 一起使用，JavaScript 端就可以在不重新整理的情況下接收新通知。在開始前，請先閱讀有關[廣播通知頻道](/docs/{{version}}/notifications#broadcast-notifications)的說明文件。"

#: docs/8.x/broadcasting.md:block 304 (paragraph)
msgid "Once you have configured a notification to use the broadcast channel, you may listen for the broadcast events using Echo's `notification` method. Remember, the channel name should match the class name of the entity receiving the notifications:"
msgstr "設定讓通知使用廣播頻道後，就可以使用 Echo 的 `notification` 方法來接收廣播。請記住，頻道的名稱應與接收通知的使用者類別名稱相符："

#: docs/8.x/broadcasting.md:block 305 (code)
msgid "Echo.private(`App.Models.User.${userId}`)\n"
"    .notification((notification) => {\n"
"        console.log(notification.type);\n"
"    });\n"
msgstr "Echo.private(`App.Models.User.${userId}`)\n"
"    .notification((notification) => {\n"
"        console.log(notification.type);\n"
"    });\n"

#: docs/8.x/broadcasting.md:block 306 (paragraph)
msgid "In this example, all notifications sent to `App\\Models\\User` instances via the `broadcast` channel would be received by the callback. A channel authorization callback for the `App.Models.User.{id}` channel is included in the default `BroadcastServiceProvider` that ships with the Laravel framework."
msgstr "在此範例中，所有通過 `broadcast` 頻道傳送給 `App\\Models\\User` 實體的通知都會被該回呼收到。用於 `App.Models.User.{id}` 的頻道授權回呼包含在 Laravel 框架附帶的 `BroadcastServiceProvider` 內。"

#: docs/9.x/broadcasting.md:block 267 (code)
msgid "use Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred;\n\n"
"/**\n"
" * Create a new broadcastable model event for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n"
" */\n"
"protected function newBroadcastableEvent($event)\n"
"{\n"
"    return (new BroadcastableModelEventOccurred(\n"
"        $this, $event\n"
"    ))->dontBroadcastToCurrentUser();\n"
"}\n"
msgstr "use Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred;\n\n"
"/**\n"
" * Create a new broadcastable model event for the model.\n"
" *\n"
" * @param  string  $event\n"
" * @return \\Illuminate\\Database\\Eloquent\\BroadcastableModelEventOccurred\n"
" */\n"
"protected function newBroadcastableEvent($event)\n"
"{\n"
"    return (new BroadcastableModelEventOccurred(\n"
"        $this, $event\n"
"    ))->dontBroadcastToCurrentUser();\n"
"}\n"

