msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"Language: zh_TW\n"
"Language-Team: Chinese Traditional\n"
"PO-Revision-Date: 2024-06-30 08:27\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Project-Id-Version: laravel-docs\n"
"X-Crowdin-File: /main/templates/processes.pot\n"
"X-Crowdin-File-ID: 185\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"

#: ./docs/10.x/processes.md:1
#: ./docs/11.x/processes.md:1
#: ./docs/master/processes.md:1
msgctxt "H1"
msgid "Processes"
msgstr "Process"

#: ./docs/10.x/processes.md:3
#: ./docs/11.x/processes.md:3
#: ./docs/master/processes.md:3
msgctxt "P"
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: ./docs/10.x/processes.md:4
#: ./docs/11.x/processes.md:4
#: ./docs/master/processes.md:4
msgctxt "P"
msgid "[Invoking Processes](#invoking-processes)"
msgstr "[呼叫 Process](#invoking-processes)"

#: ./docs/10.x/processes.md:5
#: ./docs/11.x/processes.md:5
#: ./docs/master/processes.md:5
msgctxt "P"
msgid "[Process Options](#process-options)"
msgstr "[Process 選項](#process-options)"

#: ./docs/10.x/processes.md:6
#: ./docs/11.x/processes.md:6
#: ./docs/master/processes.md:6
msgctxt "P"
msgid "[Process Output](#process-output)"
msgstr "[Process 的輸出](#process-output)"

#: ./docs/10.x/processes.md:7
#: ./docs/11.x/processes.md:7
#: ./docs/master/processes.md:7
msgctxt "P"
msgid "[Pipelines](#process-pipelines)"
msgstr "[管道 (Pipeline)](#process-pipelines)"

#: ./docs/10.x/processes.md:8
#: ./docs/11.x/processes.md:8
#: ./docs/master/processes.md:8
msgctxt "P"
msgid "[Asynchronous Processes](#asynchronous-processes)"
msgstr "[非同步的 Process](#asynchronous-processes)"

#: ./docs/10.x/processes.md:9
#: ./docs/11.x/processes.md:9
#: ./docs/master/processes.md:9
msgctxt "P"
msgid "[Process IDs and Signals](#process-ids-and-signals)"
msgstr ""

#: ./docs/10.x/processes.md:10
#: ./docs/11.x/processes.md:10
#: ./docs/master/processes.md:10
msgctxt "P"
msgid "[Asynchronous Process Output](#asynchronous-process-output)"
msgstr "[非同步 Process 的輸出](#asynchronous-process-output)"

#: ./docs/10.x/processes.md:11
#: ./docs/11.x/processes.md:11
#: ./docs/master/processes.md:11
msgctxt "P"
msgid "[Concurrent Processes](#concurrent-processes)"
msgstr "[併行地 Process](#concurrent-processes)"

#: ./docs/10.x/processes.md:12
#: ./docs/11.x/processes.md:12
#: ./docs/master/processes.md:12
msgctxt "P"
msgid "[Naming Pool Processes](#naming-pool-processes)"
msgstr "[命名的 Pool Process](#naming-pool-processes)"

#: ./docs/10.x/processes.md:13
#: ./docs/11.x/processes.md:13
#: ./docs/master/processes.md:13
msgctxt "P"
msgid "[Pool Process IDs and Signals](#pool-process-ids-and-signals)"
msgstr ""

#: ./docs/10.x/processes.md:14
#: ./docs/11.x/processes.md:14
#: ./docs/master/processes.md:14
msgctxt "P"
msgid "[Testing](#testing)"
msgstr "[測試](#testing)"

#: ./docs/10.x/processes.md:15
#: ./docs/11.x/processes.md:15
#: ./docs/master/processes.md:15
msgctxt "P"
msgid "[Faking Processes](#faking-processes)"
msgstr "[模擬 Process](#faking-processes)"

#: ./docs/10.x/processes.md:16
#: ./docs/11.x/processes.md:16
#: ./docs/master/processes.md:16
msgctxt "P"
msgid "[Faking Specific Processes](#faking-specific-processes)"
msgstr "[模擬特定 Process](#faking-specific-processes)"

#: ./docs/10.x/processes.md:17
#: ./docs/11.x/processes.md:17
#: ./docs/master/processes.md:17
msgctxt "P"
msgid "[Faking Process Sequences](#faking-process-sequences)"
msgstr "[模擬 Process 的順序](#faking-process-sequences)"

#: ./docs/10.x/processes.md:18
#: ./docs/11.x/processes.md:18
#: ./docs/master/processes.md:18
msgctxt "P"
msgid "[Faking Asynchronous Process Lifecycles](#faking-asynchronous-process-lifecycles)"
msgstr "[模擬非同步 Process 的生命週期](#faking-asynchronous-process-lifecycles)"

#: ./docs/10.x/processes.md:19
#: ./docs/11.x/processes.md:19
#: ./docs/master/processes.md:19
msgctxt "P"
msgid "[Available Assertions](#available-assertions)"
msgstr "[可用的 Assertion](#available-assertions)"

#: ./docs/10.x/processes.md:20
#: ./docs/11.x/processes.md:20
#: ./docs/master/processes.md:20
msgctxt "P"
msgid "[Preventing Stray Processes](#preventing-stray-processes)"
msgstr "[避免漏掉的 Process](#preventing-stray-processes)"

#: ./docs/10.x/processes.md:22
#: ./docs/11.x/processes.md:22
#: ./docs/master/processes.md:22
#~ msgctxt "P"
#~ msgid "<a name=\"introduction\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:23
#: ./docs/11.x/processes.md:23
#: ./docs/master/processes.md:23
msgctxt "H2"
msgid "Introduction"
msgstr "簡介"

#: ./docs/10.x/processes.md:25
msgctxt "P"
msgid "Laravel provides an expressive, minimal API around the [Symfony Process component](https://symfony.com/doc/current/components/process.html), allowing you to conveniently invoke external processes from your Laravel application. Laravel's process features are focused on the most common use cases and a wonderful developer experience."
msgstr "Laravel 為 [Symfony 的 Process Component](https://symfony.com/doc/current/components/process.html) 提供了一個語意化、極簡的 API，能讓我們方便地在 Laravel 專案中呼叫外部 ^[Process](處理程序)。Laravel 的 Process 功能著重於最常見的使用情境，並提供優秀的開發人員經驗 (Developer Experience)。"

#: ./docs/11.x/processes.md:25
#: ./docs/master/processes.md:25
msgctxt "P"
msgid "Laravel provides an expressive, minimal API around the [Symfony Process component](https://symfony.com/doc/7.0/components/process.html), allowing you to conveniently invoke external processes from your Laravel application. Laravel's process features are focused on the most common use cases and a wonderful developer experience."
msgstr ""

#: ./docs/10.x/processes.md:27
#: ./docs/11.x/processes.md:27
#: ./docs/master/processes.md:27
#~ msgctxt "P"
#~ msgid "<a name=\"invoking-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:28
#: ./docs/11.x/processes.md:28
#: ./docs/master/processes.md:28
msgctxt "H2"
msgid "Invoking Processes"
msgstr "呼叫 Process"

#: ./docs/10.x/processes.md:30
#: ./docs/11.x/processes.md:30
#: ./docs/master/processes.md:30
msgctxt "P"
msgid "To invoke a process, you may use the `run` and `start` methods offered by the `Process` facade. The `run` method will invoke a process and wait for the process to finish executing, while the `start` method is used for asynchronous process execution. We'll examine both approaches within this documentation. First, let's examine how to invoke a basic, synchronous process and inspect its result:"
msgstr "若要呼叫 Process，可以使用 `Process` Facade 提供的 `run` 與 `start` 方法。`run` 方法會呼叫 Process，並等待該 Process 執行完畢。而 `start` 方法會以非同步方式執行 Process。我們將在此文件中詳細討論這兩種方法。首先，我們先來看看如何執行一個基本的同步 Process 並取得其執行結果："

#: ./docs/10.x/processes.md:32
#: ./docs/11.x/processes.md:32
#: ./docs/master/processes.md:32
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"$result = Process::run('ls -la');\n"
"\n"
"return $result->output();"
msgstr ""

#: ./docs/10.x/processes.md:40
#: ./docs/11.x/processes.md:40
#: ./docs/master/processes.md:40
msgctxt "P"
msgid "Of course, the `Illuminate\\Contracts\\Process\\ProcessResult` instance returned by the `run` method offers a variety of helpful methods that may be used to inspect the process result:"
msgstr "當然，`run` 方法回傳的 `Illuminate\\Contracts\\Process\\ProcessResult` 實體還包含了多種可用於檢查 Process 執行結果的實用方法："

#: ./docs/10.x/processes.md:42
#: ./docs/11.x/processes.md:42
#: ./docs/master/processes.md:42
msgctxt "CODE: php"
msgid ""
"$result = Process::run('ls -la');\n"
"\n"
"$result->successful();\n"
"$result->failed();\n"
"$result->exitCode();\n"
"$result->output();\n"
"$result->errorOutput();"
msgstr ""

#: ./docs/10.x/processes.md:52
#: ./docs/11.x/processes.md:52
#: ./docs/master/processes.md:52
#~ msgctxt "P"
#~ msgid "<a name=\"throwing-exceptions\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:53
#: ./docs/11.x/processes.md:53
#: ./docs/master/processes.md:53
msgctxt "H4"
msgid "Throwing Exceptions"
msgstr "擲回 Exception"

#: ./docs/10.x/processes.md:55
#: ./docs/11.x/processes.md:55
#: ./docs/master/processes.md:55
msgctxt "P"
msgid "If you have a process result and would like to throw an instance of `Illuminate\\Process\\Exceptions\\ProcessFailedException` if the exit code is greater than zero (thus indicating failure), you may use the `throw` and `throwIf` methods. If the process did not fail, the process result instance will be returned:"
msgstr "若在取得 Process 執行結果後，希望能讓終止代碼 (Exit Code) 大於 0 的狀況 (表示執行失敗) 擲回 `Illuminate\\Process\\Exceptions\\ProcessFailedException`，可以使用 `throw` 與 `throwIf` 方法。若 Process 並未執行失敗，則會回傳 Process 執行結果的實體："

#: ./docs/10.x/processes.md:57
#: ./docs/11.x/processes.md:57
#: ./docs/master/processes.md:57
msgctxt "CODE: php"
msgid ""
"$result = Process::run('ls -la')->throw();\n"
"\n"
"$result = Process::run('ls -la')->throwIf($condition);"
msgstr ""

#: ./docs/10.x/processes.md:63
#: ./docs/11.x/processes.md:63
#: ./docs/master/processes.md:63
#~ msgctxt "P"
#~ msgid "<a name=\"process-options\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:64
#: ./docs/11.x/processes.md:64
#: ./docs/master/processes.md:64
msgctxt "H3"
msgid "Process Options"
msgstr "Process 選項"

#: ./docs/10.x/processes.md:66
#: ./docs/11.x/processes.md:66
#: ./docs/master/processes.md:66
msgctxt "P"
msgid "Of course, you may need to customize the behavior of a process before invoking it. Thankfully, Laravel allows you to tweak a variety of process features, such as the working directory, timeout, and environment variables."
msgstr "當然，你可能會需要在呼叫 Process 前自訂該 Process 的行為。在 Laravel 中，可以調整許多 Process 的功能，例如工作目錄 (Working Directory)、逾時與環境變數等。"

#: ./docs/10.x/processes.md:68
#: ./docs/11.x/processes.md:68
#: ./docs/master/processes.md:68
#~ msgctxt "P"
#~ msgid "<a name=\"working-directory-path\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:69
#: ./docs/11.x/processes.md:69
#: ./docs/master/processes.md:69
msgctxt "H4"
msgid "Working Directory Path"
msgstr "工作目錄路徑"

#: ./docs/10.x/processes.md:71
#: ./docs/11.x/processes.md:71
#: ./docs/master/processes.md:71
msgctxt "P"
msgid "You may use the `path` method to specify the working directory of the process. If this method is not invoked, the process will inherit the working directory of the currently executing PHP script:"
msgstr "可以使用 `path` 方法來指定 Process 的工作目錄。若未呼叫此方法，則該 Process 會繼承目前執行 PHP Script 的工作目錄："

#: ./docs/10.x/processes.md:73
#: ./docs/11.x/processes.md:73
#: ./docs/master/processes.md:73
msgctxt "CODE: php"
msgid "$result = Process::path(__DIR__)->run('ls -la');"
msgstr ""

#: ./docs/10.x/processes.md:77
#: ./docs/11.x/processes.md:77
#: ./docs/master/processes.md:77
#~ msgctxt "P"
#~ msgid "<a name=\"input\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:78
#: ./docs/11.x/processes.md:78
#: ./docs/master/processes.md:78
msgctxt "H4"
msgid "Input"
msgstr "輸入"

#: ./docs/10.x/processes.md:80
#: ./docs/11.x/processes.md:80
#: ./docs/master/processes.md:80
msgctxt "P"
msgid "You may provide input via the \"standard input\" of the process using the `input` method:"
msgstr "可以通過 `input` 方法來以「標準輸入 (Standard Input)」提供輸入給 Process："

#: ./docs/10.x/processes.md:82
#: ./docs/11.x/processes.md:82
#: ./docs/master/processes.md:82
msgctxt "CODE: php"
msgid "$result = Process::input('Hello World')->run('cat');"
msgstr ""

#: ./docs/10.x/processes.md:86
#: ./docs/11.x/processes.md:86
#: ./docs/master/processes.md:86
#~ msgctxt "P"
#~ msgid "<a name=\"timeouts\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:87
#: ./docs/11.x/processes.md:87
#: ./docs/master/processes.md:87
msgctxt "H4"
msgid "Timeouts"
msgstr "逾時"

#: ./docs/10.x/processes.md:89
#: ./docs/11.x/processes.md:89
#: ./docs/master/processes.md:89
msgctxt "P"
msgid "By default, processes will throw an instance of `Illuminate\\Process\\Exceptions\\ProcessTimedOutException` after executing for more than 60 seconds. However, you can customize this behavior via the `timeout` method:"
msgstr "預設情況下，Process 會在執行超過 60 秒後擲回 `Illuminate\\Process\\Exceptions\\ProcessTimedOutException` 實體。不過，可以使用 `timeout` 方法來自定此行為："

#: ./docs/10.x/processes.md:91
#: ./docs/11.x/processes.md:91
#: ./docs/master/processes.md:91
msgctxt "CODE: php"
msgid "$result = Process::timeout(120)->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:95
#: ./docs/11.x/processes.md:95
#: ./docs/master/processes.md:95
msgctxt "P"
msgid "Or, if you would like to disable the process timeout entirely, you may invoke the `forever` method:"
msgstr "或者，若要完全禁用 Process 的逾時，可以呼叫 `forever` 方法："

#: ./docs/10.x/processes.md:97
#: ./docs/11.x/processes.md:97
#: ./docs/master/processes.md:97
msgctxt "CODE: php"
msgid "$result = Process::forever()->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:101
#: ./docs/11.x/processes.md:101
#: ./docs/master/processes.md:101
msgctxt "P"
msgid "The `idleTimeout` method may be used to specify the maximum number of seconds the process may run without returning any output:"
msgstr "`idleTimeout` 方法可用來指定 Process 在不回傳任何輸出下可執行的最大秒數："

#: ./docs/10.x/processes.md:103
#: ./docs/11.x/processes.md:103
#: ./docs/master/processes.md:103
msgctxt "CODE: php"
msgid "$result = Process::timeout(60)->idleTimeout(30)->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:107
#: ./docs/11.x/processes.md:107
#: ./docs/master/processes.md:107
#~ msgctxt "P"
#~ msgid "<a name=\"environment-variables\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:108
#: ./docs/11.x/processes.md:108
#: ./docs/master/processes.md:108
msgctxt "H4"
msgid "Environment Variables"
msgstr "環境變數"

#: ./docs/10.x/processes.md:110
#: ./docs/11.x/processes.md:110
#: ./docs/master/processes.md:110
msgctxt "P"
msgid "Environment variables may be provided to the process via the `env` method. The invoked process will also inherit all of the environment variables defined by your system:"
msgstr "可以使用 `env` 方法來提供環境變數給 Process。被呼叫的 Process 也會繼承在系統中所定義的所有環境變數："

#: ./docs/10.x/processes.md:112
#: ./docs/11.x/processes.md:112
#: ./docs/master/processes.md:112
msgctxt "CODE: php"
msgid ""
"$result = Process::forever()\n"
"            ->env(['IMPORT_PATH' => __DIR__])\n"
"            ->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:118
#: ./docs/11.x/processes.md:118
#: ./docs/master/processes.md:118
msgctxt "P"
msgid "If you wish to remove an inherited environment variable from the invoked process, you may provide that environment variable with a value of `false`:"
msgstr "若想從呼叫的 Process 中移除繼承的環境變數，可以提供一個值為 `false` 的環境變數："

#: ./docs/10.x/processes.md:120
#: ./docs/11.x/processes.md:120
#: ./docs/master/processes.md:120
msgctxt "CODE: php"
msgid ""
"$result = Process::forever()\n"
"            ->env(['LOAD_PATH' => false])\n"
"            ->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:126
#: ./docs/11.x/processes.md:126
#: ./docs/master/processes.md:126
#~ msgctxt "P"
#~ msgid "<a name=\"tty-mode\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:127
#: ./docs/11.x/processes.md:127
#: ./docs/master/processes.md:127
msgctxt "H4"
msgid "TTY Mode"
msgstr "TTY 模式"

#: ./docs/10.x/processes.md:129
#: ./docs/11.x/processes.md:129
#: ./docs/master/processes.md:129
msgctxt "P"
msgid "The `tty` method may be used to enable TTY mode for your process. TTY mode connects the input and output of the process to the input and output of your program, allowing your process to open an editor like Vim or Nano as a process:"
msgstr "`tty` 方法可用來在 Process 上啟用 TTY 模式。TTY 模式會將 Process 的 Input 與 Output 連結到你的程式的 Input 與 Output，讓你的 Process 能打開如 Vim 或 Nano 之類的 Process："

#: ./docs/10.x/processes.md:131
#: ./docs/11.x/processes.md:131
#: ./docs/master/processes.md:131
msgctxt "CODE: php"
msgid "Process::forever()->tty()->run('vim');"
msgstr ""

#: ./docs/10.x/processes.md:135
#: ./docs/11.x/processes.md:135
#: ./docs/master/processes.md:135
#~ msgctxt "P"
#~ msgid "<a name=\"process-output\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:136
#: ./docs/11.x/processes.md:136
#: ./docs/master/processes.md:136
msgctxt "H3"
msgid "Process Output"
msgstr "Process 的輸出"

#: ./docs/10.x/processes.md:138
#: ./docs/11.x/processes.md:138
#: ./docs/master/processes.md:138
msgctxt "P"
msgid "As previously discussed, process output may be accessed using the `output` (stdout) and `errorOutput` (stderr) methods on a process result:"
msgstr "剛才提到過，可以使用 `output` (stdout) 與 `errorOutput` (stderr) 方法來在 Process 結果上取得 Process 的輸出："

#: ./docs/10.x/processes.md:140
#: ./docs/11.x/processes.md:140
#: ./docs/master/processes.md:140
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"$result = Process::run('ls -la');\n"
"\n"
"echo $result->output();\n"
"echo $result->errorOutput();"
msgstr ""

#: ./docs/10.x/processes.md:149
#: ./docs/11.x/processes.md:149
#: ./docs/master/processes.md:149
msgctxt "P"
msgid "However, output may also be gathered in real-time by passing a closure as the second argument to the `run` method. The closure will receive two arguments: the \"type\" of output (`stdout` or `stderr`) and the output string itself:"
msgstr "不過，也可以在呼叫 `run` 方法時傳入一個 Closure 作為第二個引數來即時取得輸出。該 Closure 會收到兩個引數：輸出的「類型 (Type)」(`stdout` 或 `stderr`) 與輸出字串本身："

#: ./docs/10.x/processes.md:151
#: ./docs/11.x/processes.md:151
#: ./docs/master/processes.md:151
msgctxt "CODE: php"
msgid ""
"$result = Process::run('ls -la', function (string $type, string $output) {\n"
"    echo $output;\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:157
#: ./docs/11.x/processes.md:157
#: ./docs/master/processes.md:157
msgctxt "P"
msgid "Laravel also offers the `seeInOutput` and `seeInErrorOutput` methods, which provide a convenient way to determine if a given string was contained in the process' output:"
msgstr "Laravel 也提供了 `seeInOutput` 與 `seeInErrorOutput` 方法。通過這兩個方法，就可以方便地判斷給定的字串是否包含在該 Process 的輸出中："

#: ./docs/10.x/processes.md:159
#: ./docs/11.x/processes.md:159
#: ./docs/master/processes.md:159
msgctxt "CODE: php"
msgid ""
"if (Process::run('ls -la')->seeInOutput('laravel')) {\n"
"    // ...\n"
"}"
msgstr ""

#: ./docs/10.x/processes.md:165
#: ./docs/11.x/processes.md:165
#: ./docs/master/processes.md:165
#~ msgctxt "P"
#~ msgid "<a name=\"disabling-process-output\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:166
#: ./docs/11.x/processes.md:166
#: ./docs/master/processes.md:166
msgctxt "H4"
msgid "Disabling Process Output"
msgstr "關閉 Process 的輸出"

#: ./docs/10.x/processes.md:168
#: ./docs/11.x/processes.md:168
#: ./docs/master/processes.md:168
msgctxt "P"
msgid "If your process is writing a significant amount of output that you are not interested in, you can conserve memory by disabling output retrieval entirely. To accomplish this, invoke the `quietly` method while building the process:"
msgstr "若 Process 會寫入大量不必要的輸出，可以完全關閉取得輸出來減少記憶體使用。若要關閉取得輸出，請在建構 Process 時呼叫 `quietly` 方法："

#: ./docs/10.x/processes.md:170
#: ./docs/11.x/processes.md:170
#: ./docs/master/processes.md:170
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"$result = Process::quietly()->run('bash import.sh');"
msgstr ""

#: ./docs/10.x/processes.md:176
#: ./docs/11.x/processes.md:176
#: ./docs/master/processes.md:176
#~ msgctxt "P"
#~ msgid "<a name=\"process-pipelines\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:177
#: ./docs/11.x/processes.md:177
#: ./docs/master/processes.md:177
msgctxt "H3"
msgid "Pipelines"
msgstr "管道"

#: ./docs/10.x/processes.md:179
#: ./docs/11.x/processes.md:179
#: ./docs/master/processes.md:179
msgctxt "P"
msgid "Sometimes you may want to make the output of one process the input of another process. This is often referred to as \"piping\" the output of a process into another. The `pipe` method provided by the `Process` facades makes this easy to accomplish. The `pipe` method will execute the piped processes synchronously and return the process result for the last process in the pipeline:"
msgstr "有時候，我們可能會想使用某個 Process 的輸出來作為另一個 Process 的輸入。這個動作我們一般會說是把 Process 的輸出「Pipe」到另一個 Process。`Process` Facade 提供的 `pipe` 方法能讓我們輕鬆進行此動作。`pipe` 方法會同步執行被 Pipe 的Process，並回傳管道中最後一個 Process 的結果："

#: ./docs/10.x/processes.md:181
#: ./docs/11.x/processes.md:181
#: ./docs/master/processes.md:181
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Process\\Pipe;\n"
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"$result = Process::pipe(function (Pipe $pipe) {\n"
"    $pipe->command('cat example.txt');\n"
"    $pipe->command('grep -i \"laravel\"');\n"
"});\n"
"\n"
"if ($result->successful()) {\n"
"    // ...\n"
"}"
msgstr ""

#: ./docs/10.x/processes.md:195
#: ./docs/11.x/processes.md:195
#: ./docs/master/processes.md:195
msgctxt "P"
msgid "If you do not need to customize the individual processes that make up the pipeline, you may simply pass an array of command strings to the `pipe` method:"
msgstr "若不需要為組成管道的個別 Process 進行自訂，則只需要傳入一組指令字串的陣列給 `pipe` 方法即可："

#: ./docs/10.x/processes.md:197
#: ./docs/11.x/processes.md:197
#: ./docs/master/processes.md:197
msgctxt "CODE: php"
msgid ""
"$result = Process::pipe([\n"
"    'cat example.txt',\n"
"    'grep -i \"laravel\"',\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:204
#: ./docs/11.x/processes.md:204
#: ./docs/master/processes.md:204
msgctxt "P"
msgid "The process output may be gathered in real-time by passing a closure as the second argument to the `pipe` method. The closure will receive two arguments: the \"type\" of output (`stdout` or `stderr`) and the output string itself:"
msgstr "可以在呼叫 `pipe` 方法時傳入一個 Closure 作為第二個引數來即時取得輸出。該 Closure 會收到兩個引數：輸出的「類型 (Type)」(`stdout` 或 `stderr`) 與輸出字串本身："

#: ./docs/10.x/processes.md:206
#: ./docs/11.x/processes.md:206
#: ./docs/master/processes.md:206
msgctxt "CODE: php"
msgid ""
"$result = Process::pipe(function (Pipe $pipe) {\n"
"    $pipe->command('cat example.txt');\n"
"    $pipe->command('grep -i \"laravel\"');\n"
"}, function (string $type, string $output) {\n"
"    echo $output;\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:215
#: ./docs/11.x/processes.md:215
#: ./docs/master/processes.md:215
msgctxt "P"
msgid "Laravel also allows you to assign string keys to each process within a pipeline via the `as` method. This key will also be passed to the output closure provided to the `pipe` method, allowing you to determine which process the output belongs to:"
msgstr "Laravel 可讓你使用 `as` 方法來為管道中的各個 Process 指派一個字串索引鍵。該索引鍵也會傳入提供給 `pipe` 方法的輸出 Closure，讓你能判斷輸出屬於哪個 Process："

#: ./docs/10.x/processes.md:217
#: ./docs/11.x/processes.md:217
#: ./docs/master/processes.md:217
msgctxt "CODE: php"
msgid ""
"$result = Process::pipe(function (Pipe $pipe) {\n"
"    $pipe->as('first')->command('cat example.txt');\n"
"    $pipe->as('second')->command('grep -i \"laravel\"');\n"
"})->start(function (string $type, string $output, string $key) {\n"
"    // ...\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:226
#: ./docs/11.x/processes.md:226
#: ./docs/master/processes.md:226
#~ msgctxt "P"
#~ msgid "<a name=\"asynchronous-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:227
#: ./docs/11.x/processes.md:227
#: ./docs/master/processes.md:227
msgctxt "H2"
msgid "Asynchronous Processes"
msgstr "非同步的 Process"

#: ./docs/10.x/processes.md:229
#: ./docs/11.x/processes.md:229
#: ./docs/master/processes.md:229
msgctxt "P"
msgid "While the `run` method invokes processes synchronously, the `start` method may be used to invoke a process asynchronously. This allows your application to continue performing other tasks while the process runs in the background. Once the process has been invoked, you may utilize the `running` method to determine if the process is still running:"
msgstr "`run` 方法會同步呼叫 Process，而 `start` 方法可用來非同步地呼叫 Process。這樣一來，你的程式就可以繼續執行其他任務，並讓 Process 在背景執行。Process 被呼叫後，可以使用 `running` 方法來判斷該 Process 是否還在執行："

#: ./docs/10.x/processes.md:231
#: ./docs/11.x/processes.md:231
#: ./docs/master/processes.md:231
msgctxt "CODE: php"
msgid ""
"$process = Process::timeout(120)->start('bash import.sh');\n"
"\n"
"while ($process->running()) {\n"
"    // ...\n"
"}\n"
"\n"
"$result = $process->wait();"
msgstr ""

#: ./docs/10.x/processes.md:241
#: ./docs/11.x/processes.md:241
#: ./docs/master/processes.md:241
msgctxt "P"
msgid "As you may have noticed, you may invoke the `wait` method to wait until the process is finished executing and retrieve the process result instance:"
msgstr "讀者可能已經注意到，可以通過呼叫 `wait` 方法來等待 Process 完成執行，然後再取得 Process 的結果實體："

#: ./docs/10.x/processes.md:243
#: ./docs/11.x/processes.md:243
#: ./docs/master/processes.md:243
msgctxt "CODE: php"
msgid ""
"$process = Process::timeout(120)->start('bash import.sh');\n"
"\n"
"// ...\n"
"\n"
"$result = $process->wait();"
msgstr ""

#: ./docs/10.x/processes.md:251
#: ./docs/11.x/processes.md:251
#: ./docs/master/processes.md:251
#~ msgctxt "P"
#~ msgid "<a name=\"process-ids-and-signals\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:252
#: ./docs/11.x/processes.md:252
#: ./docs/master/processes.md:252
msgctxt "H3"
msgid "Process IDs and Signals"
msgstr ""

#: ./docs/10.x/processes.md:254
#: ./docs/11.x/processes.md:254
#: ./docs/master/processes.md:254
msgctxt "P"
msgid "The `id` method may be used to retrieve the operating system assigned process ID of the running process:"
msgstr "`id` 方法可用來取得正在執行的 Process 由作業系統指派的 Process ID："

#: ./docs/10.x/processes.md:256
#: ./docs/11.x/processes.md:256
#: ./docs/master/processes.md:256
msgctxt "CODE: php"
msgid ""
"$process = Process::start('bash import.sh');\n"
"\n"
"return $process->id();"
msgstr ""

#: ./docs/10.x/processes.md:262
#: ./docs/11.x/processes.md:262
#: ./docs/master/processes.md:262
msgctxt "P"
msgid "You may use the `signal` method to send a \"signal\" to the running process. A list of predefined signal constants can be found within the [PHP documentation](https://www.php.net/manual/en/pcntl.constants.php):"
msgstr "可以使用 `signal` 方法來向正在執行的 Process 傳送「訊號 (Signal)」。請參考《[PHP 說明文件](https://www.php.net/manual/en/pcntl.constants.php)》以瞭解預先定義的 Signal 常數列表："

#: ./docs/10.x/processes.md:264
#: ./docs/11.x/processes.md:264
#: ./docs/master/processes.md:264
msgctxt "CODE: php"
msgid "$process->signal(SIGUSR2);"
msgstr ""

#: ./docs/10.x/processes.md:268
#: ./docs/11.x/processes.md:268
#: ./docs/master/processes.md:268
#~ msgctxt "P"
#~ msgid "<a name=\"asynchronous-process-output\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:269
#: ./docs/11.x/processes.md:269
#: ./docs/master/processes.md:269
msgctxt "H3"
msgid "Asynchronous Process Output"
msgstr "非同步 Process 的輸出"

#: ./docs/10.x/processes.md:271
#: ./docs/11.x/processes.md:271
#: ./docs/master/processes.md:271
msgctxt "P"
msgid "While an asynchronous process is running, you may access its entire current output using the `output` and `errorOutput` methods; however, you may utilize the `latestOutput` and `latestErrorOutput` to access the output from the process that has occurred since the output was last retrieved:"
msgstr "當非同步 Process 正在執行時，可以使用 `output` 與 `errorOutput` 方法來取得該 Process 目前的完整輸出。而 `latestOutput` 與 `latestErrorOutput` 可用來存取自從上一次取得輸出後該 Process 所產生的最新輸出："

#: ./docs/10.x/processes.md:273
#: ./docs/11.x/processes.md:273
#: ./docs/master/processes.md:273
msgctxt "CODE: php"
msgid ""
"$process = Process::timeout(120)->start('bash import.sh');\n"
"\n"
"while ($process->running()) {\n"
"    echo $process->latestOutput();\n"
"    echo $process->latestErrorOutput();\n"
"\n"
"    sleep(1);\n"
"}"
msgstr ""

#: ./docs/10.x/processes.md:284
#: ./docs/11.x/processes.md:284
#: ./docs/master/processes.md:284
msgctxt "P"
msgid "Like the `run` method, output may also be gathered in real-time from asynchronous processes by passing a closure as the second argument to the `start` method. The closure will receive two arguments: the \"type\" of output (`stdout` or `stderr`) and the output string itself:"
msgstr "與 `run` 方法類似，`start` 方法也可以在呼叫時傳入一個 Closure 作為第二個引數來即時取得輸出。該 Closure 會收到兩個引數：輸出的「類型 (Type)」(`stdout` 或 `stderr`) 與輸出字串本身："

#: ./docs/10.x/processes.md:286
#: ./docs/11.x/processes.md:286
#: ./docs/master/processes.md:286
msgctxt "CODE: php"
msgid ""
"$process = Process::start('bash import.sh', function (string $type, string $output) {\n"
"    echo $output;\n"
"});\n"
"\n"
"$result = $process->wait();"
msgstr ""

#: ./docs/10.x/processes.md:294
#: ./docs/11.x/processes.md:304
#: ./docs/master/processes.md:294
#~ msgctxt "P"
#~ msgid "<a name=\"concurrent-processes\"></a>"
#~ msgstr ""

#: ./docs/11.x/processes.md:294
msgctxt "P"
msgid "Instead of waiting until the process has finished, you may use the `waitUntil` method to stop waiting based on the output of the process. Laravel will stop waiting for the process to finish when the closure given to the `waitUntil` method returns `true`:"
msgstr ""

#: ./docs/10.x/processes.md:295
#: ./docs/11.x/processes.md:305
#: ./docs/master/processes.md:295
msgctxt "H2"
msgid "Concurrent Processes"
msgstr "併行的 Process"

#: ./docs/11.x/processes.md:296
msgctxt "CODE: php"
msgid ""
"$process = Process::start('bash import.sh');\n"
"\n"
"$process->waitUntil(function (string $type, string $output) {\n"
"    return $output === 'Ready...';\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:297
#: ./docs/11.x/processes.md:307
#: ./docs/master/processes.md:297
msgctxt "P"
msgid "Laravel also makes it a breeze to manage a pool of concurrent, asynchronous processes, allowing you to easily execute many tasks simultaneously. To get started, invoke the `pool` method, which accepts a closure that receives an instance of `Illuminate\\Process\\Pool`."
msgstr "Laravel 也讓管理平行的、非同步的 Process 集區 (Pool) 變的非常容易，讓你能輕鬆的同步執行多個任務。若要執行非同步 Process 集區，請執行 `pool` 方法。請傳入一個 Closure 給 `pool` 方法，該 Closure 會收到 `Illumiante\\Process\\Pool` 的實體。"

#: ./docs/10.x/processes.md:299
#: ./docs/11.x/processes.md:309
#: ./docs/master/processes.md:299
msgctxt "P"
msgid "Within this closure, you may define the processes that belong to the pool. Once a process pool is started via the `start` method, you may access the [collection](/docs/{{version}}/collections) of running processes via the `running` method:"
msgstr "在該 Closure 中，可以定義屬於該集區的 Process。使用 `start` 方法開始 Process 集區後，可以使用 `running` 方法來存取一組包含正在執行的 Process 的 [Collection](/docs/{{version}}/collections)："

#: ./docs/10.x/processes.md:301
#: ./docs/11.x/processes.md:311
#: ./docs/master/processes.md:301
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Process\\Pool;\n"
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"$pool = Process::pool(function (Pool $pool) {\n"
"    $pool->path(__DIR__)->command('bash import-1.sh');\n"
"    $pool->path(__DIR__)->command('bash import-2.sh');\n"
"    $pool->path(__DIR__)->command('bash import-3.sh');\n"
"})->start(function (string $type, string $output, int $key) {\n"
"    // ...\n"
"});\n"
"\n"
"while ($pool->running()->isNotEmpty()) {\n"
"    // ...\n"
"}\n"
"\n"
"$results = $pool->wait();"
msgstr ""

#: ./docs/10.x/processes.md:320
#: ./docs/11.x/processes.md:330
#: ./docs/master/processes.md:320
msgctxt "P"
msgid "As you can see, you may wait for all of the pool processes to finish executing and resolve their results via the `wait` method. The `wait` method returns an array accessible object that allows you to access the process result instance of each process in the pool by its key:"
msgstr "就像這樣，可以使用 `wait` 方法來等待集區 Process 完成執行並解析這些 Process 的執行結果。`wait` 方法會回傳一個可使用陣列存取的物件 (Array Accessible Object)，讓你能使用其索引鍵來存取集區中各個 Process 的 Process 執行結果實體："

#: ./docs/10.x/processes.md:322
#: ./docs/11.x/processes.md:332
#: ./docs/master/processes.md:322
msgctxt "CODE: php"
msgid ""
"$results = $pool->wait();\n"
"\n"
"echo $results[0]->output();"
msgstr ""

#: ./docs/10.x/processes.md:328
#: ./docs/11.x/processes.md:338
#: ./docs/master/processes.md:328
msgctxt "P"
msgid "Or, for convenience, the `concurrently` method may be used to start an asynchronous process pool and immediately wait on its results. This can provide particularly expressive syntax when combined with PHP's array destructuring capabilities:"
msgstr "或者，也可以使用方便的 `concurrently` 方法來開始一組非同步 Process 集區，並馬上開始等待其執行結果。當與 PHP 的陣列解構功能搭配使用時，使用此方法就可取得富含表達性的語法："

#: ./docs/10.x/processes.md:330
#: ./docs/11.x/processes.md:340
#: ./docs/master/processes.md:330
msgctxt "CODE: php"
msgid ""
"[$first, $second, $third] = Process::concurrently(function (Pool $pool) {\n"
"    $pool->path(__DIR__)->command('ls -la');\n"
"    $pool->path(app_path())->command('ls -la');\n"
"    $pool->path(storage_path())->command('ls -la');\n"
"});\n"
"\n"
"echo $first->output();"
msgstr ""

#: ./docs/10.x/processes.md:340
#: ./docs/11.x/processes.md:350
#: ./docs/master/processes.md:340
#~ msgctxt "P"
#~ msgid "<a name=\"naming-pool-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:341
#: ./docs/11.x/processes.md:351
#: ./docs/master/processes.md:341
msgctxt "H3"
msgid "Naming Pool Processes"
msgstr "命名的 Pool Process"

#: ./docs/10.x/processes.md:343
#: ./docs/11.x/processes.md:353
#: ./docs/master/processes.md:343
msgctxt "P"
msgid "Accessing process pool results via a numeric key is not very expressive; therefore, Laravel allows you to assign string keys to each process within a pool via the `as` method. This key will also be passed to the closure provided to the `start` method, allowing you to determine which process the output belongs to:"
msgstr "使用數字索引鍵來存取 Process 集區並不是很有表達性。因此，Laravel 可讓你使用 `as` 方法來為集區中的各個 Process 指派一個字串索引鍵。該索引鍵也會傳入提供給 `start` 方法的 Closure，讓你能判斷輸出屬於哪個 Process："

#: ./docs/10.x/processes.md:345
#: ./docs/11.x/processes.md:355
#: ./docs/master/processes.md:345
msgctxt "CODE: php"
msgid ""
"$pool = Process::pool(function (Pool $pool) {\n"
"    $pool->as('first')->command('bash import-1.sh');\n"
"    $pool->as('second')->command('bash import-2.sh');\n"
"    $pool->as('third')->command('bash import-3.sh');\n"
"})->start(function (string $type, string $output, string $key) {\n"
"    // ...\n"
"});\n"
"\n"
"$results = $pool->wait();\n"
"\n"
"return $results['first']->output();"
msgstr ""

#: ./docs/10.x/processes.md:359
#: ./docs/11.x/processes.md:369
#: ./docs/master/processes.md:359
#~ msgctxt "P"
#~ msgid "<a name=\"pool-process-ids-and-signals\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:360
#: ./docs/11.x/processes.md:370
#: ./docs/master/processes.md:360
msgctxt "H3"
msgid "Pool Process IDs and Signals"
msgstr ""

#: ./docs/10.x/processes.md:362
#: ./docs/11.x/processes.md:372
#: ./docs/master/processes.md:362
msgctxt "P"
msgid "Since the process pool's `running` method provides a collection of all invoked processes within the pool, you may easily access the underlying pool process IDs:"
msgstr "由於 Process 集區的 `running` 方法提供了一組包含集區中所有已呼叫 Process 的 Collection，因此你可以輕鬆地存取集區中相應的 Process ID："

#: ./docs/10.x/processes.md:364
#: ./docs/11.x/processes.md:374
#: ./docs/master/processes.md:364
msgctxt "CODE: php"
msgid "$processIds = $pool->running()->each->id();"
msgstr ""

#: ./docs/10.x/processes.md:368
#: ./docs/11.x/processes.md:378
#: ./docs/master/processes.md:368
msgctxt "P"
msgid "And, for convenience, you may invoke the `signal` method on a process pool to send a signal to every process within the pool:"
msgstr "而且，也可以在 Process 集區上使用 `signal` 方法來方便地傳送 Signal 給集區中的每一個 Process："

#: ./docs/10.x/processes.md:370
#: ./docs/11.x/processes.md:380
#: ./docs/master/processes.md:370
msgctxt "CODE: php"
msgid "$pool->signal(SIGUSR2);"
msgstr ""

#: ./docs/10.x/processes.md:374
#: ./docs/11.x/processes.md:384
#: ./docs/master/processes.md:374
#~ msgctxt "P"
#~ msgid "<a name=\"testing\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:375
#: ./docs/11.x/processes.md:385
#: ./docs/master/processes.md:375
msgctxt "H2"
msgid "Testing"
msgstr "測試"

#: ./docs/10.x/processes.md:377
#: ./docs/11.x/processes.md:387
#: ./docs/master/processes.md:377
msgctxt "P"
msgid "Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's process service is no exception. The `Process` facade's `fake` method allows you to instruct Laravel to return stubbed / dummy results when processes are invoked."
msgstr "許多 Laravel 的服務都提供了能讓你輕鬆且表達性地撰寫測試的方法，而 Laravel 的 Process 服務也不例外。使用 `Process` Facade 的 `fake` 方法，能讓你指定要 Laravel 在執行 Process 時回傳一組模擬的執行結果。"

#: ./docs/10.x/processes.md:379
#: ./docs/11.x/processes.md:389
#: ./docs/master/processes.md:379
#~ msgctxt "P"
#~ msgid "<a name=\"faking-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:380
#: ./docs/11.x/processes.md:390
#: ./docs/master/processes.md:380
msgctxt "H3"
msgid "Faking Processes"
msgstr "模擬 Process"

#: ./docs/10.x/processes.md:382
#: ./docs/11.x/processes.md:392
#: ./docs/master/processes.md:382
msgctxt "P"
msgid "To explore Laravel's ability to fake processes, let's imagine a route that invokes a process:"
msgstr "若要瞭解 Laravel 中模擬 Process 的功能，我們先來想像有個 Route 會呼叫一個 Process："

#: ./docs/10.x/processes.md:384
#: ./docs/11.x/processes.md:394
#: ./docs/master/processes.md:384
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"use Illuminate\\Support\\Facades\\Route;\n"
"\n"
"Route::get('/import', function () {\n"
"    Process::run('bash import.sh');\n"
"\n"
"    return 'Import complete!';\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:395
#: ./docs/11.x/processes.md:405
#: ./docs/master/processes.md:395
msgctxt "P"
msgid "When testing this route, we can instruct Laravel to return a fake, successful process result for every invoked process by calling the `fake` method on the `Process` facade with no arguments. In addition, we can even [assert](#available-assertions) that a given process was \"run\":"
msgstr "在測試此 Route 時，我們可以不帶任何引數呼叫 `Process` Facade 上的 `fake` 方法，讓 Laravel 在每一個被呼叫的 Process 上回傳一組模擬的成功 Process 執行結果。此外，我們還可以 [Assert](#available-assertions) 判斷給定的 Process 是否已執行："

#: ./docs/10.x/processes.md:397
#: ./docs/11.x/processes.md:430
#: ./docs/master/processes.md:420
msgctxt "CODE: php"
msgid ""
"<?php\n"
"\n"
"namespace Tests\\Feature;\n"
"\n"
"use Illuminate\\Process\\PendingProcess;\n"
"use Illuminate\\Contracts\\Process\\ProcessResult;\n"
"use Illuminate\\Support\\Facades\\Process;\n"
"use Tests\\TestCase;\n"
"\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_process_is_invoked(): void\n"
"    {\n"
"        Process::fake();\n"
"\n"
"        $response = $this->get('/import');\n"
"\n"
"        // Simple process assertion...\n"
"        Process::assertRan('bash import.sh');\n"
"\n"
"        // Or, inspecting the process configuration...\n"
"        Process::assertRan(function (PendingProcess $process, ProcessResult $result) {\n"
"            return $process->command === 'bash import.sh' &&\n"
"                   $process->timeout === 60;\n"
"        });\n"
"    }\n"
"}"
msgstr ""

#: ./docs/11.x/processes.md:407
#: ./docs/master/processes.md:397
msgctxt "CODE: php tab=Pest"
msgid ""
"<?php\n"
"\n"
"use Illuminate\\Process\\PendingProcess;\n"
"use Illuminate\\Contracts\\Process\\ProcessResult;\n"
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"test('process is invoked', function () {\n"
"    Process::fake();\n"
"\n"
"    $response = $this->get('/import');\n"
"\n"
"    // Simple process assertion...\n"
"    Process::assertRan('bash import.sh');\n"
"\n"
"    // Or, inspecting the process configuration...\n"
"    Process::assertRan(function (PendingProcess $process, ProcessResult $result) {\n"
"        return $process->command === 'bash import.sh' &&\n"
"               $process->timeout === 60;\n"
"    });\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:427
#: ./docs/11.x/processes.md:460
#: ./docs/master/processes.md:450
msgctxt "P"
msgid "As discussed, invoking the `fake` method on the `Process` facade will instruct Laravel to always return a successful process result with no output. However, you may easily specify the output and exit code for faked processes using the `Process` facade's `result` method:"
msgstr "剛才也提到過，在 `Process` Facade 上呼叫 `fake` 方法會讓 Laravel 為每個 Process 回傳沒有輸出的 Process 執行結果。不過，你可以使用 `Process` Facade 的 `result` 方法來輕鬆地指定模擬 Process 的輸出與結束代碼 (Exit Code)："

#: ./docs/10.x/processes.md:429
#: ./docs/11.x/processes.md:462
#: ./docs/master/processes.md:452
msgctxt "CODE: php"
msgid ""
"Process::fake([\n"
"    '*' => Process::result(\n"
"        output: 'Test output',\n"
"        errorOutput: 'Test error output',\n"
"        exitCode: 1,\n"
"    ),\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:439
#: ./docs/11.x/processes.md:472
#: ./docs/master/processes.md:462
#~ msgctxt "P"
#~ msgid "<a name=\"faking-specific-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:440
#: ./docs/11.x/processes.md:473
#: ./docs/master/processes.md:463
msgctxt "H3"
msgid "Faking Specific Processes"
msgstr "模擬特定的 Process"

#: ./docs/10.x/processes.md:442
#: ./docs/11.x/processes.md:475
#: ./docs/master/processes.md:465
msgctxt "P"
msgid "As you may have noticed in a previous example, the `Process` facade allows you to specify different fake results per process by passing an array to the `fake` method."
msgstr "讀者可能已經在前一個例子中注意到，通過 `Process` Facade，就可以通過傳入一組陣列給 `fake` 方法來指定各個 Process 的模擬執行結果。"

#: ./docs/10.x/processes.md:444
#: ./docs/11.x/processes.md:477
#: ./docs/master/processes.md:467
msgctxt "P"
msgid "The array's keys should represent command patterns that you wish to fake and their associated results. The `*` character may be used as a wildcard character. Any process commands that have not been faked will actually be invoked. You may use the `Process` facade's `result` method to construct stub / fake results for these commands:"
msgstr "陣列的索引鍵代表要模擬的指令格式，以及其相應的執行結果。可使用 `*` 字元來作為萬用字元。沒有被模擬的 Process 指令會被實際執行。可以使用 `Process` Facade 的 `result` 方法來為這些指令建立模擬的執行結果："

#: ./docs/10.x/processes.md:446
#: ./docs/11.x/processes.md:479
#: ./docs/master/processes.md:469
msgctxt "CODE: php"
msgid ""
"Process::fake([\n"
"    'cat *' => Process::result(\n"
"        output: 'Test \"cat\" output',\n"
"    ),\n"
"    'ls *' => Process::result(\n"
"        output: 'Test \"ls\" output',\n"
"    ),\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:457
#: ./docs/11.x/processes.md:490
#: ./docs/master/processes.md:480
msgctxt "P"
msgid "If you do not need to customize the exit code or error output of a faked process, you may find it more convenient to specify the fake process results as simple strings:"
msgstr "若不需要自定模擬 Process 的終止代碼或錯誤輸出，那麼使用字串來指定 Process 的模擬結果可能會更方便："

#: ./docs/10.x/processes.md:459
#: ./docs/11.x/processes.md:492
#: ./docs/master/processes.md:482
msgctxt "CODE: php"
msgid ""
"Process::fake([\n"
"    'cat *' => 'Test \"cat\" output',\n"
"    'ls *' => 'Test \"ls\" output',\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:466
#: ./docs/11.x/processes.md:499
#: ./docs/master/processes.md:489
#~ msgctxt "P"
#~ msgid "<a name=\"faking-process-sequences\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:467
#: ./docs/11.x/processes.md:500
#: ./docs/master/processes.md:490
msgctxt "H3"
msgid "Faking Process Sequences"
msgstr "模擬 Process 序列"

#: ./docs/10.x/processes.md:469
#: ./docs/11.x/processes.md:502
#: ./docs/master/processes.md:492
msgctxt "P"
msgid "If the code you are testing invokes multiple processes with the same command, you may wish to assign a different fake process result to each process invocation. You may accomplish this via the `Process` facade's `sequence` method:"
msgstr "若要測試的程式碼會以相同指令來呼叫多個 Process，則可為各個 Process 呼叫指定不同的 Process 模擬執行結果。若要為各個 Process 呼叫設定各自的執行結果，請使用 `Process` Facade 的 `sequence` 方法："

#: ./docs/10.x/processes.md:471
#: ./docs/11.x/processes.md:504
#: ./docs/master/processes.md:494
msgctxt "CODE: php"
msgid ""
"Process::fake([\n"
"    'ls *' => Process::sequence()\n"
"                ->push(Process::result('First invocation'))\n"
"                ->push(Process::result('Second invocation')),\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:479
#: ./docs/11.x/processes.md:512
#: ./docs/master/processes.md:502
#~ msgctxt "P"
#~ msgid "<a name=\"faking-asynchronous-process-lifecycles\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:480
#: ./docs/11.x/processes.md:513
#: ./docs/master/processes.md:503
msgctxt "H3"
msgid "Faking Asynchronous Process Lifecycles"
msgstr "模擬非同步 Process 的生命週期"

#: ./docs/10.x/processes.md:482
#: ./docs/11.x/processes.md:515
#: ./docs/master/processes.md:505
msgctxt "P"
msgid "Thus far, we have primarily discussed faking processes which are invoked synchronously using the `run` method. However, if you are attempting to test code that interacts with asynchronous processes invoked via `start`, you may need a more sophisticated approach to describing your fake processes."
msgstr "到目前為止，我們主要針對使用 `run` 方法同步呼叫的 Process 討論要如何進行模擬。不過，若要測試的程式碼中有使用 `start` 來非同步呼叫 Process，就需要使用更複雜的方法來模擬 Process。"

#: ./docs/10.x/processes.md:484
#: ./docs/11.x/processes.md:517
#: ./docs/master/processes.md:507
msgctxt "P"
msgid "For example, let's imagine the following route which interacts with an asynchronous process:"
msgstr "舉例來說，假設有下列 Route 會觸發非同步 Process："

#: ./docs/10.x/processes.md:486
#: ./docs/11.x/processes.md:519
#: ./docs/master/processes.md:509
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Log;\n"
"use Illuminate\\Support\\Facades\\Route;\n"
"\n"
"Route::get('/import', function () {\n"
"    $process = Process::start('bash import.sh');\n"
"\n"
"    while ($process->running()) {\n"
"        Log::info($process->latestOutput());\n"
"        Log::info($process->latestErrorOutput());\n"
"    }\n"
"\n"
"    return 'Done';\n"
"});"
msgstr ""

#: ./docs/10.x/processes.md:502
#: ./docs/11.x/processes.md:535
#: ./docs/master/processes.md:525
msgctxt "P"
msgid "To properly fake this process, we need to be able to describe how many times the `running` method should return `true`. In addition, we may want to specify multiple lines of output that should be returned in sequence. To accomplish this, we can use the `Process` facade's `describe` method:"
msgstr "若要正確模擬此 Process，我們需要能夠描述 `running` 方法要回傳幾次 `true`。此外，我們可能還需要指定要依序回傳的多行輸出。為此，我們可以使用 `Process` Facade 的 `describe` 方法："

#: ./docs/10.x/processes.md:504
#: ./docs/11.x/processes.md:537
#: ./docs/master/processes.md:527
msgctxt "CODE: php"
msgid ""
"Process::fake([\n"
"    'bash import.sh' => Process::describe()\n"
"            ->output('First line of standard output')\n"
"            ->errorOutput('First line of error output')\n"
"            ->output('Second line of standard output')\n"
"            ->exitCode(0)\n"
"            ->iterations(3),\n"
"]);"
msgstr ""

#: ./docs/10.x/processes.md:515
#: ./docs/11.x/processes.md:548
#: ./docs/master/processes.md:538
msgctxt "P"
msgid "Let's dig into the example above. Using the `output` and `errorOutput` methods, we may specify multiple lines of output that will be returned in sequence. The `exitCode` method may be used to specify the final exit code of the fake process. Finally, the `iterations` method may be used to specify how many times the `running` method should return `true`."
msgstr "讓我們來仔細看看上面的範例。使用 `output` 與 `errorOutput` 方法，我們可以指定要依序回傳的多行輸出。`exitCode` 方法可用來指定模擬 Process 最終的終止代碼。最後，`iterations` 方法可用來指定 `running` 方法要回傳幾次 `true`。"

#: ./docs/10.x/processes.md:517
#: ./docs/11.x/processes.md:550
#: ./docs/master/processes.md:540
#~ msgctxt "P"
#~ msgid "<a name=\"available-assertions\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:518
#: ./docs/11.x/processes.md:551
#: ./docs/master/processes.md:541
msgctxt "H3"
msgid "Available Assertions"
msgstr "可用的 Assertion"

#: ./docs/10.x/processes.md:520
#: ./docs/11.x/processes.md:553
#: ./docs/master/processes.md:543
msgctxt "P"
msgid "As [previously discussed](#faking-processes), Laravel provides several process assertions for your feature tests. We'll discuss each of these assertions below."
msgstr "就像[剛才提到過的](#faking-processes)，Laravel 為功能測試 (Feature Test) 提供了多個 Process 的 ^[Assertion](判斷提示)。我們會在接下來的部分討論這些 Assertion。"

#: ./docs/10.x/processes.md:522
#: ./docs/11.x/processes.md:555
#: ./docs/master/processes.md:545
#~ msgctxt "P"
#~ msgid "<a name=\"assert-process-ran\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:523
#: ./docs/11.x/processes.md:556
#: ./docs/master/processes.md:546
msgctxt "H4"
msgid "assertRan"
msgstr "assertRan"

#: ./docs/10.x/processes.md:525
#: ./docs/11.x/processes.md:558
#: ./docs/master/processes.md:548
msgctxt "P"
msgid "Assert that a given process was invoked:"
msgstr "判斷給定 Process 是否已被呼叫："

#: ./docs/10.x/processes.md:527
#: ./docs/11.x/processes.md:560
#: ./docs/master/processes.md:550
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"Process::assertRan('ls -la');"
msgstr ""

#: ./docs/10.x/processes.md:533
#: ./docs/11.x/processes.md:566
#: ./docs/master/processes.md:556
msgctxt "P"
msgid "The `assertRan` method also accepts a closure, which will receive an instance of a process and a process result, allowing you to inspect the process' configured options. If this closure returns `true`, the assertion will \"pass\":"
msgstr "也可傳入一個 Closure 給 `assertRun` 方法。該 Closure 會收到 Process 的實體與 Process 的執行結果，讓你能檢查 Process 上的設定。若讓該 Closure 回傳 `true`，則該 Assertion 就會通過 (Pass)："

#: ./docs/10.x/processes.md:535
#: ./docs/11.x/processes.md:568
#: ./docs/master/processes.md:558
msgctxt "CODE: php"
msgid ""
"Process::assertRan(fn ($process, $result) =>\n"
"    $process->command === 'ls -la' &&\n"
"    $process->path === __DIR__ &&\n"
"    $process->timeout === 60\n"
");"
msgstr ""

#: ./docs/10.x/processes.md:543
#: ./docs/11.x/processes.md:576
#: ./docs/master/processes.md:566
msgctxt "P"
msgid "The `$process` passed to the `assertRan` closure is an instance of `Illuminate\\Process\\PendingProcess`, while the `$result` is an instance of `Illuminate\\Contracts\\Process\\ProcessResult`."
msgstr "傳給 `assertRun` Closure 的 `$process` 是 `Illuminate\\Process\\PendingProcess` 的實體，而 `$result` 是 `Illuminate\\Contracts\\Process\\ProcessResult` 的實體。"

#: ./docs/10.x/processes.md:545
#: ./docs/11.x/processes.md:578
#: ./docs/master/processes.md:568
#~ msgctxt "P"
#~ msgid "<a name=\"assert-process-didnt-run\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:546
#: ./docs/11.x/processes.md:579
#: ./docs/master/processes.md:569
msgctxt "H4"
msgid "assertDidntRun"
msgstr "assertDidntRun"

#: ./docs/10.x/processes.md:548
#: ./docs/11.x/processes.md:581
#: ./docs/master/processes.md:571
msgctxt "P"
msgid "Assert that a given process was not invoked:"
msgstr "判斷給定 Process 是否未被呼叫："

#: ./docs/10.x/processes.md:550
#: ./docs/11.x/processes.md:583
#: ./docs/master/processes.md:573
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"Process::assertDidntRun('ls -la');"
msgstr ""

#: ./docs/10.x/processes.md:556
#: ./docs/11.x/processes.md:589
#: ./docs/master/processes.md:579
msgctxt "P"
msgid "Like the `assertRan` method, the `assertDidntRun` method also accepts a closure, which will receive an instance of a process and a process result, allowing you to inspect the process' configured options. If this closure returns `true`, the assertion will \"fail\":"
msgstr "與 `assertRun` 方法類似，`assertDidntRun` 方法也可被傳入一個 Closure。傳給 `assertDidntRun` 的 Closure 會收到 Process 實體與 Process 的執行結果，讓你能檢查 Process 上的設定。若該 Closure 回傳 `true`，則該 Assertion 就會失敗 (Fail)："

#: ./docs/10.x/processes.md:558
#: ./docs/11.x/processes.md:591
#: ./docs/master/processes.md:581
msgctxt "CODE: php"
msgid ""
"Process::assertDidntRun(fn (PendingProcess $process, ProcessResult $result) =>\n"
"    $process->command === 'ls -la'\n"
");"
msgstr ""

#: ./docs/10.x/processes.md:564
#: ./docs/11.x/processes.md:597
#: ./docs/master/processes.md:587
#~ msgctxt "P"
#~ msgid "<a name=\"assert-process-ran-times\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:565
#: ./docs/11.x/processes.md:598
#: ./docs/master/processes.md:588
msgctxt "H4"
msgid "assertRanTimes"
msgstr "assertRanTimes"

#: ./docs/10.x/processes.md:567
#: ./docs/11.x/processes.md:600
#: ./docs/master/processes.md:590
msgctxt "P"
msgid "Assert that a given process was invoked a given number of times:"
msgstr "判斷給定 Process 是否被呼叫了給定次數："

#: ./docs/10.x/processes.md:569
#: ./docs/11.x/processes.md:602
#: ./docs/master/processes.md:592
msgctxt "CODE: php"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"Process::assertRanTimes('ls -la', times: 3);"
msgstr ""

#: ./docs/10.x/processes.md:575
#: ./docs/11.x/processes.md:608
#: ./docs/master/processes.md:598
msgctxt "P"
msgid "The `assertRanTimes` method also accepts a closure, which will receive an instance of a process and a process result, allowing you to inspect the process' configured options. If this closure returns `true` and the process was invoked the specified number of times, the assertion will \"pass\":"
msgstr "也可傳入一個 Closure 給 `assertRanTimes` 方法。該 Closure 會收到 Process 的實體與 Process 的執行結果，讓你能檢查 Process 上的設定。若讓該 Closure 回傳 `true`，且該 Process 被呼叫了給定的次數，則該 Assertion 就會通過 (Pass)："

#: ./docs/10.x/processes.md:577
#: ./docs/11.x/processes.md:610
#: ./docs/master/processes.md:600
msgctxt "CODE: php"
msgid ""
"Process::assertRanTimes(function (PendingProcess $process, ProcessResult $result) {\n"
"    return $process->command === 'ls -la';\n"
"}, times: 3);"
msgstr ""

#: ./docs/10.x/processes.md:583
#: ./docs/11.x/processes.md:616
#: ./docs/master/processes.md:606
#~ msgctxt "P"
#~ msgid "<a name=\"preventing-stray-processes\"></a>"
#~ msgstr ""

#: ./docs/10.x/processes.md:584
#: ./docs/11.x/processes.md:617
#: ./docs/master/processes.md:607
msgctxt "H3"
msgid "Preventing Stray Processes"
msgstr "避免漏掉的 Process"

#: ./docs/10.x/processes.md:586
#: ./docs/11.x/processes.md:619
#: ./docs/master/processes.md:609
msgctxt "P"
msgid "If you would like to ensure that all invoked processes have been faked throughout your individual test or complete test suite, you can call the `preventStrayProcesses` method. After calling this method, any processes that do not have a corresponding fake result will throw an exception rather than starting an actual process:"
msgstr "若想在個別測試或整個測試套件中，確保所有呼叫的 Process 都被模擬，則可呼叫 `preventStrayProcesses` 方法。呼叫該方法後，若某個 Process 沒有相對應的模擬結果，該 Process 就不會被執行，而會擲回一個 Exception："

#: ./docs/10.x/processes.md:588
#: ./docs/11.x/processes.md:621
#: ./docs/master/processes.md:611
msgctxt "CODE"
msgid ""
"use Illuminate\\Support\\Facades\\Process;\n"
"\n"
"Process::preventStrayProcesses();\n"
"\n"
"Process::fake([\n"
"    'ls *' => 'Test output...',\n"
"]);\n"
"\n"
"// Fake response is returned...\n"
"Process::run('ls -la');\n"
"\n"
"// An exception is thrown...\n"
"Process::run('bash import.sh');"
msgstr ""
