# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Taylor Otwell
# This file is distributed under the same license as the Laravel Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Laravel Documentation VERSION\n"
"POT-Creation-Date: 2022-01-28 10:57+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: docs/master/queues.md:1
#, no-wrap
msgid "Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:47
#, no-wrap
msgid ""
"- [Introduction](#introduction)\n"
"    - [Connections Vs. Queues](#connections-vs-queues)\n"
"    - [Driver Notes & Prerequisites](#driver-prerequisites)\n"
"- [Creating Jobs](#creating-jobs)\n"
"    - [Generating Job Classes](#generating-job-classes)\n"
"    - [Class Structure](#class-structure)\n"
"    - [Unique Jobs](#unique-jobs)\n"
"- [Job Middleware](#job-middleware)\n"
"    - [Rate Limiting](#rate-limiting)\n"
"    - [Preventing Job Overlaps](#preventing-job-overlaps)\n"
"    - [Throttling Exceptions](#throttling-exceptions)\n"
"- [Dispatching Jobs](#dispatching-jobs)\n"
"    - [Delayed Dispatching](#delayed-dispatching)\n"
"    - [Synchronous Dispatching](#synchronous-dispatching)\n"
"    - [Jobs & Database Transactions](#jobs-and-database-transactions)\n"
"    - [Job Chaining](#job-chaining)\n"
"    - [Customizing The Queue & "
"Connection](#customizing-the-queue-and-connection)\n"
"    - [Specifying Max Job Attempts / Timeout "
"Values](#max-job-attempts-and-timeout)\n"
"    - [Error Handling](#error-handling)\n"
"- [Job Batching](#job-batching)\n"
"    - [Defining Batchable Jobs](#defining-batchable-jobs)\n"
"    - [Dispatching Batches](#dispatching-batches)\n"
"    - [Adding Jobs To Batches](#adding-jobs-to-batches)\n"
"    - [Inspecting Batches](#inspecting-batches)\n"
"    - [Cancelling Batches](#cancelling-batches)\n"
"    - [Batch Failures](#batch-failures)\n"
"    - [Pruning Batches](#pruning-batches)\n"
"- [Queueing Closures](#queueing-closures)\n"
"- [Running The Queue Worker](#running-the-queue-worker)\n"
"    - [The `queue:work` Command](#the-queue-work-command)\n"
"    - [Queue Priorities](#queue-priorities)\n"
"    - [Queue Workers & Deployment](#queue-workers-and-deployment)\n"
"    - [Job Expirations & Timeouts](#job-expirations-and-timeouts)\n"
"- [Supervisor Configuration](#supervisor-configuration)\n"
"- [Dealing With Failed Jobs](#dealing-with-failed-jobs)\n"
"    - [Cleaning Up After Failed Jobs](#cleaning-up-after-failed-jobs)\n"
"    - [Retrying Failed Jobs](#retrying-failed-jobs)\n"
"    - [Ignoring Missing Models](#ignoring-missing-models)\n"
"    - [Storing Failed Jobs In DynamoDB](#storing-failed-jobs-in-dynamodb)\n"
"    - [Pruning Failed Jobs](#pruning-failed-jobs)\n"
"    - [Failed Job Events](#failed-job-events)\n"
"- [Clearing Jobs From Queues](#clearing-jobs-from-queues)\n"
"- [Monitoring Your Queues](#monitoring-your-queues)\n"
"- [Job Events](#job-events)\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:49
#, no-wrap
msgid "<a name=\"introduction\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:49
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:52
msgid ""
"While building your web application, you may have some tasks, such as "
"parsing and storing an uploaded CSV file, that take too long to perform "
"during a typical web request. Thankfully, Laravel allows you to easily "
"create queued jobs that may be processed in the background. By moving time "
"intensive tasks to a queue, your application can respond to web requests "
"with blazing speed and provide a better user experience to your customers."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:54
msgid ""
"Laravel queues provide a unified queueing API across a variety of different "
"queue backends, such as [Amazon SQS](https://aws.amazon.com/sqs/), "
"[Redis](https://redis.io), or even a relational database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:56
msgid ""
"Laravel's queue configuration options are stored in your application's "
"`config/queue.php` configuration file. In this file, you will find "
"connection configurations for each of the queue drivers that are included "
"with the framework, including the database, [Amazon "
"SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), and "
"[Beanstalkd](https://beanstalkd.github.io/) drivers, as well as a "
"synchronous driver that will execute jobs immediately (for use during local "
"development). A `null` queue driver is also included which discards queued "
"jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:58
#, no-wrap
msgid ""
"> {tip} Laravel now offers Horizon, a beautiful dashboard and configuration "
"system for your Redis powered queues. Check out the full [Horizon "
"documentation](/docs/{{version}}/horizon) for more information.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:60
#, no-wrap
msgid "<a name=\"connections-vs-queues\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:60
#, no-wrap
msgid "Connections Vs. Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:63
msgid ""
"Before getting started with Laravel queues, it is important to understand "
"the distinction between \"connections\" and \"queues\". In your "
"`config/queue.php` configuration file, there is a `connections` "
"configuration array. This option defines the connections to backend queue "
"services such as Amazon SQS, Beanstalk, or Redis. However, any given queue "
"connection may have multiple \"queues\" which may be thought of as different "
"stacks or piles of queued jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:65
msgid ""
"Note that each connection configuration example in the `queue` configuration "
"file contains a `queue` attribute. This is the default queue that jobs will "
"be dispatched to when they are sent to a given connection. In other words, "
"if you dispatch a job without explicitly defining which queue it should be "
"dispatched to, the job will be placed on the queue that is defined in the "
"`queue` attribute of the connection configuration:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:67 docs/master/queues.md:736
#, no-wrap
msgid "    use App\\Jobs\\ProcessPodcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:70
#, no-wrap
msgid ""
"    // This job is sent to the default connection's default queue...\n"
"    ProcessPodcast::dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:73
#, no-wrap
msgid ""
"    // This job is sent to the default connection's \"emails\" queue...\n"
"    ProcessPodcast::dispatch()->onQueue('emails');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:75
msgid ""
"Some applications may not need to ever push jobs onto multiple queues, "
"instead preferring to have one simple queue. However, pushing jobs to "
"multiple queues can be especially useful for applications that wish to "
"prioritize or segment how jobs are processed, since the Laravel queue worker "
"allows you to specify which queues it should process by priority. For "
"example, if you push jobs to a `high` queue, you may run a worker that gives "
"them higher processing priority:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:77
#, no-wrap
msgid "    php artisan queue:work --queue=high,default\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:79
#, no-wrap
msgid "<a name=\"driver-prerequisites\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:79
#, no-wrap
msgid "Driver Notes & Prerequisites"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:82
#, no-wrap
msgid "<a name=\"database\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:82
#, no-wrap
msgid "Database"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:85
msgid ""
"In order to use the `database` queue driver, you will need a database table "
"to hold the jobs. To generate a migration that creates this table, run the "
"`queue:table` Artisan command. Once the migration has been created, you may "
"migrate your database using the `migrate` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:87
#, no-wrap
msgid "    php artisan queue:table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:89 docs/master/queues.md:1119 docs/master/queues.md:1595
#, no-wrap
msgid "    php artisan migrate\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:91
msgid ""
"Finally, don't forget to instruct your application to use the `database` "
"driver by updating the `QUEUE_CONNECTION` variable in your application's "
"`.env` file:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:93
#, no-wrap
msgid "    QUEUE_CONNECTION=database\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:95
#, no-wrap
msgid "<a name=\"redis\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:95
#, no-wrap
msgid "Redis"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:98
msgid ""
"In order to use the `redis` queue driver, you should configure a Redis "
"database connection in your `config/database.php` configuration file."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:100
#, no-wrap
msgid "**Redis Cluster**\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:102
msgid ""
"If your Redis queue connection uses a Redis Cluster, your queue names must "
"contain a [key hash "
"tag](https://redis.io/topics/cluster-spec#keys-hash-tags). This is required "
"in order to ensure all of the Redis keys for a given queue are placed into "
"the same hash slot:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:109
#, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        'connection' => 'default',\n"
"        'queue' => '{default}',\n"
"        'retry_after' => 90,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:111
#, no-wrap
msgid "**Blocking**\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:113
msgid ""
"When using the Redis queue, you may use the `block_for` configuration option "
"to specify how long the driver should wait for a job to become available "
"before iterating through the worker loop and re-polling the Redis database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:115
msgid ""
"Adjusting this value based on your queue load can be more efficient than "
"continually polling the Redis database for new jobs. For instance, you may "
"set the value to `5` to indicate that the driver should block for five "
"seconds while waiting for a job to become available:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:123
#, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        'connection' => 'default',\n"
"        'queue' => 'default',\n"
"        'retry_after' => 90,\n"
"        'block_for' => 5,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:125
#, no-wrap
msgid ""
"> {note} Setting `block_for` to `0` will cause queue workers to block "
"indefinitely until a job is available. This will also prevent signals such "
"as `SIGTERM` from being handled until the next job has been processed.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:127
#, no-wrap
msgid "<a name=\"other-driver-prerequisites\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:127
#, no-wrap
msgid "Other Driver Prerequisites"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:130
msgid ""
"The following dependencies are needed for the listed queue drivers. These "
"dependencies may be installed via the Composer package manager:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:136
#, no-wrap
msgid ""
"<div class=\"content-list\" markdown=\"1\">\n"
"- Amazon SQS: `aws/aws-sdk-php ~3.0`\n"
"- Beanstalkd: `pda/pheanstalk ~4.0`\n"
"- Redis: `predis/predis ~1.0` or phpredis PHP extension\n"
"</div>\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:138
#, no-wrap
msgid "<a name=\"creating-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:138
#, no-wrap
msgid "Creating Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:141
#, no-wrap
msgid "<a name=\"generating-job-classes\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:141
#, no-wrap
msgid "Generating Job Classes"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:144
msgid ""
"By default, all of the queueable jobs for your application are stored in the "
"`app/Jobs` directory. If the `app/Jobs` directory doesn't exist, it will be "
"created when you run the `make:job` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:146
#, no-wrap
msgid "    php artisan make:job ProcessPodcast\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:148
msgid ""
"The generated class will implement the "
"`Illuminate\\Contracts\\Queue\\ShouldQueue` interface, indicating to Laravel "
"that the job should be pushed onto the queue to run asynchronously."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:150
#, no-wrap
msgid ""
"> {tip} Job stubs may be customized using [stub "
"publishing](/docs/{{version}}/artisan#stub-customization).\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:152
#, no-wrap
msgid "<a name=\"class-structure\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:152
#, no-wrap
msgid "Class Structure"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:155
msgid ""
"Job classes are very simple, normally containing only a `handle` method that "
"is invoked when the job is processed by the queue. To get started, let's "
"take a look at an example job class. In this example, we'll pretend we "
"manage a podcast publishing service and need to process the uploaded podcast "
"files before they are published:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:157 docs/master/queues.md:246 docs/master/queues.md:260 docs/master/queues.md:300 docs/master/queues.md:364 docs/master/queues.md:594 docs/master/queues.md:632 docs/master/queues.md:685 docs/master/queues.md:807 docs/master/queues.md:836 docs/master/queues.md:866 docs/master/queues.md:901 docs/master/queues.md:942 docs/master/queues.md:978 docs/master/queues.md:1033 docs/master/queues.md:1126 docs/master/queues.md:1643 docs/master/queues.md:1790 docs/master/queues.md:1882
#, no-wrap
msgid "    <?php\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:159 docs/master/queues.md:838 docs/master/queues.md:903 docs/master/queues.md:944 docs/master/queues.md:980 docs/master/queues.md:1035 docs/master/queues.md:1128 docs/master/queues.md:1645
#, no-wrap
msgid "    namespace App\\Jobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:167
#, no-wrap
msgid ""
"    use App\\Models\\Podcast;\n"
"    use App\\Services\\AudioProcessor;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:171 docs/master/queues.md:848 docs/master/queues.md:913
#, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:178
#, no-wrap
msgid ""
"        /**\n"
"         * The podcast instance.\n"
"         *\n"
"         * @var \\App\\Models\\Podcast\n"
"         */\n"
"        protected $podcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:189
#, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @param  App\\Models\\Podcast  $podcast\n"
"         * @return void\n"
"         */\n"
"        public function __construct(Podcast $podcast)\n"
"        {\n"
"            $this->podcast = $podcast;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:201
#, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @param  App\\Services\\AudioProcessor  $processor\n"
"         * @return void\n"
"         */\n"
"        public function handle(AudioProcessor $processor)\n"
"        {\n"
"            // Process uploaded podcast...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:203
msgid ""
"In this example, note that we were able to pass an [Eloquent "
"model](/docs/{{version}}/eloquent) directly into the queued job's "
"constructor. Because of the `SerializesModels` trait that the job is using, "
"Eloquent models and their loaded relationships will be gracefully serialized "
"and unserialized when the job is processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:205
msgid ""
"If your queued job accepts an Eloquent model in its constructor, only the "
"identifier for the model will be serialized onto the queue. When the job is "
"actually handled, the queue system will automatically re-retrieve the full "
"model instance and its loaded relationships from the database. This approach "
"to model serialization allows for much smaller job payloads to be sent to "
"your queue driver."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:207
#, no-wrap
msgid "<a name=\"handle-method-dependency-injection\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:207
#, no-wrap
msgid "`handle` Method Dependency Injection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:210
msgid ""
"The `handle` method is invoked when the job is processed by the queue. Note "
"that we are able to type-hint dependencies on the `handle` method of the "
"job. The Laravel [service container](/docs/{{version}}/container) "
"automatically injects these dependencies."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:212
msgid ""
"If you would like to take total control over how the container injects "
"dependencies into the `handle` method, you may use the container's "
"`bindMethod` method. The `bindMethod` method accepts a callback which "
"receives the job and the container. Within the callback, you are free to "
"invoke the `handle` method however you wish. Typically, you should call this "
"method from the `boot` method of your `App\\Providers\\AppServiceProvider` "
"[service provider](/docs/{{version}}/providers):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:215
#, no-wrap
msgid ""
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Services\\AudioProcessor;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:219
#, no-wrap
msgid ""
"    $this->app->bindMethod([ProcessPodcast::class, 'handle'], function "
"($job, $app) {\n"
"        return $job->handle($app->make(AudioProcessor::class));\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:221
#, no-wrap
msgid ""
"> {note} Binary data, such as raw image contents, should be passed through "
"the `base64_encode` function before being passed to a queued job. Otherwise, "
"the job may not properly serialize to JSON when being placed on the queue.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:223
#, no-wrap
msgid "<a name=\"handling-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:223
#, no-wrap
msgid "Handling Relationships"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:226
msgid ""
"Because loaded relationships also get serialized, the serialized job string "
"can sometimes become quite large. To prevent relations from being "
"serialized, you can call the `withoutRelations` method on the model when "
"setting a property value. This method will return an instance of the model "
"without its loaded relationships:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:237
#, no-wrap
msgid ""
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast->withoutRelations();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:239
#, no-wrap
msgid "<a name=\"unique-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:239
#, no-wrap
msgid "Unique Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:242
#, no-wrap
msgid ""
"> {note} Unique jobs require a cache driver that supports "
"[locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, "
"`redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support "
"atomic locks. In addition, unique job constraints do not apply to jobs "
"within batches.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:244
msgid ""
"Sometimes, you may want to ensure that only one instance of a specific job "
"is on the queue at any point in time. You may do so by implementing the "
"`ShouldBeUnique` interface on your job class. This interface does not "
"require you to define any additional methods on your class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:249
#, no-wrap
msgid ""
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:254
#, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:256
msgid ""
"In the example above, the `UpdateSearchIndex` job is unique. So, the job "
"will not be dispatched if another instance of the job is already on the "
"queue and has not finished processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:258
msgid ""
"In certain cases, you may want to define a specific \"key\" that makes the "
"job unique or you may want to specify a timeout beyond which the job no "
"longer stays unique. To accomplish this, you may define `uniqueId` and "
"`uniqueFor` properties or methods on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:264
#, no-wrap
msgid ""
"    use App\\Product;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:273
#, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        /**\n"
"         * The product instance.\n"
"         *\n"
"         * @var \\App\\Product\n"
"         */\n"
"        public $product;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:280
#, no-wrap
msgid ""
"        /**\n"
"         * The number of seconds after which the job's unique lock will be "
"released.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $uniqueFor = 3600;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:291
#, no-wrap
msgid ""
"        /**\n"
"         * The unique ID of the job.\n"
"         *\n"
"         * @return string\n"
"         */\n"
"        public function uniqueId()\n"
"        {\n"
"            return $this->product->id;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:293
msgid ""
"In the example above, the `UpdateSearchIndex` job is unique by a product "
"ID. So, any new dispatches of the job with the same product ID will be "
"ignored until the existing job has completed processing. In addition, if the "
"existing job is not processed within one hour, the unique lock will be "
"released and another job with the same unique key can be dispatched to the "
"queue."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:295
#, no-wrap
msgid "<a name=\"keeping-jobs-unique-until-processing-begins\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:295
#, no-wrap
msgid "Keeping Jobs Unique Until Processing Begins"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:298
msgid ""
"By default, unique jobs are \"unlocked\" after a job completes processing or "
"fails all of its retry attempts. However, there may be situations where you "
"would like your job to unlock immediately before it is processed. To "
"accomplish this, your job should implement the "
"`ShouldBeUniqueUntilProcessing` contract instead of the `ShouldBeUnique` "
"contract:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:304
#, no-wrap
msgid ""
"    use App\\Product;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:309
#, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, "
"ShouldBeUniqueUntilProcessing\n"
"    {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:311
#, no-wrap
msgid "<a name=\"unique-job-locks\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:311
#, no-wrap
msgid "Unique Job Locks"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:314
msgid ""
"Behind the scenes, when a `ShouldBeUnique` job is dispatched, Laravel "
"attempts to acquire a [lock](/docs/{{version}}/cache#atomic-locks) with the "
"`uniqueId` key. If the lock is not acquired, the job is not dispatched. This "
"lock is released when the job completes processing or fails all of its retry "
"attempts. By default, Laravel will use the default cache driver to obtain "
"this lock. However, if you wish to use another driver for acquiring the "
"lock, you may define a `uniqueVia` method that returns the cache driver that "
"should be used:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:316
#, no-wrap
msgid "    use Illuminate\\Support\\Facades\\Cache;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:320
#, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:331
#, no-wrap
msgid ""
"        /**\n"
"         * Get the cache driver for the unique job lock.\n"
"         *\n"
"         * @return \\Illuminate\\Contracts\\Cache\\Repository\n"
"         */\n"
"        public function uniqueVia()\n"
"        {\n"
"            return Cache::driver('redis');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:333
#, no-wrap
msgid ""
"> {tip} If you only need to limit the concurrent processing of a job, use "
"the [`WithoutOverlapping`](/docs/{{version}}/queues#preventing-job-overlaps) "
"job middleware instead.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:335
#, no-wrap
msgid "<a name=\"job-middleware\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:335
#, no-wrap
msgid "Job Middleware"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:338
msgid ""
"Job middleware allow you to wrap custom logic around the execution of queued "
"jobs, reducing boilerplate in the jobs themselves. For example, consider the "
"following `handle` method which leverages Laravel's Redis rate limiting "
"features to allow only one job to process every five seconds:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:340 docs/master/queues.md:368 docs/master/queues.md:982
#, no-wrap
msgid "    use Illuminate\\Support\\Facades\\Redis;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:350
#, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function "
"() {\n"
"            info('Lock obtained...');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:354
#, no-wrap
msgid ""
"            // Handle job...\n"
"        }, function () {\n"
"            // Could not obtain lock...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:358
#, no-wrap
msgid ""
"            return $this->release(5);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:360
msgid ""
"While this code is valid, the implementation of the `handle` method becomes "
"noisy since it is cluttered with Redis rate limiting logic. In addition, "
"this rate limiting logic must be duplicated for any other jobs that we want "
"to rate limit."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:362
msgid ""
"Instead of rate limiting in the handle method, we could define a job "
"middleware that handles rate limiting. Laravel does not have a default "
"location for job middleware, so you are welcome to place job middleware "
"anywhere in your application. In this example, we will place the middleware "
"in an `app/Jobs/Middleware` directory:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:366
#, no-wrap
msgid "    namespace App\\Jobs\\Middleware;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:384
#, no-wrap
msgid ""
"    class RateLimited\n"
"    {\n"
"        /**\n"
"         * Process the queued job.\n"
"         *\n"
"         * @param  mixed  $job\n"
"         * @param  callable  $next\n"
"         * @return mixed\n"
"         */\n"
"        public function handle($job, $next)\n"
"        {\n"
"            Redis::throttle('key')\n"
"                    ->block(0)->allow(1)->every(5)\n"
"                    ->then(function () use ($job, $next) {\n"
"                        // Lock obtained...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:388
#, no-wrap
msgid ""
"                        $next($job);\n"
"                    }, function () use ($job) {\n"
"                        // Could not obtain lock...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:393
#, no-wrap
msgid ""
"                        $job->release(5);\n"
"                    });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:395
msgid ""
"As you can see, like [route middleware](/docs/{{version}}/middleware), job "
"middleware receive the job being processed and a callback that should be "
"invoked to continue processing the job."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:397
msgid ""
"After creating job middleware, they may be attached to a job by returning "
"them from the job's `middleware` method. This method does not exist on jobs "
"scaffolded by the `make:job` Artisan command, so you will need to manually "
"add it to your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:399
#, no-wrap
msgid "    use App\\Jobs\\Middleware\\RateLimited;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:409
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new RateLimited];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:411
#, no-wrap
msgid ""
"> {tip} Job middleware can also be assigned to queueable event listeners, "
"mailables, and notifications.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:413
#, no-wrap
msgid "<a name=\"rate-limiting\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:413
#, no-wrap
msgid "Rate Limiting"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:416
msgid ""
"Although we just demonstrated how to write your own rate limiting job "
"middleware, Laravel actually includes a rate limiting middleware that you "
"may utilize to rate limit jobs. Like [route rate "
"limiters](/docs/{{version}}/routing#defining-rate-limiters), job rate "
"limiters are defined using the `RateLimiter` facade's `for` method."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:418
msgid ""
"For example, you may wish to allow users to backup their data once per hour "
"while imposing no such limit on premium customers. To accomplish this, you "
"may define a `RateLimiter` in the `boot` method of your "
"`AppServiceProvider`:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:421
#, no-wrap
msgid ""
"    use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"    use Illuminate\\Support\\Facades\\RateLimiter;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:435
#, no-wrap
msgid ""
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        RateLimiter::for('backups', function ($job) {\n"
"            return $job->user->vipCustomer()\n"
"                        ? Limit::none()\n"
"                        : Limit::perHour(1)->by($job->user->id);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:437
msgid ""
"In the example above, we defined an hourly rate limit; however, you may "
"easily define a rate limit based on minutes using the `perMinute` method. In "
"addition, you may pass any value you wish to the `by` method of the rate "
"limit; however, this value is most often used to segment rate limits by "
"customer:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:439
#, no-wrap
msgid "    return Limit::perMinute(50)->by($job->user->id);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:441
msgid ""
"Once you have defined your rate limit, you may attach the rate limiter to "
"your backup job using the `Illuminate\\Queue\\Middleware\\RateLimited` "
"middleware. Each time the job exceeds the rate limit, this middleware will "
"release the job back to the queue with an appropriate delay based on the "
"rate limit duration."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:443
#, no-wrap
msgid "    use Illuminate\\Queue\\Middleware\\RateLimited;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:453
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new RateLimited('backups')];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:455
msgid ""
"Releasing a rate limited job back onto the queue will still increment the "
"job's total number of `attempts`. You may wish to tune your `tries` and "
"`maxExceptions` properties on your job class accordingly. Or, you may wish "
"to use the [`retryUntil` method](#time-based-attempts) to define the amount "
"of time until the job should no longer be attempted."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:457
msgid ""
"If you do not want a job to be retried when it is rate limited, you may use "
"the `dontRelease` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:467
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new RateLimited('backups'))->dontRelease()];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:469
#, no-wrap
msgid ""
"> {tip} If you are using Redis, you may use the "
"`Illuminate\\Queue\\Middleware\\RateLimitedWithRedis` middleware, which is "
"fine-tuned for Redis and more efficient than the basic rate limiting "
"middleware.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:471
#, no-wrap
msgid "<a name=\"preventing-job-overlaps\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:471
#, no-wrap
msgid "Preventing Job Overlaps"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:474
msgid ""
"Laravel includes an `Illuminate\\Queue\\Middleware\\WithoutOverlapping` "
"middleware that allows you to prevent job overlaps based on an arbitrary "
"key. This can be helpful when a queued job is modifying a resource that "
"should only be modified by one job at a time."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:476
msgid ""
"For example, let's imagine you have a queued job that updates a user's "
"credit score and you want to prevent credit score update job overlaps for "
"the same user ID. To accomplish this, you can return the "
"`WithoutOverlapping` middleware from your job's `middleware` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:478
#, no-wrap
msgid "    use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:488
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new WithoutOverlapping($this->user->id)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:490
msgid ""
"Any overlapping jobs will be released back to the queue. You may also "
"specify the number of seconds that must elapse before the released job will "
"be attempted again:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:500
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new "
"WithoutOverlapping($this->order->id))->releaseAfter(60)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:502
msgid ""
"If you wish to immediately delete any overlapping jobs so that they will not "
"be retried, you may use the `dontRelease` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:512
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new "
"WithoutOverlapping($this->order->id))->dontRelease()];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:514
msgid ""
"The `WithoutOverlapping` middleware is powered by Laravel's atomic lock "
"feature. Sometimes, your job may unexpectedly fail or timeout in such a way "
"that the lock is not released. Therefore, you may explicitly define a lock "
"expiration time using the `expireAfter` method. For example, the example "
"below will instruct Laravel to release the `WithoutOverlapping` lock three "
"minutes after the job has started processing:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:524
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new "
"WithoutOverlapping($this->order->id))->expireAfter(180)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:526
#, no-wrap
msgid ""
"> {note} The `WithoutOverlapping` middleware requires a cache driver that "
"supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the "
"`memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache "
"drivers support atomic locks.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:528
#, no-wrap
msgid "<a name=\"throttling-exceptions\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:528
#, no-wrap
msgid "Throttling Exceptions"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:531
msgid ""
"Laravel includes a `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` "
"middleware that allows you to throttle exceptions. Once the job throws a "
"given number of exceptions, all further attempts to execute the job are "
"delayed until a specified time interval lapses. This middleware is "
"particularly useful for jobs that interact with third-party services that "
"are unstable."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:533
msgid ""
"For example, let's imagine a queued job that interacts with a third-party "
"API that begins throwing exceptions. To throttle exceptions, you can return "
"the `ThrottlesExceptions` middleware from your job's `middleware` "
"method. Typically, this middleware should be paired with a job that "
"implements [time based attempts](#time-based-attempts):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:535 docs/master/queues.md:561 docs/master/queues.md:575
#, no-wrap
msgid "    use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:545
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new ThrottlesExceptions(10, 5)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:555
#, no-wrap
msgid ""
"    /**\n"
"     * Determine the time at which the job should timeout.\n"
"     *\n"
"     * @return \\DateTime\n"
"     */\n"
"    public function retryUntil()\n"
"    {\n"
"        return now()->addMinutes(5);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:557
msgid ""
"The first constructor argument accepted by the middleware is the number of "
"exceptions the job can throw before being throttled, while the second "
"constructor argument is the number of minutes that should elapse before the "
"job is attempted again once it has been throttled. In the code example "
"above, if the job throws 10 exceptions within 5 minutes, we will wait 5 "
"minutes before attempting the job again."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:559
msgid ""
"When a job throws an exception but the exception threshold has not yet been "
"reached, the job will typically be retried immediately. However, you may "
"specify the number of minutes such a job should be delayed by calling the "
"`backoff` method when attaching the middleware to the job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:571
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new ThrottlesExceptions(10, 5))->backoff(5)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:573
msgid ""
"Internally, this middleware uses Laravel's cache system to implement rate "
"limiting, and the job's class name is utilized as the cache \"key\". You may "
"override this key by calling the `by` method when attaching the middleware "
"to your job. This may be useful if you have multiple jobs interacting with "
"the same third-party service and you would like them to share a common "
"throttling \"bucket\":"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:585
#, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new ThrottlesExceptions(10, 10))->by('key')];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:587
#, no-wrap
msgid ""
"> {tip} If you are using Redis, you may use the "
"`Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis` middleware, "
"which is fine-tuned for Redis and more efficient than the basic exception "
"throttling middleware.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:589
#, no-wrap
msgid "<a name=\"dispatching-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:589
#, no-wrap
msgid "Dispatching Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:592
msgid ""
"Once you have written your job class, you may dispatch it using the "
"`dispatch` method on the job itself. The arguments passed to the `dispatch` "
"method will be given to the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:596 docs/master/queues.md:634 docs/master/queues.md:687 docs/master/queues.md:809 docs/master/queues.md:868
#, no-wrap
msgid "    namespace App\\Http\\Controllers;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:601 docs/master/queues.md:639 docs/master/queues.md:692 docs/master/queues.md:814 docs/master/queues.md:873
#, no-wrap
msgid ""
"    use App\\Http\\Controllers\\Controller;\n"
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Models\\Podcast;\n"
"    use Illuminate\\Http\\Request;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:613 docs/master/queues.md:651 docs/master/queues.md:704 docs/master/queues.md:826 docs/master/queues.md:885
#, no-wrap
msgid ""
"    class PodcastController extends Controller\n"
"    {\n"
"        /**\n"
"         * Store a new podcast.\n"
"         *\n"
"         * @param  \\Illuminate\\Http\\Request  $request\n"
"         * @return \\Illuminate\\Http\\Response\n"
"         */\n"
"        public function store(Request $request)\n"
"        {\n"
"            $podcast = Podcast::create(...);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:615 docs/master/queues.md:653
#, no-wrap
msgid "            // ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:619
#, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:621
msgid ""
"If you would like to conditionally dispatch a job, you may use the "
"`dispatchIf` and `dispatchUnless` methods:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:623
#, no-wrap
msgid "    ProcessPodcast::dispatchIf($accountActive, $podcast);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:625
#, no-wrap
msgid "    ProcessPodcast::dispatchUnless($accountSuspended, $podcast);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:627
#, no-wrap
msgid "<a name=\"delayed-dispatching\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:627
#, no-wrap
msgid "Delayed Dispatching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:630
msgid ""
"If you would like to specify that a job should not be immediately available "
"for processing by a queue worker, you may use the `delay` method when "
"dispatching the job. For example, let's specify that a job should not be "
"available for processing until 10 minutes after it has been dispatched:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:658
#, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)\n"
"                        ->delay(now()->addMinutes(10));\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:660
#, no-wrap
msgid ""
"> {note} The Amazon SQS queue service has a maximum delay time of 15 "
"minutes.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:662
#, no-wrap
msgid "<a name=\"dispatching-after-the-response-is-sent-to-browser\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:662
#, no-wrap
msgid "Dispatching After The Response Is Sent To Browser"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:665
msgid ""
"Alternatively, the `dispatchAfterResponse` method delays dispatching a job "
"until after the HTTP response is sent to the user's browser. This will still "
"allow the user to begin using the application even though a queued job is "
"still executing. This should typically only be used for jobs that take about "
"a second, such as sending an email. Since they are processed within the "
"current HTTP request, jobs dispatched in this fashion do not require a queue "
"worker to be running in order for them to be processed:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:667
#, no-wrap
msgid "    use App\\Jobs\\SendNotification;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:669
#, no-wrap
msgid "    SendNotification::dispatchAfterResponse();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:671
msgid ""
"You may also `dispatch` a closure and chain the `afterResponse` method onto "
"the `dispatch` helper to execute a closure after the HTTP response has been "
"sent to the browser:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:674
#, no-wrap
msgid ""
"    use App\\Mail\\WelcomeMessage;\n"
"    use Illuminate\\Support\\Facades\\Mail;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:678
#, no-wrap
msgid ""
"    dispatch(function () {\n"
"        Mail::to('taylor@example.com')->send(new WelcomeMessage);\n"
"    })->afterResponse();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:680
#, no-wrap
msgid "<a name=\"synchronous-dispatching\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:680
#, no-wrap
msgid "Synchronous Dispatching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:683
msgid ""
"If you would like to dispatch a job immediately (synchronously), you may use "
"the `dispatchSync` method. When using this method, the job will not be "
"queued and will be executed immediately within the current process:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:706 docs/master/queues.md:828 docs/master/queues.md:887
#, no-wrap
msgid "            // Create podcast...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:710
#, no-wrap
msgid ""
"            ProcessPodcast::dispatchSync($podcast);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:712
#, no-wrap
msgid "<a name=\"jobs-and-database-transactions\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:712
#, no-wrap
msgid "Jobs & Database Transactions"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:715
msgid ""
"While it is perfectly fine to dispatch jobs within database transactions, "
"you should take special care to ensure that your job will actually be able "
"to execute successfully. When dispatching a job within a transaction, it is "
"possible that the job will be processed by a worker before the transaction "
"has committed. When this happens, any updates you have made to models or "
"database records during the database transaction may not yet be reflected in "
"the database. In addition, any models or database records created within the "
"transaction may not exist in the database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:717
msgid ""
"Thankfully, Laravel provides several methods of working around this "
"problem. First, you may set the `after_commit` connection option in your "
"queue connection's configuration array:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:723
#, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        // ...\n"
"        'after_commit' => true,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:725
msgid ""
"When the `after_commit` option is `true`, you may dispatch jobs within "
"database transactions; however, Laravel will wait until all open database "
"transactions have been committed before actually dispatching the job. Of "
"course, if no database transactions are currently open, the job will be "
"dispatched immediately."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:727
msgid ""
"If a transaction is rolled back due to an exception that occurs during the "
"transaction, the dispatched jobs that were dispatched during that "
"transaction will be discarded."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:729
#, no-wrap
msgid ""
"> {tip} Setting the `after_commit` configuration option to `true` will also "
"cause any queued event listeners, mailables, notifications, and broadcast "
"events to be dispatched after all open database transactions have been "
"committed.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:731
#, no-wrap
msgid "<a name=\"specifying-commit-dispatch-behavior-inline\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:731
#, no-wrap
msgid "Specifying Commit Dispatch Behavior Inline"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:734
msgid ""
"If you do not set the `after_commit` queue connection configuration option "
"to `true`, you may still indicate that a specific job should be dispatched "
"after all open database transactions have been committed. To accomplish "
"this, you may chain the `afterCommit` method onto your dispatch operation:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:738
#, no-wrap
msgid "    ProcessPodcast::dispatch($podcast)->afterCommit();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:740
msgid ""
"Likewise, if the `after_commit` configuration option is set to `true`, you "
"may indicate that a specific job should be dispatched immediately without "
"waiting for any open database transactions to commit:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:742
#, no-wrap
msgid "    ProcessPodcast::dispatch($podcast)->beforeCommit();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:744
#, no-wrap
msgid "<a name=\"job-chaining\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:744
#, no-wrap
msgid "Job Chaining"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:747
msgid ""
"Job chaining allows you to specify a list of queued jobs that should be run "
"in sequence after the primary job has executed successfully. If one job in "
"the sequence fails, the rest of the jobs will not be run. To execute a "
"queued job chain, you may use the `chain` method provided by the `Bus` "
"facade. Laravel's command bus is a lower level component that queued job "
"dispatching is built on top of:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:752
#, no-wrap
msgid ""
"    use App\\Jobs\\OptimizePodcast;\n"
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Jobs\\ReleasePodcast;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:758
#, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:760
msgid "In addition to chaining job class instances, you may also chain closures:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:768
#, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        function () {\n"
"            Podcast::update(...);\n"
"        },\n"
"    ])->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:770
#, no-wrap
msgid ""
"> {note} Deleting jobs using the `$this->delete()` method within the job "
"will not prevent chained jobs from being processed. The chain will only stop "
"executing if a job in the chain fails.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:772
#, no-wrap
msgid "<a name=\"chain-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:772
#, no-wrap
msgid "Chain Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:775
msgid ""
"If you would like to specify the connection and queue that should be used "
"for the chained jobs, you may use the `onConnection` and `onQueue` "
"methods. These methods specify the queue connection and queue name that "
"should be used unless the queued job is explicitly assigned a different "
"connection / queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:781
#, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->onConnection('redis')->onQueue('podcasts')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:783
#, no-wrap
msgid "<a name=\"chain-failures\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:783
#, no-wrap
msgid "Chain Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:786
msgid ""
"When chaining jobs, you may use the `catch` method to specify a closure that "
"should be invoked if a job within the chain fails. The given callback will "
"receive the `Throwable` instance that caused the job failure:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:789
#, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:797
#, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->catch(function (Throwable $e) {\n"
"        // A job within the chain has failed...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:799
#, no-wrap
msgid "<a name=\"customizing-the-queue-and-connection\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:799
#, no-wrap
msgid "Customizing The Queue & Connection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:802
#, no-wrap
msgid "<a name=\"dispatching-to-a-particular-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:802
#, no-wrap
msgid "Dispatching To A Particular Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:805
msgid ""
"By pushing jobs to different queues, you may \"categorize\" your queued jobs "
"and even prioritize how many workers you assign to various queues. Keep in "
"mind, this does not push jobs to different queue \"connections\" as defined "
"by your queue configuration file, but only to specific queues within a "
"single connection. To specify the queue, use the `onQueue` method when "
"dispatching the job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:832
#, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:834
msgid ""
"Alternatively, you may specify the job's queue by calling the `onQueue` "
"method within the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:844 docs/master/queues.md:909
#, no-wrap
msgid ""
"     use Illuminate\\Bus\\Queueable;\n"
"     use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"     use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"     use Illuminate\\Queue\\InteractsWithQueue;\n"
"     use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:859
#, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function __construct()\n"
"        {\n"
"            $this->onQueue('processing');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:861
#, no-wrap
msgid "<a name=\"dispatching-to-a-particular-connection\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:861
#, no-wrap
msgid "Dispatching To A Particular Connection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:864
msgid ""
"If your application interacts with multiple queue connections, you may "
"specify which connection to push a job to using the `onConnection` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:891
#, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:893
msgid ""
"You may chain the `onConnection` and `onQueue` methods together to specify "
"the connection and the queue for a job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:897
#, no-wrap
msgid ""
"    ProcessPodcast::dispatch($podcast)\n"
"                  ->onConnection('sqs')\n"
"                  ->onQueue('processing');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:899
msgid ""
"Alternatively, you may specify the job's connection by calling the "
"`onConnection` method within the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:924
#, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function __construct()\n"
"        {\n"
"            $this->onConnection('sqs');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:926
#, no-wrap
msgid "<a name=\"max-job-attempts-and-timeout\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:926
#, no-wrap
msgid "Specifying Max Job Attempts / Timeout Values"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:929
#, no-wrap
msgid "<a name=\"max-attempts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:929
#, no-wrap
msgid "Max Attempts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:932
msgid ""
"If one of your queued jobs is encountering an error, you likely do not want "
"it to keep retrying indefinitely. Therefore, Laravel provides various ways "
"to specify how many times or for how long a job may be attempted."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:934
msgid ""
"One approach to specifying the maximum number of times a job may be "
"attempted is via the `--tries` switch on the Artisan command line. This will "
"apply to all jobs processed by the worker unless the job being processed "
"specifies a more specific number of times it may be attempted:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:936
#, no-wrap
msgid "    php artisan queue:work --tries=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:938
msgid ""
"If a job exceeds its maximum number of attempts, it will be considered a "
"\"failed\" job. For more information on handling failed jobs, consult the "
"[failed job documentation](#dealing-with-failed-jobs)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:940
msgid ""
"You may take a more granular approach by defining the maximum number of "
"times a job may be attempted on the job class itself. If the maximum number "
"of attempts is specified on the job, it will take precedence over the "
"`--tries` value provided on the command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:954
#, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of times the job may be attempted.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $tries = 5;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:956
#, no-wrap
msgid "<a name=\"time-based-attempts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:956
#, no-wrap
msgid "Time Based Attempts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:959
msgid ""
"As an alternative to defining how many times a job may be attempted before "
"it fails, you may define a time at which the job should no longer be "
"attempted. This allows a job to be attempted any number of times within a "
"given time frame. To define the time at which a job should no longer be "
"attempted, add a `retryUntil` method to your job class. This method should "
"return a `DateTime` instance:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:969
#, no-wrap
msgid ""
"    /**\n"
"     * Determine the time at which the job should timeout.\n"
"     *\n"
"     * @return \\DateTime\n"
"     */\n"
"    public function retryUntil()\n"
"    {\n"
"        return now()->addMinutes(10);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:971
#, no-wrap
msgid ""
"> {tip} You may also define a `tries` property or `retryUntil` method on "
"your [queued event "
"listeners](/docs/{{version}}/events#queued-event-listeners).\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:973
#, no-wrap
msgid "<a name=\"max-exceptions\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:973
#, no-wrap
msgid "Max Exceptions"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:976
msgid ""
"Sometimes you may wish to specify that a job may be attempted many times, "
"but should fail if the retries are triggered by a given number of unhandled "
"exceptions (as opposed to being released by the `release` method "
"directly). To accomplish this, you may define a `maxExceptions` property on "
"your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:991
#, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of times the job may be attempted.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $tries = 25;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:998
#, no-wrap
msgid ""
"        /**\n"
"         * The maximum number of unhandled exceptions to allow before "
"failing.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $maxExceptions = 3;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1014
#, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function handle()\n"
"        {\n"
"            Redis::throttle('key')->allow(10)->every(60)->then(function () "
"{\n"
"                // Lock obtained, process the podcast...\n"
"            }, function () {\n"
"                // Unable to obtain lock...\n"
"                return $this->release(10);\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1016
msgid ""
"In this example, the job is released for ten seconds if the application is "
"unable to obtain a Redis lock and will continue to be retried up to 25 "
"times. However, the job will fail if three unhandled exceptions are thrown "
"by the job."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1018
#, no-wrap
msgid "<a name=\"timeout\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1018
#, no-wrap
msgid "Timeout"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1021
#, no-wrap
msgid ""
"> {note} The `pcntl` PHP extension must be installed in order to specify job "
"timeouts.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1023
msgid ""
"Often, you know roughly how long you expect your queued jobs to take. For "
"this reason, Laravel allows you to specify a \"timeout\" value. If a job is "
"processing for longer than the number of seconds specified by the timeout "
"value, the worker processing the job will exit with an error. Typically, the "
"worker will be restarted automatically by a [process manager configured on "
"your server](#supervisor-configuration)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1025
msgid ""
"The maximum number of seconds that jobs can run may be specified using the "
"`--timeout` switch on the Artisan command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1027
#, no-wrap
msgid "    php artisan queue:work --timeout=30\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1029
msgid ""
"If the job exceeds its maximum attempts by continually timing out, it will "
"be marked as failed."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1031
msgid ""
"You may also define the maximum number of seconds a job should be allowed to "
"run on the job class itself. If the timeout is specified on the job, it will "
"take precedence over any timeout specified on the command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1045
#, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of seconds the job can run before timing out.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $timeout = 120;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1047
msgid ""
"Sometimes, IO blocking processes such as sockets or outgoing HTTP "
"connections may not respect your specified timeout. Therefore, when using "
"these features, you should always attempt to specify a timeout using their "
"APIs as well. For example, when using Guzzle, you should always specify a "
"connection and request timeout value."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1049
#, no-wrap
msgid "<a name=\"failing-on-timeout\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1049
#, no-wrap
msgid "Failing On Timeout"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1052
msgid ""
"If you would like to indicate that a job should be marked as "
"[failed](#dealing-with-failed-jobs) on timeout, you may define the "
"`$failOnTimeout` property on the job class:"
msgstr ""

#. type: Code fence info string
#: docs/master/queues.md:1053 docs/master/queues.md:1763 docs/master/queues.md:1852
#, no-wrap
msgid "php"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1053
#, no-wrap
msgid ""
"/**\n"
" * Indicate if the job should be marked as failed on timeout.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $failOnTimeout = true;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1063
#, no-wrap
msgid "<a name=\"error-handling\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1063
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1066
msgid ""
"If an exception is thrown while the job is being processed, the job will "
"automatically be released back onto the queue so it may be attempted "
"again. The job will continue to be released until it has been attempted the "
"maximum number of times allowed by your application. The maximum number of "
"attempts is defined by the `--tries` switch used on the `queue:work` Artisan "
"command. Alternatively, the maximum number of attempts may be defined on the "
"job class itself. More information on running the queue worker [can be found "
"below](#running-the-queue-worker)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1068
#, no-wrap
msgid "<a name=\"manually-releasing-a-job\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1068
#, no-wrap
msgid "Manually Releasing A Job"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1071
msgid ""
"Sometimes you may wish to manually release a job back onto the queue so that "
"it can be attempted again at a later time. You may accomplish this by "
"calling the `release` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1080 docs/master/queues.md:1101
#, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        // ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1083
#, no-wrap
msgid ""
"        $this->release();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1085
msgid ""
"By default, the `release` method will release the job back onto the queue "
"for immediate processing. However, by passing an integer to the `release` "
"method you may instruct the queue to not make the job available for "
"processing until a given number of seconds has elapsed:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1087
#, no-wrap
msgid "    $this->release(10);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1089
#, no-wrap
msgid "<a name=\"manually-failing-a-job\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1089
#, no-wrap
msgid "Manually Failing A Job"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1092
msgid ""
"Occasionally you may need to manually mark a job as \"failed\". To do so, "
"you may call the `fail` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1104
#, no-wrap
msgid ""
"        $this->fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1106
msgid ""
"If you would like to mark your job as failed because of an exception that "
"you have caught, you may pass the exception to the `fail` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1108
#, no-wrap
msgid "    $this->fail($exception);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1110
#, no-wrap
msgid ""
"> {tip} For more information on failed jobs, check out the [documentation on "
"dealing with job failures](#dealing-with-failed-jobs).\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1112
#, no-wrap
msgid "<a name=\"job-batching\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1112
#, no-wrap
msgid "Job Batching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1115
msgid ""
"Laravel's job batching feature allows you to easily execute a batch of jobs "
"and then perform some action when the batch of jobs has completed "
"executing. Before getting started, you should create a database migration to "
"build a table to contain meta information about your job batches, such as "
"their completion percentage. This migration may be generated using the "
"`queue:batches-table` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1117
#, no-wrap
msgid "    php artisan queue:batches-table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1121
#, no-wrap
msgid "<a name=\"defining-batchable-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1121
#, no-wrap
msgid "Defining Batchable Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1124
msgid ""
"To define a batchable job, you should [create a queueable "
"job](#creating-jobs) as normal; however, you should add the "
"`Illuminate\\Bus\\Batchable` trait to the job class. This trait provides "
"access to a `batch` method which may be used to retrieve the current batch "
"that the job is executing within:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1135
#, no-wrap
msgid ""
"    use Illuminate\\Bus\\Batchable;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1139
#, no-wrap
msgid ""
"    class ImportCsv implements ShouldQueue\n"
"    {\n"
"        use Batchable, Dispatchable, InteractsWithQueue, Queueable, "
"SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1149
#, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function handle()\n"
"        {\n"
"            if ($this->batch()->cancelled()) {\n"
"                // Determine if the batch has been cancelled...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1152
#, no-wrap
msgid ""
"                return;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1156
#, no-wrap
msgid ""
"            // Import a portion of the CSV file...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1158
#, no-wrap
msgid "<a name=\"dispatching-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1158
#, no-wrap
msgid "Dispatching Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1161
msgid ""
"To dispatch a batch of jobs, you should use the `batch` method of the `Bus` "
"facade. Of course, batching is primarily useful when combined with "
"completion callbacks. So, you may use the `then`, `catch`, and `finally` "
"methods to define completion callbacks for the batch. Each of these "
"callbacks will receive an `Illuminate\\Bus\\Batch` instance when they are "
"invoked. In this example, we will imagine we are queueing a batch of jobs "
"that each process a given number of rows from a CSV file:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1166
#, no-wrap
msgid ""
"    use App\\Jobs\\ImportCsv;\n"
"    use Illuminate\\Bus\\Batch;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1180
#, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        new ImportCsv(1, 100),\n"
"        new ImportCsv(101, 200),\n"
"        new ImportCsv(201, 300),\n"
"        new ImportCsv(301, 400),\n"
"        new ImportCsv(401, 500),\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->catch(function (Batch $batch, Throwable $e) {\n"
"        // First batch job failure detected...\n"
"    })->finally(function (Batch $batch) {\n"
"        // The batch has finished executing...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1182
#, no-wrap
msgid "    return $batch->id;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1184
#, no-wrap
msgid ""
"The batch's ID, which may be accessed via the `$batch->id` property, may be "
"used to [query the Laravel command bus](#inspecting-batches) for information "
"about the batch after it has been dispatched.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1186
#, no-wrap
msgid ""
"> {note} Since batch callbacks are serialized and executed at a later time "
"by the Laravel queue, you should not use the `$this` variable within the "
"callbacks.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1188
#, no-wrap
msgid "<a name=\"naming-batches\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1188
#, no-wrap
msgid "Naming Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1191
msgid ""
"Some tools such as Laravel Horizon and Laravel Telescope may provide more "
"user-friendly debug information for batches if batches are named. To assign "
"an arbitrary name to a batch, you may call the `name` method while defining "
"the batch:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1197
#, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->name('Import CSV')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1199
#, no-wrap
msgid "<a name=\"batch-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1199
#, no-wrap
msgid "Batch Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1202
msgid ""
"If you would like to specify the connection and queue that should be used "
"for the batched jobs, you may use the `onConnection` and `onQueue` "
"methods. All batched jobs must execute within the same connection and queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1208
#, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->onConnection('redis')->onQueue('imports')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1210
#, no-wrap
msgid "<a name=\"chains-within-batches\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1210
#, no-wrap
msgid "Chains Within Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1213
msgid ""
"You may define a set of [chained jobs](#job-chaining) within a batch by "
"placing the chained jobs within an array. For example, we may execute two "
"job chains in parallel and execute a callback when both job chains have "
"finished processing:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1218
#, no-wrap
msgid ""
"    use App\\Jobs\\ReleasePodcast;\n"
"    use App\\Jobs\\SendPodcastReleaseNotification;\n"
"    use Illuminate\\Bus\\Batch;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1231
#, no-wrap
msgid ""
"    Bus::batch([\n"
"        [\n"
"            new ReleasePodcast(1),\n"
"            new SendPodcastReleaseNotification(1),\n"
"        ],\n"
"        [\n"
"            new ReleasePodcast(2),\n"
"            new SendPodcastReleaseNotification(2),\n"
"        ],\n"
"    ])->then(function (Batch $batch) {\n"
"        // ...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1233
#, no-wrap
msgid "<a name=\"adding-jobs-to-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1233
#, no-wrap
msgid "Adding Jobs To Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1236
msgid ""
"Sometimes it may be useful to add additional jobs to a batch from within a "
"batched job. This pattern can be useful when you need to batch thousands of "
"jobs which may take too long to dispatch during a web request. So, instead, "
"you may wish to dispatch an initial batch of \"loader\" jobs that hydrate "
"the batch with even more jobs:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1244
#, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        new LoadImportBatch,\n"
"        new LoadImportBatch,\n"
"        new LoadImportBatch,\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->name('Import Contacts')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1246
msgid ""
"In this example, we will use the `LoadImportBatch` job to hydrate the batch "
"with additional jobs. To accomplish this, we may use the `add` method on the "
"batch instance that may be accessed via the job's `batch` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1249
#, no-wrap
msgid ""
"    use App\\Jobs\\ImportContacts;\n"
"    use Illuminate\\Support\\Collection;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1260 docs/master/queues.md:1350
#, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1265
#, no-wrap
msgid ""
"        $this->batch()->add(Collection::times(1000, function () {\n"
"            return new ImportContacts;\n"
"        }));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1267
#, no-wrap
msgid ""
"> {note} You may only add jobs to a batch from within a job that belongs to "
"the same batch.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1269
#, no-wrap
msgid "<a name=\"inspecting-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1269
#, no-wrap
msgid "Inspecting Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1272
msgid ""
"The `Illuminate\\Bus\\Batch` instance that is provided to batch completion "
"callbacks has a variety of properties and methods to assist you in "
"interacting with and inspecting a given batch of jobs:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1275
#, no-wrap
msgid ""
"    // The UUID of the batch...\n"
"    $batch->id;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1278
#, no-wrap
msgid ""
"    // The name of the batch (if applicable)...\n"
"    $batch->name;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1281
#, no-wrap
msgid ""
"    // The number of jobs assigned to the batch...\n"
"    $batch->totalJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1284
#, no-wrap
msgid ""
"    // The number of jobs that have not been processed by the queue...\n"
"    $batch->pendingJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1287
#, no-wrap
msgid ""
"    // The number of jobs that have failed...\n"
"    $batch->failedJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1290
#, no-wrap
msgid ""
"    // The number of jobs that have been processed thus far...\n"
"    $batch->processedJobs();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1293
#, no-wrap
msgid ""
"    // The completion percentage of the batch (0-100)...\n"
"    $batch->progress();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1296
#, no-wrap
msgid ""
"    // Indicates if the batch has finished executing...\n"
"    $batch->finished();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1299
#, no-wrap
msgid ""
"    // Cancel the execution of the batch...\n"
"    $batch->cancel();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1302
#, no-wrap
msgid ""
"    // Indicates if the batch has been cancelled...\n"
"    $batch->cancelled();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1304
#, no-wrap
msgid "<a name=\"returning-batches-from-routes\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1304
#, no-wrap
msgid "Returning Batches From Routes"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1307
msgid ""
"All `Illuminate\\Bus\\Batch` instances are JSON serializable, meaning you "
"can return them directly from one of your application's routes to retrieve a "
"JSON payload containing information about the batch, including its "
"completion progress. This makes it convenient to display information about "
"the batch's completion progress in your application's UI."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1309
msgid ""
"To retrieve a batch by its ID, you may use the `Bus` facade's `findBatch` "
"method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1312
#, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Illuminate\\Support\\Facades\\Route;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1316
#, no-wrap
msgid ""
"    Route::get('/batch/{batchId}', function (string $batchId) {\n"
"        return Bus::findBatch($batchId);\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1318
#, no-wrap
msgid "<a name=\"cancelling-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1318
#, no-wrap
msgid "Cancelling Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1321
msgid ""
"Sometimes you may need to cancel a given batch's execution. This can be "
"accomplished by calling the `cancel` method on the `Illuminate\\Bus\\Batch` "
"instance:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1332
#, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->user->exceedsImportLimit()) {\n"
"            return $this->batch()->cancel();\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1337
#, no-wrap
msgid ""
"        if ($this->batch()->cancelled()) {\n"
"            return;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1339
msgid ""
"As you may have noticed in previous examples, batched jobs should typically "
"check to see if the batch has been cancelled at the beginning of their "
"`handle` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1353
#, no-wrap
msgid ""
"        // Continue processing...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1355
#, no-wrap
msgid "<a name=\"batch-failures\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1355
#, no-wrap
msgid "Batch Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1358
msgid ""
"When a batched job fails, the `catch` callback (if assigned) will be "
"invoked. This callback is only invoked for the first job that fails within "
"the batch."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1360
#, no-wrap
msgid "<a name=\"allowing-failures\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1360
#, no-wrap
msgid "Allowing Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1363
msgid ""
"When a job within a batch fails, Laravel will automatically mark the batch "
"as \"cancelled\". If you wish, you may disable this behavior so that a job "
"failure does not automatically mark the batch as cancelled. This may be "
"accomplished by calling the `allowFailures` method while dispatching the "
"batch:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1369
#, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->allowFailures()->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1371
#, no-wrap
msgid "<a name=\"retrying-failed-batch-jobs\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1371
#, no-wrap
msgid "Retrying Failed Batch Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1374
msgid ""
"For convenience, Laravel provides a `queue:retry-batch` Artisan command that "
"allows you to easily retry all of the failed jobs for a given batch. The "
"`queue:retry-batch` command accepts the UUID of the batch whose failed jobs "
"should be retried:"
msgstr ""

#. type: Code fence info string
#: docs/master/queues.md:1375 docs/master/queues.md:1524 docs/master/queues.md:1577 docs/master/queues.md:1846
#, no-wrap
msgid "bash"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1375
#, no-wrap
msgid "php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1380
#, no-wrap
msgid "<a name=\"pruning-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1380
#, no-wrap
msgid "Pruning Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1383
msgid ""
"Without pruning, the `job_batches` table can accumulate records very "
"quickly. To mitigate this, you should "
"[schedule](/docs/{{version}}/scheduling) the `queue:prune-batches` Artisan "
"command to run daily:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1385
#, no-wrap
msgid "    $schedule->command('queue:prune-batches')->daily();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1387
msgid ""
"By default, all finished batches that are more than 24 hours old will be "
"pruned. You may use the `hours` option when calling the command to determine "
"how long to retain batch data. For example, the following command will "
"delete all batches that finished over 48 hours ago:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1389
#, no-wrap
msgid "    $schedule->command('queue:prune-batches --hours=48')->daily();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1391
msgid ""
"Sometimes, your `jobs_batches` table may accumulate batch records for "
"batches that never completed successfully, such as batches where a job "
"failed and that job was never retried successfully. You may instruct the "
"`queue:prune-batches` command to prune these unfinished batch records using "
"the `unfinished` option:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1393
#, no-wrap
msgid ""
"    $schedule->command('queue:prune-batches --hours=48 "
"--unfinished=72')->daily();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1395
#, no-wrap
msgid "<a name=\"queueing-closures\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1395
#, no-wrap
msgid "Queueing Closures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1398
msgid ""
"Instead of dispatching a job class to the queue, you may also dispatch a "
"closure. This is great for quick, simple tasks that need to be executed "
"outside of the current request cycle. When dispatching closures to the "
"queue, the closure's code content is cryptographically signed so that it can "
"not be modified in transit:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1400
#, no-wrap
msgid "    $podcast = App\\Podcast::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1404
#, no-wrap
msgid ""
"    dispatch(function () use ($podcast) {\n"
"        $podcast->publish();\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1406
msgid ""
"Using the `catch` method, you may provide a closure that should be executed "
"if the queued closure fails to complete successfully after exhausting all of "
"your queue's [configured retry attempts](#max-job-attempts-and-timeout):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1408
#, no-wrap
msgid "    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1414
#, no-wrap
msgid ""
"    dispatch(function () use ($podcast) {\n"
"        $podcast->publish();\n"
"    })->catch(function (Throwable $e) {\n"
"        // This job has failed...\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1416
#, no-wrap
msgid "<a name=\"running-the-queue-worker\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1416
#, no-wrap
msgid "Running The Queue Worker"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1419
#, no-wrap
msgid "<a name=\"the-queue-work-command\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1419
#, no-wrap
msgid "The `queue:work` Command"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1422
msgid ""
"Laravel includes an Artisan command that will start a queue worker and "
"process new jobs as they are pushed onto the queue. You may run the worker "
"using the `queue:work` Artisan command. Note that once the `queue:work` "
"command has started, it will continue to run until it is manually stopped or "
"you close your terminal:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1424
#, no-wrap
msgid "    php artisan queue:work\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1426
#, no-wrap
msgid ""
"> {tip} To keep the `queue:work` process running permanently in the "
"background, you should use a process monitor such as "
"[Supervisor](#supervisor-configuration) to ensure that the queue worker does "
"not stop running.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1428
msgid ""
"Remember, queue workers, are long-lived processes and store the booted "
"application state in memory. As a result, they will not notice changes in "
"your code base after they have been started. So, during your deployment "
"process, be sure to [restart your queue "
"workers](#queue-workers-and-deployment). In addition, remember that any "
"static state created or modified by your application will not be "
"automatically reset between jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1430
msgid ""
"Alternatively, you may run the `queue:listen` command. When using the "
"`queue:listen` command, you don't have to manually restart the worker when "
"you want to reload your updated code or reset the application state; "
"however, this command is significantly less efficient than the `queue:work` "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1432
#, no-wrap
msgid "    php artisan queue:listen\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1434
#, no-wrap
msgid "<a name=\"running-multiple-queue-workers\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1434
#, no-wrap
msgid "Running Multiple Queue Workers"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1437
msgid ""
"To assign multiple workers to a queue and process jobs concurrently, you "
"should simply start multiple `queue:work` processes. This can either be done "
"locally via multiple tabs in your terminal or in production using your "
"process manager's configuration settings. [When using "
"Supervisor](#supervisor-configuration), you may use the `numprocs` "
"configuration value."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1439
#, no-wrap
msgid "<a name=\"specifying-the-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1439
#, no-wrap
msgid "Specifying The Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1442
msgid ""
"You may also specify which queue connection the worker should utilize. The "
"connection name passed to the `work` command should correspond to one of the "
"connections defined in your `config/queue.php` configuration file:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1444
#, no-wrap
msgid "    php artisan queue:work redis\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1446
msgid ""
"By default, the `queue:work` command only processes jobs for the default "
"queue on a given connection. However, you may customize your queue worker "
"even further by only processing particular queues for a given "
"connection. For example, if all of your emails are processed in an `emails` "
"queue on your `redis` queue connection, you may issue the following command "
"to start a worker that only processes that queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1448
#, no-wrap
msgid "    php artisan queue:work redis --queue=emails\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1450
#, no-wrap
msgid "<a name=\"processing-a-specified-number-of-jobs\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1450
#, no-wrap
msgid "Processing A Specified Number Of Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1453
msgid ""
"The `--once` option may be used to instruct the worker to only process a "
"single job from the queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1455
#, no-wrap
msgid "    php artisan queue:work --once\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1457
msgid ""
"The `--max-jobs` option may be used to instruct the worker to process the "
"given number of jobs and then exit. This option may be useful when combined "
"with [Supervisor](#supervisor-configuration) so that your workers are "
"automatically restarted after processing a given number of jobs, releasing "
"any memory they may have accumulated:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1459
#, no-wrap
msgid "    php artisan queue:work --max-jobs=1000\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1461
#, no-wrap
msgid "<a name=\"processing-all-queued-jobs-then-exiting\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1461
#, no-wrap
msgid "Processing All Queued Jobs & Then Exiting"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1464
msgid ""
"The `--stop-when-empty` option may be used to instruct the worker to process "
"all jobs and then exit gracefully. This option can be useful when processing "
"Laravel queues within a Docker container if you wish to shutdown the "
"container after the queue is empty:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1466
#, no-wrap
msgid "    php artisan queue:work --stop-when-empty\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1468
#, no-wrap
msgid "<a name=\"processing-jobs-for-a-given-number-of-seconds\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1468
#, no-wrap
msgid "Processing Jobs For A Given Number Of Seconds"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1471
msgid ""
"The `--max-time` option may be used to instruct the worker to process jobs "
"for the given number of seconds and then exit. This option may be useful "
"when combined with [Supervisor](#supervisor-configuration) so that your "
"workers are automatically restarted after processing jobs for a given amount "
"of time, releasing any memory they may have accumulated:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1474
#, no-wrap
msgid ""
"    // Process jobs for one hour and then exit...\n"
"    php artisan queue:work --max-time=3600\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1476
#, no-wrap
msgid "<a name=\"worker-sleep-duration\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1476
#, no-wrap
msgid "Worker Sleep Duration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1479
msgid ""
"When jobs are available on the queue, the worker will keep processing jobs "
"with no delay in between them. However, the `sleep` option determines how "
"many seconds the worker will \"sleep\" if there are no new jobs "
"available. While sleeping, the worker will not process any new jobs - the "
"jobs will be processed after the worker wakes up again."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1481
#, no-wrap
msgid "    php artisan queue:work --sleep=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1483
#, no-wrap
msgid "<a name=\"resource-considerations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1483
#, no-wrap
msgid "Resource Considerations"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1486
msgid ""
"Daemon queue workers do not \"reboot\" the framework before processing each "
"job. Therefore, you should release any heavy resources after each job "
"completes. For example, if you are doing image manipulation with the GD "
"library, you should free the memory with `imagedestroy` when you are done "
"processing the image."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1488
#, no-wrap
msgid "<a name=\"queue-priorities\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1488
#, no-wrap
msgid "Queue Priorities"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1491
msgid ""
"Sometimes you may wish to prioritize how your queues are processed. For "
"example, in your `config/queue.php` configuration file, you may set the "
"default `queue` for your `redis` connection to `low`. However, occasionally "
"you may wish to push a job to a `high` priority queue like so:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1493
#, no-wrap
msgid "    dispatch((new Job)->onQueue('high'));\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1495
msgid ""
"To start a worker that verifies that all of the `high` queue jobs are "
"processed before continuing to any jobs on the `low` queue, pass a "
"comma-delimited list of queue names to the `work` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1497
#, no-wrap
msgid "    php artisan queue:work --queue=high,low\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1499
#, no-wrap
msgid "<a name=\"queue-workers-and-deployment\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1499
#, no-wrap
msgid "Queue Workers & Deployment"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1502
msgid ""
"Since queue workers are long-lived processes, they will not notice changes "
"to your code without being restarted. So, the simplest way to deploy an "
"application using queue workers is to restart the workers during your "
"deployment process. You may gracefully restart all of the workers by issuing "
"the `queue:restart` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1504
#, no-wrap
msgid "    php artisan queue:restart\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1506
msgid ""
"This command will instruct all queue workers to gracefully exit after they "
"finish processing their current job so that no existing jobs are lost. Since "
"the queue workers will exit when the `queue:restart` command is executed, "
"you should be running a process manager such as "
"[Supervisor](#supervisor-configuration) to automatically restart the queue "
"workers."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1508
#, no-wrap
msgid ""
"> {tip} The queue uses the [cache](/docs/{{version}}/cache) to store restart "
"signals, so you should verify that a cache driver is properly configured for "
"your application before using this feature.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1510
#, no-wrap
msgid "<a name=\"job-expirations-and-timeouts\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1510
#, no-wrap
msgid "Job Expirations & Timeouts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1513
#, no-wrap
msgid "<a name=\"job-expiration\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1513
#, no-wrap
msgid "Job Expiration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1516
msgid ""
"In your `config/queue.php` configuration file, each queue connection defines "
"a `retry_after` option. This option specifies how many seconds the queue "
"connection should wait before retrying a job that is being processed. For "
"example, if the value of `retry_after` is set to `90`, the job will be "
"released back onto the queue if it has been processing for 90 seconds "
"without being released or deleted. Typically, you should set the "
"`retry_after` value to the maximum number of seconds your jobs should "
"reasonably take to complete processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1518
#, no-wrap
msgid ""
"> {note} The only queue connection which does not contain a `retry_after` "
"value is Amazon SQS. SQS will retry the job based on the [Default Visibility "
"Timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) "
"which is managed within the AWS console.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1520
#, no-wrap
msgid "<a name=\"worker-timeouts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1520
#, no-wrap
msgid "Worker Timeouts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1523
msgid ""
"The `queue:work` Artisan command exposes a `--timeout` option. If a job is "
"processing for longer than the number of seconds specified by the timeout "
"value, the worker processing the job will exit with an error. Typically, the "
"worker will be restarted automatically by a [process manager configured on "
"your server](#supervisor-configuration):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1524
#, no-wrap
msgid "php artisan queue:work --timeout=60\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1529
msgid ""
"The `retry_after` configuration option and the `--timeout` CLI option are "
"different, but work together to ensure that jobs are not lost and that jobs "
"are only successfully processed once."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1531
#, no-wrap
msgid ""
"> {note} The `--timeout` value should always be at least several seconds "
"shorter than your `retry_after` configuration value. This will ensure that a "
"worker processing a frozen job is always terminated before the job is "
"retried. If your `--timeout` option is longer than your `retry_after` "
"configuration value, your jobs may be processed twice.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1533
#, no-wrap
msgid "<a name=\"supervisor-configuration\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1533
#, no-wrap
msgid "Supervisor Configuration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1536
msgid ""
"In production, you need a way to keep your `queue:work` processes running. A "
"`queue:work` process may stop running for a variety of reasons, such as an "
"exceeded worker timeout or the execution of the `queue:restart` command."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1538
msgid ""
"For this reason, you need to configure a process monitor that can detect "
"when your `queue:work` processes exit and automatically restart them. In "
"addition, process monitors can allow you to specify how many `queue:work` "
"processes you would like to run concurrently. Supervisor is a process "
"monitor commonly used in Linux environments and we will discuss how to "
"configure it in the following documentation."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1540
#, no-wrap
msgid "<a name=\"installing-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1540
#, no-wrap
msgid "Installing Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1543
msgid ""
"Supervisor is a process monitor for the Linux operating system, and will "
"automatically restart your `queue:work` processes if they fail. To install "
"Supervisor on Ubuntu, you may use the following command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1545
#, no-wrap
msgid "    sudo apt-get install supervisor\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1547
#, no-wrap
msgid ""
"> {tip} If configuring and managing Supervisor yourself sounds overwhelming, "
"consider using [Laravel Forge](https://forge.laravel.com), which will "
"automatically install and configure Supervisor for your production Laravel "
"projects.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1549
#, no-wrap
msgid "<a name=\"configuring-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1549
#, no-wrap
msgid "Configuring Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1552
msgid ""
"Supervisor configuration files are typically stored in the "
"`/etc/supervisor/conf.d` directory. Within this directory, you may create "
"any number of configuration files that instruct supervisor how your "
"processes should be monitored. For example, let's create a "
"`laravel-worker.conf` file that starts and monitors `queue:work` processes:"
msgstr ""

#. type: Code fence info string
#: docs/master/queues.md:1553
#, no-wrap
msgid "ini"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1553
#, no-wrap
msgid ""
"[program:laravel-worker]\n"
"process_name=%(program_name)s_%(process_num)02d\n"
"command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 "
"--max-time=3600\n"
"autostart=true\n"
"autorestart=true\n"
"stopasgroup=true\n"
"killasgroup=true\n"
"user=forge\n"
"numprocs=8\n"
"redirect_stderr=true\n"
"stdout_logfile=/home/forge/app.com/worker.log\n"
"stopwaitsecs=3600\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1569
msgid ""
"In this example, the `numprocs` directive will instruct Supervisor to run "
"eight `queue:work` processes and monitor all of them, automatically "
"restarting them if they fail. You should change the `command` directive of "
"the configuration to reflect your desired queue connection and worker "
"options."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1571
#, no-wrap
msgid ""
"> {note} You should ensure that the value of `stopwaitsecs` is greater than "
"the number of seconds consumed by your longest running job. Otherwise, "
"Supervisor may kill the job before it is finished processing.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1573
#, no-wrap
msgid "<a name=\"starting-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1573
#, no-wrap
msgid "Starting Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1576
msgid ""
"Once the configuration file has been created, you may update the Supervisor "
"configuration and start the processes using the following commands:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1577
#, no-wrap
msgid ""
"sudo supervisorctl reread\n"
"\n"
"sudo supervisorctl update\n"
"\n"
"sudo supervisorctl start laravel-worker:*\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1586
msgid ""
"For more information on Supervisor, consult the [Supervisor "
"documentation](http://supervisord.org/index.html)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1588
#, no-wrap
msgid "<a name=\"dealing-with-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1588
#, no-wrap
msgid "Dealing With Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1591
msgid ""
"Sometimes your queued jobs will fail. Don't worry, things don't always go as "
"planned! Laravel includes a convenient way to [specify the maximum number of "
"times a job should be attempted](#max-job-attempts-and-timeout). After a job "
"has exceeded this number of attempts, it will be inserted into the "
"`failed_jobs` database table. Of course, we will need to create that table "
"if it does not already exist. To create a migration for the `failed_jobs` "
"table, you may use the `queue:failed-table` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1593
#, no-wrap
msgid "    php artisan queue:failed-table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1597
msgid ""
"When running a [queue worker](#running-the-queue-worker) process, you may "
"specify the maximum number of times a job should be attempted using the "
"`--tries` switch on the `queue:work` command. If you do not specify a value "
"for the `--tries` option, jobs will only be attempted once or as many times "
"as specified by the job class' `$tries` property:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1599
#, no-wrap
msgid "    php artisan queue:work redis --tries=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1601
msgid ""
"Using the `--backoff` option, you may specify how many seconds Laravel "
"should wait before retrying a job that has encountered an exception. By "
"default, a job is immediately released back onto the queue so that it may be "
"attempted again:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1603
#, no-wrap
msgid "    php artisan queue:work redis --tries=3 --backoff=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1605
msgid ""
"If you would like to configure how many seconds Laravel should wait before "
"retrying a job that has encountered an exception on a per-job basis, you may "
"do so by defining a `backoff` property on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1612
#, no-wrap
msgid ""
"    /**\n"
"     * The number of seconds to wait before retrying the job.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $backoff = 3;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1614
msgid ""
"If you require more complex logic for determining the job's backoff time, "
"you may define a `backoff` method on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1624
#, no-wrap
msgid ""
"    /**\n"
"    * Calculate the number of seconds to wait before retrying the job.\n"
"    *\n"
"    * @return int\n"
"    */\n"
"    public function backoff()\n"
"    {\n"
"        return 3;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1626
msgid ""
"You may easily configure \"exponential\" backoffs by returning an array of "
"backoff values from the `backoff` method. In this example, the retry delay "
"will be 1 second for the first retry, 5 seconds for the second retry, and 10 "
"seconds for the third retry:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1636
#, no-wrap
msgid ""
"    /**\n"
"    * Calculate the number of seconds to wait before retrying the job.\n"
"    *\n"
"    * @return array\n"
"    */\n"
"    public function backoff()\n"
"    {\n"
"        return [1, 5, 10];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1638
#, no-wrap
msgid "<a name=\"cleaning-up-after-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1638
#, no-wrap
msgid "Cleaning Up After Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1641
msgid ""
"When a particular job fails, you may want to send an alert to your users or "
"revert any actions that were partially completed by the job. To accomplish "
"this, you may define a `failed` method on your job class. The `Throwable` "
"instance that caused the job to fail will be passed to the `failed` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1653
#, no-wrap
msgid ""
"    use App\\Models\\Podcast;\n"
"    use App\\Services\\AudioProcessor;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1657
#, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        use InteractsWithQueue, Queueable, SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1664
#, no-wrap
msgid ""
"        /**\n"
"         * The podcast instance.\n"
"         *\n"
"         * @var \\App\\Podcast\n"
"         */\n"
"        protected $podcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1675
#, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @param  \\App\\Models\\Podcast  $podcast\n"
"         * @return void\n"
"         */\n"
"        public function __construct(Podcast $podcast)\n"
"        {\n"
"            $this->podcast = $podcast;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1686
#, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @param  \\App\\Services\\AudioProcessor  $processor\n"
"         * @return void\n"
"         */\n"
"        public function handle(AudioProcessor $processor)\n"
"        {\n"
"            // Process uploaded podcast...\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1698
#, no-wrap
msgid ""
"        /**\n"
"         * Handle a job failure.\n"
"         *\n"
"         * @param  \\Throwable  $exception\n"
"         * @return void\n"
"         */\n"
"        public function failed(Throwable $exception)\n"
"        {\n"
"            // Send user notification of failure, etc...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1700
#, no-wrap
msgid ""
"> {note} A new instance of the job is instantiated before invoking the "
"`failed` method; therefore, any class property modifications that may have "
"occurred within the `handle` method will be lost.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1702
#, no-wrap
msgid "<a name=\"retrying-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1702
#, no-wrap
msgid "Retrying Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1705
msgid ""
"To view all of the failed jobs that have been inserted into your "
"`failed_jobs` database table, you may use the `queue:failed` Artisan "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1707
#, no-wrap
msgid "    php artisan queue:failed\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1709
msgid ""
"The `queue:failed` command will list the job ID, connection, queue, failure "
"time, and other information about the job. The job ID may be used to retry "
"the failed job. For instance, to retry a failed job that has an ID of "
"`ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece`, issue the following command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1711
#, no-wrap
msgid "    php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1713
msgid "If necessary, you may pass multiple IDs to the command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1715
#, no-wrap
msgid ""
"    php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece "
"91401d2c-0784-4f43-824c-34f94a33c24d\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1717
msgid "You may also retry all of the failed jobs for a particular queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1719
#, no-wrap
msgid "    php artisan queue:retry --queue=name\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1721
msgid ""
"To retry all of your failed jobs, execute the `queue:retry` command and pass "
"`all` as the ID:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1723
#, no-wrap
msgid "    php artisan queue:retry all\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1725
msgid ""
"If you would like to delete a failed job, you may use the `queue:forget` "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1727
#, no-wrap
msgid "    php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1729
#, no-wrap
msgid ""
"> {tip} When using [Horizon](/docs/{{version}}/horizon), you should use the "
"`horizon:forget` command to delete a failed job instead of the "
"`queue:forget` command.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1731
msgid ""
"To delete all of your failed jobs from the `failed_jobs` table, you may use "
"the `queue:flush` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1733
#, no-wrap
msgid "    php artisan queue:flush\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1735
#, no-wrap
msgid "<a name=\"ignoring-missing-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1735
#, no-wrap
msgid "Ignoring Missing Models"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1738
msgid ""
"When injecting an Eloquent model into a job, the model is automatically "
"serialized before being placed on the queue and re-retrieved from the "
"database when the job is processed. However, if the model has been deleted "
"while the job was waiting to be processed by a worker, your job may fail "
"with a `ModelNotFoundException`."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1740
msgid ""
"For convenience, you may choose to automatically delete jobs with missing "
"models by setting your job's `deleteWhenMissingModels` property to "
"`true`. When this property is set to `true`, Laravel will quietly discard "
"the job without raising an exception:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1747
#, no-wrap
msgid ""
"    /**\n"
"     * Delete the job if its models no longer exist.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $deleteWhenMissingModels = true;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1749
#, no-wrap
msgid "<a name=\"storing-failed-jobs-in-dynamodb\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1749
#, no-wrap
msgid "Storing Failed Jobs In DynamoDB"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1752
msgid ""
"Laravel also provides support for storing your failed job records in "
"[DynamoDB](https://aws.amazon.com/dynamodb) instead of a relational database "
"table. However, you must create a DynamoDB table to store all of the failed "
"job records. Typically, this table should be named `failed_jobs`, but you "
"should name the table based on the value of the `queue.failed.table` "
"configuration value within your application's `queue` configuration file."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1754
msgid ""
"The `failed_jobs` table should have a string primary partition key named "
"`application` and a string primary sort key named `uuid`. The `application` "
"portion of the key will contain your application's name as defined by the "
"`name` configuration value within your application's `app` configuration "
"file. Since the application name is part of the DynamoDB table's key, you "
"can use the same table to store failed jobs for multiple Laravel "
"applications."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1756
msgid ""
"In addition, ensure that you install the AWS SDK so that your Laravel "
"application can communicate with Amazon DynamoDB:"
msgstr ""

#. type: Code fence info string
#: docs/master/queues.md:1757
#, no-wrap
msgid "nothing"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1757
#, no-wrap
msgid "composer require aws/aws-sdk-php\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1762
msgid ""
"Next, set the `queue.failed.driver` configuration option's value to "
"`dynamodb`. In addition, you should define `key`, `secret`, and `region` "
"configuration options within the failed job configuration array. These "
"options will be used to authenticate with AWS. When using the `dynamodb` "
"driver, the `queue.failed.database` configuration option is unnecessary:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1763
#, no-wrap
msgid ""
"'failed' => [\n"
"    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'failed_jobs',\n"
"],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1774
#, no-wrap
msgid "<a name=\"pruning-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1774
#, no-wrap
msgid "Pruning Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1777
msgid ""
"You may delete all of the records in your application's `failed_jobs` table "
"by invoking the `queue:prune-failed` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1779
#, no-wrap
msgid "    php artisan queue:prune-failed\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1781
msgid ""
"If you provide the `--hours` option to the command, only the failed job "
"records that were inserted within the last N number of hours will be "
"retained. For example, the following command will delete all of the failed "
"job records that were inserted more than 48 hours ago:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1783
#, no-wrap
msgid "    php artisan queue:prune-failed --hours=48\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1785
#, no-wrap
msgid "<a name=\"failed-job-events\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1785
#, no-wrap
msgid "Failed Job Events"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1788
msgid ""
"If you would like to register an event listener that will be invoked when a "
"job fails, you may use the `Queue` facade's `failing` method. For example, "
"we may attach a closure to this event from the `boot` method of the "
"`AppServiceProvider` that is included with Laravel:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1792 docs/master/queues.md:1884
#, no-wrap
msgid "    namespace App\\Providers;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1796
#, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Queue;\n"
"    use Illuminate\\Support\\ServiceProvider;\n"
"    use Illuminate\\Queue\\Events\\JobFailed;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1808 docs/master/queues.md:1901
#, no-wrap
msgid ""
"    class AppServiceProvider extends ServiceProvider\n"
"    {\n"
"        /**\n"
"         * Register any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function register()\n"
"        {\n"
"            //\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1823
#, no-wrap
msgid ""
"        /**\n"
"         * Bootstrap any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function boot()\n"
"        {\n"
"            Queue::failing(function (JobFailed $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->exception\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1825
#, no-wrap
msgid "<a name=\"clearing-jobs-from-queues\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1825
#, no-wrap
msgid "Clearing Jobs From Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1828
#, no-wrap
msgid ""
"> {tip} When using [Horizon](/docs/{{version}}/horizon), you should use the "
"`horizon:clear` command to clear jobs from the queue instead of the "
"`queue:clear` command.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1830
msgid ""
"If you would like to delete all jobs from the default queue of the default "
"connection, you may do so using the `queue:clear` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1832
#, no-wrap
msgid "    php artisan queue:clear\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1834
msgid ""
"You may also provide the `connection` argument and `queue` option to delete "
"jobs from a specific connection and queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1836
#, no-wrap
msgid "    php artisan queue:clear redis --queue=emails\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1838
#, no-wrap
msgid ""
"> {note} Clearing jobs from queues is only available for the SQS, Redis, and "
"database queue drivers. In addition, the SQS message deletion process takes "
"up to 60 seconds, so jobs sent to the SQS queue up to 60 seconds after you "
"clear the queue might also be deleted.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1840
#, no-wrap
msgid "<a name=\"monitoring-your-queues\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1840
#, no-wrap
msgid "Monitoring Your Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1843
msgid ""
"If your queue receives a sudden influx of jobs, it could become overwhelmed, "
"leading to a long wait time for jobs to complete. If you wish, Laravel can "
"alert you when your queue job count exceeds a specified threshold."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1845
msgid ""
"To get started, you should schedule the `queue:monitor` command to [run "
"every minute](/docs/{{version}}/scheduling). The command accepts the names "
"of the queues you wish to monitor as well as your desired job count "
"threshold:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1846
#, no-wrap
msgid "php artisan queue:monitor redis:default,redis:deployments --max=100\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1851
msgid ""
"Scheduling this command alone is not enough to trigger a notification "
"alerting you of the queue's overwhelmed status. When the command encounters "
"a queue that has a job count exceeding your threshold, an "
"`Illuminate\\Queue\\Events\\QueueBusy` event will be dispatched. You may "
"listen for this event within your application's `EventServiceProvider` in "
"order to send a notification to you or your development team:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1852
#, no-wrap
msgid ""
"use App\\Notifications\\QueueHasLongWaitTime;\n"
"use Illuminate\\Queue\\Events\\QueueBusy;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(function (QueueBusy $event) {\n"
"        Notification::route('mail', 'dev@example.com')\n"
"                ->notify(new QueueHasLongWaitTime(\n"
"                    $event->connection,\n"
"                    $event->queue,\n"
"                    $event->size\n"
"                ));\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1877
#, no-wrap
msgid "<a name=\"job-events\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1877
#, no-wrap
msgid "Job Events"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1880
msgid ""
"Using the `before` and `after` methods on the `Queue` "
"[facade](/docs/{{version}}/facades), you may specify callbacks to be "
"executed before or after a queued job is processed. These callbacks are a "
"great opportunity to perform additional logging or increment statistics for "
"a dashboard. Typically, you should call these methods from the `boot` method "
"of a [service provider](/docs/{{version}}/providers). For example, we may "
"use the `AppServiceProvider` that is included with Laravel:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1889
#, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Queue;\n"
"    use Illuminate\\Support\\ServiceProvider;\n"
"    use Illuminate\\Queue\\Events\\JobProcessed;\n"
"    use Illuminate\\Queue\\Events\\JobProcessing;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1914
#, no-wrap
msgid ""
"        /**\n"
"         * Bootstrap any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function boot()\n"
"        {\n"
"            Queue::before(function (JobProcessing $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->job->payload()\n"
"            });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1922
#, no-wrap
msgid ""
"            Queue::after(function (JobProcessed $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->job->payload()\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1924
msgid ""
"Using the `looping` method on the `Queue` "
"[facade](/docs/{{version}}/facades), you may specify callbacks that execute "
"before the worker attempts to fetch a job from a queue. For example, you "
"might register a closure to rollback any transactions that were left open by "
"a previously failed job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1927
#, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\DB;\n"
"    use Illuminate\\Support\\Facades\\Queue;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1932
#, no-wrap
msgid ""
"    Queue::looping(function () {\n"
"        while (DB::transactionLevel() > 0) {\n"
"            DB::rollBack();\n"
"        }\n"
"    });\n"
msgstr ""
