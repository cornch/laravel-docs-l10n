# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Taylor Otwell
# This file is distributed under the same license as the Laravel Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Laravel Documentation VERSION\n"
"POT-Creation-Date: 2021-03-30 14:16+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: docs/master/queues.md:1
#, markdown-text, no-wrap
msgid "Queues"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Introduction](#introduction)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Connections Vs. Queues](#connections-vs-queues)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Driver Notes & Prerequisites](#driver-prerequisites)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Creating Jobs](#creating-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Generating Job Classes](#generating-job-classes)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Class Structure](#class-structure)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Unique Jobs](#unique-jobs)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Job Middleware](#job-middleware)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Rate Limiting](#rate-limiting)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Preventing Job Overlaps](#preventing-job-overlaps)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Dispatching Jobs](#dispatching-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Delayed Dispatching](#delayed-dispatching)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Synchronous Dispatching](#synchronous-dispatching)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Jobs & Database Transactions](#jobs-and-database-transactions)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Job Chaining](#job-chaining)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Customizing The Queue & Connection](#customizing-the-queue-and-connection)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid ""
"[Specifying Max Job Attempts / Timeout "
"Values](#max-job-attempts-and-timeout)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Error Handling](#error-handling)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Job Batching](#job-batching)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Defining Batchable Jobs](#defining-batchable-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Dispatching Batches](#dispatching-batches)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Adding Jobs To Batches](#adding-jobs-to-batches)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Inspecting Batches](#inspecting-batches)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Cancelling Batches](#cancelling-batches)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Batch Failures](#batch-failures)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Pruning Batches](#pruning-batches)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Queueing Closures](#queueing-closures)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Running The Queue Worker](#running-the-queue-worker)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[The `queue:work` Command](#the-queue-work-command)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Queue Priorities](#queue-priorities)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Queue Workers & Deployment](#queue-workers-and-deployment)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Job Expirations & Timeouts](#job-expirations-and-timeouts)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Supervisor Configuration](#supervisor-configuration)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Dealing With Failed Jobs](#dealing-with-failed-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Cleaning Up After Failed Jobs](#cleaning-up-after-failed-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Retrying Failed Jobs](#retrying-failed-jobs)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Ignoring Missing Models](#ignoring-missing-models)"
msgstr ""

#. type: Bullet: '    - '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Failed Job Events](#failed-job-events)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Clearing Jobs From Queues](#clearing-jobs-from-queues)"
msgstr ""

#. type: Bullet: '- '
#: docs/master/queues.md:43
#, markdown-text
msgid "[Job Events](#job-events)"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:45
#, markdown-text, no-wrap
msgid "<a name=\"introduction\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:45
#, markdown-text, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:48
#, markdown-text
msgid ""
"While building your web application, you may have some tasks, such as "
"parsing and storing an uploaded CSV file, that take too long to perform "
"during a typical web request. Thankfully, Laravel allows you to easily "
"create queued jobs that may be processed in the background. By moving time "
"intensive tasks to a queue, your application can respond to web requests "
"with blazing speed and provide a better user experience to your customers."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:50
#, markdown-text
msgid ""
"Laravel queues provide a unified queueing API across a variety of different "
"queue backends, such as [Amazon SQS](https://aws.amazon.com/sqs/), "
"[Redis](https://redis.io), or even a relational database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:52
#, markdown-text
msgid ""
"Laravel's queue configuration options are stored in your application's "
"`config/queue.php` configuration file. In this file, you will find "
"connection configurations for each of the queue drivers that are included "
"with the framework, including the database, [Amazon "
"SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), and "
"[Beanstalkd](https://beanstalkd.github.io/) drivers, as well as a "
"synchronous driver that will execute jobs immediately (for use during local "
"development). A `null` queue driver is also included which discards queued "
"jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:54
#, markdown-text, no-wrap
msgid ""
"> {tip} Laravel now offers Horizon, a beautiful dashboard and configuration "
"system for your Redis powered queues. Check out the full [Horizon "
"documentation](/docs/{{version}}/horizon) for more information.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:56
#, markdown-text, no-wrap
msgid "<a name=\"connections-vs-queues\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:56
#, markdown-text, no-wrap
msgid "Connections Vs. Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:59
#, markdown-text
msgid ""
"Before getting started with Laravel queues, it is important to understand "
"the distinction between \"connections\" and \"queues\". In your "
"`config/queue.php` configuration file, there is a `connections` "
"configuration array. This option defines the connections to backend queue "
"services such as Amazon SQS, Beanstalk, or Redis. However, any given queue "
"connection may have multiple \"queues\" which may be thought of as different "
"stacks or piles of queued jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:61
#, markdown-text
msgid ""
"Note that each connection configuration example in the `queue` configuration "
"file contains a `queue` attribute. This is the default queue that jobs will "
"be dispatched to when they are sent to a given connection. In other words, "
"if you dispatch a job without explicitly defining which queue it should be "
"dispatched to, the job will be placed on the queue that is defined in the "
"`queue` attribute of the connection configuration:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:63 docs/master/queues.md:641
#, markdown-text, no-wrap
msgid "    use App\\Jobs\\ProcessPodcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:66
#, markdown-text, no-wrap
msgid ""
"    // This job is sent to the default connection's default queue...\n"
"    ProcessPodcast::dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:69
#, markdown-text, no-wrap
msgid ""
"    // This job is sent to the default connection's \"emails\" queue...\n"
"    ProcessPodcast::dispatch()->onQueue('emails');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:71
#, markdown-text
msgid ""
"Some applications may not need to ever push jobs onto multiple queues, "
"instead preferring to have one simple queue. However, pushing jobs to "
"multiple queues can be especially useful for applications that wish to "
"prioritize or segment how jobs are processed, since the Laravel queue worker "
"allows you to specify which queues it should process by priority. For "
"example, if you push jobs to a `high` queue, you may run a worker that gives "
"them higher processing priority:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:73
#, markdown-text, no-wrap
msgid "    php artisan queue:work --queue=high,default\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:75
#, markdown-text, no-wrap
msgid "<a name=\"driver-prerequisites\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:75
#, markdown-text, no-wrap
msgid "Driver Notes & Prerequisites"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:78
#, markdown-text, no-wrap
msgid "<a name=\"database\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:78
#, markdown-text, no-wrap
msgid "Database"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:81
#, markdown-text
msgid ""
"In order to use the `database` queue driver, you will need a database table "
"to hold the jobs. To generate a migration that creates this table, run the "
"`queue:table` Artisan command. Once the migration has been created, you may "
"migrate your database using the `migrate` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:83
#, markdown-text, no-wrap
msgid "    php artisan queue:table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:85 docs/master/queues.md:1010
#: docs/master/queues.md:1480
#, markdown-text, no-wrap
msgid "    php artisan migrate\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:87
#, markdown-text, no-wrap
msgid "<a name=\"redis\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:87
#, markdown-text, no-wrap
msgid "Redis"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:90
#, markdown-text
msgid ""
"In order to use the `redis` queue driver, you should configure a Redis "
"database connection in your `config/database.php` configuration file."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:92
#, markdown-text, no-wrap
msgid "**Redis Cluster**\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:94
#, markdown-text
msgid ""
"If your Redis queue connection uses a Redis Cluster, your queue names must "
"contain a [key hash "
"tag](https://redis.io/topics/cluster-spec#keys-hash-tags). This is required "
"in order to ensure all of the Redis keys for a given queue are placed into "
"the same hash slot:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:101
#, markdown-text, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        'connection' => 'default',\n"
"        'queue' => '{default}',\n"
"        'retry_after' => 90,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:103
#, markdown-text, no-wrap
msgid "**Blocking**\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:105
#, markdown-text
msgid ""
"When using the Redis queue, you may use the `block_for` configuration option "
"to specify how long the driver should wait for a job to become available "
"before iterating through the worker loop and re-polling the Redis database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:107
#, markdown-text
msgid ""
"Adjusting this value based on your queue load can be more efficient than "
"continually polling the Redis database for new jobs. For instance, you may "
"set the value to `5` to indicate that the driver should block for five "
"seconds while waiting for a job to become available:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:115
#, markdown-text, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        'connection' => 'default',\n"
"        'queue' => 'default',\n"
"        'retry_after' => 90,\n"
"        'block_for' => 5,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:117
#, markdown-text, no-wrap
msgid ""
"> {note} Setting `block_for` to `0` will cause queue workers to block "
"indefinitely until a job is available. This will also prevent signals such "
"as `SIGTERM` from being handled until the next job has been processed.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:119
#, markdown-text, no-wrap
msgid "<a name=\"other-driver-prerequisites\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:119
#, markdown-text, no-wrap
msgid "Other Driver Prerequisites"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:122
#, markdown-text
msgid ""
"The following dependencies are needed for the listed queue drivers. These "
"dependencies may be installed via the Composer package manager:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:128
#, markdown-text, no-wrap
msgid ""
"<div class=\"content-list\" markdown=\"1\">\n"
"- Amazon SQS: `aws/aws-sdk-php ~3.0`\n"
"- Beanstalkd: `pda/pheanstalk ~4.0`\n"
"- Redis: `predis/predis ~1.0` or phpredis PHP extension\n"
"</div>\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:130
#, markdown-text, no-wrap
msgid "<a name=\"creating-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:130
#, markdown-text, no-wrap
msgid "Creating Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:133
#, markdown-text, no-wrap
msgid "<a name=\"generating-job-classes\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:133
#, markdown-text, no-wrap
msgid "Generating Job Classes"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:136
#, markdown-text
msgid ""
"By default, all of the queueable jobs for your application are stored in the "
"`app/Jobs` directory. If the `app/Jobs` directory doesn't exist, it will be "
"created when you run the `make:job` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:138
#, markdown-text, no-wrap
msgid "    php artisan make:job ProcessPodcast\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:140
#, markdown-text
msgid ""
"The generated class will implement the "
"`Illuminate\\Contracts\\Queue\\ShouldQueue` interface, indicating to Laravel "
"that the job should be pushed onto the queue to run asynchronously."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:142
#, markdown-text, no-wrap
msgid ""
"> {tip} Job stubs may be customized using [stub "
"publishing](/docs/{{version}}/artisan#stub-customization)\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:144
#, markdown-text, no-wrap
msgid "<a name=\"class-structure\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:144
#, markdown-text, no-wrap
msgid "Class Structure"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:147
#, markdown-text
msgid ""
"Job classes are very simple, normally containing only a `handle` method that "
"is invoked when the job is processed by the queue. To get started, let's "
"take a look at an example job class. In this example, we'll pretend we "
"manage a podcast publishing service and need to process the uploaded podcast "
"files before they are published:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:149 docs/master/queues.md:238
#: docs/master/queues.md:252 docs/master/queues.md:292
#: docs/master/queues.md:356 docs/master/queues.md:499
#: docs/master/queues.md:537 docs/master/queues.md:590
#: docs/master/queues.md:712 docs/master/queues.md:741
#: docs/master/queues.md:771 docs/master/queues.md:806
#: docs/master/queues.md:847 docs/master/queues.md:883
#: docs/master/queues.md:938 docs/master/queues.md:1017
#: docs/master/queues.md:1528 docs/master/queues.md:1635
#: docs/master/queues.md:1690
#, markdown-text, no-wrap
msgid "    <?php\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:151 docs/master/queues.md:743
#: docs/master/queues.md:808 docs/master/queues.md:849
#: docs/master/queues.md:885 docs/master/queues.md:940
#: docs/master/queues.md:1019 docs/master/queues.md:1530
#, markdown-text, no-wrap
msgid "    namespace App\\Jobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:159
#, markdown-text, no-wrap
msgid ""
"    use App\\Models\\Podcast;\n"
"    use App\\Services\\AudioProcessor;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:163 docs/master/queues.md:753
#: docs/master/queues.md:818
#, markdown-text, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:170
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * The podcast instance.\n"
"         *\n"
"         * @var \\App\\Models\\Podcast\n"
"         */\n"
"        protected $podcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:181
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @param  App\\Models\\Podcast  $podcast\n"
"         * @return void\n"
"         */\n"
"        public function __construct(Podcast $podcast)\n"
"        {\n"
"            $this->podcast = $podcast;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:193
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @param  App\\Services\\AudioProcessor  $processor\n"
"         * @return void\n"
"         */\n"
"        public function handle(AudioProcessor $processor)\n"
"        {\n"
"            // Process uploaded podcast...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:195
#, markdown-text
msgid ""
"In this example, note that we were able to pass an [Eloquent "
"model](/docs/{{version}}/eloquent) directly into the queued job's "
"constructor. Because of the `SerializesModels` trait that the job is using, "
"Eloquent models and their loaded relationships will be gracefully serialized "
"and unserialized when the job is processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:197
#, markdown-text
msgid ""
"If your queued job accepts an Eloquent model in its constructor, only the "
"identifier for the model will be serialized onto the queue. When the job is "
"actually handled, the queue system will automatically re-retrieve the full "
"model instance and its loaded relationships from the database. This approach "
"to model serialization allows for much smaller job payloads to be sent to "
"your queue driver."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:199
#, markdown-text, no-wrap
msgid "<a name=\"handle-method-dependency-injection\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:199
#, markdown-text, no-wrap
msgid "`handle` Method Dependency Injection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:202
#, markdown-text
msgid ""
"The `handle` method is invoked when the job is processed by the queue. Note "
"that we are able to type-hint dependencies on the `handle` method of the "
"job. The Laravel [service container](/docs/{{version}}/container) "
"automatically injects these dependencies."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:204
#, markdown-text
msgid ""
"If you would like to take total control over how the container injects "
"dependencies into the `handle` method, you may use the container's "
"`bindMethod` method. The `bindMethod` method accepts a callback which "
"receives the job and the container. Within the callback, you are free to "
"invoke the `handle` method however you wish. Typically, you should call this "
"method from the `boot` method of your `App\\Providers\\AppServiceProvider` "
"[service provider](/docs/{{version}}/providers):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:207
#, markdown-text, no-wrap
msgid ""
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Services\\AudioProcessor;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:211
#, markdown-text, no-wrap
msgid ""
"    $this->app->bindMethod([ProcessPodcast::class, 'handle'], function "
"($job, $app) {\n"
"        return $job->handle($app->make(AudioProcessor::class));\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:213
#, markdown-text, no-wrap
msgid ""
"> {note} Binary data, such as raw image contents, should be passed through "
"the `base64_encode` function before being passed to a queued job. Otherwise, "
"the job may not properly serialize to JSON when being placed on the queue.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:215
#, markdown-text, no-wrap
msgid "<a name=\"handling-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:215
#, markdown-text, no-wrap
msgid "Handling Relationships"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:218
#, markdown-text
msgid ""
"Because loaded relationships also get serialized, the serialized job string "
"can sometimes become quite large. To prevent relations from being "
"serialized, you can call the `withoutRelations` method on the model when "
"setting a property value. This method will return an instance of the model "
"without its loaded relationships:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:229
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast->withoutRelations();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:231
#, markdown-text, no-wrap
msgid "<a name=\"unique-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:231
#, markdown-text, no-wrap
msgid "Unique Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:234
#, markdown-text, no-wrap
msgid ""
"> {note} Unique jobs require a cache driver that supports "
"[locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, "
"`redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support "
"atomic locks. In addition, unique job constraints do not apply to jobs "
"within batches.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:236
#, markdown-text
msgid ""
"Sometimes, you may want to ensure that only one instance of a specific job "
"is on the queue at any point in time. You may do so by implementing the "
"`ShouldBeUnique` interface on your job class. This interface does not "
"require you to define any additional methods on your class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:241
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:246
#, markdown-text, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:248
#, markdown-text
msgid ""
"In the example above, the `UpdateSearchIndex` job is unique. So, the job "
"will not be dispatched if another instance of the job is already on the "
"queue and has not finished processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:250
#, markdown-text
msgid ""
"In certain cases, you may want to define a specific \"key\" that makes the "
"job unique or you may want to specify a timeout beyond which the job no "
"longer stays unique. To accomplish this, you may define `uniqueId` and "
"`uniqueFor` properties or methods on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:256
#, markdown-text, no-wrap
msgid ""
"    use App\\Product;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:265
#, markdown-text, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        /**\n"
"         * The product instance.\n"
"         *\n"
"         * @var \\App\\Product\n"
"         */\n"
"        public $product;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:272
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"        * The number of seconds after which the job's unique lock will be "
"released.\n"
"        *\n"
"        * @var int\n"
"        */\n"
"        public $uniqueFor = 3600;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:283
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"        * The unique ID of the job.\n"
"        *\n"
"        * @return string\n"
"        */\n"
"        public function uniqueId()\n"
"        {\n"
"            return $this->product->id;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:285
#, markdown-text
msgid ""
"In the example above, the `UpdateSearchIndex` job is unique by a product "
"ID. So, any new dispatches of the job with the same product ID will be "
"ignored until the existing job has completed processing. In addition, if the "
"existing job is not processed within one hour, the unique lock will be "
"released and another job with the same unique key can be dispatched to the "
"queue."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:287
#, markdown-text, no-wrap
msgid "<a name=\"keeping-jobs-unique-until-processing-begins\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:287
#, markdown-text, no-wrap
msgid "Keeping Jobs Unique Until Processing Begins"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:290
#, markdown-text
msgid ""
"By default, unique jobs are \"unlocked\" after a job completes processing or "
"fails all of its retry attempts. However, there may be situations where you "
"would like your job to unlock immediately before it is processed. To "
"accomplish this, your job should implement the "
"`ShouldBeUniqueUntilProcessing` contract instead of the `ShouldBeUnique` "
"contract:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:296
#, markdown-text, no-wrap
msgid ""
"    use App\\Product;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:301
#, markdown-text, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, "
"ShouldBeUniqueUntilProcessing\n"
"    {\n"
"        // ...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:303
#, markdown-text, no-wrap
msgid "<a name=\"unique-job-locks\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:303
#, markdown-text, no-wrap
msgid "Unique Job Locks"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:306
#, markdown-text
msgid ""
"Behind the scenes, when a `ShouldBeUnique` job is dispatched, Laravel "
"attempts to acquire a [lock](/docs/{{version}}/cache#atomic-locks) with the "
"`uniqueId` key. If the lock is not acquired, the job is not dispatched. This "
"lock is released when the job completes processing or fails all of its retry "
"attempts. By default, Laravel will use the default cache driver to obtain "
"this lock. However, if you wish to use another driver for acquiring the "
"lock, you may define a `uniqueVia` method that returns the cache driver that "
"should be used:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:308
#, markdown-text, no-wrap
msgid "    use Illuminate\\Support\\Facades\\Cache;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:312
#, markdown-text, no-wrap
msgid ""
"    class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"    {\n"
"        ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:323
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"        * Get the cache driver for the unique job lock.\n"
"        *\n"
"        * @return \\Illuminate\\Contracts\\Cache\\Repository\n"
"        */\n"
"        public function uniqueVia()\n"
"        {\n"
"            return Cache::driver('redis');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:325
#, markdown-text, no-wrap
msgid ""
"> {tip} If you only need to limit the concurrent processing of a job, use "
"the [`WithoutOverlapping`](/docs/{{version}}/queues#preventing-job-overlaps) "
"job middleware instead.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:327
#, markdown-text, no-wrap
msgid "<a name=\"job-middleware\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:327
#, markdown-text, no-wrap
msgid "Job Middleware"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:330
#, markdown-text
msgid ""
"Job middleware allow you to wrap custom logic around the execution of queued "
"jobs, reducing boilerplate in the jobs themselves. For example, consider the "
"following `handle` method which leverages Laravel's Redis rate limiting "
"features to allow only one job to process every five seconds:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:332 docs/master/queues.md:360
#: docs/master/queues.md:887
#, markdown-text, no-wrap
msgid "    use Illuminate\\Support\\Facades\\Redis;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:342
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function "
"() {\n"
"            info('Lock obtained...');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:346
#, markdown-text, no-wrap
msgid ""
"            // Handle job...\n"
"        }, function () {\n"
"            // Could not obtain lock...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:350
#, markdown-text, no-wrap
msgid ""
"            return $this->release(5);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:352
#, markdown-text
msgid ""
"While this code is valid, the implementation of the `handle` method becomes "
"noisy since it is cluttered with Redis rate limiting logic. In addition, "
"this rate limiting logic must be duplicated for any other jobs that we want "
"to rate limit."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:354
#, markdown-text
msgid ""
"Instead of rate limiting in the handle method, we could define a job "
"middleware that handles rate limiting. Laravel does not have a default "
"location for job middleware, so you are welcome to place job middleware "
"anywhere in your application. In this example, we will place the middleware "
"in an `app/Jobs/Middleware` directory:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:358
#, markdown-text, no-wrap
msgid "    namespace App\\Jobs\\Middleware;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:376
#, markdown-text, no-wrap
msgid ""
"    class RateLimited\n"
"    {\n"
"        /**\n"
"         * Process the queued job.\n"
"         *\n"
"         * @param  mixed  $job\n"
"         * @param  callable  $next\n"
"         * @return mixed\n"
"         */\n"
"        public function handle($job, $next)\n"
"        {\n"
"            Redis::throttle('key')\n"
"                    ->block(0)->allow(1)->every(5)\n"
"                    ->then(function () use ($job, $next) {\n"
"                        // Lock obtained...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:380
#, markdown-text, no-wrap
msgid ""
"                        $next($job);\n"
"                    }, function () use ($job) {\n"
"                        // Could not obtain lock...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:385
#, markdown-text, no-wrap
msgid ""
"                        $job->release(5);\n"
"                    });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:387
#, markdown-text
msgid ""
"As you can see, like [route middleware](/docs/{{version}}/middleware), job "
"middleware receive the job being processed and a callback that should be "
"invoked to continue processing the job."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:389
#, markdown-text
msgid ""
"After creating job middleware, they may be attached to a job by returning "
"them from the job's `middleware` method. This method does not exist on jobs "
"scaffolded by the `make:job` Artisan command, so you will need to manually "
"add it to your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:391
#, markdown-text, no-wrap
msgid "    use App\\Jobs\\Middleware\\RateLimited;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:401
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new RateLimited];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:403
#, markdown-text, no-wrap
msgid "<a name=\"rate-limiting\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:403
#, markdown-text, no-wrap
msgid "Rate Limiting"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:406
#, markdown-text
msgid ""
"Although we just demonstrated how to write your own rate limiting job "
"middleware, Laravel actually includes a rate limiting middleware that you "
"may utilize to rate limit jobs. Like [route rate "
"limiters](/docs/{{version}}/routing#defining-rate-limiters), job rate "
"limiters are defined using the `RateLimiter` facade's `for` method."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:408
#, markdown-text
msgid ""
"For example, you may wish to allow users to backup their data once per hour "
"while imposing no such limit on premium customers. To accomplish this, you "
"may define a `RateLimiter` in the `boot` method of your "
"`AppServiceProvider`:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:411
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"    use Illuminate\\Support\\Facades\\RateLimiter;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:425
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        RateLimiter::for('backups', function ($job) {\n"
"            return $job->user->vipCustomer()\n"
"                        ? Limit::none()\n"
"                        : Limit::perHour(1)->by($job->user->id);\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:427
#, markdown-text
msgid ""
"In the example above, we defined an hourly rate limit; however, you may "
"easily define a rate limit based on minutes using the `perMinute` method. In "
"addition, you may pass any value you wish to the `by` method of the rate "
"limit; however, this value is most often used to segment rate limits by "
"customer:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:429
#, markdown-text, no-wrap
msgid "    return Limit::perMinute(50)->by($job->user->id);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:431
#, markdown-text
msgid ""
"Once you have defined your rate limit, you may attach the rate limiter to "
"your backup job using the `Illuminate\\Queue\\Middleware\\RateLimited` "
"middleware. Each time the job exceeds the rate limit, this middleware will "
"release the job back to the queue with an appropriate delay based on the "
"rate limit duration."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:433
#, markdown-text, no-wrap
msgid "    use Illuminate\\Queue\\Middleware\\RateLimited;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:443
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new RateLimited('backups')];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:445
#, markdown-text
msgid ""
"Releasing a rate limited job back onto the queue will still increment the "
"job's total number of `attempts`. You may wish to tune your `tries` and "
"`maxExceptions` properties on your job class accordingly. Or, you may wish "
"to use the [`retryUntil` method](#time-based-attempts) to define the amount "
"of time until the job should no longer be attempted."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:447
#, markdown-text, no-wrap
msgid ""
"> {tip} If you are using Redis, you may use the "
"`Illuminate\\Queue\\Middleware\\RateLimitedWithRedis` middleware, which is "
"fine-tuned for Redis and more efficient than the basic rate limiting "
"middleware.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:449
#, markdown-text, no-wrap
msgid "<a name=\"preventing-job-overlaps\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:449
#, markdown-text, no-wrap
msgid "Preventing Job Overlaps"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:452
#, markdown-text
msgid ""
"Laravel includes an `Illuminate\\Queue\\Middleware\\WithoutOverlapping` "
"middleware that allows you to prevent job overlaps based on an arbitrary "
"key. This can be helpful when a queued job is modifying a resource that "
"should only be modified by one job at a time."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:454
#, markdown-text
msgid ""
"For example, let's imagine you have a queued job that updates a user's "
"credit score and you want to prevent credit score update job overlaps for "
"the same user ID. To accomplish this, you can return the "
"`WithoutOverlapping` middleware from your job's `middleware` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:456
#, markdown-text, no-wrap
msgid "    use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:466
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [new WithoutOverlapping($this->user->id)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:468
#, markdown-text
msgid ""
"Any overlapping jobs will be released back to the queue. You may also "
"specify the number of seconds that must elapse before the released job will "
"be attempted again:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:478
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new "
"WithoutOverlapping($this->order->id))->releaseAfter(60)];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:480
#, markdown-text
msgid ""
"If you wish to immediately delete any overlapping jobs so that they will not "
"be retried, you may use the `dontRelease` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:490
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Get the middleware the job should pass through.\n"
"     *\n"
"     * @return array\n"
"     */\n"
"    public function middleware()\n"
"    {\n"
"        return [(new "
"WithoutOverlapping($this->order->id))->dontRelease()];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:492
#, markdown-text, no-wrap
msgid ""
"> {note} The `WithoutOverlapping` middleware requires a cache driver that "
"supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the "
"`memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache "
"drivers support atomic locks.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:494
#, markdown-text, no-wrap
msgid "<a name=\"dispatching-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:494
#, markdown-text, no-wrap
msgid "Dispatching Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:497
#, markdown-text
msgid ""
"Once you have written your job class, you may dispatch it using the "
"`dispatch` method on the job itself. The arguments passed to the `dispatch` "
"method will be given to the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:501 docs/master/queues.md:539
#: docs/master/queues.md:592 docs/master/queues.md:714
#: docs/master/queues.md:773
#, markdown-text, no-wrap
msgid "    namespace App\\Http\\Controllers;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:506 docs/master/queues.md:544
#: docs/master/queues.md:597 docs/master/queues.md:719
#: docs/master/queues.md:778
#, markdown-text, no-wrap
msgid ""
"    use App\\Http\\Controllers\\Controller;\n"
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Models\\Podcast;\n"
"    use Illuminate\\Http\\Request;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:518 docs/master/queues.md:556
#: docs/master/queues.md:609 docs/master/queues.md:731
#: docs/master/queues.md:790
#, markdown-text, no-wrap
msgid ""
"    class PodcastController extends Controller\n"
"    {\n"
"        /**\n"
"         * Store a new podcast.\n"
"         *\n"
"         * @param  \\Illuminate\\Http\\Request  $request\n"
"         * @return \\Illuminate\\Http\\Response\n"
"         */\n"
"        public function store(Request $request)\n"
"        {\n"
"            $podcast = Podcast::create(...);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:520 docs/master/queues.md:558
#, markdown-text, no-wrap
msgid "            // ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:524
#, markdown-text, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:526
#, markdown-text
msgid ""
"If you would like to conditionally dispatch a job, you may use the "
"`dispatchIf` and `dispatchUnless` methods:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:528
#, markdown-text, no-wrap
msgid "    ProcessPodcast::dispatchIf($accountActive, $podcast);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:530
#, markdown-text, no-wrap
msgid "    ProcessPodcast::dispatchUnless($accountSuspended, $podcast);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:532
#, markdown-text, no-wrap
msgid "<a name=\"delayed-dispatching\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:532
#, markdown-text, no-wrap
msgid "Delayed Dispatching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:535
#, markdown-text
msgid ""
"If you would like to specify that a job should not be immediately available "
"for processing by a queue worker, you may use the `delay` method when "
"dispatching the job. For example, let's specify that a job should not be "
"available for processing until 10 minutes after it has been dispatched:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:563
#, markdown-text, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)\n"
"                        ->delay(now()->addMinutes(10));\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:565
#, markdown-text, no-wrap
msgid ""
"> {note} The Amazon SQS queue service has a maximum delay time of 15 "
"minutes.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:567
#, markdown-text, no-wrap
msgid "<a name=\"dispatching-after-the-response-is-sent-to-browser\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:567
#, markdown-text, no-wrap
msgid "Dispatching After The Response Is Sent To Browser"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:570
#, markdown-text
msgid ""
"Alternatively, the `dispatchAfterResponse` method delays dispatching a job "
"until after the HTTP response is sent to the user's browser. This will still "
"allow the user to begin using the application even though a queued job is "
"still executing. This should typically only be used for jobs that take about "
"a second, such as sending an email. Since they are processed within the "
"current HTTP request, jobs dispatched in this fashion do not require a queue "
"worker to be running in order for them to be processed:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:572
#, markdown-text, no-wrap
msgid "    use App\\Jobs\\SendNotification;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:574
#, markdown-text, no-wrap
msgid "    SendNotification::dispatchAfterResponse();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:576
#, markdown-text
msgid ""
"You may also `dispatch` a closure and chain the `afterResponse` method onto "
"the `dispatch` helper to execute a closure after the HTTP response has been "
"sent to the browser:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:579
#, markdown-text, no-wrap
msgid ""
"    use App\\Mail\\WelcomeMessage;\n"
"    use Illuminate\\Support\\Facades\\Mail;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:583
#, markdown-text, no-wrap
msgid ""
"    dispatch(function () {\n"
"        Mail::to('taylor@example.com')->send(new WelcomeMessage);\n"
"    })->afterResponse();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:585
#, markdown-text, no-wrap
msgid "<a name=\"synchronous-dispatching\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:585
#, markdown-text, no-wrap
msgid "Synchronous Dispatching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:588
#, markdown-text
msgid ""
"If you would like to dispatch a job immediately (synchronously), you may use "
"the `dispatchSync` method. When using this method, the job will not be "
"queued and will be executed immediately within the current process:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:611 docs/master/queues.md:733
#: docs/master/queues.md:792
#, markdown-text, no-wrap
msgid "            // Create podcast...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:615
#, markdown-text, no-wrap
msgid ""
"            ProcessPodcast::dispatchSync($podcast);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:617
#, markdown-text, no-wrap
msgid "<a name=\"jobs-and-database-transactions\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:617
#, markdown-text, no-wrap
msgid "Jobs & Database Transactions"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:620
#, markdown-text
msgid ""
"While it is perfectly fine to dispatch jobs within database transactions, "
"you should take special care to ensure that your job will actually be able "
"to execute successfully. When dispatching a job within a transaction, it is "
"possible that the job will be processed by a worker before the transaction "
"has committed. When this happens, any updates you have made to models or "
"database records during the database transaction may not yet be reflected in "
"the database. In addition, any models or database records created within the "
"transaction may not exist in the database."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:622
#, markdown-text
msgid ""
"Thankfully, Laravel provides several methods of working around this "
"problem. First, you may set the `after_commit` connection option in your "
"queue connection's configuration array:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:628
#, markdown-text, no-wrap
msgid ""
"    'redis' => [\n"
"        'driver' => 'redis',\n"
"        // ...\n"
"        'after_commit' => true,\n"
"    ],\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:630
#, markdown-text
msgid ""
"When the `after_commit` option is `true`, you may dispatch jobs within "
"database transactions; however, Laravel will wait until all open database "
"transactions have been committed before actually dispatching the job. Of "
"course, if no database transactions are currently open, the job will be "
"dispatched immediately."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:632
#, markdown-text
msgid ""
"If a transaction is rolled back due to an exception that occurs during the "
"transaction, the dispatched jobs that were dispatched during that "
"transaction will be discarded."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:634
#, markdown-text, no-wrap
msgid ""
"> {tip} Setting the `after_commit` configuration option to `true` will also "
"cause any queued event listeners, mailables, notifications, and broadcast "
"events to be dispatched after all open database transactions have been "
"committed.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:636
#, markdown-text, no-wrap
msgid "<a name=\"specifying-commit-dispatch-behavior-inline\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:636
#, markdown-text, no-wrap
msgid "Specifying Commit Dispatch Behavior Inline"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:639
#, markdown-text
msgid ""
"If you do not set the `after_commit` queue connection configuration option "
"to `true`, you may still indicate that a specific job should be dispatched "
"after all open database transactions have been committed. To accomplish "
"this, you may chain the `afterCommit` method onto your dispatch operation:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:643
#, markdown-text, no-wrap
msgid "    ProcessPodcast::dispatch($podcast)->afterCommit();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:645
#, markdown-text
msgid ""
"Likewise, if the `after_commit` configuration option is set to `true`, you "
"may indicate that a specific job should be dispatched immediately without "
"waiting for any open database transactions to commit:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:647
#, markdown-text, no-wrap
msgid "    ProcessPodcast::dispatch($podcast)->beforeCommit();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:649
#, markdown-text, no-wrap
msgid "<a name=\"job-chaining\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:649
#, markdown-text, no-wrap
msgid "Job Chaining"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:652
#, markdown-text
msgid ""
"Job chaining allows you to specify a list of queued jobs that should be run "
"in sequence after the primary job has executed successfully. If one job in "
"the sequence fails, the rest of the jobs will not be run. To execute a "
"queued job chain, you may use the `chain` method provided by the `Bus` "
"facade. Laravel's command bus is a lower level component that queued job "
"dispatching is built on top of:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:657
#, markdown-text, no-wrap
msgid ""
"    use App\\Jobs\\OptimizePodcast;\n"
"    use App\\Jobs\\ProcessPodcast;\n"
"    use App\\Jobs\\ReleasePodcast;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:663
#, markdown-text, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:665
#, markdown-text
msgid "In addition to chaining job class instances, you may also chain closures:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:673
#, markdown-text, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        function () {\n"
"            Podcast::update(...);\n"
"        },\n"
"    ])->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:675
#, markdown-text, no-wrap
msgid ""
"> {note} Deleting jobs using the `$this->delete()` method within the job "
"will not prevent chained jobs from being processed. The chain will only stop "
"executing if a job in the chain fails.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:677
#, markdown-text, no-wrap
msgid "<a name=\"chain-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:677
#, markdown-text, no-wrap
msgid "Chain Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:680
#, markdown-text
msgid ""
"If you would like to specify the connection and queue that should be used "
"for the chained jobs, you may use the `onConnection` and `onQueue` "
"methods. These methods specify the queue connection and queue name that "
"should be used unless the queued job is explicitly assigned a different "
"connection / queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:686
#, markdown-text, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->onConnection('redis')->onQueue('podcasts')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:688
#, markdown-text, no-wrap
msgid "<a name=\"chain-failures\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:688
#, markdown-text, no-wrap
msgid "Chain Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:691
#, markdown-text
msgid ""
"When chaining jobs, you may use the `catch` method to specify a closure that "
"should be invoked if a job within the chain fails. The given callback will "
"receive the `Throwable` instance that caused the job failure:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:694
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:702
#, markdown-text, no-wrap
msgid ""
"    Bus::chain([\n"
"        new ProcessPodcast,\n"
"        new OptimizePodcast,\n"
"        new ReleasePodcast,\n"
"    ])->catch(function (Throwable $e) {\n"
"        // A job within the chain has failed...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:704
#, markdown-text, no-wrap
msgid "<a name=\"customizing-the-queue-and-connection\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:704
#, markdown-text, no-wrap
msgid "Customizing The Queue & Connection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:707
#, markdown-text, no-wrap
msgid "<a name=\"dispatching-to-a-particular-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:707
#, markdown-text, no-wrap
msgid "Dispatching To A Particular Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:710
#, markdown-text
msgid ""
"By pushing jobs to different queues, you may \"categorize\" your queued jobs "
"and even prioritize how many workers you assign to various queues. Keep in "
"mind, this does not push jobs to different queue \"connections\" as defined "
"by your queue configuration file, but only to specific queues within a "
"single connection. To specify the queue, use the `onQueue` method when "
"dispatching the job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:737
#, markdown-text, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:739
#, markdown-text
msgid ""
"Alternatively, you may specify the job's queue by calling the `onQueue` "
"method within the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:749 docs/master/queues.md:814
#, markdown-text, no-wrap
msgid ""
"     use Illuminate\\Bus\\Queueable;\n"
"     use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"     use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"     use Illuminate\\Queue\\InteractsWithQueue;\n"
"     use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:764
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function __construct()\n"
"        {\n"
"            $this->onQueue('processing');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:766
#, markdown-text, no-wrap
msgid "<a name=\"dispatching-to-a-particular-connection\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:766
#, markdown-text, no-wrap
msgid "Dispatching To A Particular Connection"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:769
#, markdown-text
msgid ""
"If your application interacts with multiple queue connections, you may "
"specify which connection to push a job to using the `onConnection` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:796
#, markdown-text, no-wrap
msgid ""
"            ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:798
#, markdown-text
msgid ""
"You may chain the `onConnection` and `onQueue` methods together to specify "
"the connection and the queue for a job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:802
#, markdown-text, no-wrap
msgid ""
"    ProcessPodcast::dispatch($podcast)\n"
"                  ->onConnection('sqs')\n"
"                  ->onQueue('processing');\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:804
#, markdown-text
msgid ""
"Alternatively, you may specify the job's connection by calling the "
"`onConnection` method within the job's constructor:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:829
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function __construct()\n"
"        {\n"
"            $this->onConnection('sqs');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:831
#, markdown-text, no-wrap
msgid "<a name=\"max-job-attempts-and-timeout\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:831
#, markdown-text, no-wrap
msgid "Specifying Max Job Attempts / Timeout Values"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:834
#, markdown-text, no-wrap
msgid "<a name=\"max-attempts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:834
#, markdown-text, no-wrap
msgid "Max Attempts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:837
#, markdown-text
msgid ""
"If one of your queued jobs is encountering an error, you likely do not want "
"it to keep retrying indefinitely. Therefore, Laravel provides various ways "
"to specify how many times or for how long a job may be attempted."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:839
#, markdown-text
msgid ""
"One approach to specifying the maximum number of times a job may be "
"attempted is via the `--tries` switch on the Artisan command line. This will "
"apply to all jobs processed by the worker unless the job being processed "
"specifies a more specific number of times it may be attempted:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:841
#, markdown-text, no-wrap
msgid "    php artisan queue:work --tries=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:843
#, markdown-text
msgid ""
"If a job exceeds its maximum number of attempts, it will be considered a "
"\"failed\" job. For more information on handling failed jobs, consult the "
"[failed job documentation](#dealing-with-failed-jobs)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:845
#, markdown-text
msgid ""
"You may take a more granular approach by defining the maximum number of "
"times a job may be attempted on the job class itself. If the maximum number "
"of attempts is specified on the job, it will take precedence over the "
"`--tries` value provided on the command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:859
#, markdown-text, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of times the job may be attempted.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $tries = 5;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:861
#, markdown-text, no-wrap
msgid "<a name=\"time-based-attempts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:861
#, markdown-text, no-wrap
msgid "Time Based Attempts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:864
#, markdown-text
msgid ""
"As an alternative to defining how many times a job may be attempted before "
"it fails, you may define a time at which the job should no longer be "
"attempted. This allows a job to be attempted any number of times within a "
"given time frame. To define the time at which a job should no longer be "
"attempted, add a `retryUntil` method to your job class. This method should "
"return a `DateTime` instance:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:874
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Determine the time at which the job should timeout.\n"
"     *\n"
"     * @return \\DateTime\n"
"     */\n"
"    public function retryUntil()\n"
"    {\n"
"        return now()->addMinutes(10);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:876
#, markdown-text, no-wrap
msgid ""
"> {tip} You may also define a `tries` property or `retryUntil` method on "
"your [queued event "
"listeners](/docs/{{version}}/events#queued-event-listeners).\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:878
#, markdown-text, no-wrap
msgid "<a name=\"max-exceptions\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:878
#, markdown-text, no-wrap
msgid "Max Exceptions"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:881
#, markdown-text
msgid ""
"Sometimes you may wish to specify that a job may be attempted many times, "
"but should fail if the retries are triggered by a given number of unhandled "
"exceptions (as opposed to being released by the `release` method "
"directly). To accomplish this, you may define a `maxExceptions` property on "
"your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:896
#, markdown-text, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of times the job may be attempted.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $tries = 25;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:903
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * The maximum number of unhandled exceptions to allow before "
"failing.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $maxExceptions = 3;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:919
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function handle()\n"
"        {\n"
"            Redis::throttle('key')->allow(10)->every(60)->then(function () "
"{\n"
"                // Lock obtained, process the podcast...\n"
"            }, function () {\n"
"                // Unable to obtain lock...\n"
"                return $this->release(10);\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:921
#, markdown-text
msgid ""
"In this example, the job is released for ten seconds if the application is "
"unable to obtain a Redis lock and will continue to be retried up to 25 "
"times. However, the job will fail if three unhandled exceptions are thrown "
"by the job."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:923
#, markdown-text, no-wrap
msgid "<a name=\"timeout\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:923
#, markdown-text, no-wrap
msgid "Timeout"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:926
#, markdown-text, no-wrap
msgid ""
"> {note} The `pcntl` PHP extension must be installed in order to specify job "
"timeouts.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:928
#, markdown-text
msgid ""
"Often, you know roughly how long you expect your queued jobs to take. For "
"this reason, Laravel allows you to specify a \"timeout\" value. If a job is "
"processing for longer than the number of seconds specified by the timeout "
"value, the worker processing the job will exit with an error. Typically, the "
"worker will be restarted automatically by a [process manager configured on "
"your server](#supervisor-configuration)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:930
#, markdown-text
msgid ""
"The maximum number of seconds that jobs can run may be specified using the "
"`--timeout` switch on the Artisan command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:932
#, markdown-text, no-wrap
msgid "    php artisan queue:work --timeout=30\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:934
#, markdown-text
msgid ""
"If the job exceeds its maximum attempts by continually timing out, it will "
"be marked as failed."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:936
#, markdown-text
msgid ""
"You may also define the maximum number of seconds a job should be allowed to "
"run on the job class itself. If the timeout is specified on the job, it will "
"take precedence over any timeout specified on the command line:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:950
#, markdown-text, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        /**\n"
"         * The number of seconds the job can run before timing out.\n"
"         *\n"
"         * @var int\n"
"         */\n"
"        public $timeout = 120;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:952
#, markdown-text
msgid ""
"Sometimes, IO blocking processes such as sockets or outgoing HTTP "
"connections may not respect your specified timeout. Therefore, when using "
"these features, you should always attempt to specify a timeout using their "
"APIs as well. For example, when using Guzzle, you should always specify a "
"connection and request timeout value."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:954
#, markdown-text, no-wrap
msgid "<a name=\"error-handling\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:954
#, markdown-text, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:957
#, markdown-text
msgid ""
"If an exception is thrown while the job is being processed, the job will "
"automatically be released back onto the queue so it may be attempted "
"again. The job will continue to be released until it has been attempted the "
"maximum number of times allowed by your application. The maximum number of "
"attempts is defined by the `--tries` switch used on the `queue:work` Artisan "
"command. Alternatively, the maximum number of attempts may be defined on the "
"job class itself. More information on running the queue worker [can be found "
"below](#running-the-queue-worker)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:959
#, markdown-text, no-wrap
msgid "<a name=\"manually-releasing-a-job\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:959
#, markdown-text, no-wrap
msgid "Manually Releasing A Job"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:962
#, markdown-text
msgid ""
"Sometimes you may wish to manually release a job back onto the queue so that "
"it can be attempted again at a later time. You may accomplish this by "
"calling the `release` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:971 docs/master/queues.md:992
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        // ...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:974
#, markdown-text, no-wrap
msgid ""
"        $this->release();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:976
#, markdown-text
msgid ""
"By default, the `release` method will release the job back onto the queue "
"for immediate processing. However, by passing an integer to the `release` "
"method you may instruct the queue to not make the job available for "
"processing until a given number of seconds has elapsed:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:978
#, markdown-text, no-wrap
msgid "    $this->release(10)\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:980
#, markdown-text, no-wrap
msgid "<a name=\"manually-failing-a-job\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:980
#, markdown-text, no-wrap
msgid "Manually Failing A Job"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:983
#, markdown-text
msgid ""
"Occasionally you may need to manually mark a job as \"failed\". To do so, "
"you may call the `fail` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:995
#, markdown-text, no-wrap
msgid ""
"        $this->fail();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:997
#, markdown-text
msgid ""
"If you would like to mark your job as failed because of an exception that "
"you have caught, you may pass the exception to the `fail` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:999
#, markdown-text, no-wrap
msgid "    $this->fail($exception);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1001
#, markdown-text, no-wrap
msgid ""
"> {tip} For more information on failed jobs, check out the [documentation on "
"dealing with job failures](#dealing-with-failed-jobs).\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1003
#, markdown-text, no-wrap
msgid "<a name=\"job-batching\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1003
#, markdown-text, no-wrap
msgid "Job Batching"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1006
#, markdown-text
msgid ""
"Laravel's job batching feature allows you to easily execute a batch of jobs "
"and then perform some action when the batch of jobs has completed "
"executing. Before getting started, you should create a database migration to "
"build a table to contain meta information about your job batches, such as "
"their completion percentage. This migration may be generated using the "
"`queue:batches-table` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1008
#, markdown-text, no-wrap
msgid "    php artisan queue:batches-table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1012
#, markdown-text, no-wrap
msgid "<a name=\"defining-batchable-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1012
#, markdown-text, no-wrap
msgid "Defining Batchable Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1015
#, markdown-text
msgid ""
"To define a batchable job, you should [create a queueable "
"job](#creating-jobs) as normal; however, you should add the "
"`Illuminate\\Bus\\Batchable` trait to the job class. This trait provides "
"access to a `batch` method which may be used to retrieve the current batch "
"that the job is executing within:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1026
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Bus\\Batchable;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1030
#, markdown-text, no-wrap
msgid ""
"    class ImportCsv implements ShouldQueue\n"
"    {\n"
"        use Batchable, Dispatchable, InteractsWithQueue, Queueable, "
"SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1040
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function handle()\n"
"        {\n"
"            if ($this->batch()->cancelled()) {\n"
"                // Determine if the batch has been cancelled...\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1043
#, markdown-text, no-wrap
msgid ""
"                return;\n"
"            }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1047
#, markdown-text, no-wrap
msgid ""
"            // Import a portion of the CSV file...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1049
#, markdown-text, no-wrap
msgid "<a name=\"dispatching-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1049
#, markdown-text, no-wrap
msgid "Dispatching Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1052
#, markdown-text
msgid ""
"To dispatch a batch of jobs, you should use the `batch` method of the `Bus` "
"facade. Of course, batching is primarily useful when combined with "
"completion callbacks. So, you may use the `then`, `catch`, and `finally` "
"methods to define completion callbacks for the batch. Each of these "
"callbacks will receive an `Illuminate\\Bus\\Batch` instance when they are "
"invoked. In this example, we will imagine we are queueing a batch of jobs "
"that each process a given number of rows from a CSV file:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1057
#, markdown-text, no-wrap
msgid ""
"    use App\\Jobs\\ImportCsv;\n"
"    use Illuminate\\Bus\\Batch;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1071
#, markdown-text, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        new ImportCsv(1, 100),\n"
"        new ImportCsv(101, 200),\n"
"        new ImportCsv(201, 300),\n"
"        new ImportCsv(301, 400),\n"
"        new ImportCsv(401, 500),\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->catch(function (Batch $batch, Throwable $e) {\n"
"        // First batch job failure detected...\n"
"    })->finally(function (Batch $batch) {\n"
"        // The batch has finished executing...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1073
#, markdown-text, no-wrap
msgid "    return $batch->id;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1075
#, markdown-text, no-wrap
msgid ""
"The batch's ID, which may be accessed via the `$batch->id` property, may be "
"used to [query the Laravel command bus](#inspecting-batches) for information "
"about the batch after it has been dispatched.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1077
#, markdown-text, no-wrap
msgid "<a name=\"naming-batches\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1077
#, markdown-text, no-wrap
msgid "Naming Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1080
#, markdown-text
msgid ""
"Some tools such as Laravel Horizon and Laravel Telescope may provide more "
"user-friendly debug information for batches if batches are named. To assign "
"an arbitrary name to a batch, you may call the `name` method while defining "
"the batch:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1086
#, markdown-text, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->name('Import CSV')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1088
#, markdown-text, no-wrap
msgid "<a name=\"batch-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1088
#, markdown-text, no-wrap
msgid "Batch Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1091
#, markdown-text
msgid ""
"If you would like to specify the connection and queue that should be used "
"for the batched jobs, you may use the `onConnection` and `onQueue` "
"methods. All batched jobs must execute within the same connection and queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1097
#, markdown-text, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->onConnection('redis')->onQueue('imports')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1099
#, markdown-text, no-wrap
msgid "<a name=\"chains-within-batches\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1099
#, markdown-text, no-wrap
msgid "Chains Within Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1102
#, markdown-text
msgid ""
"You may define a set of [chained jobs](#job-chaining) within a batch by "
"placing the chained jobs within an array. For example, we may execute two "
"job chains in parallel and execute a callback when both job chains have "
"finished processing:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1107
#, markdown-text, no-wrap
msgid ""
"    use App\\Jobs\\ReleasePodcast;\n"
"    use App\\Jobs\\SendPodcastReleaseNotification;\n"
"    use Illuminate\\Bus\\Batch;\n"
"    use Illuminate\\Support\\Facades\\Bus;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1120
#, markdown-text, no-wrap
msgid ""
"    Bus::batch([\n"
"        [\n"
"            new ReleasePodcast(1),\n"
"            new SendPodcastReleaseNotification(1),\n"
"        ],\n"
"        [\n"
"            new ReleasePodcast(2),\n"
"            new SendPodcastReleaseNotification(2),\n"
"        ],\n"
"    ])->then(function (Batch $batch) {\n"
"        // ...\n"
"    })->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1122
#, markdown-text, no-wrap
msgid "<a name=\"adding-jobs-to-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1122
#, markdown-text, no-wrap
msgid "Adding Jobs To Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1125
#, markdown-text
msgid ""
"Sometimes it may be useful to add additional jobs to a batch from within a "
"batched job. This pattern can be useful when you need to batch thousands of "
"jobs which may take too long to dispatch during a web request. So, instead, "
"you may wish to dispatch an initial batch of \"loader\" jobs that hydrate "
"the batch with even more jobs:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1133
#, markdown-text, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        new LoadImportBatch,\n"
"        new LoadImportBatch,\n"
"        new LoadImportBatch,\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->name('Import Contacts')->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1135
#, markdown-text
msgid ""
"In this example, we will use the `LoadImportBatch` job to hydrate the batch "
"with additional jobs. To accomplish this, we may use the `add` method on the "
"batch instance that may be accessed via the job's `batch` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1138
#, markdown-text, no-wrap
msgid ""
"    use App\\Jobs\\ImportContacts;\n"
"    use Illuminate\\Support\\Collection;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1149 docs/master/queues.md:1239
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            return;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1154
#, markdown-text, no-wrap
msgid ""
"        $this->batch()->add(Collection::times(1000, function () {\n"
"            return new ImportContacts;\n"
"        }));\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1156
#, markdown-text, no-wrap
msgid ""
"> {note} You may only add jobs to a batch from within a job that belongs to "
"the same batch.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1158
#, markdown-text, no-wrap
msgid "<a name=\"inspecting-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1158
#, markdown-text, no-wrap
msgid "Inspecting Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1161
#, markdown-text
msgid ""
"The `Illuminate\\Bus\\Batch` instance that is provided to batch completion "
"callbacks has a variety of properties and methods to assist you in "
"interacting with and inspecting a given batch of jobs:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1164
#, markdown-text, no-wrap
msgid ""
"    // The UUID of the batch...\n"
"    $batch->id;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1167
#, markdown-text, no-wrap
msgid ""
"    // The name of the batch (if applicable)...\n"
"    $batch->name;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1170
#, markdown-text, no-wrap
msgid ""
"    // The number of jobs assigned to the batch...\n"
"    $batch->totalJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1173
#, markdown-text, no-wrap
msgid ""
"    // The number of jobs that have not been processed by the queue...\n"
"    $batch->pendingJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1176
#, markdown-text, no-wrap
msgid ""
"    // The number of jobs that have failed...\n"
"    $batch->failedJobs;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1179
#, markdown-text, no-wrap
msgid ""
"    // The number of jobs that have been processed thus far...\n"
"    $batch->processedJobs();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1182
#, markdown-text, no-wrap
msgid ""
"    // The completion percentage of the batch (0-100)...\n"
"    $batch->progress();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1185
#, markdown-text, no-wrap
msgid ""
"    // Indicates if the batch has finished executing...\n"
"    $batch->finished();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1188
#, markdown-text, no-wrap
msgid ""
"    // Cancel the execution of the batch...\n"
"    $batch->cancel();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1191
#, markdown-text, no-wrap
msgid ""
"    // Indicates if the batch has been cancelled...\n"
"    $batch->cancelled();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1193
#, markdown-text, no-wrap
msgid "<a name=\"returning-batches-from-routes\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1193
#, markdown-text, no-wrap
msgid "Returning Batches From Routes"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1196
#, markdown-text
msgid ""
"All `Illuminate\\Bus\\Batch` instances are JSON serializable, meaning you "
"can return them directly from one of your application's routes to retrieve a "
"JSON payload containing information about the batch, including its "
"completion progress. This makes it convenient to display information about "
"the batch's completion progress in your application's UI."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1198
#, markdown-text
msgid ""
"To retrieve a batch by its ID, you may use the `Bus` facade's `findBatch` "
"method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1201
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Bus;\n"
"    use Illuminate\\Support\\Facades\\Route;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1205
#, markdown-text, no-wrap
msgid ""
"    Route::get('/batch/{batchId}', function (string $batchId) {\n"
"        return Bus::findBatch($batchId);\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1207
#, markdown-text, no-wrap
msgid "<a name=\"cancelling-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1207
#, markdown-text, no-wrap
msgid "Cancelling Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1210
#, markdown-text
msgid ""
"Sometimes you may need to cancel a given batch's execution. This can be "
"accomplished by calling the `cancel` method on the `Illuminate\\Bus\\Batch` "
"instance:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1221
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->user->exceedsImportLimit()) {\n"
"            return $this->batch()->cancel();\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1226
#, markdown-text, no-wrap
msgid ""
"        if ($this->batch()->cancelled()) {\n"
"            return;\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1228
#, markdown-text
msgid ""
"As you may have noticed in previous examples, batched jobs should typically "
"check to see if the batch has been cancelled at the beginning of their "
"`handle` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1242
#, markdown-text, no-wrap
msgid ""
"        // Continue processing...\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1244
#, markdown-text, no-wrap
msgid "<a name=\"batch-failures\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1244
#, markdown-text, no-wrap
msgid "Batch Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1247
#, markdown-text
msgid ""
"When a batched job fails, the `catch` callback (if assigned) will be "
"invoked. This callback is only invoked for the first job that fails within "
"the batch."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1249
#, markdown-text, no-wrap
msgid "<a name=\"allowing-failures\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1249
#, markdown-text, no-wrap
msgid "Allowing Failures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1252
#, markdown-text
msgid ""
"When a job within a batch fails, Laravel will automatically mark the batch "
"as \"cancelled\". If you wish, you may disable this behavior so that a job "
"failure does not automatically mark the batch as cancelled. This may be "
"accomplished by calling the `allowFailures` method while dispatching the "
"batch:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1258
#, markdown-text, no-wrap
msgid ""
"    $batch = Bus::batch([\n"
"        // ...\n"
"    ])->then(function (Batch $batch) {\n"
"        // All jobs completed successfully...\n"
"    })->allowFailures()->dispatch();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1260
#, markdown-text, no-wrap
msgid "<a name=\"retrying-failed-batch-jobs\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1260
#, markdown-text, no-wrap
msgid "Retrying Failed Batch Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1263
#, markdown-text
msgid ""
"For convenience, Laravel provides a `queue:retry-batch` Artisan command that "
"allows you to easily retry all of the failed jobs for a given batch. The "
"`queue:retry-batch` command accepts the UUID of the batch whose failed jobs "
"should be retried:"
msgstr ""

#. type: Fenced code block (bash)
#: docs/master/queues.md:1264
#, no-wrap
msgid "php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1269
#, markdown-text, no-wrap
msgid "<a name=\"pruning-batches\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1269
#, markdown-text, no-wrap
msgid "Pruning Batches"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1272
#, markdown-text
msgid ""
"Without pruning, the `job_batches` table can accumulate records very "
"quickly. To mitigate this, you should "
"[schedule](/docs/{{version}}/scheduling) the `queue:prune-batches` Artisan "
"command to run daily:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1274
#, markdown-text, no-wrap
msgid "    $schedule->command('queue:prune-batches')->daily();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1276
#, markdown-text
msgid ""
"By default, all finished batches that are more than 24 hours old will be "
"pruned. You may use the `hours` option when calling the command to determine "
"how long to retain batch data. For example, the following command will "
"delete all batches that finished over 48 hours ago:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1278
#, markdown-text, no-wrap
msgid "    $schedule->command('queue:prune-batches --hours=48')->daily();\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1280
#, markdown-text, no-wrap
msgid "<a name=\"queueing-closures\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1280
#, markdown-text, no-wrap
msgid "Queueing Closures"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1283
#, markdown-text
msgid ""
"Instead of dispatching a job class to the queue, you may also dispatch a "
"closure. This is great for quick, simple tasks that need to be executed "
"outside of the current request cycle. When dispatching closures to the "
"queue, the closure's code content is cryptographically signed so that it can "
"not be modified in transit:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1285
#, markdown-text, no-wrap
msgid "    $podcast = App\\Podcast::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1289
#, markdown-text, no-wrap
msgid ""
"    dispatch(function () use ($podcast) {\n"
"        $podcast->publish();\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1291
#, markdown-text
msgid ""
"Using the `catch` method, you may provide a closure that should be executed "
"if the queued closure fails to complete successfully after exhausting all of "
"your queue's [configured retry attempts](#max-job-attempts-and-timeout):"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1293
#, markdown-text, no-wrap
msgid "    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1299
#, markdown-text, no-wrap
msgid ""
"    dispatch(function () use ($podcast) {\n"
"        $podcast->publish();\n"
"    })->catch(function (Throwable $e) {\n"
"        // This job has failed...\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1301
#, markdown-text, no-wrap
msgid "<a name=\"running-the-queue-worker\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1301
#, markdown-text, no-wrap
msgid "Running The Queue Worker"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1304
#, markdown-text, no-wrap
msgid "<a name=\"the-queue-work-command\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1304
#, markdown-text, no-wrap
msgid "The `queue:work` Command"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1307
#, markdown-text
msgid ""
"Laravel includes an Artisan command that will start a queue worker and "
"process new jobs as they are pushed onto the queue. You may run the worker "
"using the `queue:work` Artisan command. Note that once the `queue:work` "
"command has started, it will continue to run until it is manually stopped or "
"you close your terminal:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1309
#, markdown-text, no-wrap
msgid "    php artisan queue:work\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1311
#, markdown-text, no-wrap
msgid ""
"> {tip} To keep the `queue:work` process running permanently in the "
"background, you should use a process monitor such as "
"[Supervisor](#supervisor-configuration) to ensure that the queue worker does "
"not stop running.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1313
#, markdown-text
msgid ""
"Remember, queue workers, are long-lived processes and store the booted "
"application state in memory. As a result, they will not notice changes in "
"your code base after they have been started. So, during your deployment "
"process, be sure to [restart your queue "
"workers](#queue-workers-and-deployment). In addition, remember that any "
"static state created or modified by your application will not be "
"automatically reset between jobs."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1315
#, markdown-text
msgid ""
"Alternatively, you may run the `queue:listen` command. When using the "
"`queue:listen` command, you don't have to manually restart the worker when "
"you want to reload your updated code or reset the application state; "
"however, this command is significantly less efficient than the `queue:work` "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1317
#, markdown-text, no-wrap
msgid "    php artisan queue:listen\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1319
#, markdown-text, no-wrap
msgid "<a name=\"running-multiple-queue-workers\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1319
#, markdown-text, no-wrap
msgid "Running Multiple Queue Workers"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1322
#, markdown-text
msgid ""
"To assign multiple workers to a queue and process jobs concurrently, you "
"should simply start multiple `queue:work` processes. This can either be done "
"locally via multiple tabs in your terminal or in production using your "
"process manager's configuration settings. [When using "
"Supervisor](#supervisor-configuration), you may use the `numprocs` "
"configuration value."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1324
#, markdown-text, no-wrap
msgid "<a name=\"specifying-the-connection-queue\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1324
#, markdown-text, no-wrap
msgid "Specifying The Connection & Queue"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1327
#, markdown-text
msgid ""
"You may also specify which queue connection the worker should utilize. The "
"connection name passed to the `work` command should correspond to one of the "
"connections defined in your `config/queue.php` configuration file:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1329
#, markdown-text, no-wrap
msgid "    php artisan queue:work redis\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1331
#, markdown-text
msgid ""
"You may customize your queue worker even further by only processing "
"particular queues for a given connection. For example, if all of your emails "
"are processed in an `emails` queue on your `redis` queue connection, you may "
"issue the following command to start a worker that only processes that "
"queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1333
#, markdown-text, no-wrap
msgid "    php artisan queue:work redis --queue=emails\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1335
#, markdown-text, no-wrap
msgid "<a name=\"processing-a-specified-number-of-jobs\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1335
#, markdown-text, no-wrap
msgid "Processing A Specified Number Of Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1338
#, markdown-text
msgid ""
"The `--once` option may be used to instruct the worker to only process a "
"single job from the queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1340
#, markdown-text, no-wrap
msgid "    php artisan queue:work --once\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1342
#, markdown-text
msgid ""
"The `--max-jobs` option may be used to instruct the worker to process the "
"given number of jobs and then exit. This option may be useful when combined "
"with [Supervisor](#supervisor-configuration) so that your workers are "
"automatically restarted after processing a given number of jobs, releasing "
"any memory they may have accumulated:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1344
#, markdown-text, no-wrap
msgid "    php artisan queue:work --max-jobs=1000\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1346
#, markdown-text, no-wrap
msgid "<a name=\"processing-all-queued-jobs-then-exiting\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1346
#, markdown-text, no-wrap
msgid "Processing All Queued Jobs & Then Exiting"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1349
#, markdown-text
msgid ""
"The `--stop-when-empty` option may be used to instruct the worker to process "
"all jobs and then exit gracefully. This option can be useful when processing "
"Laravel queues within a Docker container if you wish to shutdown the "
"container after the queue is empty:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1351
#, markdown-text, no-wrap
msgid "    php artisan queue:work --stop-when-empty\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1353
#, markdown-text, no-wrap
msgid "<a name=\"processing-jobs-for-a-given-number-of-seconds\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1353
#, markdown-text, no-wrap
msgid "Processing Jobs For A Given Number Of Seconds"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1356
#, markdown-text
msgid ""
"The `--max-time` option may be used to instruct the worker to process jobs "
"for the given number of seconds and then exit. This option may be useful "
"when combined with [Supervisor](#supervisor-configuration) so that your "
"workers are automatically restarted after processing jobs for a given amount "
"of time, releasing any memory they may have accumulated:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1359
#, markdown-text, no-wrap
msgid ""
"    // Process jobs for one hour and then exit...\n"
"    php artisan queue:work --max-time=3600\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1361
#, markdown-text, no-wrap
msgid "<a name=\"worker-sleep-duration\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1361
#, markdown-text, no-wrap
msgid "Worker Sleep Duration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1364
#, markdown-text
msgid ""
"When jobs are available on the queue, the worker will keep processing jobs "
"with no delay in between them. However, the `sleep` option determines how "
"many seconds the worker will \"sleep\" if there are no new jobs "
"available. While sleeping, the worker will not process any new jobs - the "
"jobs will be processed after the worker wakes up again."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1366
#, markdown-text, no-wrap
msgid "    php artisan queue:work --sleep=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1368
#, markdown-text, no-wrap
msgid "<a name=\"resource-considerations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1368
#, markdown-text, no-wrap
msgid "Resource Considerations"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1371
#, markdown-text
msgid ""
"Daemon queue workers do not \"reboot\" the framework before processing each "
"job. Therefore, you should release any heavy resources after each job "
"completes. For example, if you are doing image manipulation with the GD "
"library, you should free the memory with `imagedestroy` when you are done "
"processing the image."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1373
#, markdown-text, no-wrap
msgid "<a name=\"queue-priorities\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1373
#, markdown-text, no-wrap
msgid "Queue Priorities"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1376
#, markdown-text
msgid ""
"Sometimes you may wish to prioritize how your queues are processed. For "
"example, in your `config/queue.php` configuration file, you may set the "
"default `queue` for your `redis` connection to `low`. However, occasionally "
"you may wish to push a job to a `high` priority queue like so:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1378
#, markdown-text, no-wrap
msgid "    dispatch((new Job)->onQueue('high'));\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1380
#, markdown-text
msgid ""
"To start a worker that verifies that all of the `high` queue jobs are "
"processed before continuing to any jobs on the `low` queue, pass a "
"comma-delimited list of queue names to the `work` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1382
#, markdown-text, no-wrap
msgid "    php artisan queue:work --queue=high,low\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1384
#, markdown-text, no-wrap
msgid "<a name=\"queue-workers-and-deployment\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1384
#, markdown-text, no-wrap
msgid "Queue Workers & Deployment"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1387
#, markdown-text
msgid ""
"Since queue workers are long-lived processes, they will not notice changes "
"to your code without being restarted. So, the simplest way to deploy an "
"application using queue workers is to restart the workers during your "
"deployment process. You may gracefully restart all of the workers by issuing "
"the `queue:restart` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1389
#, markdown-text, no-wrap
msgid "    php artisan queue:restart\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1391
#, markdown-text
msgid ""
"This command will instruct all queue workers to gracefully exit after they "
"finish processing their current job so that no existing jobs are lost. Since "
"the queue workers will exit when the `queue:restart` command is executed, "
"you should be running a process manager such as "
"[Supervisor](#supervisor-configuration) to automatically restart the queue "
"workers."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1393
#, markdown-text, no-wrap
msgid ""
"> {tip} The queue uses the [cache](/docs/{{version}}/cache) to store restart "
"signals, so you should verify that a cache driver is properly configured for "
"your application before using this feature.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1395
#, markdown-text, no-wrap
msgid "<a name=\"job-expirations-and-timeouts\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1395
#, markdown-text, no-wrap
msgid "Job Expirations & Timeouts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1398
#, markdown-text, no-wrap
msgid "<a name=\"job-expiration\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1398
#, markdown-text, no-wrap
msgid "Job Expiration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1401
#, markdown-text
msgid ""
"In your `config/queue.php` configuration file, each queue connection defines "
"a `retry_after` option. This option specifies how many seconds the queue "
"connection should wait before retrying a job that is being processed. For "
"example, if the value of `retry_after` is set to `90`, the job will be "
"released back onto the queue if it has been processing for 90 seconds "
"without being released or deleted. Typically, you should set the "
"`retry_after` value to the maximum number of seconds your jobs should "
"reasonably take to complete processing."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1403
#, markdown-text, no-wrap
msgid ""
"> {note} The only queue connection which does not contain a `retry_after` "
"value is Amazon SQS. SQS will retry the job based on the [Default Visibility "
"Timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) "
"which is managed within the AWS console.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1405
#, markdown-text, no-wrap
msgid "<a name=\"worker-timeouts\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1405
#, markdown-text, no-wrap
msgid "Worker Timeouts"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1408
#, markdown-text
msgid ""
"The `queue:work` Artisan command exposes a `--timeout` option. If a job is "
"processing for longer than the number of seconds specified by the timeout "
"value, the worker processing the job will exit with an error. Typically, the "
"worker will be restarted automatically by a [process manager configured on "
"your server](#supervisor-configuration):"
msgstr ""

#. type: Fenced code block (bash)
#: docs/master/queues.md:1409
#, no-wrap
msgid "php artisan queue:work --timeout=60\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1414
#, markdown-text
msgid ""
"The `retry_after` configuration option and the `--timeout` CLI option are "
"different, but work together to ensure that jobs are not lost and that jobs "
"are only successfully processed once."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1416
#, markdown-text, no-wrap
msgid ""
"> {note} The `--timeout` value should always be at least several seconds "
"shorter than your `retry_after` configuration value. This will ensure that a "
"worker processing a frozen job is always terminated before the job is "
"retried. If your `--timeout` option is longer than your `retry_after` "
"configuration value, your jobs may be processed twice.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1418
#, markdown-text, no-wrap
msgid "<a name=\"supervisor-configuration\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1418
#, markdown-text, no-wrap
msgid "Supervisor Configuration"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1421
#, markdown-text
msgid ""
"In production, you need a way to keep your `queue:work` processes running. A "
"`queue:work` process may stop running for a variety of reasons, such as an "
"exceeded worker timeout or the execution of the `queue:restart` command."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1423
#, markdown-text
msgid ""
"For this reason, you need to configure a process monitor that can detect "
"when your `queue:work` processes exit and automatically restart them. In "
"addition, process monitors can allow you to specify how many `queue:work` "
"processes you would like to run concurrently. Supervisor is a process "
"monitor commonly used in Linux environments and we will discuss how to "
"configure it in the following documentation."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1425
#, markdown-text, no-wrap
msgid "<a name=\"installing-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1425
#, markdown-text, no-wrap
msgid "Installing Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1428
#, markdown-text
msgid ""
"Supervisor is a process monitor for the Linux operating system, and will "
"automatically restart your `queue:work` processes if they fail. To install "
"Supervisor on Ubuntu, you may use the following command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1430
#, markdown-text, no-wrap
msgid "    sudo apt-get install supervisor\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1432
#, markdown-text, no-wrap
msgid ""
"> {tip} If configuring and managing Supervisor yourself sounds overwhelming, "
"consider using [Laravel Forge](https://forge.laravel.com), which will "
"automatically install and configure Supervisor for your production Laravel "
"projects.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1434
#, markdown-text, no-wrap
msgid "<a name=\"configuring-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1434
#, markdown-text, no-wrap
msgid "Configuring Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1437
#, markdown-text
msgid ""
"Supervisor configuration files are typically stored in the "
"`/etc/supervisor/conf.d` directory. Within this directory, you may create "
"any number of configuration files that instruct supervisor how your "
"processes should be monitored. For example, let's create a "
"`laravel-worker.conf` file that starts and monitors `queue:work` processes:"
msgstr ""

#. type: Fenced code block (ini)
#: docs/master/queues.md:1438
#, no-wrap
msgid ""
"[program:laravel-worker]\n"
"process_name=%(program_name)s_%(process_num)02d\n"
"command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 "
"--max-time=3600\n"
"autostart=true\n"
"autorestart=true\n"
"stopasgroup=true\n"
"killasgroup=true\n"
"user=forge\n"
"numprocs=8\n"
"redirect_stderr=true\n"
"stdout_logfile=/home/forge/app.com/worker.log\n"
"stopwaitsecs=3600\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1454
#, markdown-text
msgid ""
"In this example, the `numprocs` directive will instruct Supervisor to run "
"eight `queue:work` processes and monitor all of them, automatically "
"restarting them if they fail. You should change the `command` directive of "
"the configuration to reflect your desired queue connection and worker "
"options."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1456
#, markdown-text, no-wrap
msgid ""
"> {note} You should ensure that the value of `stopwaitsecs` is greater than "
"the number of seconds consumed by your longest running job. Otherwise, "
"Supervisor may kill the job before it is finished processing.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1458
#, markdown-text, no-wrap
msgid "<a name=\"starting-supervisor\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/master/queues.md:1458
#, markdown-text, no-wrap
msgid "Starting Supervisor"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1461
#, markdown-text
msgid ""
"Once the configuration file has been created, you may update the Supervisor "
"configuration and start the processes using the following commands:"
msgstr ""

#. type: Fenced code block (bash)
#: docs/master/queues.md:1462
#, no-wrap
msgid ""
"sudo supervisorctl reread\n"
"\n"
"sudo supervisorctl update\n"
"\n"
"sudo supervisorctl start laravel-worker:*\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1471
#, markdown-text
msgid ""
"For more information on Supervisor, consult the [Supervisor "
"documentation](http://supervisord.org/index.html)."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1473
#, markdown-text, no-wrap
msgid "<a name=\"dealing-with-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1473
#, markdown-text, no-wrap
msgid "Dealing With Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1476
#, markdown-text
msgid ""
"Sometimes your queued jobs will fail. Don't worry, things don't always go as "
"planned! Laravel includes a convenient way to [specify the maximum number of "
"times a job should be attempted](#max-job-attempts-and-timeout). After a job "
"has exceeded this number of attempts, it will be inserted into the "
"`failed_jobs` database table. Of course, we will need to create that table "
"if it does not already exist. To create a migration for the `failed_jobs` "
"table, you may use the `queue:failed-table` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1478
#, markdown-text, no-wrap
msgid "    php artisan queue:failed-table\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1482
#, markdown-text
msgid ""
"When running a [queue worker](#running-the-queue-worker) process, you may "
"specify the maximum number of times a job should be attempted using the "
"`--tries` switch on the `queue:work` command. If you do not specify a value "
"for the `--tries` option, jobs will only be attempted once or as many times "
"as specified by the job class' `$tries` property:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1484
#, markdown-text, no-wrap
msgid "    php artisan queue:work redis --tries=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1486
#, markdown-text
msgid ""
"Using the `--backoff` option, you may specify how many seconds Laravel "
"should wait before retrying a job that has encountered an exception. By "
"default, a job is immediately released back onto the queue so that it may be "
"attempted again:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1488
#, markdown-text, no-wrap
msgid "    php artisan queue:work redis --tries=3 --backoff=3\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1490
#, markdown-text
msgid ""
"If you would like to configure how many seconds Laravel should wait before "
"retrying a job that has encountered an exception on a per-job basis, you may "
"do so by defining a `backoff` property on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1497
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * The number of seconds to wait before retrying the job.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $backoff = 3;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1499
#, markdown-text
msgid ""
"If you require more complex logic for determining the job's backoff time, "
"you may define a `backoff` method on your job class:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1509
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"    * Calculate the number of seconds to wait before retrying the job.\n"
"    *\n"
"    * @return int\n"
"    */\n"
"    public function backoff()\n"
"    {\n"
"        return 3;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1511
#, markdown-text
msgid ""
"You may easily configure \"exponential\" backoffs by returning an array of "
"backoff values from the `backoff` method. In this example, the retry delay "
"will be 1 second for the first retry, 5 seconds for the second retry, and 10 "
"seconds for the third retry:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1521
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"    * Calculate the number of seconds to wait before retrying the job.\n"
"    *\n"
"    * @return array\n"
"    */\n"
"    public function backoff()\n"
"    {\n"
"        return [1, 5, 10];\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1523
#, markdown-text, no-wrap
msgid "<a name=\"cleaning-up-after-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1523
#, markdown-text, no-wrap
msgid "Cleaning Up After Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1526
#, markdown-text
msgid ""
"When a particular job fails, you may want to send an alert to your users or "
"revert any actions that were partially completed by the job. To accomplish "
"this, you may define a `failed` method on your job class. The `Throwable` "
"instance that caused the job to fail will be passed to the `failed` method:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1538
#, markdown-text, no-wrap
msgid ""
"    use App\\Models\\Podcast;\n"
"    use App\\Services\\AudioProcessor;\n"
"    use Illuminate\\Bus\\Queueable;\n"
"    use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"    use Illuminate\\Queue\\InteractsWithQueue;\n"
"    use Illuminate\\Queue\\SerializesModels;\n"
"    use Throwable;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1542
#, markdown-text, no-wrap
msgid ""
"    class ProcessPodcast implements ShouldQueue\n"
"    {\n"
"        use InteractsWithQueue, Queueable, SerializesModels;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1549
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * The podcast instance.\n"
"         *\n"
"         * @var \\App\\Podcast\n"
"         */\n"
"        protected $podcast;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1560
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Create a new job instance.\n"
"         *\n"
"         * @param  \\App\\Models\\Podcast  $podcast\n"
"         * @return void\n"
"         */\n"
"        public function __construct(Podcast $podcast)\n"
"        {\n"
"            $this->podcast = $podcast;\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1571
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Execute the job.\n"
"         *\n"
"         * @param  \\App\\Services\\AudioProcessor  $processor\n"
"         * @return void\n"
"         */\n"
"        public function handle(AudioProcessor $processor)\n"
"        {\n"
"            // Process uploaded podcast...\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1583
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Handle a job failure.\n"
"         *\n"
"         * @param  \\Throwable  $exception\n"
"         * @return void\n"
"         */\n"
"        public function failed(Throwable $exception)\n"
"        {\n"
"            // Send user notification of failure, etc...\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1585
#, markdown-text, no-wrap
msgid "<a name=\"retrying-failed-jobs\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1585
#, markdown-text, no-wrap
msgid "Retrying Failed Jobs"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1588
#, markdown-text
msgid ""
"To view all of the failed jobs that have been inserted into your "
"`failed_jobs` database table, you may use the `queue:failed` Artisan "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1590
#, markdown-text, no-wrap
msgid "    php artisan queue:failed\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1592
#, markdown-text
msgid ""
"The `queue:failed` command will list the job ID, connection, queue, failure "
"time, and other information about the job. The job ID may be used to retry "
"the failed job. For instance, to retry a failed job that has an ID of `5`, "
"issue the following command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1594
#, markdown-text, no-wrap
msgid "    php artisan queue:retry 5\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1596
#, markdown-text
msgid ""
"If necessary, you may pass multiple IDs or an ID range (when using numeric "
"IDs) to the command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1598
#, markdown-text, no-wrap
msgid "    php artisan queue:retry 5 6 7 8 9 10\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1600
#, markdown-text, no-wrap
msgid "    php artisan queue:retry --range=5-10\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1602
#, markdown-text
msgid ""
"To retry all of your failed jobs, execute the `queue:retry` command and pass "
"`all` as the ID:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1604
#, markdown-text, no-wrap
msgid "    php artisan queue:retry all\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1606
#, markdown-text
msgid ""
"If you would like to delete a failed job, you may use the `queue:forget` "
"command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1608
#, markdown-text, no-wrap
msgid "    php artisan queue:forget 5\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1610
#, markdown-text, no-wrap
msgid ""
"> {tip} When using [Horizon](/docs/{{version}}/horizon), you should use the "
"`horizon:forget` command to delete a failed job instead of the "
"`queue:forget` command.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1612
#, markdown-text
msgid ""
"To delete all of your failed jobs from the `failed_jobs` table, you may use "
"the `queue:flush` command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1614
#, markdown-text, no-wrap
msgid "    php artisan queue:flush\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1616
#, markdown-text, no-wrap
msgid "<a name=\"ignoring-missing-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1616
#, markdown-text, no-wrap
msgid "Ignoring Missing Models"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1619
#, markdown-text
msgid ""
"When injecting an Eloquent model into a job, the model is automatically "
"serialized before being placed on the queue and re-retrieved from the "
"database when the job is processed. However, if the model has been deleted "
"while the job was waiting to be processed by a worker, your job may fail "
"with a `ModelNotFoundException`."
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1621
#, markdown-text
msgid ""
"For convenience, you may choose to automatically delete jobs with missing "
"models by setting your job's `deleteWhenMissingModels` property to "
"`true`. When this property is set to `true`, Laravel will quietly discard "
"the job without raising an exception:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1628
#, markdown-text, no-wrap
msgid ""
"    /**\n"
"     * Delete the job if its models no longer exist.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $deleteWhenMissingModels = true;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1630
#, markdown-text, no-wrap
msgid "<a name=\"failed-job-events\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/master/queues.md:1630
#, markdown-text, no-wrap
msgid "Failed Job Events"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1633
#, markdown-text
msgid ""
"If you would like to register an event listener that will be invoked when a "
"job fails, you may use the `Queue` facade's `failing` method. For example, "
"we may attach a closure to this event from the `boot` method of the "
"`AppServiceProvider` that is included with Laravel:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1637 docs/master/queues.md:1692
#, markdown-text, no-wrap
msgid "    namespace App\\Providers;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1641
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Queue;\n"
"    use Illuminate\\Support\\ServiceProvider;\n"
"    use Illuminate\\Queue\\Events\\JobFailed;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1653 docs/master/queues.md:1709
#, markdown-text, no-wrap
msgid ""
"    class AppServiceProvider extends ServiceProvider\n"
"    {\n"
"        /**\n"
"         * Register any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function register()\n"
"        {\n"
"            //\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1668
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Bootstrap any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function boot()\n"
"        {\n"
"            Queue::failing(function (JobFailed $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->exception\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1670
#, markdown-text, no-wrap
msgid "<a name=\"clearing-jobs-from-queues\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1670
#, markdown-text, no-wrap
msgid "Clearing Jobs From Queues"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1673
#, markdown-text, no-wrap
msgid ""
"> {tip} When using [Horizon](/docs/{{version}}/horizon), you should use the "
"`horizon:clear` command to clear jobs from the queue instead of the "
"`queue:clear` command.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1675
#, markdown-text
msgid ""
"If you would like to delete all jobs from the default queue of the default "
"connection, you may do so using the `queue:clear` Artisan command:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1677
#, markdown-text, no-wrap
msgid "    php artisan queue:clear\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1679
#, markdown-text
msgid ""
"You may also provide the `connection` argument and `queue` option to delete "
"jobs from a specific connection and queue:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1681
#, markdown-text, no-wrap
msgid "    php artisan queue:clear redis --queue=emails\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1683
#, markdown-text, no-wrap
msgid ""
"> {note} Clearing jobs from queues is only available for the SQS, Redis, and "
"database queue drivers. In addition, the SQS message deletion process takes "
"up to 60 seconds, so jobs sent to the SQS queue up to 60 seconds after you "
"clear the queue might also be deleted.\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1685
#, markdown-text, no-wrap
msgid "<a name=\"job-events\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/master/queues.md:1685
#, markdown-text, no-wrap
msgid "Job Events"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1688
#, markdown-text
msgid ""
"Using the `before` and `after` methods on the `Queue` "
"[facade](/docs/{{version}}/facades), you may specify callbacks to be "
"executed before or after a queued job is processed. These callbacks are a "
"great opportunity to perform additional logging or increment statistics for "
"a dashboard. Typically, you should call these methods from the `boot` method "
"of a [service provider](/docs/{{version}}/providers). For example, we may "
"use the `AppServiceProvider` that is included with Laravel:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1697
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\Queue;\n"
"    use Illuminate\\Support\\ServiceProvider;\n"
"    use Illuminate\\Queue\\Events\\JobProcessed;\n"
"    use Illuminate\\Queue\\Events\\JobProcessing;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1722
#, markdown-text, no-wrap
msgid ""
"        /**\n"
"         * Bootstrap any application services.\n"
"         *\n"
"         * @return void\n"
"         */\n"
"        public function boot()\n"
"        {\n"
"            Queue::before(function (JobProcessing $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->job->payload()\n"
"            });\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1730
#, markdown-text, no-wrap
msgid ""
"            Queue::after(function (JobProcessed $event) {\n"
"                // $event->connectionName\n"
"                // $event->job\n"
"                // $event->job->payload()\n"
"            });\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1732
#, markdown-text
msgid ""
"Using the `looping` method on the `Queue` "
"[facade](/docs/{{version}}/facades), you may specify callbacks that execute "
"before the worker attempts to fetch a job from a queue. For example, you "
"might register a closure to rollback any transactions that were left open by "
"a previously failed job:"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1735
#, markdown-text, no-wrap
msgid ""
"    use Illuminate\\Support\\Facades\\DB;\n"
"    use Illuminate\\Support\\Facades\\Queue;\n"
msgstr ""

#. type: Plain text
#: docs/master/queues.md:1740
#, markdown-text, no-wrap
msgid ""
"    Queue::looping(function () {\n"
"        while (DB::transactionLevel() > 0) {\n"
"            DB::rollBack();\n"
"        }\n"
"    });\n"
msgstr ""
