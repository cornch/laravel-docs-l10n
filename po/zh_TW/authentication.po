msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/authentication.pot\n"
"X-Crowdin-File-ID: 11\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2024-06-30 09:00\n"

#: docs/10.x/authentication.md:block 1 (header)
msgid "Authentication"
msgstr "認證"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Starter Kits](#starter-kits)"
msgstr "[入門套件](#starter-kits)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Database Considerations](#introduction-database-considerations)"
msgstr "[資料庫選擇](#introduction-database-considerations)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Ecosystem Overview](#ecosystem-overview)"
msgstr "[生態鏈概覽](#ecosystem-overview)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Authentication Quickstart](#authentication-quickstart)"
msgstr "[「驗證」快速入門](#authentication-quickstart)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Install a Starter Kit](#install-a-starter-kit)"
msgstr ""

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Retrieving the Authenticated User](#retrieving-the-authenticated-user)"
msgstr ""

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Protecting Routes](#protecting-routes)"
msgstr "[受保護的 Route](#protecting-routes)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Login Throttling](#login-throttling)"
msgstr "[登入頻率限制](#login-throttling)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Manually Authenticating Users](#authenticating-users)"
msgstr "[手動登入使用者](#authenticating-users)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Remembering Users](#remembering-users)"
msgstr "[記住使用者](#remembering-users)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Other Authentication Methods](#other-authentication-methods)"
msgstr "[其他認證方法](#other-authentication-methods)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[HTTP Basic Authentication](#http-basic-authentication)"
msgstr "[HTTP Basic 認證](#http-basic-authentication)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Stateless HTTP Basic Authentication](#stateless-http-basic-authentication)"
msgstr "[Stateless HTTP Basic 認證](#stateless-http-basic-authentication)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Logging Out](#logging-out)"
msgstr "[登出](#logging-out)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Invalidating Sessions on Other Devices](#invalidating-sessions-on-other-devices)"
msgstr ""

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Password Confirmation](#password-confirmation)"
msgstr "[確認密碼](#password-confirmation)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Configuration](#password-confirmation-configuration)"
msgstr "[設定](#password-confirmation-configuration)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Routing](#password-confirmation-routing)"
msgstr "[路由](#password-confirmation-routing)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Protecting Routes](#password-confirmation-protecting-routes)"
msgstr "[保護 Route](#password-confirmation-protecting-routes)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Adding Custom Guards](#adding-custom-guards)"
msgstr "[新增自訂 Guard](#adding-custom-guards)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Closure Request Guards](#closure-request-guards)"
msgstr "[閉包的 Request Guard](#closure-request-guards)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Adding Custom User Providers](#adding-custom-user-providers)"
msgstr "[新增自訂的 User Provider](#adding-custom-user-providers)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[The User Provider Contract](#the-user-provider-contract)"
msgstr "[UserProvider Contract](#the-user-provider-contract)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[The Authenticatable Contract](#the-authenticatable-contract)"
msgstr "[Authenticatable Contract](#the-authenticatable-contract)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Social Authentication](/docs/{{version}}/socialite)"
msgstr "[社群登入](/docs/{{version}}/socialite)"

#: docs/10.x/authentication.md:block 2 (unordered list)
msgid "[Events](#events)"
msgstr "[事件](#events)"

#: docs/10.x/authentication.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/10.x/authentication.md:block 5 (paragraph)
msgid "Many web applications provide a way for their users to authenticate with the application and \"login\". Implementing this feature in web applications can be a complex and potentially risky endeavor. For this reason, Laravel strives to give you the tools you need to implement authentication quickly, securely, and easily."
msgstr "許多網頁 App 都提供了讓使用者向 App 認證以及「登入」的功能。在網頁 App 上實作這些功能可能會很複雜，而且可能會有些風險。為此，Laravel 竭力為你提供了用於快速、安全、且簡單地實作認證功能的工具。"

#: docs/10.x/authentication.md:block 6 (paragraph)
msgid "At its core, Laravel's authentication facilities are made up of \"guards\" and \"providers\". Guards define how users are authenticated for each request. For example, Laravel ships with a `session` guard which maintains state using session storage and cookies."
msgstr "在 Laravel 的核心中，認證功能是通過「Guard」與「Provider」來提供的。Guard 用來定義使用者在每個請求上是如何被認證的。舉例來說，Laravel 附帶了一個 `session` Guard，會通過 Session 儲存空間與 Cookie 來維護認證狀態。"

#: docs/10.x/authentication.md:block 7 (paragraph)
msgid "Providers define how users are retrieved from your persistent storage. Laravel ships with support for retrieving users using [Eloquent](/docs/{{version}}/eloquent) and the database query builder. However, you are free to define additional providers as needed for your application."
msgstr "Provider 則定義了要如何從長期儲存空間內取得使用者。Laravel 內建支援使用 [Eloquent](/docs/{{version}}/eloquent) 或資料庫 Query Builder 來取得使用者。不過，你也可以自行依據需求額外定義其他 Provider。"

#: docs/10.x/authentication.md:block 8 (paragraph)
msgid "Your application's authentication configuration file is located at `config/auth.php`. This file contains several well-documented options for tweaking the behavior of Laravel's authentication services."
msgstr "你的專案的認證設定檔位於 `config/auth.php` 內。該檔案包含了多個有文件說明的選項，可以調整 Laravel 認證服務的行為。"

#: docs/10.x/authentication.md:block 9 (quote)
msgid "[!NOTE] Guards and providers should not be confused with \"roles\" and \"permissions\". To learn more about authorizing user actions via permissions, please refer to the [authorization](/docs/{{version}}/authorization) documentation."
msgstr ""

#: docs/10.x/authentication.md:block 11 (header)
msgid "Starter Kits"
msgstr "入門套件"

#: docs/10.x/authentication.md:block 12 (paragraph)
msgid "Want to get started fast? Install a [Laravel application starter kit](/docs/{{version}}/starter-kits) in a fresh Laravel application. After migrating your database, navigate your browser to `/register` or any other URL that is assigned to your application. The starter kits will take care of scaffolding your entire authentication system!"
msgstr "想要快速入門嗎？請在全新的 Laravel 專案內安裝一個 [Laravel 專案入門套件](docs/{{version}}/starter-kits)。完成資料庫遷移後，在瀏覽器上開啟 `/register` 或其他任何設定給應用程式的 URL。這些入門套件會幫你搞定整個認證系統的 Scaffolding。"

#: docs/10.x/authentication.md:block 13 (paragraph)
msgid "**Even if you choose not to use a starter kit in your final Laravel application, installing the [Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze) starter kit can be a wonderful opportunity to learn how to implement all of Laravel's authentication functionality in an actual Laravel project.** Since Laravel Breeze creates authentication controllers, routes, and views for you, you can examine the code within these files to learn how Laravel's authentication features may be implemented."
msgstr "**就算最後不會在 Laravel 專案上使用任何一種入門套件，安裝 [Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze) 入門套件也是個學習如何在實際 Laravel 專案上實作所有 Laravel 認證功能的好機會。** 由於 Laravel Breeze 會為你建立好認證 Controller、路由、以及 View，因此可以通過閱讀這些檔案的程式碼來學習可如何實作 Laravel 的認證功能。"

#: docs/10.x/authentication.md:block 15 (header)
msgid "Database Considerations"
msgstr "資料庫選擇"

#: docs/10.x/authentication.md:block 16 (paragraph)
msgid "By default, Laravel includes an `App\\Models\\User` [Eloquent model](/docs/{{version}}/eloquent) in your `app/Models` directory. This model may be used with the default Eloquent authentication driver. If your application is not using Eloquent, you may use the `database` authentication provider which uses the Laravel query builder."
msgstr "預設情況下，Laravel 在 `app/Models` 資料夾中包含了一個 `App\\Models\\User` [Eloquent Model](/docs/{{version}}/eloquent)。這個 Model 可以用在預設的 Eloquent 登入 Driver 上。若你的專案不使用 Eloquent，則可以使用 `database` 認證 Provider，該 Provider 使用 Laravel 的 Query Builder。"

#: docs/10.x/authentication.md:block 17 (paragraph)
msgid "When building the database schema for the `App\\Models\\User` model, make sure the password column is at least 60 characters in length. Of course, the `users` table migration that is included in new Laravel applications already creates a column that exceeds this length."
msgstr "為 `App\\Models\\User` 模型建立資料庫結構時，請確保密碼欄位的長度至少有 60 個字元。當然，在新建立的 Laravel 專案中， `users` 資料表遷移檔已經建立了超過這個長度的欄位。"

#: docs/10.x/authentication.md:block 18 (paragraph)
msgid "Also, you should verify that your `users` (or equivalent) table contains a nullable, string `remember_token` column of 100 characters. This column will be used to store a token for users that select the \"remember me\" option when logging into your application. Again, the default `users` table migration that is included in new Laravel applications already contains this column."
msgstr "另外，也請求確保 `users`（或其相應的）資料表有包含一個 Nullable、100 字元的 `remember_token` 字串欄位。該欄位會用來在使用者登入時勾選「記住我」選項時使用。同樣地，在新建立的 Laravel 專案中，`users` 資料表遷移檔已經有包含了這個欄位。"

#: docs/10.x/authentication.md:block 20 (header)
msgid "Ecosystem Overview"
msgstr "生態鏈概覽"

#: docs/10.x/authentication.md:block 21 (paragraph)
msgid "Laravel offers several packages related to authentication. Before continuing, we'll review the general authentication ecosystem in Laravel and discuss each package's intended purpose."
msgstr "Laravel 提供了多個有關認證的套件。在繼續之前，我們先來看看這些 Laravel 中的一般認證生態鏈，並討論各個套件預設的目的。"

#: docs/10.x/authentication.md:block 22 (paragraph)
msgid "First, consider how authentication works. When using a web browser, a user will provide their username and password via a login form. If these credentials are correct, the application will store information about the authenticated user in the user's [session](/docs/{{version}}/session). A cookie issued to the browser contains the session ID so that subsequent requests to the application can associate the user with the correct session. After the session cookie is received, the application will retrieve the session data based on the session ID, note that the authentication information has been stored in the session, and will consider the user as \"authenticated\"."
msgstr "首先，我們先來看看認證是怎麼運作的。在使用網頁瀏覽器時，使用者會通過登入表格來提供他們的使用者名稱以及密碼。若帳號密碼正確，則網站會將已認證使用者的資訊儲存在使用者的 [Session](/docs/{{version}}/session) 中。Cookie 會傳給瀏覽器，其中包含了 Session ID。這樣一來，我們就可以通過正確的 Session 來將接下來向網站發起的請求與使用者連結起來。收到 Session Cookie 後，網站會依據 Session ID 來取得 Session 資料。請注意，由於認證資訊已經被保存在 Session 中了，所以該使用者將被視為「已認證」。"

#: docs/10.x/authentication.md:block 23 (paragraph)
msgid "When a remote service needs to authenticate to access an API, cookies are not typically used for authentication because there is no web browser. Instead, the remote service sends an API token to the API on each request. The application may validate the incoming token against a table of valid API tokens and \"authenticate\" the request as being performed by the user associated with that API token."
msgstr "當遠端服務需要認證來存取 API 時，通常不會在認證上使用 Cookie，因為這種情況下並沒有網頁瀏覽器。取而代之地，遠端服務會在每個請求時帶上 API 權杖。網站可以通過將傳入的權杖與包含了有效 API 憑證的資料表進行比對來「認證」該請求，並將其視為是有與 API 權杖管理的使用者所進行的操作。"

#: docs/10.x/authentication.md:block 25 (header)
msgid "Laravel's Built-in Browser Authentication Services"
msgstr "Laravel 的內建瀏覽器認證服務"

#: docs/10.x/authentication.md:block 26 (paragraph)
msgid "Laravel includes built-in authentication and session services which are typically accessed via the `Auth` and `Session` facades. These features provide cookie-based authentication for requests that are initiated from web browsers. They provide methods that allow you to verify a user's credentials and authenticate the user. In addition, these services will automatically store the proper authentication data in the user's session and issue the user's session cookie. A discussion of how to use these services is contained within this documentation."
msgstr "Laravel 的內建認證與 Session 服務通常會通過 `Auth` 與 `Session` Facade 來存取。這些功能為從瀏覽器發起的請求提供了基於 Cookie 的認證功能。這些功能也提供了能認證使用者憑證與認證使用者的方法。此外，這些服務也會自動將正確的資料儲存在使用者的 Session 內，並為使用者核發 Session Cookie。本文件中包含了如何使用這些服務的討論。"

#: docs/10.x/authentication.md:block 27 (paragraph)
msgid "**Application Starter Kits**"
msgstr "**應用程式入門套件**"

#: docs/10.x/authentication.md:block 28 (paragraph)
msgid "As discussed in this documentation, you can interact with these authentication services manually to build your application's own authentication layer. However, to help you get started more quickly, we have released [free packages](/docs/{{version}}/starter-kits) that provide robust, modern scaffolding of the entire authentication layer. These packages are [Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze), [Laravel Jetstream](/docs/{{version}}/starter-kits#laravel-jetstream), and [Laravel Fortify](/docs/{{version}}/fortify)."
msgstr "我們剛才也在本文中討論過，你可以通過手動操作這些認證服務來為專案建立一套「認證層」。但，為了讓你可以更快入門，我們也釋出了[一些免費套件](/docs/{{version}}/starter-kits)來提供更快速且現代化的完整認證層 Scaffolding：[Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze), [Laravel Jetstream](/docs/{{version}}/starter-kits#laravel-jetstream)，與 [Laravel Fortify](/docs/{{version}}/fortify)。"

#: docs/10.x/authentication.md:block 29 (paragraph)
msgid "*Laravel Breeze* is a simple, minimal implementation of all of Laravel's authentication features, including login, registration, password reset, email verification, and password confirmation. Laravel Breeze's view layer is comprised of simple [Blade templates](/docs/{{version}}/blade) styled with [Tailwind CSS](https://tailwindcss.com). To get started, check out the documentation on Laravel's [application starter kits](/docs/{{version}}/starter-kits)."
msgstr "**Laravel Breeze** 是一個簡單且最小化實作出所有 Laravel 驗證功能的套件，包含登入、註冊、密碼重設、電子郵件驗證、以及密碼確認。Laravel Breeze 的檢視器層是通過簡單的 [Blade 樣板](/docs/{{version}}/blade) 搭配 [Tailwind CSS](https://tailwindcss.com) 提供樣式組合而成的。若要瞭解有關 Laravel Breeze，請參考 Laravel 的 [應用程式入門套件](/docs/{{version}}/starter-kits) 說明文件。"

#: docs/10.x/authentication.md:block 30 (paragraph)
msgid "*Laravel Fortify* is a headless authentication backend for Laravel that implements many of the features found in this documentation, including cookie-based authentication as well as other features such as two-factor authentication and email verification. Fortify provides the authentication backend for Laravel Jetstream or may be used independently in combination with [Laravel Sanctum](/docs/{{version}}/sanctum) to provide authentication for an SPA that needs to authenticate with Laravel."
msgstr "**Laravel Fortify** 是一種用於 Laravel 的無周邊（Headless）驗證後端。Laravel Fortify 實作了許多可在此說明文件中找到的功能，包含基於 Cookie 的驗證以及其他如二步驟驗證與電子郵件驗證等功能。Fortify 也為 Laravel Jetstream 提供了驗證後端。或者，也可以通過與 [Laravel Sanctum](/docs/{{version}}/sanctum) 組合使用來為需要在 Laravel 中進行驗證的 SPA（Single Page Application，單一頁面應用程式）提供驗證功能。"

#: docs/10.x/authentication.md:block 31 (paragraph)
msgid "*[Laravel Jetstream](https://jetstream.laravel.com)* is a robust application starter kit that consumes and exposes Laravel Fortify's authentication services with a beautiful, modern UI powered by [Tailwind CSS](https://tailwindcss.com), [Livewire](https://livewire.laravel.com), and / or [Inertia](https://inertiajs.com). Laravel Jetstream includes optional support for two-factor authentication, team support, browser session management, profile management, and built-in integration with [Laravel Sanctum](/docs/{{version}}/sanctum) to offer API token authentication. Laravel's API authentication offerings are discussed below."
msgstr "**[Laravel Jetstream](https://jetstream.laravel.com)** 是一個強大的入門套件，該套件使用者 Laravel Fortify 的驗證服務，並將其通過 [Tailwind CSS](https://tailwindcss.com), [Livewire](https://livewire.laravel.com)，與／或 [Inertia](https://inertiajs.com) 來提供美麗且現代的 UI。Laravel Jetstream 也提供了對二步驟驗證、團隊支援、瀏覽器啟程管理、個人檔案管理、以及內建與 [Laravel Sanctum](/docs/{{version}}/sunctum) 整合來提供 API 權杖驗證的可選支援。Laravel 提供的 API 驗證功能將在下方討論。"

#: docs/10.x/authentication.md:block 33 (header)
msgid "Laravel's API Authentication Services"
msgstr "Laravel 的 API 認證服務"

#: docs/10.x/authentication.md:block 34 (paragraph)
msgid "Laravel provides two optional packages to assist you in managing API tokens and authenticating requests made with API tokens: [Passport](/docs/{{version}}/passport) and [Sanctum](/docs/{{version}}/sanctum). Please note that these libraries and Laravel's built-in cookie based authentication libraries are not mutually exclusive. These libraries primarily focus on API token authentication while the built-in authentication services focus on cookie based browser authentication. Many applications will use both Laravel's built-in cookie based authentication services and one of Laravel's API authentication packages."
msgstr "Laravel 提供了兩個可選的套件來協助你管理 API 權杖以及認證以 API 權杖建立的請求：[Passport](/docs/{{version}}/passport) 與 [Sanctum](/docs/{{version}}/sanctum)。請注意，這些函式庫與 Laravel 內建的基於 Cookie 的認證函式庫並不互相衝突。這些函式庫的重點都是在提供 API 進行權杖認證，而內建的認證服務則著重於基於 Cookie 的瀏覽器認證。許多網站都會同時使用 Laravel 內建的基於 Cookie 的認證服務，以及其中一種 Laravel 的 API 認證套件。"

#: docs/10.x/authentication.md:block 35 (paragraph)
msgid "**Passport**"
msgstr "**Passport**"

#: docs/10.x/authentication.md:block 36 (paragraph)
msgid "Passport is an OAuth2 authentication provider, offering a variety of OAuth2 \"grant types\" which allow you to issue various types of tokens. In general, this is a robust and complex package for API authentication. However, most applications do not require the complex features offered by the OAuth2 spec, which can be confusing for both users and developers. In addition, developers have been historically confused about how to authenticate SPA applications or mobile applications using OAuth2 authentication providers like Passport."
msgstr "Passport 是一個 OAuth2 認證 Provider，提供了多種 OAuth2 的「Grant Type」來讓你簽發各種不同的權杖。通常來說，對於 API 認證來說 Passport 是一個很強大很複雜的套件。但，大多數的網站並不需要 OAuth2 規格所提供的那些複雜的功能。這些功能只會讓使用者與開發人員都搞不清楚要怎麼用。而且，很多開發人員都搞不懂要怎麽樣使用 Passport 這樣的 OAuth2 認證 Provider 來認證 SPA App 或手機 App。"

#: docs/10.x/authentication.md:block 37 (paragraph)
msgid "**Sanctum**"
msgstr "**Sanctum**"

#: docs/10.x/authentication.md:block 38 (paragraph)
msgid "In response to the complexity of OAuth2 and developer confusion, we set out to build a simpler, more streamlined authentication package that could handle both first-party web requests from a web browser and API requests via tokens. This goal was realized with the release of [Laravel Sanctum](/docs/{{version}}/sanctum), which should be considered the preferred and recommended authentication package for applications that will be offering a first-party web UI in addition to an API, or will be powered by a single-page application (SPA) that exists separately from the backend Laravel application, or applications that offer a mobile client."
msgstr "為了處理 OAuth2 很複雜的問題以及解決開發者的困惑，我們希望建立一種更簡單、更精簡的認證套件。這個套件不但要可以處理來自網頁瀏覽器的第一方網頁請求，也要可以處理通過權杖發起的 API 請求。我們在 [Laravel Sanctum](/docs/{{version}}/sanctum) 中解決了這些問題。對於「有提供第一方 Web UI 的 API」、「有獨立 Laravel 後端的 SPA」、或是「有提供手機 App 的網站」，Laravel Sanctum 目前是我們推薦與建議的認證套件。"

#: docs/10.x/authentication.md:block 39 (paragraph)
msgid "Laravel Sanctum is a hybrid web / API authentication package that can manage your application's entire authentication process. This is possible because when Sanctum based applications receive a request, Sanctum will first determine if the request includes a session cookie that references an authenticated session. Sanctum accomplishes this by calling Laravel's built-in authentication services which we discussed earlier. If the request is not being authenticated via a session cookie, Sanctum will inspect the request for an API token. If an API token is present, Sanctum will authenticate the request using that token. To learn more about this process, please consult Sanctum's [\"how it works\"](/docs/{{version}}/sanctum#how-it-works) documentation."
msgstr "Laravel Sanctum 混合了網頁認證與 API 認證，可以用來處理整個網站的認證流程。怎麼做到的呢？當使用 Sanctum 的網站收到請求後，Sanctum 會先判斷該請求是否有包含了認證 Session 的 Session Cookie。Sanctum 是通過呼叫我們稍早討論過的 Laravel 內建認證服務來達成此一功能的。若該請求的 Session Cookie 未被認證過，則 Sanctum 接著會檢查請求的 API 權杖。若有找到 API 權杖，則 Sanctum 會使用該權杖來認證請求。要瞭解更多有關此一流程的資訊，請參考 Sanctum 的[「運作方式」](/docs/{{version}}/sanctum#how-it-works)說明文件。"

#: docs/10.x/authentication.md:block 40 (paragraph)
msgid "Laravel Sanctum is the API package we have chosen to include with the [Laravel Jetstream](https://jetstream.laravel.com) application starter kit because we believe it is the best fit for the majority of web application's authentication needs."
msgstr "Laravel Sanctum 是我們在 [Laravel Jetstream](https://jetstream.laravel.com) 專案入門套件中選擇的 API 套件，因為我們認為該套件最符合大多數網頁 App 的認證需求。"

#: docs/10.x/authentication.md:block 42 (header)
msgid "Summary and Choosing Your Stack"
msgstr ""

#: docs/10.x/authentication.md:block 43 (paragraph)
msgid "In summary, if your application will be accessed using a browser and you are building a monolithic Laravel application, your application will use Laravel's built-in authentication services."
msgstr "總結一下，若你的專案會通過瀏覽器來存取，而且你只會製作單一一個 Laravel 專案，則應使用 Laravel 的內建認證服務。"

#: docs/10.x/authentication.md:block 44 (paragraph)
msgid "Next, if your application offers an API that will be consumed by third parties, you will choose between [Passport](/docs/{{version}}/passport) or [Sanctum](/docs/{{version}}/sanctum) to provide API token authentication for your application. In general, Sanctum should be preferred when possible since it is a simple, complete solution for API authentication, SPA authentication, and mobile authentication, including support for \"scopes\" or \"abilities\"."
msgstr "若你的專案中包含了會被第三方使用的 API，則應選擇 [Passport](/docs/{{version}}/passport) 或 [Sanctum](/docs/{{version}}/sanctum) 來為專案提供 API 權杖認證。一般來說，應該儘量先選擇 Sanctum，因為 Sanctum 對 API 認證、SPA 認證、以及行動裝置認證來說是最簡單且完整的解決方案，而且也支援「範圍 (Scope)」與「權限 (Ability)」。"

#: docs/10.x/authentication.md:block 45 (paragraph)
msgid "If you are building a single-page application (SPA) that will be powered by a Laravel backend, you should use [Laravel Sanctum](/docs/{{version}}/sanctum). When using Sanctum, you will either need to [manually implement your own backend authentication routes](#authenticating-users) or utilize [Laravel Fortify](/docs/{{version}}/fortify) as a headless authentication backend service that provides routes and controllers for features such as registration, password reset, email verification, and more."
msgstr "如果你正在製作由 Laravel 提供後端的 SPA，則應該使用 [Laravel Sanctum](/docs/{{version}}/sanctum)。在使用 Sanctum 時，會需要[手動實作你自己的認證路由後端](#authenticating-users)，或是使用 [Laravel Fortify](/docs/{{version}}/fortify) 來作為 Headless 的認證後端服務，來為註冊、密碼重設、電子郵件認證等功能提供路由與 Controller。"

#: docs/10.x/authentication.md:block 46 (paragraph)
msgid "Passport may be chosen when your application absolutely needs all of the features provided by the OAuth2 specification."
msgstr "當你的專案真的需要所有 OAuth2 規格所提供的功能時，就可以選擇使用 Passport。"

#: docs/10.x/authentication.md:block 47 (paragraph)
msgid "And, if you would like to get started quickly, we are pleased to recommend [Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze) as a quick way to start a new Laravel application that already uses our preferred authentication stack of Laravel's built-in authentication services and Laravel Sanctum."
msgstr "此外，若想要快速入門，我們誠摯推薦你使用 [Laravel Breeze](/docs/{{version}}/starter-kits#laravel-breeze) 來作為快速建立新 Laravel 專案的方法。Laravel Breeze 已經使用了我們偏好的認證 Stack —— 使用 Laravel 的內建認證服務與 Laravel Sanctum。"

#: docs/10.x/authentication.md:block 49 (header)
msgid "Authentication Quickstart"
msgstr "「認證」快速入門"

#: docs/10.x/authentication.md:block 50 (quote)
msgid "[!WARNING] This portion of the documentation discusses authenticating users via the [Laravel application starter kits](/docs/{{version}}/starter-kits), which includes UI scaffolding to help you get started quickly. If you would like to integrate with Laravel's authentication systems directly, check out the documentation on [manually authenticating users](#authenticating-users)."
msgstr ""

#: docs/10.x/authentication.md:block 52 (header)
msgid "Install a Starter Kit"
msgstr ""

#: docs/10.x/authentication.md:block 53 (paragraph)
msgid "First, you should [install a Laravel application starter kit](/docs/{{version}}/starter-kits). Our current starter kits, Laravel Breeze and Laravel Jetstream, offer beautifully designed starting points for incorporating authentication into your fresh Laravel application."
msgstr "首先，需要[安裝一個 Laravel 專案入門套件](/docs/{{version}}/starter-kits)。我們目前的入門套件 —— Laravel Breeze 與 Laravel Jetstream —— 都是讓你的 Laravel 新專案有個美觀設計的起始點。"

#: docs/10.x/authentication.md:block 54 (paragraph)
msgid "Laravel Breeze is a minimal, simple implementation of all of Laravel's authentication features, including login, registration, password reset, email verification, and password confirmation. Laravel Breeze's view layer is made up of simple [Blade templates](/docs/{{version}}/blade) styled with [Tailwind CSS](https://tailwindcss.com). Additionally, Breeze provides scaffolding options based on [Livewire](https://livewire.laravel.com) or [Inertia](https://inertiajs.com), with the choice of using Vue or React for the Inertia-based scaffolding."
msgstr "Laravel Breeze 是一個簡單且最小化實作出所有 Laravel 認證功能的套件，包含登入、註冊、密碼重設、電子郵件認證、以及密碼確認。Laravel Breeze 的檢視器層是通過簡單的 [Blade 樣板](/docs/{{version}}/blade) 搭配 [Tailwind CSS](https://tailwindcss.com) 提供樣式組合而成的。此外，Breeze 也提供了基於 [Livewire](https://livewire.laravel.com) 或 [Inertia](https://inertiajs.com) 的 Scaffolding 選項，並且在選擇基於 Inertia 的 Scaffolding 時可選擇使用 Vue 或 React。"

#: docs/10.x/authentication.md:block 55 (paragraph)
msgid "[Laravel Jetstream](https://jetstream.laravel.com) is a more robust application starter kit that includes support for scaffolding your application with [Livewire](https://livewire.laravel.com) or [Inertia and Vue](https://inertiajs.com). In addition, Jetstream features optional support for two-factor authentication, teams, profile management, browser session management, API support via [Laravel Sanctum](/docs/{{version}}/sanctum), account deletion, and more."
msgstr "[Laravel Jetstream](https://jetstream.laravel.com) 是一個更複雜的專案入門套件，其中包含了使用 [Livewire](https://livewire.laravel.com) 或 [Inertia 與 Vue](https://inertiajs.com) 來對應用程式 Scaffolding 的支援。此外，Jetstream 也提供了對二步驟認證、團隊、個人檔案管理、瀏覽器啟程管理、通過 [Laravel Sanctum](/docs/{{version}}/sanctum) 提供的 API 支援、帳號刪除…等功能的可選支援。"

#: docs/10.x/authentication.md:block 57 (header)
msgid "Retrieving the Authenticated User"
msgstr ""

#: docs/10.x/authentication.md:block 58 (paragraph)
msgid "After installing an authentication starter kit and allowing users to register and authenticate with your application, you will often need to interact with the currently authenticated user. While handling an incoming request, you may access the authenticated user via the `Auth` facade's `user` method:"
msgstr "安裝完認證入門套件並讓使用者在網站內註冊與認證後，我們通常需要與目前已登入的使用者進行互動。在處理連入請求時，我們可以通過 `Auth` Facade 的 `user` 方法來存取已登入的使用者："

#: docs/10.x/authentication.md:block 59 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"// Retrieve the currently authenticated user...\n"
"$user = Auth::user();\n\n"
"// Retrieve the currently authenticated user's ID...\n"
"$id = Auth::id();\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"// 取得目前登入的使用者...\n"
"$user = Auth::user();\n\n"
"// 取得目前登入使用者的 ID...\n"
"$id = Auth::id();\n"

#: docs/10.x/authentication.md:block 60 (paragraph)
msgid "Alternatively, once a user is authenticated, you may access the authenticated user via an `Illuminate\\Http\\Request` instance. Remember, type-hinted classes will automatically be injected into your controller methods. By type-hinting the `Illuminate\\Http\\Request` object, you may gain convenient access to the authenticated user from any controller method in your application via the request's `user` method:"
msgstr "另外，使用者認證後，也可以通過 `Illuminate\\Http\\Request` 實體來存取已登入的使用者。請記得，有型別提示的類別會自動被插入到 Controller 方法內。只要型別提示 `Illuminate\\Http\\Request` 物件，就可以方便地通過 Request 的 `user` 方法來在任何 Controller 方法內存取已登入的使用者："

#: docs/10.x/authentication.md:block 61 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n\n"
"class FlightController extends Controller\n"
"{\n"
"    /**\n"
"     * Update the flight information for an existing flight.\n"
"     */\n"
"    public function update(Request $request): RedirectResponse\n"
"    {\n"
"        $user = $request->user();\n\n"
"        // ...\n\n"
"        return redirect('/flights');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n\n"
"class FlightController extends Controller\n"
"{\n"
"    /**\n"
"     * Update the flight information for an existing flight.\n"
"     */\n"
"    public function update(Request $request): RedirectResponse\n"
"    {\n"
"        $user = $request->user();\n\n"
"        // ...\n\n"
"        return redirect('/flights');\n"
"    }\n"
"}\n"

#: docs/10.x/authentication.md:block 63 (header)
msgid "Determining if the Current User is Authenticated"
msgstr ""

#: docs/10.x/authentication.md:block 64 (paragraph)
msgid "To determine if the user making the incoming HTTP request is authenticated, you may use the `check` method on the `Auth` facade. This method will return `true` if the user is authenticated:"
msgstr "若要判斷建立連入 HTTP 請求的使用者是否已登入，可以使用 `Auth` Facade 的 `check` 方法。該方法會在使用者已登入的時候回傳 `true`："

#: docs/10.x/authentication.md:block 65 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::check()) {\n"
"    // The user is logged in...\n"
"}\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::check()) {\n"
"    // The user is logged in...\n"
"}\n"

#: docs/10.x/authentication.md:block 66 (quote)
msgid "[!NOTE] Even though it is possible to determine if a user is authenticated using the `check` method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on [protecting routes](/docs/{{version}}/authentication#protecting-routes)."
msgstr ""

#: docs/10.x/authentication.md:block 68 (header)
msgid "Protecting Routes"
msgstr "保護路由"

#: docs/10.x/authentication.md:block 69 (paragraph)
msgid "[Route middleware](/docs/{{version}}/middleware) can be used to only allow authenticated users to access a given route. Laravel ships with an `auth` middleware, which references the `Illuminate\\Auth\\Middleware\\Authenticate` class. Since this middleware is already registered in your application's HTTP kernel, all you need to do is attach the middleware to a route definition:"
msgstr "[路由 Middleware](/docs/{{version}}/middleware) 可以用來只允許已認證的使用者存取指定的路由。Laravel 內建了一個 `auth` Middleware，這個 Middleware為 `Illuminate\\Auth\\Middleware\\Authenticate` 類別。由於該 Middleware已預先在專案中的 HTTP Kernel 內註冊好了，所以只需要在路由定義內加上這個 Middleware 即可："

#: docs/10.x/authentication.md:block 70 (code)
msgid "Route::get('/flights', function () {\n"
"    // Only authenticated users may access this route...\n"
"})->middleware('auth');\n"
msgstr "Route::get('/flights', function () {\n"
"    // 只有已登入的使用者才能存取此路由…\n"
"})->middleware('auth');\n"

#: docs/10.x/authentication.md:block 72 (header)
msgid "Redirecting Unauthenticated Users"
msgstr "重新導向未登入的使用者"

#: docs/10.x/authentication.md:block 73 (paragraph)
msgid "When the `auth` middleware detects an unauthenticated user, it will redirect the user to the `login` [named route](/docs/{{version}}/routing#named-routes). You may modify this behavior by updating the `redirectTo` function in your application's `app/Http/Middleware/Authenticate.php` file:"
msgstr "當 `auth` Middleware 偵測到未登入的使用者，`auth` Middleware 會將使用者重新導向到 `login` 這個[帶名稱的路由](/docs/{{version}}/routing#named-routes)上。可以通過更新專案中 `app/Http/Middleware/Authenticate.php` 檔案內的 `redirectTo` 方法來更改此一行為。"

#: docs/10.x/authentication.md:block 74 (code)
msgid "use Illuminate\\Http\\Request;\n\n"
"/**\n"
" * Get the path the user should be redirected to.\n"
" */\n"
"protected function redirectTo(Request $request): string\n"
"{\n"
"    return route('login');\n"
"}\n"
msgstr "use Illuminate\\Http\\Request;\n\n"
"/**\n"
" * Get the path the user should be redirected to.\n"
" */\n"
"protected function redirectTo(Request $request): string\n"
"{\n"
"    return route('login');\n"
"}\n"

#: docs/10.x/authentication.md:block 76 (header)
msgid "Specifying a Guard"
msgstr ""

#: docs/10.x/authentication.md:block 77 (paragraph)
msgid "When attaching the `auth` middleware to a route, you may also specify which \"guard\" should be used to authenticate the user. The guard specified should correspond to one of the keys in the `guards` array of your `auth.php` configuration file:"
msgstr "在將 `auth` 中間層加到路由時，可以指定要使用哪個「Guard」來認證使用者。可以通過指定 `auth.php` 設定檔中 `guards` 陣列內對應的鍵值來指定 Guard："

#: docs/10.x/authentication.md:block 78 (code)
msgid "Route::get('/flights', function () {\n"
"    // Only authenticated users may access this route...\n"
"})->middleware('auth:admin');\n"
msgstr "Route::get('/flights', function () {\n"
"    // 只有已登入的使用者才能存取該 Route...\n"
"})->middleware('auth:admin');\n"

#: docs/10.x/authentication.md:block 80 (header)
msgid "Login Throttling"
msgstr "登入頻率限制"

#: docs/10.x/authentication.md:block 81 (paragraph)
msgid "If you are using the Laravel Breeze or Laravel Jetstream [starter kits](/docs/{{version}}/starter-kits), rate limiting will automatically be applied to login attempts. By default, the user will not be able to login for one minute if they fail to provide the correct credentials after several attempts. The throttling is unique to the user's username / email address and their IP address."
msgstr "若使用 Laravel Breeze 或 Laravel Jetstream [入門套件](/docs/{{version}}/starter-kits)，會自動將頻率限制套用到登入限制上。預設情況下，若使用者嘗試了數次仍未提供正確的帳號密碼，則將在一分鐘之內都無法登入。登入限制是基於每個使用者的使用者名稱或電子郵件，以及其 IP 位址來區分的。"

#: docs/10.x/authentication.md:block 82 (quote)
msgid "[!NOTE] If you would like to rate limit other routes in your application, check out the [rate limiting documentation](/docs/{{version}}/routing#rate-limiting)."
msgstr ""

#: docs/10.x/authentication.md:block 84 (header)
msgid "Manually Authenticating Users"
msgstr "手動認證使用者"

#: docs/10.x/authentication.md:block 85 (paragraph)
msgid "You are not required to use the authentication scaffolding included with Laravel's [application starter kits](/docs/{{version}}/starter-kits). If you choose not to use this scaffolding, you will need to manage user authentication using the Laravel authentication classes directly. Don't worry, it's a cinch!"
msgstr "不一定要使用 Laravel [專案入門套件](/docs/{{version}}/starter-kits) 內包含的認證 Scaffolding。若決定不使用這些 Scaffolding 的話，就需要直接使用 Laravel 的認證類別來處理使用者認證。別擔心，這只是小菜一碟！"

#: docs/10.x/authentication.md:block 86 (paragraph)
msgid "We will access Laravel's authentication services via the `Auth` [facade](/docs/{{version}}/facades), so we'll need to make sure to import the `Auth` facade at the top of the class. Next, let's check out the `attempt` method. The `attempt` method is normally used to handle authentication attempts from your application's \"login\" form. If authentication is successful, you should regenerate the user's [session](/docs/{{version}}/session) to prevent [session fixation](https://en.wikipedia.org/wiki/Session_fixation):"
msgstr "我們會通過 `Auth` [Facade](/docs/{{version}}/facades) 來存取 Laravel 的認證服務。因此，我們需要確保有在該類別的最上方引入 `Auth` Facade。接著，還要確認一下我們的 `attempt` 方法。這個 `attempt` 方法通常會用來處理來自網站「登入」表單的認證嘗試。若成功認證，則應該重新產生使用者的 [session](/docs/{{version}}/session) 來防止 [Session Fixation (英語)](https://en.wikipedia.org/wiki/Session_fixation)："

#: docs/10.x/authentication.md:block 87 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     */\n"
"    public function authenticate(Request $request): RedirectResponse\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ])->onlyInput('email');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     */\n"
"    public function authenticate(Request $request): RedirectResponse\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ])->onlyInput('email');\n"
"    }\n"
"}\n"

#: docs/10.x/authentication.md:block 88 (paragraph)
msgid "The `attempt` method accepts an array of key / value pairs as its first argument. The values in the array will be used to find the user in your database table. So, in the example above, the user will be retrieved by the value of the `email` column. If the user is found, the hashed password stored in the database will be compared with the `password` value passed to the method via the array. You should not hash the incoming request's `password` value, since the framework will automatically hash the value before comparing it to the hashed password in the database. An authenticated session will be started for the user if the two hashed passwords match."
msgstr "`attempt` 方法接收包含了索引鍵／值配對的陣列作為其第一個引數。陣列中的值會被用來在資料庫資料表中尋找使用者。因此，在上方的範例中，使用者會依照 `email` 欄位中的值來取得。若找到該使用者，則會將資料庫中儲存的密碼雜湊跟陣列中的 `password` 值進行比對。請不要將連入請求的 `password` 進行雜湊，因為框架會自動在與資料庫中雜湊密碼比對時自動對齊進行雜湊。當兩個雜湊密碼相符合時，將開始該使用者的認證 Session。"

#: docs/10.x/authentication.md:block 89 (paragraph)
msgid "Remember, Laravel's authentication services will retrieve users from your database based on your authentication guard's \"provider\" configuration. In the default `config/auth.php` configuration file, the Eloquent user provider is specified and it is instructed to use the `App\\Models\\User` model when retrieving users. You may change these values within your configuration file based on the needs of your application."
msgstr "請記得，Laravel 的認證服務會依據認證 Guard 的「provider」設定來從資料庫中取得使用者。預設的 `config/auth.php` 設定檔中使用了 Eloquent User Provider，並使用 `App\\Models\\User` Model 來取得使用者。可以依照專案需求來在設定檔中更改這些值。"

#: docs/10.x/authentication.md:block 90 (paragraph)
msgid "The `attempt` method will return `true` if authentication was successful. Otherwise, `false` will be returned."
msgstr "當認證成功後，`attempt` 方法會回傳 `true`。否則，會回傳 `false`。"

#: docs/10.x/authentication.md:block 91 (paragraph)
msgid "The `intended` method provided by Laravel's redirector will redirect the user to the URL they were attempting to access before being intercepted by the authentication middleware. A fallback URI may be given to this method in case the intended destination is not available."
msgstr "Laravel 的重新導向程式中提供的 `intended` 方法可以用來將使用者導向到他們被認證中間層攔截存取前正在嘗試存取的 URL。可以提供一個遞補的 URI 給該方法，以免沒有預期的目的地。"

#: docs/10.x/authentication.md:block 93 (header)
msgid "Specifying Additional Conditions"
msgstr "指定額外條件"

#: docs/10.x/authentication.md:block 94 (paragraph)
msgid "If you wish, you may also add extra query conditions to the authentication query in addition to the user's email and password. To accomplish this, we may simply add the query conditions to the array passed to the `attempt` method. For example, we may verify that the user is marked as \"active\":"
msgstr "若有需要的話，也可以在認證查詢上指定除了使用者的電子郵件與密碼外的額外查詢條件。為此，只需要將查詢條件加到傳給 `attempt` 方法的陣列中即可。如，我們可以認證使用者有被標示為「啟用」："

#: docs/10.x/authentication.md:block 95 (code)
msgid "if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {\n"
"    // Authentication was successful...\n"
"}\n"
msgstr "if (Auth::attempt(['email' => $email, 'password' => $password, 'active' => 1])) {\n"
"    // 認證成功...\n"
"}\n"

#: docs/10.x/authentication.md:block 96 (paragraph)
msgid "For complex query conditions, you may provide a closure in your array of credentials. This closure will be invoked with the query instance, allowing you to customize the query based on your application's needs:"
msgstr "對於複雜的查詢條件，可以提供在帳號密碼陣列中提供一個閉包。Laravel 會以查詢實體來呼叫此閉包，讓你可以依據專案需求自定查詢："

#: docs/10.x/authentication.md:block 97 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"if (Auth::attempt([\n"
"    'email' => $email, \n"
"    'password' => $password, \n"
"    fn (Builder $query) => $query->has('activeSubscription'),\n"
"])) {\n"
"    // Authentication was successful...\n"
"}\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"if (Auth::attempt([\n"
"    'email' => $email, \n"
"    'password' => $password, \n"
"    fn (Builder $query) => $query->has('activeSubscription'),\n"
"])) {\n"
"    // 登入成功...\n"
"}\n"

#: docs/10.x/authentication.md:block 98 (quote)
msgid "[!WARNING] In these examples, `email` is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database table."
msgstr ""

#: docs/10.x/authentication.md:block 99 (paragraph)
msgid "The `attemptWhen` method, which receives a closure as its second argument, may be used to perform more extensive inspection of the potential user before actually authenticating the user. The closure receives the potential user and should return `true` or `false` to indicate if the user may be authenticated:"
msgstr "`attemptWhen` 方法所接收的第二個引數為閉包，該閉包可用來在使用者實際登入前，對正在嘗試登入的使用者執行更進一步的檢驗。這個閉包會收到正在嘗試登入的使用者，並應回傳 `true` 或 `false` 來表示使用者是否可登入："

#: docs/10.x/authentication.md:block 100 (code)
msgid "if (Auth::attemptWhen([\n"
"    'email' => $email,\n"
"    'password' => $password,\n"
"], function (User $user) {\n"
"    return $user->isNotBanned();\n"
"})) {\n"
"    // Authentication was successful...\n"
"}\n"
msgstr "if (Auth::attemptWhen([\n"
"    'email' => $email,\n"
"    'password' => $password,\n"
"], function (User $user) {\n"
"    return $user->isNotBanned();\n"
"})) {\n"
"    // 登入成功...\n"
"}\n"

#: docs/10.x/authentication.md:block 102 (header)
msgid "Accessing Specific Guard Instances"
msgstr "存取特定 Guard 實體"

#: docs/10.x/authentication.md:block 103 (paragraph)
msgid "Via the `Auth` facade's `guard` method, you may specify which guard instance you would like to utilize when authenticating the user. This allows you to manage authentication for separate parts of your application using entirely separate authenticatable models or user tables."
msgstr "通過 `Auth` Facade 的 `guard` 方法，可以指定使用者登入時要使用哪個 Guard 實體。如此一來便能為專案中不同部分的登入功能使用不同的 Authenticatable Model 或使用者資料表。"

#: docs/10.x/authentication.md:block 104 (paragraph)
msgid "The guard name passed to the `guard` method should correspond to one of the guards configured in your `auth.php` configuration file:"
msgstr "傳如 `guard` 方法的 Guard 名稱應為 `auth.php` 設定檔中設定的其中一個 Guard 名稱："

#: docs/10.x/authentication.md:block 105 (code)
msgid "if (Auth::guard('admin')->attempt($credentials)) {\n"
"    // ...\n"
"}\n"
msgstr "if (Auth::guard('admin')->attempt($credentials)) {\n"
"    // ...\n"
"}\n"

#: docs/10.x/authentication.md:block 107 (header)
msgid "Remembering Users"
msgstr "記住使用者"

#: docs/10.x/authentication.md:block 108 (paragraph)
msgid "Many web applications provide a \"remember me\" checkbox on their login form. If you would like to provide \"remember me\" functionality in your application, you may pass a boolean value as the second argument to the `attempt` method."
msgstr "許多網站的登入表單內都有一個「記住我」勾選框。若想為你的網站提供「記住我」功能，可以傳入布林值給 `attempt` 方法的第二個引數。"

#: docs/10.x/authentication.md:block 109 (paragraph)
msgid "When this value is `true`, Laravel will keep the user authenticated indefinitely or until they manually logout. Your `users` table must include the string `remember_token` column, which will be used to store the \"remember me\" token. The `users` table migration included with new Laravel applications already includes this column:"
msgstr "當該值為 `true` 時，Laravel 會永久儲存使用者的登入狀態，直到使用者手動登出。你的 `users` 資料表必須包含 `remember_token` 字串欄位，該欄位用來儲存「記住我」權杖。在新的 Laravel 專案中，`users` 資料表的 Migration 已包含了此欄位："

#: docs/10.x/authentication.md:block 110 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {\n"
"    // The user is being remembered...\n"
"}\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::attempt(['email' => $email, 'password' => $password], $remember)) {\n"
"    // 已記住使用者...\n"
"}\n"

#: docs/10.x/authentication.md:block 111 (paragraph)
msgid "If your application offers \"remember me\" functionality, you may use the `viaRemember` method to determine if the currently authenticated user was authenticated using the \"remember me\" cookie:"
msgstr "若專案有提供「記住我」的功能，則可使用 `viaRemember` 方法來判斷目前登入的使用者是否是使用「記住我」Cookie 登入的："

#: docs/10.x/authentication.md:block 112 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::viaRemember()) {\n"
"    // ...\n"
"}\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"if (Auth::viaRemember()) {\n"
"    // ...\n"
"}\n"

#: docs/10.x/authentication.md:block 114 (header)
msgid "Other Authentication Methods"
msgstr "其他認證方法"

#: docs/10.x/authentication.md:block 116 (header)
msgid "Authenticate a User Instance"
msgstr ""

#: docs/10.x/authentication.md:block 117 (paragraph)
msgid "If you need to set an existing user instance as the currently authenticated user, you may pass the user instance to the `Auth` facade's `login` method. The given user instance must be an implementation of the `Illuminate\\Contracts\\Auth\\Authenticatable` [contract](/docs/{{version}}/contracts). The `App\\Models\\User` model included with Laravel already implements this interface. This method of authentication is useful when you already have a valid user instance, such as directly after a user registers with your application:"
msgstr "若需要將目前已認證使用者設為一個現有的使用者實體，可以將該實體傳入 `Auth` Facade 的 `login` 方法內。給定的使用者實體必須要實作 `Illuminate\\Contracts\\Auth\\Authenticatable` [Contract](/docs/{{version}}/contracts)。Laravel 中的 `App\\Models\\User` Model 已經實作了這個介面。這種認證的方法適用與已有有效使用者實體的情況，如使用者在網站上註冊之後："

#: docs/10.x/authentication.md:block 118 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"Auth::login($user);\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"Auth::login($user);\n"

#: docs/10.x/authentication.md:block 119 (paragraph)
msgid "You may pass a boolean value as the second argument to the `login` method. This value indicates if \"remember me\" functionality is desired for the authenticated session. Remember, this means that the session will be authenticated indefinitely or until the user manually logs out of the application:"
msgstr "可以將布林值傳入 `login` 方法的第二個引數。這個布林值會用來判斷該登入 Session 是否可套用「記住我」功能。請記得，啟用該功能就表示這個 Session 將永久可用，直到使用者手動登出："

#: docs/10.x/authentication.md:block 120 (code)
msgid "Auth::login($user, $remember = true);\n"
msgstr "Auth::login($user, $remember = true);\n"

#: docs/10.x/authentication.md:block 121 (paragraph)
msgid "If needed, you may specify an authentication guard before calling the `login` method:"
msgstr "若有需要，可以在呼叫 `login` 方法前指定一個認證 Guard："

#: docs/10.x/authentication.md:block 122 (code)
msgid "Auth::guard('admin')->login($user);\n"
msgstr "Auth::guard('admin')->login($user);\n"

#: docs/10.x/authentication.md:block 124 (header)
msgid "Authenticate a User by ID"
msgstr ""

#: docs/10.x/authentication.md:block 125 (paragraph)
msgid "To authenticate a user using their database record's primary key, you may use the `loginUsingId` method. This method accepts the primary key of the user you wish to authenticate:"
msgstr "若要使用資料庫中的主索引鍵 (Primary Key) 來認證使用者，可以使用 `loginUsingId` 方法。該方法接受要用來認證使用者的主索引鍵值："

#: docs/10.x/authentication.md:block 126 (code)
msgid "Auth::loginUsingId(1);\n"
msgstr "Auth::loginUsingId(1);\n"

#: docs/10.x/authentication.md:block 127 (paragraph)
msgid "You may pass a boolean value as the second argument to the `loginUsingId` method. This value indicates if \"remember me\" functionality is desired for the authenticated session. Remember, this means that the session will be authenticated indefinitely or until the user manually logs out of the application:"
msgstr "可以將布林值傳入 `loginUsingId` 方法的第二個引數。這個布林值會用來判斷該登入 Session 是否可套用「記住我」功能。請記得，啟用該功能就標示該 Session 將永久可用，直到使用者手動登出："

#: docs/10.x/authentication.md:block 128 (code)
msgid "Auth::loginUsingId(1, $remember = true);\n"
msgstr "Auth::loginUsingId(1, $remember = true);\n"

#: docs/10.x/authentication.md:block 130 (header)
msgid "Authenticate a User Once"
msgstr ""

#: docs/10.x/authentication.md:block 131 (paragraph)
msgid "You may use the `once` method to authenticate a user with the application for a single request. No sessions or cookies will be utilized when calling this method:"
msgstr "可以使用 `once` 方法來只在單一請求內認證使用者。呼叫此方法時不會使用到 Session 或 Cookie："

#: docs/10.x/authentication.md:block 132 (code)
msgid "if (Auth::once($credentials)) {\n"
"    // ...\n"
"}\n"
msgstr "if (Auth::once($credentials)) {\n"
"    // ...\n"
"}\n"

#: docs/10.x/authentication.md:block 134 (header)
msgid "HTTP Basic Authentication"
msgstr "HTTP 基本認證"

#: docs/10.x/authentication.md:block 135 (paragraph)
msgid "[HTTP Basic Authentication](https://en.wikipedia.org/wiki/Basic_access_authentication) provides a quick way to authenticate users of your application without setting up a dedicated \"login\" page. To get started, attach the `auth.basic` [middleware](/docs/{{version}}/middleware) to a route. The `auth.basic` middleware is included with the Laravel framework, so you do not need to define it:"
msgstr "[HTTP 基本認證](https://zh.wikipedia.org/zh-tw/HTTP%E5%9F%BA%E6%9C%AC%E8%AE%A4%E8%AF%81)提供了一種不需要設定專屬「登入」頁面而快速認證專案中使用者的方法。要進行 HTTP 基本認證，請將 `auth.basic` [Middleware](/docs/{{version}}/middleware) 加到路由上。`auth.basic` Middleware 已包含在 Laravel 框架內，不需要自行定義："

#: docs/10.x/authentication.md:block 136 (code)
msgid "Route::get('/profile', function () {\n"
"    // Only authenticated users may access this route...\n"
"})->middleware('auth.basic');\n"
msgstr "Route::get('/profile', function () {\n"
"    // 只有已登入使用者可以存取這個 Route...\n"
"})->middleware('auth.basic');\n"

#: docs/10.x/authentication.md:block 137 (paragraph)
msgid "Once the middleware has been attached to the route, you will automatically be prompted for credentials when accessing the route in your browser. By default, the `auth.basic` middleware will assume the `email` column on your `users` database table is the user's \"username\"."
msgstr "將該 Middleware 加到路由上後，在瀏覽器上存取該路由時會自動被提示帳號密碼。預設情況下，`auth.basic` 中間層會假設 `email` 欄位是 `users` 資料表中的使用者「帳號」欄位。"

#: docs/10.x/authentication.md:block 139 (header)
msgid "A Note on FastCGI"
msgstr ""

#: docs/10.x/authentication.md:block 140 (paragraph)
msgid "If you are using PHP FastCGI and Apache to serve your Laravel application, HTTP Basic authentication may not work correctly. To correct these problems, the following lines may be added to your application's `.htaccess` file:"
msgstr "若使用 PHP FastCGI 與 Apache 來執行 Laravel 專案，則 HTTP 基本認證可能不會正確運作。要修正這個問題，請將下列幾行加到專案的 `.htaccess` 檔中："

#: docs/10.x/authentication.md:block 141 (code)
msgid "RewriteCond %{HTTP:Authorization} ^(.+)$\n"
"RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n"
msgstr "RewriteCond %{HTTP:Authorization} ^(.+)$\n"
"RewriteRule .* - [E=HTTP_AUTHORIZATION:%{HTTP:Authorization}]\n"

#: docs/10.x/authentication.md:block 143 (header)
msgid "Stateless HTTP Basic Authentication"
msgstr "無周邊 HTTP 基本認證"

#: docs/10.x/authentication.md:block 144 (paragraph)
msgid "You may also use HTTP Basic Authentication without setting a user identifier cookie in the session. This is primarily helpful if you choose to use HTTP Authentication to authenticate requests to your application's API. To accomplish this, [define a middleware](/docs/{{version}}/middleware) that calls the `onceBasic` method. If no response is returned by the `onceBasic` method, the request may be passed further into the application:"
msgstr "也可以於不在 Session 內寫入可識別使用者 Cookie 的情況下使用 HTTP 基本認證。這個作法通常適用於想通過 HTTP 認證來認證網站 API 請求時。為此，請先[定義一個 Middleware](/docs/{{version}}/middleware)，並在該 Middleware 中呼叫 `onceBasic` 方法。若 `onceBasic` 方法無回傳值，則該請求才會接著被傳遞到專案中："

#: docs/10.x/authentication.md:block 145 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Middleware;\n\n"
"use Closure;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n"
"use Symfony\\Component\\HttpFoundation\\Response;\n\n"
"class AuthenticateOnceWithBasicAuth\n"
"{\n"
"    /**\n"
"     * Handle an incoming request.\n"
"     *\n"
"     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\n"
"     */\n"
"    public function handle(Request $request, Closure $next): Response\n"
"    {\n"
"        return Auth::onceBasic() ?: $next($request);\n"
"    }\n\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Middleware;\n\n"
"use Closure;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n"
"use Symfony\\Component\\HttpFoundation\\Response;\n\n"
"class AuthenticateOnceWithBasicAuth\n"
"{\n"
"    /**\n"
"     * Handle an incoming request.\n"
"     *\n"
"     * @param  \\Closure(\\Illuminate\\Http\\Request): (\\Symfony\\Component\\HttpFoundation\\Response)  $next\n"
"     */\n"
"    public function handle(Request $request, Closure $next): Response\n"
"    {\n"
"        return Auth::onceBasic() ?: $next($request);\n"
"    }\n\n"
"}\n"

#: docs/10.x/authentication.md:block 146 (paragraph)
msgid "Next, attach the middleware to a route:"
msgstr "接著，將這個 Middleware 附加到 Route 上："

#: docs/10.x/authentication.md:block 147 (code)
msgid "Route::get('/api/user', function () {\n"
"    // Only authenticated users may access this route...\n"
"})->middleware(AuthenticateOnceWithBasicAuth::class);\n"
msgstr "Route::get('/api/user', function () {\n"
"    // 只有已登入使用者可以存取這個 Route...\n"
"})->middleware(AuthenticateOnceWithBasicAuth::class);\n"

#: docs/10.x/authentication.md:block 149 (header)
msgid "Logging Out"
msgstr "登出"

#: docs/10.x/authentication.md:block 150 (paragraph)
msgid "To manually log users out of your application, you may use the `logout` method provided by the `Auth` facade. This will remove the authentication information from the user's session so that subsequent requests are not authenticated."
msgstr "若要手動將使用者登出網站，可以使用 `Auth` Facade 提供的 `logout` 方法。該方法會從使用者的 Session 中將認證資訊移除，如此一來，接下來的請求都會是已登出的狀態。"

#: docs/10.x/authentication.md:block 151 (paragraph)
msgid "In addition to calling the `logout` method, it is recommended that you invalidate the user's session and regenerate their [CSRF token](/docs/{{version}}/csrf). After logging the user out, you would typically redirect the user to the root of your application:"
msgstr "除了呼叫 `logout` 方法外，也建議將使用者的 Session 無效化，並為使用者重新產生 [CSRF 權杖](/docs/{{version}}/csrf)。登出使用者後，我們通常會將使用者重新導向回網站根目錄："

#: docs/10.x/authentication.md:block 152 (code)
msgid "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Log the user out of the application.\n"
" */\n"
"public function logout(Request $request): RedirectResponse\n"
"{\n"
"    Auth::logout();\n\n"
"    $request->session()->invalidate();\n\n"
"    $request->session()->regenerateToken();\n\n"
"    return redirect('/');\n"
"}\n"
msgstr "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Log the user out of the application.\n"
" */\n"
"public function logout(Request $request): RedirectResponse\n"
"{\n"
"    Auth::logout();\n\n"
"    $request->session()->invalidate();\n\n"
"    $request->session()->regenerateToken();\n\n"
"    return redirect('/');\n"
"}\n"

#: docs/10.x/authentication.md:block 154 (header)
msgid "Invalidating Sessions on Other Devices"
msgstr ""

#: docs/10.x/authentication.md:block 155 (paragraph)
msgid "Laravel also provides a mechanism for invalidating and \"logging out\" a user's sessions that are active on other devices without invalidating the session on their current device. This feature is typically utilized when a user is changing or updating their password and you would like to invalidate sessions on other devices while keeping the current device authenticated."
msgstr "Laravel 也提供了另一個機制，可以用來在不影響目前裝置上 Session 的情況下將使用者在其他裝置的 Session 無效化並登出使用者。該功能通常適用於使用者更改密碼、或是想將其他 Session 無效化但想讓目前裝置保持認證的情況。"

#: docs/10.x/authentication.md:block 156 (paragraph)
msgid "Before getting started, you should make sure that the `Illuminate\\Session\\Middleware\\AuthenticateSession` middleware is included on the routes that should receive session authentication. Typically, you should place this middleware on a route group definition so that it can be applied to the majority of your application's routes. By default, the `AuthenticateSession` middleware may be attached to a route using the `auth.session` route middleware alias as defined in your application's HTTP kernel:"
msgstr "在開始之前，請先確保要收到 Session 身份驗證的 Route 都有包含 `Illuminate\\Session\\Middleware\\AuthenticateSession` Middleware。一般來說，應在 Route 群組定義內放入這個 Middleware，好讓該 Middleware 被套用到專案中大多數的 Route。預設情況下，`AuthenticateSession` Middleware 可使用專案 HTTP Kernel 中所定義的 `auth.session` 這個 Route Middleware 來附加到 Route 上："

#: docs/10.x/authentication.md:block 157 (code)
msgid "Route::middleware(['auth', 'auth.session'])->group(function () {\n"
"    Route::get('/', function () {\n"
"        // ...\n"
"    });\n"
"});\n"
msgstr "Route::middleware(['auth', 'auth.session'])->group(function () {\n"
"    Route::get('/', function () {\n"
"        // ...\n"
"    });\n"
"});\n"

#: docs/10.x/authentication.md:block 158 (paragraph)
msgid "Then, you may use the `logoutOtherDevices` method provided by the `Auth` facade. This method requires the user to confirm their current password, which your application should accept through an input form:"
msgstr "接著，可以使用 `Auth` Facade 提供的 `logoutOtherDevices` 方法。該方法會需要使用者確認目前密碼，而你的網站應通過一個輸入表單來接收密碼："

#: docs/10.x/authentication.md:block 159 (code)
msgid "use Illuminate\\Support\\Facades\\Auth;\n\n"
"Auth::logoutOtherDevices($currentPassword);\n"
msgstr "use Illuminate\\Support\\Facades\\Auth;\n\n"
"Auth::logoutOtherDevices($currentPassword);\n"

#: docs/10.x/authentication.md:block 160 (paragraph)
msgid "When the `logoutOtherDevices` method is invoked, the user's other sessions will be invalidated entirely, meaning they will be \"logged out\" of all guards they were previously authenticated by."
msgstr "當 `logoutOtherDevices` 方法被叫用後，使用者的其他 Session 將被立即無效化。這代表，使用者會被從其他所有已認證過的 Guard 中被「登出」。"

#: docs/10.x/authentication.md:block 162 (header)
msgid "Password Confirmation"
msgstr "密碼確認"

#: docs/10.x/authentication.md:block 163 (paragraph)
msgid "While building your application, you may occasionally have actions that should require the user to confirm their password before the action is performed or before the user is redirected to a sensitive area of the application. Laravel includes built-in middleware to make this process a breeze. Implementing this feature will require you to define two routes: one route to display a view asking the user to confirm their password and another route to confirm that the password is valid and redirect the user to their intended destination."
msgstr "在製作網站時，有時可能會需要使用者在執行某個操作前、或是在使用者被重新導向到網站機敏區域前要求使用者確認密碼。Laravel 提供了一個內建的 Middleware 來讓這個過程變得很輕鬆。要實作這項功能會需要定義兩個路由：一個用於顯示並要求使用者確認密碼的路由，另一個則用於確認密碼有效並將使用者重新導向至預期目的地的路由。"

#: docs/10.x/authentication.md:block 164 (quote)
msgid "[!NOTE] The following documentation discusses how to integrate with Laravel's password confirmation features directly; however, if you would like to get started more quickly, the [Laravel application starter kits](/docs/{{version}}/starter-kits) include support for this feature!"
msgstr ""

#: docs/10.x/authentication.md:block 166 (header)
msgid "Configuration"
msgstr "設定"

#: docs/10.x/authentication.md:block 167 (paragraph)
msgid "After confirming their password, a user will not be asked to confirm their password again for three hours. However, you may configure the length of time before the user is re-prompted for their password by changing the value of the `password_timeout` configuration value within your application's `config/auth.php` configuration file."
msgstr "確認使用者密碼後，接下來的三小時內就不會再次向使用者詢問密碼了。但是，只需要更改專案中 `config/auth.php` 設定檔的 `password_timeout` 設定，就可以調整要重新詢問使用者密碼的時間長度。"

#: docs/10.x/authentication.md:block 169 (header)
msgid "Routing"
msgstr "路由"

#: docs/10.x/authentication.md:block 171 (header)
msgid "The Password Confirmation Form"
msgstr "密碼確認表單"

#: docs/10.x/authentication.md:block 172 (paragraph)
msgid "First, we will define a route to display a view that requests the user to confirm their password:"
msgstr "首先，我們先定義用來顯示要求使用者確認密碼的路由："

#: docs/10.x/authentication.md:block 173 (code)
msgid "Route::get('/confirm-password', function () {\n"
"    return view('auth.confirm-password');\n"
"})->middleware('auth')->name('password.confirm');\n"
msgstr "Route::get('/confirm-password', function () {\n"
"    return view('auth.confirm-password');\n"
"})->middleware('auth')->name('password.confirm');\n"

#: docs/10.x/authentication.md:block 174 (paragraph)
msgid "As you might expect, the view that is returned by this route should have a form containing a `password` field. In addition, feel free to include text within the view that explains that the user is entering a protected area of the application and must confirm their password."
msgstr "跟我們預期的一樣，這個路由所回傳的 View 內應有一個含有 `password` 欄位的表單。此外，我們也可以隨意在該 View 中加上文字說明，來告訴使用者他們正在進入網站中受保護的區域，必須要輸入密碼來進行確認。"

#: docs/10.x/authentication.md:block 176 (header)
msgid "Confirming the Password"
msgstr ""

#: docs/10.x/authentication.md:block 177 (paragraph)
msgid "Next, we will define a route that will handle the form request from the \"confirm password\" view. This route will be responsible for validating the password and redirecting the user to their intended destination:"
msgstr "接著，我們來定義要處理來自「確認密碼」View 傳來的表單請求的路由。該路由會負責認證使用者的密碼，並將使用者重新導向至原本預定的目的地。"

#: docs/10.x/authentication.md:block 178 (code)
msgid "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Hash;\n"
"use Illuminate\\Support\\Facades\\Redirect;\n\n"
"Route::post('/confirm-password', function (Request $request) {\n"
"    if (! Hash::check($request->password, $request->user()->password)) {\n"
"        return back()->withErrors([\n"
"            'password' => ['The provided password does not match our records.']\n"
"        ]);\n"
"    }\n\n"
"    $request->session()->passwordConfirmed();\n\n"
"    return redirect()->intended();\n"
"})->middleware(['auth', 'throttle:6,1']);\n"
msgstr "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Hash;\n"
"use Illuminate\\Support\\Facades\\Redirect;\n\n"
"Route::post('/confirm-password', function (Request $request) {\n"
"    if (! Hash::check($request->password, $request->user()->password)) {\n"
"        return back()->withErrors([\n"
"            'password' => ['The provided password does not match our records.']\n"
"        ]);\n"
"    }\n\n"
"    $request->session()->passwordConfirmed();\n\n"
"    return redirect()->intended();\n"
"})->middleware(['auth', 'throttle:6,1']);\n"

#: docs/10.x/authentication.md:block 179 (paragraph)
msgid "Before moving on, let's examine this route in more detail. First, the request's `password` field is determined to actually match the authenticated user's password. If the password is valid, we need to inform Laravel's session that the user has confirmed their password. The `passwordConfirmed` method will set a timestamp in the user's session that Laravel can use to determine when the user last confirmed their password. Finally, we can redirect the user to their intended destination."
msgstr "在繼續之前，來更仔細地看看這個路由。首先，會判斷請求的 `password` 是否真的符合已認證使用者的密碼。若密碼有效，則我們會通知 Laravel 的 Session 該使用者已確認密碼了。`passwordConfirmed` 方法會在使用者的 Session 上設定一個時間戳記，這樣 Laravel 便能判斷使用者上次確認密碼是什麼時候。最後，我們將使用者重新導向至原本預定的目的地。"

#: docs/10.x/authentication.md:block 182 (paragraph)
msgid "You should ensure that any route that performs an action which requires recent password confirmation is assigned the `password.confirm` middleware. This middleware is included with the default installation of Laravel and will automatically store the user's intended destination in the session so that the user may be redirected to that location after confirming their password. After storing the user's intended destination in the session, the middleware will redirect the user to the `password.confirm` [named route](/docs/{{version}}/routing#named-routes):"
msgstr "任何有需要確保最近認證過密碼操作的路由都應設定 `password.confirm` 中間層。該中間層已包含在預設 Laravel 安裝內，且會自動將使用者預定的目的地保存在 Session 內。因此，使用者在確認密碼後會被重新導向之該頁面。將使用者預定的目的地保存在 Session 後，該中間層會將使用者重新導向之 `password.confirm` 這個[命名路由](/docs/{{version}}/routing#named-routes)："

#: docs/10.x/authentication.md:block 183 (code)
msgid "Route::get('/settings', function () {\n"
"    // ...\n"
"})->middleware(['password.confirm']);\n\n"
"Route::post('/settings', function () {\n"
"    // ...\n"
"})->middleware(['password.confirm']);\n"
msgstr "Route::get('/settings', function () {\n"
"    // ...\n"
"})->middleware(['password.confirm']);\n\n"
"Route::post('/settings', function () {\n"
"    // ...\n"
"})->middleware(['password.confirm']);\n"

#: docs/10.x/authentication.md:block 185 (header)
msgid "Adding Custom Guards"
msgstr "新增自訂 Guard"

#: docs/10.x/authentication.md:block 186 (paragraph)
msgid "You may define your own authentication guards using the `extend` method on the `Auth` facade. You should place your call to the `extend` method within a [service provider](/docs/{{version}}/providers). Since Laravel already ships with an `AuthServiceProvider`, we can place the code in that provider:"
msgstr "可以通過 `Auth` Facade 中的 `extend` 方法來定義你自己的認證 Guard。`extend` 方法的呼叫應放置於一個 [Service Provider](/docs/{{version}}/providers) 內。由於 Laravel 預設已附帶了 `AuthServiceProvider`，因此我們可以將程式碼放在這個 Provider 中："

#: docs/10.x/authentication.md:block 187 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Services\\Auth\\JwtGuard;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::extend('jwt', function (Application $app, string $name, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n"
"            return new JwtGuard(Auth::createUserProvider($config['provider']));\n"
"        });\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Services\\Auth\\JwtGuard;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::extend('jwt', function (Application $app, string $name, array $config) {\n"
"            // 回傳 Illuminate\\Contracts\\Auth\\Guard 的實體...\n\n"
"            return new JwtGuard(Auth::createUserProvider($config['provider']));\n"
"        });\n"
"    }\n"
"}\n"

#: docs/10.x/authentication.md:block 188 (paragraph)
msgid "As you can see in the example above, the callback passed to the `extend` method should return an implementation of `Illuminate\\Contracts\\Auth\\Guard`. This interface contains a few methods you will need to implement to define a custom guard. Once your custom guard has been defined, you may reference the guard in the `guards` configuration of your `auth.php` configuration file:"
msgstr "如同在上方範例中看到的一樣，傳給 `extend` 方法的閉包應回傳 `Illuminate\\Contracts\\Auth\\Guard` 的實作。\n"
"`Illuminate\\Contracts\\Auth\\Guard` 這個介面中有一些定義自訂 Guard 所需要實作的方法。定義好自訂 Guard 後，就能在 `auth.php` 設定檔中的 `guards` 設定來參照自訂 Guard。"

#: docs/10.x/authentication.md:block 189 (code)
msgid "'guards' => [\n"
"    'api' => [\n"
"        'driver' => 'jwt',\n"
"        'provider' => 'users',\n"
"    ],\n"
"],\n"
msgstr "'guards' => [\n"
"    'api' => [\n"
"        'driver' => 'jwt',\n"
"        'provider' => 'users',\n"
"    ],\n"
"],\n"

#: docs/10.x/authentication.md:block 191 (header)
msgid "Closure Request Guards"
msgstr "閉包請求 Guard"

#: docs/10.x/authentication.md:block 192 (paragraph)
msgid "The simplest way to implement a custom, HTTP request based authentication system is by using the `Auth::viaRequest` method. This method allows you to quickly define your authentication process using a single closure."
msgstr "要實作一個基於 HTTP 請求的自訂認證系統最簡單的方法，就是通過 `Auth::viaRequest`。通過此方法就可以用單一閉包來快速定義認證流程。"

#: docs/10.x/authentication.md:block 193 (paragraph)
msgid "To get started, call the `Auth::viaRequest` method within the `boot` method of your `AuthServiceProvider`. The `viaRequest` method accepts an authentication driver name as its first argument. This name can be any string that describes your custom guard. The second argument passed to the method should be a closure that receives the incoming HTTP request and returns a user instance or, if authentication fails, `null`:"
msgstr "要開始定義自訂 Guard，先在 `AuthServiceProvider` 中的 `boot` 方法內呼叫 `Auth::viaRequest` 方法。`viaRequest` 方法的第一個引數為認證 Driver 的名稱。這個 Driver 名稱可以是用來描述該自訂 Guard 的一個任意字串。傳入該方法的第二個引數則應為接收連入 HTTP 請求的閉包，該閉包應在認證成功時回傳使用者實體、認證失敗時回傳 `null`。"

#: docs/10.x/authentication.md:block 194 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', (string) $request->token)->first();\n"
"    });\n"
"}\n"
msgstr "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', (string) $request->token)->first();\n"
"    });\n"
"}\n"

#: docs/10.x/authentication.md:block 195 (paragraph)
msgid "Once your custom authentication driver has been defined, you may configure it as a driver within the `guards` configuration of your `auth.php` configuration file:"
msgstr "定義好自訂認證 Driver 後，可以將其設定在 `auth.php` 設定檔中的 `guards` 設定。"

#: docs/10.x/authentication.md:block 196 (code)
msgid "'guards' => [\n"
"    'api' => [\n"
"        'driver' => 'custom-token',\n"
"    ],\n"
"],\n"
msgstr "'guards' => [\n"
"    'api' => [\n"
"        'driver' => 'custom-token',\n"
"    ],\n"
"],\n"

#: docs/10.x/authentication.md:block 197 (paragraph)
msgid "Finally, you may reference the guard when assigning the authentication middleware to a route:"
msgstr "最後，在 Route 中指定驗證 Middleware 時可參照這個 Guard："

#: docs/10.x/authentication.md:block 198 (code)
msgid "Route::middleware('auth:api')->group(function () {\n"
"    // ...\n"
"});\n"
msgstr "Route::middleware('auth:api')->group(function () {\n"
"    // ...\n"
"});\n"

#: docs/10.x/authentication.md:block 200 (header)
msgid "Adding Custom User Providers"
msgstr "新增自訂 User Provider"

#: docs/10.x/authentication.md:block 201 (paragraph)
msgid "If you are not using a traditional relational database to store your users, you will need to extend Laravel with your own authentication user provider. We will use the `provider` method on the `Auth` facade to define a custom user provider. The user provider resolver should return an implementation of `Illuminate\\Contracts\\Auth\\UserProvider`:"
msgstr "若你不是使用傳統關聯式資料庫來儲存使用者，就需要擴充 Laravel 來新增自訂的認證 User Provider。接下來我們會用 `Auth` Facade 的 `provider` 方法來定義自訂 User Provider。這個 User Provider 的解析程式應回傳一個 `Illuminate\\Contracts\\Auth\\UserProvider` 的實作："

#: docs/10.x/authentication.md:block 202 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Extensions\\MongoUserProvider;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::provider('mongo', function (Application $app, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n"
"            return new MongoUserProvider($app->make('mongo.connection'));\n"
"        });\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Extensions\\MongoUserProvider;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::provider('mongo', function (Application $app, array $config) {\n"
"            // 回傳 Illuminate\\Contracts\\Auth\\UserProvider 的實體...\n\n"
"            return new MongoUserProvider($app->make('mongo.connection'));\n"
"        });\n"
"    }\n"
"}\n"

#: docs/10.x/authentication.md:block 203 (paragraph)
msgid "After you have registered the provider using the `provider` method, you may switch to the new user provider in your `auth.php` configuration file. First, define a `provider` that uses your new driver:"
msgstr "通過 `provider` 方法註冊好 Provider 後，即可在 `auth.php` 設定檔內更改為新的 User Provider。首先，先定義使用這個新 Driver 的 `provider`："

#: docs/10.x/authentication.md:block 204 (code)
msgid "'providers' => [\n"
"    'users' => [\n"
"        'driver' => 'mongo',\n"
"    ],\n"
"],\n"
msgstr "'providers' => [\n"
"    'users' => [\n"
"        'driver' => 'mongo',\n"
"    ],\n"
"],\n"

#: docs/10.x/authentication.md:block 205 (paragraph)
msgid "Finally, you may reference this provider in your `guards` configuration:"
msgstr "最後，就能在 `guards` 設定中參照這個 Provider："

#: docs/10.x/authentication.md:block 206 (code)
msgid "'guards' => [\n"
"    'web' => [\n"
"        'driver' => 'session',\n"
"        'provider' => 'users',\n"
"    ],\n"
"],\n"
msgstr "'guards' => [\n"
"    'web' => [\n"
"        'driver' => 'session',\n"
"        'provider' => 'users',\n"
"    ],\n"
"],\n"

#: docs/10.x/authentication.md:block 208 (header)
msgid "The User Provider Contract"
msgstr "User Provider Contract"

#: docs/10.x/authentication.md:block 209 (paragraph)
msgid "`Illuminate\\Contracts\\Auth\\UserProvider` implementations are responsible for fetching an `Illuminate\\Contracts\\Auth\\Authenticatable` implementation out of a persistent storage system, such as MySQL, MongoDB, etc. These two interfaces allow the Laravel authentication mechanisms to continue functioning regardless of how the user data is stored or what type of class is used to represent the authenticated user:"
msgstr "`Illuminate\\Contracts\\Auth\\UserProvider` 的實作應負責從持續性儲存系統 (如 MySQL、MongoDB…等) 中取出 `Illuminate\\Contracts\\Auth\\Authenticatable` 的實作。有了這兩個介面，不論我們如何儲存使用者資料、不論我們使用什麼類型的 Class 來代表已登入使用者，Laravel 的認證機制都能繼續運作："

#: docs/10.x/authentication.md:block 210 (paragraph)
msgid "Let's take a look at the `Illuminate\\Contracts\\Auth\\UserProvider` contract:"
msgstr "我們來看看 `Illuminate\\Contracts\\Auth\\UserProvider` Contract："

#: docs/10.x/authentication.md:block 211 (code)
msgid "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface UserProvider\n"
"{\n"
"    public function retrieveById($identifier);\n"
"    public function retrieveByToken($identifier, $token);\n"
"    public function updateRememberToken(Authenticatable $user, $token);\n"
"    public function retrieveByCredentials(array $credentials);\n"
"    public function validateCredentials(Authenticatable $user, array $credentials);\n"
"}\n"
msgstr "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface UserProvider\n"
"{\n"
"    public function retrieveById($identifier);\n"
"    public function retrieveByToken($identifier, $token);\n"
"    public function updateRememberToken(Authenticatable $user, $token);\n"
"    public function retrieveByCredentials(array $credentials);\n"
"    public function validateCredentials(Authenticatable $user, array $credentials);\n"
"}\n"

#: docs/10.x/authentication.md:block 212 (paragraph)
msgid "The `retrieveById` function typically receives a key representing the user, such as an auto-incrementing ID from a MySQL database. The `Authenticatable` implementation matching the ID should be retrieved and returned by the method."
msgstr "`retrieveById` 方法通常會接受一個代表使用者的索引鍵，如 MySQL 資料庫中的 Auto-Increment ID。該方法應回傳一個符合該 ID 的 `Authenticatable` 實作。"

#: docs/10.x/authentication.md:block 213 (paragraph)
msgid "The `retrieveByToken` function retrieves a user by their unique `$identifier` and \"remember me\" `$token`, typically stored in a database column like `remember_token`. As with the previous method, the `Authenticatable` implementation with a matching token value should be returned by this method."
msgstr "`retrieveByToken` 方法通過每個使用者獨立的 `$identifier` 以及一個在資料庫中通常存在 `remember_token` 欄位的「記住我」權杖 `$token` 來取得使用者。與上個方法類似，這個方法應回傳一個符合該權杖的 `Authenticatable` 。"

#: docs/10.x/authentication.md:block 214 (paragraph)
msgid "The `updateRememberToken` method updates the `$user` instance's `remember_token` with the new `$token`. A fresh token is assigned to users on a successful \"remember me\" authentication attempt or when the user is logging out."
msgstr "`updateRememberToken` 方法將 `$user` 實體的 `remember_token` 更新為新的 `$token` 。當有勾選「記住我」的登入認證成功、或使用者登出後，會指派新的權杖給使用者。"

#: docs/10.x/authentication.md:block 215 (paragraph)
msgid "The `retrieveByCredentials` method receives the array of credentials passed to the `Auth::attempt` method when attempting to authenticate with an application. The method should then \"query\" the underlying persistent storage for the user matching those credentials. Typically, this method will run a query with a \"where\" condition that searches for a user record with a \"username\" matching the value of `$credentials['username']`. The method should return an implementation of `Authenticatable`. **This method should not attempt to do any password validation or authentication.**"
msgstr "`retrieveByCredentials` 方法接受一個包含登入憑證的陣列。該陣列是在使用者嘗試登入時傳給 `Auth::attempt` 的憑證。接著該方法內可以向對應的持續性儲存空間以這組憑證進行「查詢」。通常來說，這個方法會執行一個「where」條件句，來搜尋「username」符合 `$credentials['username']` 的使用者記錄。該方法應回傳 `Authenticatable` 的實作。**不應在該方法內認證密碼或進行登入。**"

#: docs/10.x/authentication.md:block 216 (paragraph)
msgid "The `validateCredentials` method should compare the given `$user` with the `$credentials` to authenticate the user. For example, this method will typically use the `Hash::check` method to compare the value of `$user->getAuthPassword()` to the value of `$credentials['password']`. This method should return `true` or `false` indicating whether the password is valid."
msgstr "`validateCredentials` 方法應負責使用 `$credentials` 來比對給定的 `$user` 以驗證使用者。舉例來說，該方法通常會使用 `Hash::check` 方法來比對 `$user->getAuthPassword()` 與 `$credentials['password']` 的值。該方法應回傳 `true` 或 `false` 來標示密碼是否有效。"

#: docs/10.x/authentication.md:block 218 (header)
msgid "The Authenticatable Contract"
msgstr "Authenticatable Contract"

#: docs/10.x/authentication.md:block 219 (paragraph)
msgid "Now that we have explored each of the methods on the `UserProvider`, let's take a look at the `Authenticatable` contract. Remember, user providers should return implementations of this interface from the `retrieveById`, `retrieveByToken`, and `retrieveByCredentials` methods:"
msgstr "現在我們已經看過 `UserProvider` 內的各個方法了。接著來看看 `Authenticatable` Contract。請記住，User Provider 應在 `retrieveById`, `retrieveByToken` 以及 `retrieveByCredentials` 方法內回傳該介面的實作："

#: docs/10.x/authentication.md:block 220 (code)
msgid "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface Authenticatable\n"
"{\n"
"    public function getAuthIdentifierName();\n"
"    public function getAuthIdentifier();\n"
"    public function getAuthPassword();\n"
"    public function getRememberToken();\n"
"    public function setRememberToken($value);\n"
"    public function getRememberTokenName();\n"
"}\n"
msgstr "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface Authenticatable\n"
"{\n"
"    public function getAuthIdentifierName();\n"
"    public function getAuthIdentifier();\n"
"    public function getAuthPassword();\n"
"    public function getRememberToken();\n"
"    public function setRememberToken($value);\n"
"    public function getRememberTokenName();\n"
"}\n"

#: docs/10.x/authentication.md:block 221 (paragraph)
msgid "This interface is simple. The `getAuthIdentifierName` method should return the name of the \"primary key\" field of the user and the `getAuthIdentifier` method should return the \"primary key\" of the user. When using a MySQL back-end, this would likely be the auto-incrementing primary key assigned to the user record. The `getAuthPassword` method should return the user's hashed password."
msgstr "這個介面很簡單。`getAuthIdentifierName` 應回傳使用者「主索引鍵 (Primary Key)」欄位的名稱，而 `getAuthIdentifier` 則回傳使用者的「主索引鍵」。當使用 MySQL 後端時，主索引鍵通常就是指派給使用者記錄的自動遞增 (Auto-Increment) 主索引鍵。"

#: docs/10.x/authentication.md:block 222 (paragraph)
msgid "This interface allows the authentication system to work with any \"user\" class, regardless of what ORM or storage abstraction layer you are using. By default, Laravel includes an `App\\Models\\User` class in the `app/Models` directory which implements this interface."
msgstr "有了這個介面，不論使用什麼 ORM 或儲存抽象層，認證系統都能與任何的「使用者」Class 搭配使用。預設情況下，Laravel 在 `app/Models` 目錄內包含了一個 `App\\Models\\User` Class，`App\\Models\\User` 就實作了這個介面。"

#: docs/10.x/authentication.md:block 224 (header)
msgid "Events"
msgstr "事件"

#: docs/10.x/authentication.md:block 225 (paragraph)
msgid "Laravel dispatches a variety of [events](/docs/{{version}}/events) during the authentication process. You may attach listeners to these events in your `EventServiceProvider`:"
msgstr "Laravel 會在認證的過程中分派數個 [事件](/docs/{{version}}/events)。可以在 `EventServiceProvider` 內為這些事件附加監聽程式。"

#: docs/10.x/authentication.md:block 226 (code)
msgid "/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    'Illuminate\\Auth\\Events\\Registered' => [\n"
"        'App\\Listeners\\LogRegisteredUser',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Attempting' => [\n"
"        'App\\Listeners\\LogAuthenticationAttempt',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Authenticated' => [\n"
"        'App\\Listeners\\LogAuthenticated',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Login' => [\n"
"        'App\\Listeners\\LogSuccessfulLogin',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Failed' => [\n"
"        'App\\Listeners\\LogFailedLogin',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Validated' => [\n"
"        'App\\Listeners\\LogValidated',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Verified' => [\n"
"        'App\\Listeners\\LogVerified',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Logout' => [\n"
"        'App\\Listeners\\LogSuccessfulLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\CurrentDeviceLogout' => [\n"
"        'App\\Listeners\\LogCurrentDeviceLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\OtherDeviceLogout' => [\n"
"        'App\\Listeners\\LogOtherDeviceLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Lockout' => [\n"
"        'App\\Listeners\\LogLockout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\PasswordReset' => [\n"
"        'App\\Listeners\\LogPasswordReset',\n"
"    ],\n"
"];\n"
msgstr "/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    'Illuminate\\Auth\\Events\\Registered' => [\n"
"        'App\\Listeners\\LogRegisteredUser',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Attempting' => [\n"
"        'App\\Listeners\\LogAuthenticationAttempt',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Authenticated' => [\n"
"        'App\\Listeners\\LogAuthenticated',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Login' => [\n"
"        'App\\Listeners\\LogSuccessfulLogin',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Failed' => [\n"
"        'App\\Listeners\\LogFailedLogin',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Validated' => [\n"
"        'App\\Listeners\\LogValidated',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Verified' => [\n"
"        'App\\Listeners\\LogVerified',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Logout' => [\n"
"        'App\\Listeners\\LogSuccessfulLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\CurrentDeviceLogout' => [\n"
"        'App\\Listeners\\LogCurrentDeviceLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\OtherDeviceLogout' => [\n"
"        'App\\Listeners\\LogOtherDeviceLogout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\Lockout' => [\n"
"        'App\\Listeners\\LogLockout',\n"
"    ],\n\n"
"    'Illuminate\\Auth\\Events\\PasswordReset' => [\n"
"        'App\\Listeners\\LogPasswordReset',\n"
"    ],\n"
"];\n"

#: docs/11.x/authentication.md:block 2 (unordered list)
msgid "[Automatic Password Rehashing](#automatic-password-rehashing)"
msgstr ""

#: docs/11.x/authentication.md:block 69 (paragraph)
msgid "[Route middleware](/docs/{{version}}/middleware) can be used to only allow authenticated users to access a given route. Laravel ships with an `auth` middleware, which is a [middleware alias](/docs/{{version}}/middleware#middleware-alias) for the `Illuminate\\Auth\\Middleware\\Authenticate` class. Since this middleware is already aliased internally by Laravel, all you need to do is attach the middleware to a route definition:"
msgstr ""

#: docs/11.x/authentication.md:block 73 (paragraph)
msgid "When the `auth` middleware detects an unauthenticated user, it will redirect the user to the `login` [named route](/docs/{{version}}/routing#named-routes). You may modify this behavior using the method `redirectGuestsTo` of your application's `bootstrap/app.php` file:"
msgstr ""

#: docs/11.x/authentication.md:block 74 (code)
msgid "use Illuminate\\Http\\Request;\n\n"
"->withMiddleware(function (Middleware $middleware) {\n"
"    $middleware->redirectGuestsTo('/login');\n\n"
"    // Using a closure...\n"
"    $middleware->redirectGuestsTo(fn (Request $request) => route('login'));\n"
"})\n"
msgstr ""

#: docs/11.x/authentication.md:block 156 (paragraph)
msgid "Before getting started, you should make sure that the `Illuminate\\Session\\Middleware\\AuthenticateSession` middleware is included on the routes that should receive session authentication. Typically, you should place this middleware on a route group definition so that it can be applied to the majority of your application's routes. By default, the `AuthenticateSession` middleware may be attached to a route using the `auth.session` [middleware alias](/docs/{{version}}/middleware#middleware-alias):"
msgstr ""

#: docs/11.x/authentication.md:block 186 (paragraph)
msgid "You may define your own authentication guards using the `extend` method on the `Auth` facade. You should place your call to the `extend` method within a [service provider](/docs/{{version}}/providers). Since Laravel already ships with an `AppServiceProvider`, we can place the code in that provider:"
msgstr ""

#: docs/11.x/authentication.md:block 187 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Services\\Auth\\JwtGuard;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Support\\Facades\\Auth;\n"
"use Illuminate\\Support\\ServiceProvider;\n\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    // ...\n\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::extend('jwt', function (Application $app, string $name, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n"
"            return new JwtGuard(Auth::createUserProvider($config['provider']));\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/11.x/authentication.md:block 193 (paragraph)
msgid "To get started, call the `Auth::viaRequest` method within the `boot` method of your application's `AppServiceProvider`. The `viaRequest` method accepts an authentication driver name as its first argument. This name can be any string that describes your custom guard. The second argument passed to the method should be a closure that receives the incoming HTTP request and returns a user instance or, if authentication fails, `null`:"
msgstr ""

#: docs/11.x/authentication.md:block 194 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', (string) $request->token)->first();\n"
"    });\n"
"}\n"
msgstr ""

#: docs/11.x/authentication.md:block 202 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Extensions\\MongoUserProvider;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"use Illuminate\\Support\\Facades\\Auth;\n"
"use Illuminate\\Support\\ServiceProvider;\n\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    // ...\n\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Auth::provider('mongo', function (Application $app, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n"
"            return new MongoUserProvider($app->make('mongo.connection'));\n"
"        });\n"
"    }\n"
"}\n"
msgstr ""

#: docs/11.x/authentication.md:block 211 (code)
msgid "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface UserProvider\n"
"{\n"
"    public function retrieveById($identifier);\n"
"    public function retrieveByToken($identifier, $token);\n"
"    public function updateRememberToken(Authenticatable $user, $token);\n"
"    public function retrieveByCredentials(array $credentials);\n"
"    public function validateCredentials(Authenticatable $user, array $credentials);\n"
"    public function rehashPasswordIfRequired(Authenticatable $user, array $credentials, bool $force = false);\n"
"}\n"
msgstr ""

#: docs/11.x/authentication.md:block 217 (paragraph)
msgid "The `rehashPasswordIfRequired` method should rehash the given `$user`'s password if required and supported. For example, this method will typically use the `Hash::needsRehash` method to determine if the `$credentials['password']` value needs to be rehashed. If the password needs to be rehashed, the method should use the `Hash::make` method to rehash the password and update the user's record in the underlying persistent storage."
msgstr ""

#: docs/11.x/authentication.md:block 221 (code)
msgid "<?php\n\n"
"namespace Illuminate\\Contracts\\Auth;\n\n"
"interface Authenticatable\n"
"{\n"
"    public function getAuthIdentifierName();\n"
"    public function getAuthIdentifier();\n"
"    public function getAuthPasswordName();\n"
"    public function getAuthPassword();\n"
"    public function getRememberToken();\n"
"    public function setRememberToken($value);\n"
"    public function getRememberTokenName();\n"
"}\n"
msgstr ""

#: docs/11.x/authentication.md:block 222 (paragraph)
msgid "This interface is simple. The `getAuthIdentifierName` method should return the name of the \"primary key\" column for the user and the `getAuthIdentifier` method should return the \"primary key\" of the user. When using a MySQL back-end, this would likely be the auto-incrementing primary key assigned to the user record. The `getAuthPasswordName` method should return the name of the user's password column. The `getAuthPassword` method should return the user's hashed password."
msgstr ""

#: docs/11.x/authentication.md:block 225 (header)
msgid "Automatic Password Rehashing"
msgstr ""

#: docs/11.x/authentication.md:block 226 (paragraph)
msgid "Laravel's default password hashing algorithm is bcrypt. The \"work factor\" for bcrypt hashes can be adjusted via your application's `config/hashing.php` configuration file or the `BCRYPT_ROUNDS` environment variable."
msgstr ""

#: docs/11.x/authentication.md:block 227 (paragraph)
msgid "Typically, the bcrypt work factor should be increased over time as CPU / GPU processing power increases. If you increase the bcrypt work factor for your application, Laravel will gracefully and automatically rehash user passwords as users authenticate with your application via Laravel's starter kits or when you [manually authenticate users](#authenticating-users) via the `attempt` method."
msgstr ""

#: docs/11.x/authentication.md:block 228 (paragraph)
msgid "Typically, automatic password rehashing should not disrupt your application; however, you may disable this behavior by publishing the `hashing` configuration file:"
msgstr ""

#: docs/11.x/authentication.md:block 229 (code)
msgid "php artisan config:publish hashing\n"
msgstr ""

#: docs/11.x/authentication.md:block 230 (paragraph)
msgid "Once the configuration file has been published, you may set the `rehash_on_login` configuration value to `false`:"
msgstr ""

#: docs/11.x/authentication.md:block 231 (code)
msgid "'rehash_on_login' => false,\n"
msgstr ""

#: docs/11.x/authentication.md:block 234 (paragraph)
msgid "Laravel dispatches a variety of [events](/docs/{{version}}/events) during the authentication process. You may [define listeners](/docs/{{version}}/events) for any of the following events:"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "Event Name"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Registered`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Attempting`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Authenticated`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Login`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Failed`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Validated`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Verified`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Logout`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\CurrentDeviceLogout`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\OtherDeviceLogout`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\Lockout`"
msgstr ""

#: docs/11.x/authentication.md:block 235 (table)
msgid "`Illuminate\\Auth\\Events\\PasswordReset`"
msgstr ""

#: docs/8.x/authentication.md:block 2 (unordered list)
msgid "[Install A Starter Kit](#install-a-starter-kit)"
msgstr "[安裝入門套件](#install-a-starter-kit)"

#: docs/8.x/authentication.md:block 2 (unordered list)
msgid "[Retrieving The Authenticated User](#retrieving-the-authenticated-user)"
msgstr "[取得已登入的使用者](#retrieving-the-authenticated-user)"

#: docs/8.x/authentication.md:block 2 (unordered list)
msgid "[Invalidating Sessions On Other Devices](#invalidating-sessions-on-other-devices)"
msgstr "[登出其他裝置上的工作階段](#invalidating-sessions-on-other-devices)"

#: docs/8.x/authentication.md:block 9 (quote)
msgid "{tip} Guards and providers should not be confused with \"roles\" and \"permissions\". To learn more about authorizing user actions via permissions, please refer to the [authorization](/docs/{{version}}/authorization) documentation."
msgstr "{tip} Guard 與 Provider 跟「角色」以及「權限」不同，不應混謠。若要瞭解如何依照權限來授權使用者的方法，請參考[授權](/docs/{{version}}/authorization) 說明文件。"

#: docs/8.x/authentication.md:block 31 (paragraph)
msgid "*[Laravel Jetstream](https://jetstream.laravel.com)* is a robust application starter kit that consumes and exposes Laravel Fortify's authentication services with a beautiful, modern UI powered by [Tailwind CSS](https://tailwindcss.com), [Livewire](https://laravel-livewire.com), and / or [Inertia.js](https://inertiajs.com). Laravel Jetstream includes optional support for two-factor authentication, team support, browser session management, profile management, and built-in integration with [Laravel Sanctum](/docs/{{version}}/sanctum) to offer API token authentication. Laravel's API authentication offerings are discussed below."
msgstr "**[Laravel Jetstream](https://jetstream.laravel.com)** 是一個強大的入門套件，該套件使用者 Laravel Fortify 的驗證服務，並將其通過 [Tailwind CSS](https://tailwindcss.com), [Livewire](https://laravel-livewire.com)，與／或 [Inertia.js](https://inertiajs.com) 來提供美麗且現代的 UI。Laravel Jetstream 也提供了對二步驟驗證、團隊支援、瀏覽器啟程管理、個人檔案管理、以及內建與 [Laravel Sanctum](/docs/{{version}}/sunctum) 整合來提供 API 權杖驗證的可選支援。Laravel 提供的 API 驗證功能將在下方討論。"

#: docs/8.x/authentication.md:block 42 (header)
msgid "Summary & Choosing Your Stack"
msgstr "總結與選擇你的 Stack"

#: docs/8.x/authentication.md:block 47 (paragraph)
msgid "And, if you would like to get started quickly, we are pleased to recommend [Laravel Jetstream](https://jetstream.laravel.com) as a quick way to start a new Laravel application that already uses our preferred authentication stack of Laravel's built-in authentication services and Laravel Sanctum."
msgstr "此外，若想要快速入門，我們誠摯推薦你使用 [Laravel Jetstream](https://jetstream.laravel.com) 來作為快速建立新 Laravel 專案的方法。Laravel Jetstream 已經使用了我們偏好的認證 Stack —— 使用 Laravel 的內建認證服務與 Laravel Sanctum。"

#: docs/8.x/authentication.md:block 50 (quote)
msgid "{note} This portion of the documentation discusses authenticating users via the [Laravel application starter kits](/docs/{{version}}/starter-kits), which includes UI scaffolding to help you get started quickly. If you would like to integrate with Laravel's authentication systems directly, check out the documentation on [manually authenticating users](#authenticating-users)."
msgstr "{note} 這部分的文件會討論通過 [Laravel 應用程式入門套件](/docs/{{version}}/starter-kits) 來驗證使用者，這些入門套件包含了能協助你快速開始的 UI Scaffolding。若你想要直接與 Laravel 的驗證系統整合，請參考 [手動驗證使用者](#authenticating-users) 內的說明文件。"

#: docs/8.x/authentication.md:block 52 (header)
msgid "Install A Starter Kit"
msgstr "安裝一種入門套件"

#: docs/8.x/authentication.md:block 54 (paragraph)
msgid "Laravel Breeze is a minimal, simple implementation of all of Laravel's authentication features, including login, registration, password reset, email verification, and password confirmation. Laravel Breeze's view layer is made up of simple [Blade templates](/docs/{{version}}/blade) styled with [Tailwind CSS](https://tailwindcss.com). Breeze also offers an [Inertia](https://inertiajs.com) based scaffolding option using Vue or React."
msgstr "Laravel Breeze 是一個簡單且最小化實作出所有 Laravel 認證功能的套件，包含登入、註冊、密碼重設、電子郵件認證、以及密碼確認。Laravel Breeze 的檢視器層是通過簡單的 [Blade 樣板](/docs/{{version}}/blade) 搭配 [Tailwind CSS](https://tailwindcss.com) 提供樣式組合而成的。Breeze 也提供了一個使用 Vue 或 React 的基於 [Inertia](https://inertiajs.com) 的 Scaffolding 選項。"

#: docs/8.x/authentication.md:block 55 (paragraph)
msgid "[Laravel Jetstream](https://jetstream.laravel.com) is a more robust application starter kit that includes support for scaffolding your application with [Livewire](https://laravel-livewire.com) or [Inertia.js and Vue](https://inertiajs.com). In addition, Jetstream features optional support for two-factor authentication, teams, profile management, browser session management, API support via [Laravel Sanctum](/docs/{{version}}/sanctum), account deletion, and more."
msgstr "[Laravel Jetstream](https://jetstream.laravel.com) 是一個更複雜的專案入門套件，其中包含了使用 [Livewire](https://laravel-livewire.com) 或 [Inertia.js 與 Vue](https://inertiajs.com) 來對應用程式 Scaffolding 的支援。此外，Jetstream 也提供了對二步驟認證、團隊、個人檔案管理、瀏覽器啟程管理、通過 [Laravel Sanctum](/docs/{{version}}/sanctum) 提供的 API 支援、帳號刪除…等功能的可選支援。"

#: docs/8.x/authentication.md:block 57 (header)
msgid "Retrieving The Authenticated User"
msgstr "取得已登入的使用者"

#: docs/8.x/authentication.md:block 61 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n\n"
"class FlightController extends Controller\n"
"{\n"
"    /**\n"
"     * Update the flight information for an existing flight.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function update(Request $request)\n"
"    {\n"
"        // $request->user()\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n\n"
"class FlightController extends Controller\n"
"{\n"
"    /**\n"
"     * Update the flight information for an existing flight.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function update(Request $request)\n"
"    {\n"
"        // $request->user()\n"
"    }\n"
"}\n"

#: docs/8.x/authentication.md:block 63 (header)
msgid "Determining If The Current User Is Authenticated"
msgstr "判斷目前使用者是否已認證"

#: docs/8.x/authentication.md:block 66 (quote)
msgid "{tip} Even though it is possible to determine if a user is authenticated using the `check` method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on [protecting routes](/docs/{{version}}/authentication#protecting-routes)."
msgstr "{tip} 雖然可以使用 `check` 方法來判斷使用者是否已登入，但通常可以使用 Middleware 來在使用者存取特定 Route 或 Controller 前就先驗證該使用者是否已登入。關更多詳情，參考[保護 Route](/docs/{{version}}/authentication#protecting-routes) 內的說明文件。"

#: docs/8.x/authentication.md:block 74 (code)
msgid "/**\n"
" * Get the path the user should be redirected to.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @return string\n"
" */\n"
"protected function redirectTo($request)\n"
"{\n"
"    return route('login');\n"
"}\n"
msgstr "/**\n"
" * Get the path the user should be redirected to.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @return string\n"
" */\n"
"protected function redirectTo($request)\n"
"{\n"
"    return route('login');\n"
"}\n"

#: docs/8.x/authentication.md:block 76 (header)
msgid "Specifying A Guard"
msgstr "指定 Guard"

#: docs/8.x/authentication.md:block 82 (quote)
msgid "{tip} If you would like to rate limit other routes in your application, check out the [rate limiting documentation](/docs/{{version}}/routing#rate-limiting)."
msgstr "{tip} 若想在專案中的其他 Route 上提供頻率限制，請參考[頻率限制的說明文件](/docs/{{version}}/routing#rate-limiting)。"

#: docs/8.x/authentication.md:block 87 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function authenticate(Request $request)\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ]);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function authenticate(Request $request)\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ]);\n"
"    }\n"
"}\n"

#: docs/8.x/authentication.md:block 96 (quote)
msgid "{note} In these examples, `email` is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database table."
msgstr "{note} 不一定要像這個例子一樣使用 `email` 欄位，此處只是以 E-Mail 當作範例。可以使用任何在資料庫中相當於「使用者名稱」的欄位來認證。"

#: docs/8.x/authentication.md:block 110 (header)
msgid "Authenticate A User Instance"
msgstr "認證使用者實體"

#: docs/8.x/authentication.md:block 118 (header)
msgid "Authenticate A User By ID"
msgstr "通過 ID 認證使用者"

#: docs/8.x/authentication.md:block 124 (header)
msgid "Authenticate A User Once"
msgstr "僅認證使用者一次"

#: docs/8.x/authentication.md:block 126 (code)
msgid "if (Auth::once($credentials)) {\n"
"    //\n"
"}\n"
msgstr "if (Auth::once($credentials)) {\n"
"    //\n"
"}\n"

#: docs/8.x/authentication.md:block 133 (header)
msgid "A Note On FastCGI"
msgstr "FastCGI 備註"

#: docs/8.x/authentication.md:block 139 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Middleware;\n\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthenticateOnceWithBasicAuth\n"
"{\n"
"    /**\n"
"     * Handle an incoming request.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @param  \\Closure  $next\n"
"     * @return mixed\n"
"     */\n"
"    public function handle($request, $next)\n"
"    {\n"
"        return Auth::onceBasic() ?: $next($request);\n"
"    }\n\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Middleware;\n\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthenticateOnceWithBasicAuth\n"
"{\n"
"    /**\n"
"     * Handle an incoming request.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @param  \\Closure  $next\n"
"     * @return mixed\n"
"     */\n"
"    public function handle($request, $next)\n"
"    {\n"
"        return Auth::onceBasic() ?: $next($request);\n"
"    }\n\n"
"}\n"

#: docs/8.x/authentication.md:block 140 (paragraph)
msgid "Next, [register the route middleware](/docs/{{version}}/middleware#registering-middleware) and attach it to a route:"
msgstr "接著，請[註冊路由 Middleware](/docs/{{version}}/middleware#registering-middleware)，並將其附加到路由上："

#: docs/8.x/authentication.md:block 141 (code)
msgid "Route::get('/api/user', function () {\n"
"    // Only authenticated users may access this route...\n"
"})->middleware('auth.basic.once');\n"
msgstr "Route::get('/api/user', function () {\n"
"    // 只有已登入使用者可以存取這個 Route...\n"
"})->middleware('auth.basic.once');\n"

#: docs/8.x/authentication.md:block 146 (code)
msgid "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Log the user out of the application.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @return \\Illuminate\\Http\\Response\n"
" */\n"
"public function logout(Request $request)\n"
"{\n"
"    Auth::logout();\n\n"
"    $request->session()->invalidate();\n\n"
"    $request->session()->regenerateToken();\n\n"
"    return redirect('/');\n"
"}\n"
msgstr "use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Log the user out of the application.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @return \\Illuminate\\Http\\Response\n"
" */\n"
"public function logout(Request $request)\n"
"{\n"
"    Auth::logout();\n\n"
"    $request->session()->invalidate();\n\n"
"    $request->session()->regenerateToken();\n\n"
"    return redirect('/');\n"
"}\n"

#: docs/8.x/authentication.md:block 148 (header)
msgid "Invalidating Sessions On Other Devices"
msgstr "將其他裝置上的 Session 無效化"

#: docs/8.x/authentication.md:block 150 (paragraph)
msgid "Before getting started, you should make sure that the `Illuminate\\Session\\Middleware\\AuthenticateSession` middleware is present and un-commented in your `App\\Http\\Kernel` class' `web` middleware group:"
msgstr "在開始前，請先確保 `Illuminate\\Session\\Middleware\\AuthenticateSession` Middleware 有出現在 `App\\Http\\Kernel` 類別的 `web` Middleware 群組中，並且未被註解掉："

#: docs/8.x/authentication.md:block 151 (code)
msgid "'web' => [\n"
"    // ...\n"
"    \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\n"
"    // ...\n"
"],\n"
msgstr "'web' => [\n"
"    // ...\n"
"    \\Illuminate\\Session\\Middleware\\AuthenticateSession::class,\n"
"    // ...\n"
"],\n"

#: docs/8.x/authentication.md:block 158 (quote)
msgid "{tip} The following documentation discusses how to integrate with Laravel's password confirmation features directly; however, if you would like to get started more quickly, the [Laravel application starter kits](/docs/{{version}}/starter-kits) include support for this feature!"
msgstr "{tip} 下列說明文件討論了如何直接整合 Laravel 的密碼確認功能。但若想更快速地入門， [Laravel 專案入門套件](/docs/{{version}}/starter-kits) 有內建支援這個功能！"

#: docs/8.x/authentication.md:block 170 (header)
msgid "Confirming The Password"
msgstr "確認密碼"

#: docs/8.x/authentication.md:block 181 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Services\\Auth\\JwtGuard;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        $this->registerPolicies();\n\n"
"        Auth::extend('jwt', function ($app, $name, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n"
"            return new JwtGuard(Auth::createUserProvider($config['provider']));\n"
"        });\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Services\\Auth\\JwtGuard;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        $this->registerPolicies();\n\n"
"        Auth::extend('jwt', function ($app, $name, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\Guard...\n\n"
"            return new JwtGuard(Auth::createUserProvider($config['provider']));\n"
"        });\n"
"    }\n"
"}\n"

#: docs/8.x/authentication.md:block 188 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    $this->registerPolicies();\n\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', $request->token)->first();\n"
"    });\n"
"}\n"
msgstr "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    $this->registerPolicies();\n\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', $request->token)->first();\n"
"    });\n"
"}\n"

#: docs/8.x/authentication.md:block 194 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Extensions\\MongoUserProvider;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        $this->registerPolicies();\n\n"
"        Auth::provider('mongo', function ($app, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n"
"            return new MongoUserProvider($app->make('mongo.connection'));\n"
"        });\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Extensions\\MongoUserProvider;\n"
"use Illuminate\\Foundation\\Support\\Providers\\AuthServiceProvider as ServiceProvider;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class AuthServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application authentication / authorization services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        $this->registerPolicies();\n\n"
"        Auth::provider('mongo', function ($app, array $config) {\n"
"            // Return an instance of Illuminate\\Contracts\\Auth\\UserProvider...\n\n"
"            return new MongoUserProvider($app->make('mongo.connection'));\n"
"        });\n"
"    }\n"
"}\n"

#: docs/8.x/authentication.md:block 214 (paragraph)
msgid "This interface allows the authentication system to work with any \"user\" class, regardless of what ORM or storage abstraction layer you are using. By default, Laravel includes a `App\\Models\\User` class in the `app/Models` directory which implements this interface."
msgstr "有了這個介面，不論使用什麼 ORM 或儲存抽象層，認證系統都能與任何的「使用者」Class 搭配使用。預設情況下，Laravel 在 `app/Models` 目錄內包含了一個 `App\\Models\\User` Class，`App\\Models\\User` 就實作了這個介面。"

#: docs/9.x/authentication.md:block 9 (quote)
msgid "**Note** Guards and providers should not be confused with \"roles\" and \"permissions\". To learn more about authorizing user actions via permissions, please refer to the [authorization](/docs/{{version}}/authorization) documentation."
msgstr "**Note** Guard 與 Provider 與「角色」以及「權限」不同，不應溷肴。要瞭解如何依照權限來授權使用者的方法，請參考 [授權](/docs/{{version}}/authorization) 說明文件。"

#: docs/9.x/authentication.md:block 31 (paragraph)
msgid "*[Laravel Jetstream](https://jetstream.laravel.com)* is a robust application starter kit that consumes and exposes Laravel Fortify's authentication services with a beautiful, modern UI powered by [Tailwind CSS](https://tailwindcss.com), [Livewire](https://laravel-livewire.com), and / or [Inertia](https://inertiajs.com). Laravel Jetstream includes optional support for two-factor authentication, team support, browser session management, profile management, and built-in integration with [Laravel Sanctum](/docs/{{version}}/sanctum) to offer API token authentication. Laravel's API authentication offerings are discussed below."
msgstr "**[Laravel Jetstream](https://jetstream.laravel.com)** 是一個強大的入門套件，該套件使用者 Laravel Fortify 的驗證服務，並將其通過 [Tailwind CSS](https://tailwindcss.com), [Livewire](https://laravel-livewire.com)，與／或 [Inertia](https://inertiajs.com) 來提供美麗且現代的 UI。Laravel Jetstream 也提供了對二步驟驗證、團隊支援、瀏覽器啟程管理、個人檔案管理、以及內建與 [Laravel Sanctum](/docs/{{version}}/sunctum) 整合來提供 API 權杖驗證的可選支援。Laravel 提供的 API 驗證功能將在下方討論。"

#: docs/9.x/authentication.md:block 50 (quote)
msgid "**Warning** This portion of the documentation discusses authenticating users via the [Laravel application starter kits](/docs/{{version}}/starter-kits), which includes UI scaffolding to help you get started quickly. If you would like to integrate with Laravel's authentication systems directly, check out the documentation on [manually authenticating users](#authenticating-users)."
msgstr "**Warning** 這部分的文件會討論通過 [Laravel 應用程式入門套件](/docs/{{version}}/starter-kits) 來驗證使用者，這些入門套件包含了能協助你快速開始的 UI Scaffolding。若你想要直接與 Laravel 的驗證系統整合，請參考 [手動驗證使用者](#authenticating-users) 內的說明文件。"

#: docs/9.x/authentication.md:block 55 (paragraph)
msgid "[Laravel Jetstream](https://jetstream.laravel.com) is a more robust application starter kit that includes support for scaffolding your application with [Livewire](https://laravel-livewire.com) or [Inertia and Vue](https://inertiajs.com). In addition, Jetstream features optional support for two-factor authentication, teams, profile management, browser session management, API support via [Laravel Sanctum](/docs/{{version}}/sanctum), account deletion, and more."
msgstr "[Laravel Jetstream](https://jetstream.laravel.com) 是一個更複雜的專案入門套件，其中包含了使用 [Livewire](https://laravel-livewire.com) 或 [Inertia 與 Vue](https://inertiajs.com) 來對應用程式 Scaffolding 的支援。此外，Jetstream 也提供了對二步驟認證、團隊、個人檔案管理、瀏覽器啟程管理、通過 [Laravel Sanctum](/docs/{{version}}/sanctum) 提供的 API 支援、帳號刪除…等功能的可選支援。"

#: docs/9.x/authentication.md:block 66 (quote)
msgid "**Note** Even though it is possible to determine if a user is authenticated using the `check` method, you will typically use a middleware to verify that the user is authenticated before allowing the user access to certain routes / controllers. To learn more about this, check out the documentation on [protecting routes](/docs/{{version}}/authentication#protecting-routes)."
msgstr "**Note** 雖然可以使用 `check` 方法來判斷使用者是否已登入，但通常可以使用 Middleware 來在使用者存取特定 Route 或 Controller 前就先驗證該使用者是否已登入。關更多詳情，參考[保護 Route](/docs/{{version}}/authentication#protecting-routes) 內的說明文件。"

#: docs/9.x/authentication.md:block 82 (quote)
msgid "**Note** If you would like to rate limit other routes in your application, check out the [rate limiting documentation](/docs/{{version}}/routing#rate-limiting)."
msgstr "**Note** 若想在專案中的其他 Route 上提供頻率限制，請參考[頻率限制的說明文件](/docs/{{version}}/routing#rate-limiting)。"

#: docs/9.x/authentication.md:block 87 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function authenticate(Request $request)\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ])->onlyInput('email');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"class LoginController extends Controller\n"
"{\n"
"    /**\n"
"     * Handle an authentication attempt.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function authenticate(Request $request)\n"
"    {\n"
"        $credentials = $request->validate([\n"
"            'email' => ['required', 'email'],\n"
"            'password' => ['required'],\n"
"        ]);\n\n"
"        if (Auth::attempt($credentials)) {\n"
"            $request->session()->regenerate();\n\n"
"            return redirect()->intended('dashboard');\n"
"        }\n\n"
"        return back()->withErrors([\n"
"            'email' => 'The provided credentials do not match our records.',\n"
"        ])->onlyInput('email');\n"
"    }\n"
"}\n"

#: docs/9.x/authentication.md:block 97 (code)
msgid "if (Auth::attempt([\n"
"    'email' => $email, \n"
"    'password' => $password, \n"
"    fn ($query) => $query->has('activeSubscription'),\n"
"])) {\n"
"    // Authentication was successful...\n"
"}\n"
msgstr "if (Auth::attempt([\n"
"    'email' => $email, \n"
"    'password' => $password, \n"
"    fn ($query) => $query->has('activeSubscription'),\n"
"])) {\n"
"    // 登入成功...\n"
"}\n"

#: docs/9.x/authentication.md:block 98 (quote)
msgid "**Warning** In these examples, `email` is not a required option, it is merely used as an example. You should use whatever column name corresponds to a \"username\" in your database table."
msgstr "**Warning** 不一定要像這個例子一樣使用 `email` 欄位，此處只是以 E-Mail 當作範例。可以使用任何在資料庫中相當於「使用者名稱」的欄位來認證。"

#: docs/9.x/authentication.md:block 100 (code)
msgid "if (Auth::attemptWhen([\n"
"    'email' => $email,\n"
"    'password' => $password,\n"
"], function ($user) {\n"
"    return $user->isNotBanned();\n"
"})) {\n"
"    // Authentication was successful...\n"
"}\n"
msgstr "if (Auth::attemptWhen([\n"
"    'email' => $email,\n"
"    'password' => $password,\n"
"], function ($user) {\n"
"    return $user->isNotBanned();\n"
"})) {\n"
"    // 登入成功...\n"
"}\n"

#: docs/9.x/authentication.md:block 156 (paragraph)
msgid "Before getting started, you should make sure that the `Illuminate\\Session\\Middleware\\AuthenticateSession` middleware is included on the routes that should receive session authentication. Typically, you should place this middleware on a route group definition so that it can be applied to the majority of your application's routes. By default, the `AuthenticateSession` middleware may be attached to a route using the `auth.session` route middleware key as defined in your application's HTTP kernel:"
msgstr "在開始之前，請先確保要收到 Session 身份驗證的 Route 都有包含 `Illuminate\\Session\\Middleware\\AuthenticateSession` Middleware。一般來說，應在 Route 群組定義內放入這個 Middleware，好讓該 Middleware 被套用到專案中大多數的 Route。預設情況下，`AuthenticateSession` Middleware 可使用專案 HTTP Kernel 中所定義的 `auth.session` 這個 Route Middleware 索引鍵來附加到 Route 上："

#: docs/9.x/authentication.md:block 164 (quote)
msgid "**Note** The following documentation discusses how to integrate with Laravel's password confirmation features directly; however, if you would like to get started more quickly, the [Laravel application starter kits](/docs/{{version}}/starter-kits) include support for this feature!"
msgstr "**Note** 下列說明文件討論了如何直接整合 Laravel 的密碼確認功能。但若想更快速地入門， [Laravel 專案入門套件](/docs/{{version}}/starter-kits) 有內建支援這個功能！"

#: docs/9.x/authentication.md:block 194 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    $this->registerPolicies();\n\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', (string) $request->token)->first();\n"
"    });\n"
"}\n"
msgstr "use App\\Models\\User;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Auth;\n\n"
"/**\n"
" * Register any application authentication / authorization services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    $this->registerPolicies();\n\n"
"    Auth::viaRequest('custom-token', function (Request $request) {\n"
"        return User::where('token', (string) $request->token)->first();\n"
"    });\n"
"}\n"

#: docs/9.x/authentication.md:block 198 (code)
msgid "Route::middleware('auth:api')->group(function () {\n"
"    // ...\n"
"}\n"
msgstr "Route::middleware('auth:api')->group(function () {\n"
"    // ...\n"
"}\n"

