msgid ""
msgstr ""
"Project-Id-Version: laravel-docs\n"
"POT-Creation-Date: 2022-02-07 15:39+0000\n"
"PO-Revision-Date: 2022-02-07 15:43\n"
"Last-Translator: \n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/eloquent-relationships.pot\n"
"X-Crowdin-File-ID: 55\n"

# File: docs/8.x/eloquent-relationships.md, line: 1
# File: docs/master/eloquent-relationships.md, line: 1
#. type: Title #
#, no-wrap
msgid "Eloquent: Relationships"
msgstr "Eloquent：關聯"

# File: docs/8.x/eloquent-relationships.md, line: 41
# File: docs/master/eloquent-relationships.md, line: 41
#. type: Bullet: '- '
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

# File: docs/8.x/eloquent-relationships.md, line: 41
# File: docs/master/eloquent-relationships.md, line: 41
#. type: Plain text
#, no-wrap
msgid "- [Defining Relationships](#defining-relationships)\n"
"    - [One To One](#one-to-one)\n"
"    - [One To Many](#one-to-many)\n"
"    - [One To Many (Inverse) / Belongs To](#one-to-many-inverse)\n"
"    - [Has One Of Many](#has-one-of-many)\n"
"    - [Has One Through](#has-one-through)\n"
"    - [Has Many Through](#has-many-through)\n"
"- [Many To Many Relationships](#many-to-many)\n"
"    - [Retrieving Intermediate Table Columns](#retrieving-intermediate-table-columns)\n"
"    - [Filtering Queries Via Intermediate Table Columns](#filtering-queries-via-intermediate-table-columns)\n"
"    - [Defining Custom Intermediate Table Models](#defining-custom-intermediate-table-models)\n"
"- [Polymorphic Relationships](#polymorphic-relationships)\n"
"    - [One To One](#one-to-one-polymorphic-relations)\n"
"    - [One To Many](#one-to-many-polymorphic-relations)\n"
"    - [One Of Many](#one-of-many-polymorphic-relations)\n"
"    - [Many To Many](#many-to-many-polymorphic-relations)\n"
"    - [Custom Polymorphic Types](#custom-polymorphic-types)\n"
"- [Dynamic Relationships](#dynamic-relationships)\n"
"- [Querying Relations](#querying-relations)\n"
"    - [Relationship Methods Vs. Dynamic Properties](#relationship-methods-vs-dynamic-properties)\n"
"    - [Querying Relationship Existence](#querying-relationship-existence)\n"
"    - [Querying Relationship Absence](#querying-relationship-absence)\n"
"    - [Querying Morph To Relationships](#querying-morph-to-relationships)\n"
"- [Aggregating Related Models](#aggregating-related-models)\n"
"    - [Counting Related Models](#counting-related-models)\n"
"    - [Other Aggregate Functions](#other-aggregate-functions)\n"
"    - [Counting Related Models On Morph To Relationships](#counting-related-models-on-morph-to-relationships)\n"
"- [Eager Loading](#eager-loading)\n"
"    - [Constraining Eager Loads](#constraining-eager-loads)\n"
"    - [Lazy Eager Loading](#lazy-eager-loading)\n"
"    - [Preventing Lazy Loading](#preventing-lazy-loading)\n"
"- [Inserting & Updating Related Models](#inserting-and-updating-related-models)\n"
"    - [The `save` Method](#the-save-method)\n"
"    - [The `create` Method](#the-create-method)\n"
"    - [Belongs To Relationships](#updating-belongs-to-relationships)\n"
"    - [Many To Many Relationships](#updating-many-to-many-relationships)\n"
"- [Touching Parent Timestamps](#touching-parent-timestamps)\n"
msgstr "- [定義關聯](#defining-relationships)\n"
"    - [一對一](#one-to-one)\n"
"    - [一對多](#one-to-many)\n"
"    - [一對多 (反向) / Belongs To](#one-to-many-inverse)\n"
"    - [一對多中之一](#has-one-of-many)\n"
"    - [間接一對一](#has-one-through)\n"
"    - [間接一對多](#has-many-through)\n"
"- [多對多關聯](#many-to-many)\n"
"    - [存取中間資料表欄位](#retrieving-intermediate-table-columns)\n"
"    - [通過中間資料表欄位來過濾查詢](#filtering-queries-via-intermediate-table-columns)\n"
"    - [定義自訂的中間資料表 Model](#defining-custom-intermediate-table-models)\n"
"- [多型關聯](#polymorphic-relationships)\n"
"    - [一對一](#one-to-one-polymorphic-relations)\n"
"    - [一對多](#one-to-many-polymorphic-relations)\n"
"    - [多中之一](#one-of-many-polymorphic-relations)\n"
"    - [多對多](#many-to-many-polymorphic-relations)\n"
"    - [自訂多型類型](#custom-polymorphic-types)\n"
"- [動態關聯](#dynamic-relationships)\n"
"- [查詢關聯](#querying-relations)\n"
"    - [關聯方法 Vs. 動態屬性](#relationship-methods-vs-dynamic-properties)\n"
"    - [查詢關聯存在](#querying-relationship-existence)\n"
"    - [查詢關聯不存在](#querying-relationship-absence)\n"
"    - [查詢多型關聯](#querying-morph-to-relationships)\n"
"- [匯總關聯的 Model](#aggregating-related-models)\n"
"    - [計算關聯的 Model 數量](#counting-related-models)\n"
"    - [其他匯總函式](#other-aggregate-functions)\n"
"    - [計算關聯 Model 的多型關聯數量](#counting-related-models-on-morph-to-relationships)\n"
"- [積極式載入](#eager-loading)\n"
"    - [帶條件的積極式載入](#constraining-eager-loads)\n"
"    - [消極的積極式載入](#lazy-eager-loading)\n"
"    - [預防消極式載入](#preventing-lazy-loading)\n"
"- [插入與更新關聯的 Model](#inserting-and-updating-related-models)\n"
"    - [`save` 方法](#the-save-method)\n"
"    - [`create` 方法](#the-create-method)\n"
"    - [BelongsTo 關聯](#updating-belongs-to-relationships)\n"
"    - [多對多關聯](#updating-many-to-many-relationships)\n"
"- [更新上層 Model 的時戳](#touching-parent-timestamps)\n"

# File: docs/8.x/eloquent-relationships.md, line: 43
# File: docs/master/eloquent-relationships.md, line: 43
#. type: Plain text
#, no-wrap
msgid "<a name=\"introduction\"></a>\n"
msgstr "<a name=\"introduction\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 43
# File: docs/master/eloquent-relationships.md, line: 43
#. type: Title ##
#, no-wrap
msgid "Introduction"
msgstr "簡介"

# File: docs/8.x/eloquent-relationships.md, line: 46
# File: docs/master/eloquent-relationships.md, line: 46
#. type: Plain text
msgid "Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports a variety of common relationships:"
msgstr "資料庫中的資料表通常會互相彼此關聯。舉例來說，部落格文章可能會有許多的留言，而訂單則可能會關聯到建立訂單的使用者。在 Eloquent 中，要管理並處理這些關聯非常簡單，並支援多種常見的關聯："

# File: docs/8.x/eloquent-relationships.md, line: 48
# File: docs/master/eloquent-relationships.md, line: 48
#. type: Plain text
#, no-wrap
msgid "<div class=\"content-list\" markdown=\"1\">\n"
msgstr ""

# File: docs/8.x/eloquent-relationships.md, line: 57
# File: docs/master/eloquent-relationships.md, line: 57
#. type: Plain text
msgid "- [One To One](#one-to-one)  - [One To Many](#one-to-many)  - [Many To Many](#many-to-many)  - [Has One Through](#has-one-through)  - [Has Many Through](#has-many-through)  - [One To One (Polymorphic)](#one-to-one-polymorphic-relations)  - [One To Many (Polymorphic)](#one-to-many-polymorphic-relations)  - [Many To Many (Polymorphic)](#many-to-many-polymorphic-relations)"
msgstr ""

# File: docs/8.x/eloquent-relationships.md, line: 59
# File: docs/master/eloquent-relationships.md, line: 59
#. type: Plain text
#, no-wrap
msgid "</div>\n"
msgstr ""

# File: docs/8.x/eloquent-relationships.md, line: 61
# File: docs/master/eloquent-relationships.md, line: 61
#. type: Plain text
#, no-wrap
msgid "<a name=\"defining-relationships\"></a>\n"
msgstr "<a name=\"defining-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 61
# File: docs/master/eloquent-relationships.md, line: 61
#. type: Title ##
#, no-wrap
msgid "Defining Relationships"
msgstr "定義關聯"

# File: docs/8.x/eloquent-relationships.md, line: 64
# File: docs/master/eloquent-relationships.md, line: 64
#. type: Plain text
msgid "Eloquent relationships are defined as methods on your Eloquent model classes. Since relationships also serve as powerful [query builders](/docs/{{version}}/queries), defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional query constraints on this `posts` relationship:"
msgstr "Eloquent 關聯是作為方法定義在 Eloquent Model 類別中。由於關聯也可當作強大的 [Query Builder](/docs/{{version}}/queries) 使用，因此將關聯定義為方法也能讓方法得以串連使用並進行查詢。舉例來說，我們可以在這個 `posts` 關聯中串上額外的查詢條件："

# File: docs/8.x/eloquent-relationships.md, line: 66
# File: docs/8.x/eloquent-relationships.md, line: 1132
# File: docs/master/eloquent-relationships.md, line: 66
# File: docs/master/eloquent-relationships.md, line: 1132
#. type: Plain text
#, no-wrap
msgid "    $user->posts()->where('active', 1)->get();\n"
msgstr "    $user->posts()->where('active', 1)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 68
# File: docs/master/eloquent-relationships.md, line: 68
#. type: Plain text
msgid "But, before diving too deep into using relationships, let's learn how to define each type of relationship supported by Eloquent."
msgstr "不過，在更深入瞭解如何使用關聯以前，我們先來了解一下如何定義 Eloquent 所支援的各種關聯型別吧！"

# File: docs/8.x/eloquent-relationships.md, line: 70
# File: docs/master/eloquent-relationships.md, line: 70
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one\"></a>\n"
msgstr "<a name=\"one-to-one\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 70
# File: docs/master/eloquent-relationships.md, line: 70
#. type: Title ###
#, no-wrap
msgid "One To One"
msgstr "一對一"

# File: docs/8.x/eloquent-relationships.md, line: 73
# File: docs/master/eloquent-relationships.md, line: 73
#. type: Plain text
msgid "A one-to-one relationship is a very basic type of database relationship. For example, a `User` model might be associated with one `Phone` model. To define this relationship, we will place a `phone` method on the `User` model. The `phone` method should call the `hasOne` method and return its result. The `hasOne` method is available to your model via the model's `Illuminate\\Database\\Eloquent\\Model` base class:"
msgstr "一對一關聯是一種非常基本的資料庫關聯。舉例來說，一個 `User` Model 可能與一個 `Phone` Model 有關。要定義這個關聯，我們先在 `User` Model 中定義一個 `phone` 方法。`phone` 方法應呼叫 `hasOne` 方法並回傳其結果。`hasOne` 方法是通過 Model 的 `Illuminate\\Database\\Eloquent\\Model` 基礎類別提供的："

# File: docs/8.x/eloquent-relationships.md, line: 75
# File: docs/8.x/eloquent-relationships.md, line: 109
# File: docs/8.x/eloquent-relationships.md, line: 153
# File: docs/8.x/eloquent-relationships.md, line: 199
# File: docs/8.x/eloquent-relationships.md, line: 388
# File: docs/8.x/eloquent-relationships.md, line: 451
# File: docs/8.x/eloquent-relationships.md, line: 521
# File: docs/8.x/eloquent-relationships.md, line: 565
# File: docs/8.x/eloquent-relationships.md, line: 665
# File: docs/8.x/eloquent-relationships.md, line: 684
# File: docs/8.x/eloquent-relationships.md, line: 743
# File: docs/8.x/eloquent-relationships.md, line: 845
# File: docs/8.x/eloquent-relationships.md, line: 984
# File: docs/8.x/eloquent-relationships.md, line: 1008
# File: docs/8.x/eloquent-relationships.md, line: 1109
# File: docs/8.x/eloquent-relationships.md, line: 1451
# File: docs/8.x/eloquent-relationships.md, line: 1515
# File: docs/8.x/eloquent-relationships.md, line: 1559
# File: docs/8.x/eloquent-relationships.md, line: 1669
# File: docs/8.x/eloquent-relationships.md, line: 1904
# File: docs/master/eloquent-relationships.md, line: 75
# File: docs/master/eloquent-relationships.md, line: 109
# File: docs/master/eloquent-relationships.md, line: 153
# File: docs/master/eloquent-relationships.md, line: 199
# File: docs/master/eloquent-relationships.md, line: 388
# File: docs/master/eloquent-relationships.md, line: 451
# File: docs/master/eloquent-relationships.md, line: 521
# File: docs/master/eloquent-relationships.md, line: 565
# File: docs/master/eloquent-relationships.md, line: 665
# File: docs/master/eloquent-relationships.md, line: 684
# File: docs/master/eloquent-relationships.md, line: 743
# File: docs/master/eloquent-relationships.md, line: 845
# File: docs/master/eloquent-relationships.md, line: 984
# File: docs/master/eloquent-relationships.md, line: 1008
# File: docs/master/eloquent-relationships.md, line: 1109
# File: docs/master/eloquent-relationships.md, line: 1451
# File: docs/master/eloquent-relationships.md, line: 1515
# File: docs/master/eloquent-relationships.md, line: 1559
# File: docs/master/eloquent-relationships.md, line: 1669
# File: docs/master/eloquent-relationships.md, line: 1904
#. type: Plain text
#, no-wrap
msgid "    <?php\n"
msgstr "    <?php\n"

# File: docs/8.x/eloquent-relationships.md, line: 77
# File: docs/8.x/eloquent-relationships.md, line: 111
# File: docs/8.x/eloquent-relationships.md, line: 155
# File: docs/8.x/eloquent-relationships.md, line: 201
# File: docs/8.x/eloquent-relationships.md, line: 390
# File: docs/8.x/eloquent-relationships.md, line: 453
# File: docs/8.x/eloquent-relationships.md, line: 523
# File: docs/8.x/eloquent-relationships.md, line: 567
# File: docs/8.x/eloquent-relationships.md, line: 667
# File: docs/8.x/eloquent-relationships.md, line: 686
# File: docs/8.x/eloquent-relationships.md, line: 745
# File: docs/8.x/eloquent-relationships.md, line: 847
# File: docs/8.x/eloquent-relationships.md, line: 986
# File: docs/8.x/eloquent-relationships.md, line: 1010
# File: docs/8.x/eloquent-relationships.md, line: 1111
# File: docs/8.x/eloquent-relationships.md, line: 1453
# File: docs/8.x/eloquent-relationships.md, line: 1561
# File: docs/8.x/eloquent-relationships.md, line: 1906
# File: docs/master/eloquent-relationships.md, line: 77
# File: docs/master/eloquent-relationships.md, line: 111
# File: docs/master/eloquent-relationships.md, line: 155
# File: docs/master/eloquent-relationships.md, line: 201
# File: docs/master/eloquent-relationships.md, line: 390
# File: docs/master/eloquent-relationships.md, line: 453
# File: docs/master/eloquent-relationships.md, line: 523
# File: docs/master/eloquent-relationships.md, line: 567
# File: docs/master/eloquent-relationships.md, line: 667
# File: docs/master/eloquent-relationships.md, line: 686
# File: docs/master/eloquent-relationships.md, line: 745
# File: docs/master/eloquent-relationships.md, line: 847
# File: docs/master/eloquent-relationships.md, line: 986
# File: docs/master/eloquent-relationships.md, line: 1010
# File: docs/master/eloquent-relationships.md, line: 1111
# File: docs/master/eloquent-relationships.md, line: 1453
# File: docs/master/eloquent-relationships.md, line: 1561
# File: docs/master/eloquent-relationships.md, line: 1906
#. type: Plain text
#, no-wrap
msgid "    namespace App\\Models;\n"
msgstr "    namespace App\\Models;\n"

# File: docs/8.x/eloquent-relationships.md, line: 79
# File: docs/8.x/eloquent-relationships.md, line: 113
# File: docs/8.x/eloquent-relationships.md, line: 157
# File: docs/8.x/eloquent-relationships.md, line: 203
# File: docs/8.x/eloquent-relationships.md, line: 392
# File: docs/8.x/eloquent-relationships.md, line: 455
# File: docs/8.x/eloquent-relationships.md, line: 525
# File: docs/8.x/eloquent-relationships.md, line: 569
# File: docs/8.x/eloquent-relationships.md, line: 669
# File: docs/8.x/eloquent-relationships.md, line: 747
# File: docs/8.x/eloquent-relationships.md, line: 849
# File: docs/8.x/eloquent-relationships.md, line: 988
# File: docs/8.x/eloquent-relationships.md, line: 1012
# File: docs/8.x/eloquent-relationships.md, line: 1113
# File: docs/8.x/eloquent-relationships.md, line: 1455
# File: docs/8.x/eloquent-relationships.md, line: 1517
# File: docs/8.x/eloquent-relationships.md, line: 1563
# File: docs/8.x/eloquent-relationships.md, line: 1671
# File: docs/8.x/eloquent-relationships.md, line: 1908
# File: docs/master/eloquent-relationships.md, line: 79
# File: docs/master/eloquent-relationships.md, line: 113
# File: docs/master/eloquent-relationships.md, line: 157
# File: docs/master/eloquent-relationships.md, line: 203
# File: docs/master/eloquent-relationships.md, line: 392
# File: docs/master/eloquent-relationships.md, line: 455
# File: docs/master/eloquent-relationships.md, line: 525
# File: docs/master/eloquent-relationships.md, line: 569
# File: docs/master/eloquent-relationships.md, line: 669
# File: docs/master/eloquent-relationships.md, line: 747
# File: docs/master/eloquent-relationships.md, line: 849
# File: docs/master/eloquent-relationships.md, line: 988
# File: docs/master/eloquent-relationships.md, line: 1012
# File: docs/master/eloquent-relationships.md, line: 1113
# File: docs/master/eloquent-relationships.md, line: 1455
# File: docs/master/eloquent-relationships.md, line: 1517
# File: docs/master/eloquent-relationships.md, line: 1563
# File: docs/master/eloquent-relationships.md, line: 1671
# File: docs/master/eloquent-relationships.md, line: 1908
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Model;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Model;\n"

# File: docs/8.x/eloquent-relationships.md, line: 90
# File: docs/master/eloquent-relationships.md, line: 90
#. type: Plain text
#, no-wrap
msgid "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the phone associated with the user.\n"
"         */\n"
"        public function phone()\n"
"        {\n"
"            return $this->hasOne(Phone::class);\n"
"        }\n"
"    }\n"
msgstr "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the phone associated with the user.\n"
"         */\n"
"        public function phone()\n"
"        {\n"
"            return $this->hasOne(Phone::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 92
# File: docs/master/eloquent-relationships.md, line: 92
#. type: Plain text
msgid "The first argument passed to the `hasOne` method is the name of the related model class. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model:"
msgstr "傳給 `hasOne` 方法的第一個引述是關聯 Model 類別的名稱。定義好關聯後，我們就可以通過 Eloquent 的動態屬性來存取這個關聯的紀錄。動態屬性能讓我們像在存取定義在 Model 上的屬性一樣來存取關聯方法："

# File: docs/8.x/eloquent-relationships.md, line: 94
# File: docs/master/eloquent-relationships.md, line: 94
#. type: Plain text
#, no-wrap
msgid "    $phone = User::find(1)->phone;\n"
msgstr "    $phone = User::find(1)->phone;\n"

# File: docs/8.x/eloquent-relationships.md, line: 96
# File: docs/master/eloquent-relationships.md, line: 96
#. type: Plain text
msgid "Eloquent determines the foreign key of the relationship based on the parent model name. In this case, the `Phone` model is automatically assumed to have a `user_id` foreign key. If you wish to override this convention, you may pass a second argument to the `hasOne` method:"
msgstr "Eloquent 會通過上層 Model 的名稱來判斷關聯的外部索引鍵 (Foreign Key)。在這個例子中，Eloquent 會自動假設 `Phone` Model 中有個 `user_id` 外部索引鍵。若要複寫這個慣例用法的話，可以傳入第二個引數給 `hasOne` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 98
# File: docs/master/eloquent-relationships.md, line: 98
#. type: Plain text
#, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key');\n"
msgstr "    return $this->hasOne(Phone::class, 'foreign_key');\n"

# File: docs/8.x/eloquent-relationships.md, line: 100
# File: docs/master/eloquent-relationships.md, line: 100
#. type: Plain text
msgid "Additionally, Eloquent assumes that the foreign key should have a value matching the primary key column of the parent. In other words, Eloquent will look for the value of the user's `id` column in the `user_id` column of the `Phone` record. If you would like the relationship to use a primary key value other than `id` or your model's `$primaryKey` property, you may pass a third argument to the `hasOne` method:"
msgstr "此外，Eloquent 還會假設這個外部索引鍵應該要有個與上層資料的主索引鍵欄位相同的值。換句話說，Eloquent 會在 `Phone` 紀錄的 `user_id` 欄位中找到與該使用者 `id` 欄位值相同的資料。若想在關聯中使用 `id` 或 Model 的 `$primaryKey` 屬性意外的其他主索引鍵值的話，可傳入第三個引數給 `hasOne` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 102
# File: docs/master/eloquent-relationships.md, line: 102
#. type: Plain text
#, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"
msgstr "    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"

# File: docs/8.x/eloquent-relationships.md, line: 104
# File: docs/master/eloquent-relationships.md, line: 104
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr "<a name=\"one-to-one-defining-the-inverse-of-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 104
# File: docs/8.x/eloquent-relationships.md, line: 560
# File: docs/8.x/eloquent-relationships.md, line: 1001
# File: docs/master/eloquent-relationships.md, line: 104
# File: docs/master/eloquent-relationships.md, line: 560
# File: docs/master/eloquent-relationships.md, line: 1001
#. type: Title ####
#, no-wrap
msgid "Defining The Inverse Of The Relationship"
msgstr "定義反向的關聯"

# File: docs/8.x/eloquent-relationships.md, line: 107
# File: docs/master/eloquent-relationships.md, line: 107
#. type: Plain text
msgid "So, we can access the `Phone` model from our `User` model. Next, let's define a relationship on the `Phone` model that will let us access the user that owns the phone. We can define the inverse of a `hasOne` relationship using the `belongsTo` method:"
msgstr "好了，我們現在可以在 `User` Model 中存取 `Phone` Model 了。接著，我們來在 `Phone` Model 上定義關聯，好讓我們能在存取擁有這隻電話的使用者。我們可以使用 `belongsTo` 方法來定義反向的 `hasOne` 關聯："

# File: docs/8.x/eloquent-relationships.md, line: 124
# File: docs/master/eloquent-relationships.md, line: 124
#. type: Plain text
#, no-wrap
msgid "    class Phone extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user that owns the phone.\n"
"         */\n"
"        public function user()\n"
"        {\n"
"            return $this->belongsTo(User::class);\n"
"        }\n"
"    }\n"
msgstr "    class Phone extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user that owns the phone.\n"
"         */\n"
"        public function user()\n"
"        {\n"
"            return $this->belongsTo(User::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 126
# File: docs/master/eloquent-relationships.md, line: 126
#. type: Plain text
msgid "When invoking the `user` method, Eloquent will attempt to find a `User` model that has an `id` which matches the `user_id` column on the `Phone` model."
msgstr "當叫用 `user` 方法時，Eloquent 會嘗試尋找一筆 `id` 符合 `Phone` Model 中 `user_id` 欄位的 `User` Model。"

# File: docs/8.x/eloquent-relationships.md, line: 128
# File: docs/master/eloquent-relationships.md, line: 128
#. type: Plain text
msgid "Eloquent determines the foreign key name by examining the name of the relationship method and suffixing the method name with `_id`. So, in this case, Eloquent assumes that the `Phone` model has a `user_id` column. However, if the foreign key on the `Phone` model is not `user_id`, you may pass a custom key name as the second argument to the `belongsTo` method:"
msgstr "Eloquent 會檢查關聯方法的名稱，並在這個方法的名稱後加上 `_id` 來自動判斷外部索引鍵名稱。因此，在這個例子中，Eloquent 會假設 `Phone` Model 有個 `user_id` 欄位。不過，若 `Phone` Model 的外部索引鍵不是 `user_id`，則可以傳遞一個自訂索引鍵名稱給 `belongsTo`，作為第二個引數："

# File: docs/8.x/eloquent-relationships.md, line: 136
# File: docs/master/eloquent-relationships.md, line: 136
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key');\n"
"    }\n"
msgstr "    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 138
# File: docs/master/eloquent-relationships.md, line: 138
#. type: Plain text
msgid "If the parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying the parent table's custom key:"
msgstr "若上層 Model 不使用 `id` 作為其主索引鍵，或是想要使用不同的欄位來尋找關聯的 Model，則可以傳遞第三個引數給 `belongsTo` 方法來指定上層資料表的自訂索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 146
# File: docs/master/eloquent-relationships.md, line: 146
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr "    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 148
# File: docs/master/eloquent-relationships.md, line: 148
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many\"></a>\n"
msgstr "<a name=\"one-to-many\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 148
# File: docs/master/eloquent-relationships.md, line: 148
#. type: Title ###
#, no-wrap
msgid "One To Many"
msgstr "一對多"

# File: docs/8.x/eloquent-relationships.md, line: 151
# File: docs/master/eloquent-relationships.md, line: 151
#. type: Plain text
msgid "A one-to-many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by defining a method on your Eloquent model:"
msgstr "一對多關聯可用來定義某個有一個或多個子 Model 的單一 Model。舉例來說，部落格文章可能有無限數量筆留言。與其他 Eloquent 關聯一樣，一對多關聯可通過在 Eloquent Model 中定義方法來定義："

# File: docs/8.x/eloquent-relationships.md, line: 168
# File: docs/master/eloquent-relationships.md, line: 168
#. type: Plain text
#, no-wrap
msgid "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the comments for the blog post.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->hasMany(Comment::class);\n"
"        }\n"
"    }\n"
msgstr "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the comments for the blog post.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->hasMany(Comment::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 170
# File: docs/master/eloquent-relationships.md, line: 170
#. type: Plain text
msgid "Remember, Eloquent will automatically determine the proper foreign key column for the `Comment` model. By convention, Eloquent will take the \"snake case\" name of the parent model and suffix it with `_id`. So, in this example, Eloquent will assume the foreign key column on the `Comment` model is `post_id`."
msgstr "請記得，Eloquent 會自動為 `Comment` Model 判斷適當的外部索引鍵欄位。依照慣例，Eloquent 會去上層 Model 的「蛇形命名法 (snake_case)」名稱，並在其後加上 `_id`。因此，在這個例子中，Eloquent 會假設 `Comment` Model 上的外部索引鍵欄位為 `post_id`。"

# File: docs/8.x/eloquent-relationships.md, line: 172
# File: docs/master/eloquent-relationships.md, line: 172
#. type: Plain text
msgid "Once the relationship method has been defined, we can access the [collection](/docs/{{version}}/eloquent-collections) of related comments by accessing the `comments` property. Remember, since Eloquent provides \"dynamic relationship properties\", we can access relationship methods as if they were defined as properties on the model:"
msgstr "定義好關聯方法後，我們就可以通過 `comments` 屬性來存取關聯留言的 [Collection](/docs/{{version}}/eloquent-collections)。請記得，由於 Eloquent 提供了「動態關聯屬性」，因此我們可以像我們是在 Model 上定義屬性一樣地存取關聯方法："

# File: docs/8.x/eloquent-relationships.md, line: 174
# File: docs/8.x/eloquent-relationships.md, line: 288
# File: docs/8.x/eloquent-relationships.md, line: 787
# File: docs/8.x/eloquent-relationships.md, line: 889
# File: docs/8.x/eloquent-relationships.md, line: 1038
# File: docs/8.x/eloquent-relationships.md, line: 1193
# File: docs/8.x/eloquent-relationships.md, line: 1229
# File: docs/8.x/eloquent-relationships.md, line: 1244
# File: docs/8.x/eloquent-relationships.md, line: 1325
# File: docs/8.x/eloquent-relationships.md, line: 1387
# File: docs/8.x/eloquent-relationships.md, line: 1783
# File: docs/master/eloquent-relationships.md, line: 174
# File: docs/master/eloquent-relationships.md, line: 288
# File: docs/master/eloquent-relationships.md, line: 787
# File: docs/master/eloquent-relationships.md, line: 889
# File: docs/master/eloquent-relationships.md, line: 1038
# File: docs/master/eloquent-relationships.md, line: 1193
# File: docs/master/eloquent-relationships.md, line: 1229
# File: docs/master/eloquent-relationships.md, line: 1244
# File: docs/master/eloquent-relationships.md, line: 1325
# File: docs/master/eloquent-relationships.md, line: 1387
# File: docs/master/eloquent-relationships.md, line: 1783
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Post;\n"
msgstr "    use App\\Models\\Post;\n"

# File: docs/8.x/eloquent-relationships.md, line: 176
# File: docs/master/eloquent-relationships.md, line: 176
#. type: Plain text
#, no-wrap
msgid "    $comments = Post::find(1)->comments;\n"
msgstr "    $comments = Post::find(1)->comments;\n"

# File: docs/8.x/eloquent-relationships.md, line: 180
# File: docs/master/eloquent-relationships.md, line: 180
#. type: Plain text
#, no-wrap
msgid "    foreach ($comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($comments as $comment) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 182
# File: docs/master/eloquent-relationships.md, line: 182
#. type: Plain text
msgid "Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `comments` method and continuing to chain conditions onto the query:"
msgstr "由於所有的關聯也同時是 Query Builder，因此我們也能通過呼叫 `comments` 方法並繼續在查詢上串上條件來進一步給關聯加上查詢條件："

# File: docs/8.x/eloquent-relationships.md, line: 186
# File: docs/master/eloquent-relationships.md, line: 186
#. type: Plain text
#, no-wrap
msgid "    $comment = Post::find(1)->comments()\n"
"                        ->where('title', 'foo')\n"
"                        ->first();\n"
msgstr "    $comment = Post::find(1)->comments()\n"
"                        ->where('title', 'foo')\n"
"                        ->first();\n"

# File: docs/8.x/eloquent-relationships.md, line: 188
# File: docs/master/eloquent-relationships.md, line: 188
#. type: Plain text
msgid "Like the `hasOne` method, you may also override the foreign and local keys by passing additional arguments to the `hasMany` method:"
msgstr "就像 `hasOne` 方法，我們也可以通過傳遞額外的參數給 `hasMany` 來複寫外部與內部的索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 190
# File: docs/master/eloquent-relationships.md, line: 190
#. type: Plain text
#, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key');\n"
msgstr "    return $this->hasMany(Comment::class, 'foreign_key');\n"

# File: docs/8.x/eloquent-relationships.md, line: 192
# File: docs/master/eloquent-relationships.md, line: 192
#. type: Plain text
#, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"
msgstr "    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"

# File: docs/8.x/eloquent-relationships.md, line: 194
# File: docs/master/eloquent-relationships.md, line: 194
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many-inverse\"></a>\n"
msgstr "<a name=\"one-to-many-inverse\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 194
# File: docs/master/eloquent-relationships.md, line: 194
#. type: Title ###
#, no-wrap
msgid "One To Many (Inverse) / Belongs To"
msgstr "一對多 (反向) / 隸屬於 (Belongs To)"

# File: docs/8.x/eloquent-relationships.md, line: 197
# File: docs/master/eloquent-relationships.md, line: 197
#. type: Plain text
msgid "Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a `hasMany` relationship, define a relationship method on the child model which calls the `belongsTo` method:"
msgstr "現在，我們已經可以存取一篇文章的所有留言了。讓我們來定義一個關聯，以從留言去的其上層的文章。要定義 `hasMany` 關聯的相反，我們可以在子 Model 中定義一個呼叫了 `belongsTo` 方法的關聯方法："

# File: docs/8.x/eloquent-relationships.md, line: 214
# File: docs/master/eloquent-relationships.md, line: 214
#. type: Plain text
#, no-wrap
msgid "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post that owns the comment.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post that owns the comment.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 216
# File: docs/master/eloquent-relationships.md, line: 216
#. type: Plain text
msgid "Once the relationship has been defined, we can retrieve a comment's parent post by accessing the `post` \"dynamic relationship property\":"
msgstr "定義好關聯後，我們就可以通過存取 `post`「動態關聯屬性」來取得留言的上層文章："

# File: docs/8.x/eloquent-relationships.md, line: 218
# File: docs/8.x/eloquent-relationships.md, line: 899
# File: docs/master/eloquent-relationships.md, line: 218
# File: docs/master/eloquent-relationships.md, line: 899
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Comment;\n"
msgstr "    use App\\Models\\Comment;\n"

# File: docs/8.x/eloquent-relationships.md, line: 220
# File: docs/8.x/eloquent-relationships.md, line: 901
# File: docs/master/eloquent-relationships.md, line: 220
# File: docs/master/eloquent-relationships.md, line: 901
#. type: Plain text
#, no-wrap
msgid "    $comment = Comment::find(1);\n"
msgstr "    $comment = Comment::find(1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 222
# File: docs/master/eloquent-relationships.md, line: 222
#. type: Plain text
#, no-wrap
msgid "    return $comment->post->title;\n"
msgstr "    return $comment->post->title;\n"

# File: docs/8.x/eloquent-relationships.md, line: 224
# File: docs/master/eloquent-relationships.md, line: 224
#. type: Plain text
msgid "In the example above, Eloquent will attempt to find a `Post` model that has an `id` which matches the `post_id` column on the `Comment` model."
msgstr "在上述例子中，Eloquent 會嘗試找到 `id` 符合 `Comments` Model 中 `post_id` 欄位的 `Post` Model。"

# File: docs/8.x/eloquent-relationships.md, line: 226
# File: docs/master/eloquent-relationships.md, line: 226
#. type: Plain text
msgid "Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with a `_` followed by the name of the parent model's primary key column. So, in this example, Eloquent will assume the `Post` model's foreign key on the `comments` table is `post_id`."
msgstr "Eloquent 會檢查關聯方法的名稱，並在該名稱後加上 `_`，然後再加上上層 Model 的主索引鍵欄位名稱作為預設的外部索引鍵名稱。因此，在這個例子中，Eloquent 會假設 `Post` Model 在 `comments` 資料表中的外部索引鍵為 `post_id`。"

# File: docs/8.x/eloquent-relationships.md, line: 228
# File: docs/master/eloquent-relationships.md, line: 228
#. type: Plain text
msgid "However, if the foreign key for your relationship does not follow these conventions, you may pass a custom foreign key name as the second argument to the `belongsTo` method:"
msgstr "不過，若沒有依照這種慣例來命名關聯的外部索引鍵，則可以將自訂的外部索引鍵傳遞給 `belongsTo` 方法作為第二個引數："

# File: docs/8.x/eloquent-relationships.md, line: 236
# File: docs/master/eloquent-relationships.md, line: 236
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key');\n"
"    }\n"
msgstr "    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 238
# File: docs/master/eloquent-relationships.md, line: 238
#. type: Plain text
msgid "If your parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying your parent table's custom key:"
msgstr "若上層 Model 不使用 `id` 作為其主索引鍵，或是想要使用不同的欄位來尋找關聯的 Model，則可以傳遞第三個引數給 `belongsTo` 方法來指定上層資料表的自訂索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 246
# File: docs/master/eloquent-relationships.md, line: 246
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr "    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 248
# File: docs/master/eloquent-relationships.md, line: 248
#. type: Plain text
#, no-wrap
msgid "<a name=\"default-models\"></a>\n"
msgstr "<a name=\"default-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 248
# File: docs/master/eloquent-relationships.md, line: 248
#. type: Title ####
#, no-wrap
msgid "Default Models"
msgstr "預設 Model"

# File: docs/8.x/eloquent-relationships.md, line: 251
# File: docs/master/eloquent-relationships.md, line: 251
#. type: Plain text
msgid "The `belongsTo`, `hasOne`, `hasOneThrough`, and `morphOne` relationships allow you to define a default model that will be returned if the given relationship is `null`. This pattern is often referred to as the [Null Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern) and can help remove conditional checks in your code. In the following example, the `user` relation will return an empty `App\\Models\\User` model if no user is attached to the `Post` model:"
msgstr "`belongsTo`, `hasOne`, `hasOneThrough`, 以及 `morphOne` 關聯可定義一個預設 Model，當給定的關聯為 `null` 時會回傳該預設 Model。這種模式通常稱為 [Null Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern)，並能讓你在程式碼中減少條件檢查的次數。在下列範例中，`user` 關聯會在沒有使用者附加在 `Post` Model 時回傳一個空的 `App\\Models\\User` Model："

# File: docs/8.x/eloquent-relationships.md, line: 259
# File: docs/master/eloquent-relationships.md, line: 259
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault();\n"
"    }\n"
msgstr "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault();\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 261
# File: docs/master/eloquent-relationships.md, line: 261
#. type: Plain text
msgid "To populate the default model with attributes, you may pass an array or closure to the `withDefault` method:"
msgstr "若要為預設的 Model 設定屬性，則可以傳入陣列或閉包給 `withDefault` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 271
# File: docs/master/eloquent-relationships.md, line: 271
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault([\n"
"            'name' => 'Guest Author',\n"
"        ]);\n"
"    }\n"
msgstr "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault([\n"
"            'name' => 'Guest Author',\n"
"        ]);\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 281
# File: docs/master/eloquent-relationships.md, line: 281
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault(function ($user, $post) {\n"
"            $user->name = 'Guest Author';\n"
"        });\n"
"    }\n"
msgstr "    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault(function ($user, $post) {\n"
"            $user->name = 'Guest Author';\n"
"        });\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 283
# File: docs/master/eloquent-relationships.md, line: 283
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-belongs-to-relationships\"></a>\n"
msgstr "<a name=\"querying-belongs-to-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 283
# File: docs/master/eloquent-relationships.md, line: 283
#. type: Title ####
#, no-wrap
msgid "Querying Belongs To Relationships"
msgstr "查詢 Belongs To 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 286
# File: docs/master/eloquent-relationships.md, line: 286
#. type: Plain text
msgid "When querying for the children of a \"belongs to\" relationship, you may manually build the `where` clause to retrieve the corresponding Eloquent models:"
msgstr "在查詢「Belongs To」關聯的子項目時，可以手動建立用於取得相應 Eloquent Model 的 `where` 子句："

# File: docs/8.x/eloquent-relationships.md, line: 290
# File: docs/master/eloquent-relationships.md, line: 290
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::where('user_id', $user->id)->get();\n"
msgstr "    $posts = Post::where('user_id', $user->id)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 292
# File: docs/master/eloquent-relationships.md, line: 292
#. type: Plain text
msgid "However, you may find it more convenient to use the `whereBelongsTo` method, which will automatically determine the proper relationship and foreign key for the given model:"
msgstr "不過，使用 `whereBelongsTo` 方法可能會比較方便。該方法會為給定的 Model 自動判斷適當的關聯與外部索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 294
# File: docs/master/eloquent-relationships.md, line: 294
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereBelongsTo($user)->get();\n"
msgstr "    $posts = Post::whereBelongsTo($user)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 296
# File: docs/master/eloquent-relationships.md, line: 296
#. type: Plain text
msgid "By default, Laravel will determine the relationship associated with the given model based on the class name of the model; however, you may specify the relationship name manually by providing it as the second argument to the `whereBelongsTo` method:"
msgstr "預設情況下，Larave 會依據 Model 的類別名稱來判斷與給定 Model 有關的關聯。不過，我們也可以通過傳入第二個引數給 `whereBelongsTo` 方法來手動指定關聯的名稱："

# File: docs/8.x/eloquent-relationships.md, line: 298
# File: docs/master/eloquent-relationships.md, line: 298
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereBelongsTo($user, 'author')->get();\n"
msgstr "    $posts = Post::whereBelongsTo($user, 'author')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 300
# File: docs/master/eloquent-relationships.md, line: 300
#. type: Plain text
#, no-wrap
msgid "<a name=\"has-one-of-many\"></a>\n"
msgstr "<a name=\"has-one-of-many\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 300
# File: docs/master/eloquent-relationships.md, line: 300
#. type: Title ###
#, no-wrap
msgid "Has One Of Many"
msgstr "一對多中之一"

# File: docs/8.x/eloquent-relationships.md, line: 303
# File: docs/master/eloquent-relationships.md, line: 303
#. type: Plain text
msgid "Sometimes a model may have many related models, yet you want to easily retrieve the \"latest\" or \"oldest\" related model of the relationship. For example, a `User` model may be related to many `Order` models, but you want to define a convenient way to interact with the most recent order the user has placed. You may accomplish this using the `hasOne` relationship type combined with the `ofMany` methods:"
msgstr "有時候，某個 Model 可能有多個關聯 Model，而我們可能會想取多個關聯 Model 中「最新」或「最舊」的關聯 Model。舉例來說，`User` Model (使用者) 可能會關聯到多個 `Order` Model (訂單)，而我們可能會想定義一種方便的方法來存取使用者最新的訂單。我們可以通過將 `hasOne` 關聯類型與 `ofMany` 方法搭配使用來達成："

# File: docs/8.x/eloquent-relationships.md, line: 304
# File: docs/8.x/eloquent-relationships.md, line: 316
# File: docs/8.x/eloquent-relationships.md, line: 330
# File: docs/8.x/eloquent-relationships.md, line: 349
# File: docs/8.x/eloquent-relationships.md, line: 911
# File: docs/8.x/eloquent-relationships.md, line: 923
# File: docs/8.x/eloquent-relationships.md, line: 937
# File: docs/8.x/eloquent-relationships.md, line: 1702
# File: docs/8.x/eloquent-relationships.md, line: 1720
# File: docs/master/eloquent-relationships.md, line: 304
# File: docs/master/eloquent-relationships.md, line: 316
# File: docs/master/eloquent-relationships.md, line: 330
# File: docs/master/eloquent-relationships.md, line: 349
# File: docs/master/eloquent-relationships.md, line: 911
# File: docs/master/eloquent-relationships.md, line: 923
# File: docs/master/eloquent-relationships.md, line: 937
# File: docs/master/eloquent-relationships.md, line: 1702
# File: docs/master/eloquent-relationships.md, line: 1720
#. type: Code fence info string
#, no-wrap
msgid "php"
msgstr "php"

# File: docs/8.x/eloquent-relationships.md, line: 304
# File: docs/master/eloquent-relationships.md, line: 304
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's most recent order.\n"
" */\n"
"public function latestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->latestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's most recent order.\n"
" */\n"
"public function latestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->latestOfMany();\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 315
# File: docs/8.x/eloquent-relationships.md, line: 922
# File: docs/master/eloquent-relationships.md, line: 315
# File: docs/master/eloquent-relationships.md, line: 922
#. type: Plain text
msgid "Likewise, you may define a method to retrieve the \"oldest\", or first, related model of a relationship:"
msgstr "同樣的，我們也可以定義一個方法來取得一個關聯中「最舊」或第一個關聯的 Model："

# File: docs/8.x/eloquent-relationships.md, line: 316
# File: docs/master/eloquent-relationships.md, line: 316
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's oldest order.\n"
" */\n"
"public function oldestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->oldestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's oldest order.\n"
" */\n"
"public function oldestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->oldestOfMany();\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 327
# File: docs/8.x/eloquent-relationships.md, line: 934
# File: docs/master/eloquent-relationships.md, line: 327
# File: docs/master/eloquent-relationships.md, line: 934
#. type: Plain text
msgid "By default, the `latestOfMany` and `oldestOfMany` methods will retrieve the latest or oldest related model based on the model's primary key, which must be sortable. However, sometimes you may wish to retrieve a single model from a larger relationship using a different sorting criteria."
msgstr "預設情況下，`latestOfMany` 與 `oldestOfMany` 方法會依照該 Model 的主索引鍵來取得最新或最舊的 Model，而該索引鍵必須要是可以排序的。不過，有時候我們可能會想從一個更大的關聯中通過另一種方法來取得單一 Model："

# File: docs/8.x/eloquent-relationships.md, line: 329
# File: docs/master/eloquent-relationships.md, line: 329
#. type: Plain text
msgid "For example, using the `ofMany` method, you may retrieve the user's most expensive order. The `ofMany` method accepts the sortable column as its first argument and which aggregate function (`min` or `max`) to apply when querying for the related model:"
msgstr "舉例來說，我們可以使用 `ofMany` 方法來去的使用者下過金額最高的訂單。`ofMany` 方法的第一個引數為可排序的欄位，接著則是要套用哪個匯總函式 (`min` 或 `max` 等) 在關聯的 Model 上："

# File: docs/8.x/eloquent-relationships.md, line: 330
# File: docs/master/eloquent-relationships.md, line: 330
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's largest order.\n"
" */\n"
"public function largestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->ofMany('price', 'max');\n"
"}\n"
msgstr "/**\n"
" * Get the user's largest order.\n"
" */\n"
"public function largestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->ofMany('price', 'max');\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 341
# File: docs/master/eloquent-relationships.md, line: 341
#. type: Plain text
#, no-wrap
msgid "> {note} Because PostgreSQL does not support executing the `MAX` function against UUID columns, it is not currently possible to use one-of-many relationships in combination with PostgreSQL UUID columns.\n"
msgstr "> {note} 由於 PostgreSQL 不支援在 UUID 欄位上執行 `MAX` 函式，因此目前一對多關聯無法搭配 PostgreSQL 的 UUID 欄位使用。\n"

# File: docs/8.x/eloquent-relationships.md, line: 343
# File: docs/master/eloquent-relationships.md, line: 343
#. type: Plain text
#, no-wrap
msgid "<a name=\"advanced-has-one-of-many-relationships\"></a>\n"
msgstr "<a name=\"advanced-has-one-of-many-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 343
# File: docs/master/eloquent-relationships.md, line: 343
#. type: Title ####
#, no-wrap
msgid "Advanced Has One Of Many Relationships"
msgstr "進階的一對多中之一關聯"

# File: docs/8.x/eloquent-relationships.md, line: 346
# File: docs/master/eloquent-relationships.md, line: 346
#. type: Plain text
msgid "It is possible to construct more advanced \"has one of many\" relationships. For example, A `Product` model may have many associated `Price` models that are retained in the system even after new pricing is published. In addition, new pricing data for the product may be able to be published in advance to take effect at a future date via a `published_at` column."
msgstr "我們還可以進一步地做出進階的「一對多中之一」關聯。舉例來說，`Product` Model 可能會有許多相應的 `Price` Model，這些 `Price` Model 會在每次更新商品價格後保留在系統內。此外，我們也可以進一步地通過 `published_at` 欄位來讓某個商品價格在未來的時間點生效。"

# File: docs/8.x/eloquent-relationships.md, line: 348
# File: docs/master/eloquent-relationships.md, line: 348
#. type: Plain text
msgid "So, in summary, we need to retrieve the latest published pricing where the published date is not in the future. In addition, if two prices have the same published date, we will prefer the price with the greatest ID. To accomplish this, we must pass an array to the `ofMany` method that contains the sortable columns which determine the latest price. In addition, a closure will be provided as the second argument to the `ofMany` method. This closure will be responsible for adding additional publish date constraints to the relationship query:"
msgstr "因此，總結一下，我們會需要取得最新且已發布的價格，且發佈時間不可是未來。此外，若有兩個價格的發佈時間相同，則我們取 ID 最大的那個價格。為此，我們必須傳入一個陣列給 `ofMany` 方法，該陣列序包用來判斷最新價格的可排序欄位。此外，我們會提供一個閉包給 `ofMany` 方法作為第二個引述。這個閉包會負責為關聯查詢加上額外的發佈時間條件："

# File: docs/8.x/eloquent-relationships.md, line: 349
# File: docs/master/eloquent-relationships.md, line: 349
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the current pricing for the product.\n"
" */\n"
"public function currentPricing()\n"
"{\n"
"    return $this->hasOne(Price::class)->ofMany([\n"
"        'published_at' => 'max',\n"
"        'id' => 'max',\n"
"    ], function ($query) {\n"
"        $query->where('published_at', '<', now());\n"
"    });\n"
"}\n"
msgstr "/**\n"
" * Get the current pricing for the product.\n"
" */\n"
"public function currentPricing()\n"
"{\n"
"    return $this->hasOne(Price::class)->ofMany([\n"
"        'published_at' => 'max',\n"
"        'id' => 'max',\n"
"    ], function ($query) {\n"
"        $query->where('published_at', '<', now());\n"
"    });\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 365
# File: docs/master/eloquent-relationships.md, line: 365
#. type: Plain text
#, no-wrap
msgid "<a name=\"has-one-through\"></a>\n"
msgstr "<a name=\"has-one-through\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 365
# File: docs/master/eloquent-relationships.md, line: 365
#. type: Title ###
#, no-wrap
msgid "Has One Through"
msgstr "間接一對一"

# File: docs/8.x/eloquent-relationships.md, line: 368
# File: docs/master/eloquent-relationships.md, line: 368
#. type: Plain text
msgid "The \"has-one-through\" relationship defines a one-to-one relationship with another model. However, this relationship indicates that the declaring model can be matched with one instance of another model by proceeding _through_ a third model."
msgstr "「間接一對一 (has-one-through)」關聯定義了與另一個 Model 間的一對一關係。不過，使用這種關聯代表宣告關聯的 Model 可以 **通過** 一個 Model 來對應到另一個 Model 的實體。"

# File: docs/8.x/eloquent-relationships.md, line: 370
# File: docs/master/eloquent-relationships.md, line: 370
#. type: Plain text
msgid "For example, in a vehicle repair shop application, each `Mechanic` model may be associated with one `Car` model, and each `Car` model may be associated with one `Owner` model. While the mechanic and the owner have no direct relationship within the database, the mechanic can access the owner _through_ the `Car` model. Let's look at the tables necessary to define this relationship:"
msgstr "舉例來說，在汽車維修網站中，每個 `Mechanic` Model (零件) 可以跟一個 `Car` Model 關聯。而每個 `Car` Model (汽車) 則可以關聯到一個 `Owner` Model (車主)。雖然零件與車主在資料庫中並沒有直接的關聯性，但我們可以 **通過** `Car` Model 來在零件上存取車主。來看看要定義這種關聯所需的資料表："

# File: docs/8.x/eloquent-relationships.md, line: 374
# File: docs/master/eloquent-relationships.md, line: 374
#. type: Plain text
#, no-wrap
msgid "    mechanics\n"
"        id - integer\n"
"        name - string\n"
msgstr "    mechanics\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 379
# File: docs/master/eloquent-relationships.md, line: 379
#. type: Plain text
#, no-wrap
msgid "    cars\n"
"        id - integer\n"
"        model - string\n"
"        mechanic_id - integer\n"
msgstr "    cars\n"
"        id - integer\n"
"        model - string\n"
"        mechanic_id - integer\n"

# File: docs/8.x/eloquent-relationships.md, line: 384
# File: docs/master/eloquent-relationships.md, line: 384
#. type: Plain text
#, no-wrap
msgid "    owners\n"
"        id - integer\n"
"        name - string\n"
"        car_id - integer\n"
msgstr "    owners\n"
"        id - integer\n"
"        name - string\n"
"        car_id - integer\n"

# File: docs/8.x/eloquent-relationships.md, line: 386
# File: docs/master/eloquent-relationships.md, line: 386
#. type: Plain text
msgid "Now that we have examined the table structure for the relationship, let's define the relationship on the `Mechanic` model:"
msgstr "現在，我們已經瞭解了這種關聯性的資料表結構。讓我們來在 `Mechanic` Model 上定義關聯："

# File: docs/8.x/eloquent-relationships.md, line: 403
# File: docs/master/eloquent-relationships.md, line: 403
#. type: Plain text
#, no-wrap
msgid "    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(Owner::class, Car::class);\n"
"        }\n"
"    }\n"
msgstr "    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(Owner::class, Car::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 405
# File: docs/master/eloquent-relationships.md, line: 405
#. type: Plain text
msgid "The first argument passed to the `hasOneThrough` method is the name of the final model we wish to access, while the second argument is the name of the intermediate model."
msgstr "傳給 `hasOneThrough` 方法的第一個引述是最後我們想存取的 Model 名稱；第二個引數則是中介 Model 的名稱。"

# File: docs/8.x/eloquent-relationships.md, line: 407
# File: docs/master/eloquent-relationships.md, line: 407
#. type: Plain text
#, no-wrap
msgid "<a name=\"has-one-through-key-conventions\"></a>\n"
msgstr "<a name=\"has-one-through-key-conventions\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 407
# File: docs/8.x/eloquent-relationships.md, line: 472
# File: docs/8.x/eloquent-relationships.md, line: 803
# File: docs/master/eloquent-relationships.md, line: 407
# File: docs/master/eloquent-relationships.md, line: 472
# File: docs/master/eloquent-relationships.md, line: 803
#. type: Title ####
#, no-wrap
msgid "Key Conventions"
msgstr "索引鍵慣例"

# File: docs/8.x/eloquent-relationships.md, line: 410
# File: docs/master/eloquent-relationships.md, line: 410
#. type: Plain text
msgid "Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the `hasOneThrough` method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:"
msgstr "在進行關聯查詢時，會使用到典型的 Eloquent 外部索引鍵慣例。若想自訂關聯使用的索引鍵，則可以將自訂索引鍵傳給 `hasOneThrough` 方法的第三個與第四個引數。第三個引數為中介 Model 上的外部索引鍵名稱。第四個引數則是最終 Model 的外部索引鍵名稱。第五個引數則為內部索引鍵，而第六個引述則是中介 Model 上的內部索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 428
# File: docs/master/eloquent-relationships.md, line: 428
#. type: Plain text
#, no-wrap
msgid "    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(\n"
"                Owner::class,\n"
"                Car::class,\n"
"                'mechanic_id', // Foreign key on the cars table...\n"
"                'car_id', // Foreign key on the owners table...\n"
"                'id', // Local key on the mechanics table...\n"
"                'id' // Local key on the cars table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr "    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(\n"
"                Owner::class,\n"
"                Car::class,\n"
"                'mechanic_id', // cars 表上的外部索引鍵...\n"
"                'car_id', //owners 表上的外部索引鍵...\n"
"                'id', // mechanics 表上的內部索引鍵...\n"
"                'id' // cars 表上的內部索引鍵...\n"
"            );\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 430
# File: docs/master/eloquent-relationships.md, line: 430
#. type: Plain text
#, no-wrap
msgid "<a name=\"has-many-through\"></a>\n"
msgstr "<a name=\"has-many-through\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 430
# File: docs/master/eloquent-relationships.md, line: 430
#. type: Title ###
#, no-wrap
msgid "Has Many Through"
msgstr "間接一對多"

# File: docs/8.x/eloquent-relationships.md, line: 433
# File: docs/master/eloquent-relationships.md, line: 433
#. type: Plain text
msgid "The \"has-many-through\" relationship provides a convenient way to access distant relations via an intermediate relation. For example, let's assume we are building a deployment platform like [Laravel Vapor](https://vapor.laravel.com). A `Project` model might access many `Deployment` models through an intermediate `Environment` model. Using this example, you could easily gather all deployments for a given project. Let's look at the tables required to define this relationship:"
msgstr "「間接一對多 (has-many-through)」關聯提供了一個方便的方法來通過中介關聯存取另一個關聯。舉例來說，假設我們有一個像 [Laravel Vapor](https://vapor.laravel.com) 這樣的部署平台。`Project` Model (專案)可通過一個中介的 `Environment` Model (環境) 來存取多個 `Deployment` Model (部署)。依照這個例子，我們可以很輕鬆的取得特定專案的所有部署。來看看定義這個關聯性所需的資料表："

# File: docs/8.x/eloquent-relationships.md, line: 437
# File: docs/master/eloquent-relationships.md, line: 437
#. type: Plain text
#, no-wrap
msgid "    projects\n"
"        id - integer\n"
"        name - string\n"
msgstr "    projects\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 442
# File: docs/master/eloquent-relationships.md, line: 442
#. type: Plain text
#, no-wrap
msgid "    environments\n"
"        id - integer\n"
"        project_id - integer\n"
"        name - string\n"
msgstr "    environments\n"
"        id - integer\n"
"        project_id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 447
# File: docs/master/eloquent-relationships.md, line: 447
#. type: Plain text
#, no-wrap
msgid "    deployments\n"
"        id - integer\n"
"        environment_id - integer\n"
"        commit_hash - string\n"
msgstr "    deployments\n"
"        id - integer\n"
"        environment_id - integer\n"
"        commit_hash - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 449
# File: docs/master/eloquent-relationships.md, line: 449
#. type: Plain text
msgid "Now that we have examined the table structure for the relationship, let's define the relationship on the `Project` model:"
msgstr "現在，我們已經瞭解了這種關聯性的資料表結構。讓我們來在 `Project` Model 上定義關聯："

# File: docs/8.x/eloquent-relationships.md, line: 466
# File: docs/master/eloquent-relationships.md, line: 466
#. type: Plain text
#, no-wrap
msgid "    class Project extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the deployments for the project.\n"
"         */\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(Deployment::class, Environment::class);\n"
"        }\n"
"    }\n"
msgstr "    class Project extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the deployments for the project.\n"
"         */\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(Deployment::class, Environment::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 468
# File: docs/master/eloquent-relationships.md, line: 468
#. type: Plain text
msgid "The first argument passed to the `hasManyThrough` method is the name of the final model we wish to access, while the second argument is the name of the intermediate model."
msgstr "傳給 `hasManyThrough` 方法的第一個引述是最後我們想存取的 Model 名稱；第二個引數則是中介 Model 的名稱。"

# File: docs/8.x/eloquent-relationships.md, line: 470
# File: docs/master/eloquent-relationships.md, line: 470
#. type: Plain text
#, no-wrap
msgid "Though the `Deployment` model's table does not contain a `project_id` column, the `hasManyThrough` relation provides access to a project's deployments via `$project->deployments`. To retrieve these models, Eloquent inspects the `project_id` column on the intermediate `Environment` model's table. After finding the relevant environment IDs, they are used to query the `Deployment` model's table.\n"
msgstr "雖然 `Deployment` Model 的資料表不包含 `project_id` 欄位，但 `hasManyThrough` 關聯可讓我們通過 `$project->deployments` 來存取專案的部署。為了取得這些 Model，Eloquent 會先在中介的 `Environment` Model 資料表上讀取 `project_id`。找到相關的環境 ID 後，再通過這些 ID 來查詢 `Deployment` Model 的資料表。\n"

# File: docs/8.x/eloquent-relationships.md, line: 472
# File: docs/master/eloquent-relationships.md, line: 472
#. type: Plain text
#, no-wrap
msgid "<a name=\"has-many-through-key-conventions\"></a>\n"
msgstr "<a name=\"has-many-through-key-conventions\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 475
# File: docs/master/eloquent-relationships.md, line: 475
#. type: Plain text
msgid "Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the `hasManyThrough` method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:"
msgstr "在進行關聯查詢時，會使用到典型的 Eloquent 外部索引鍵慣例。若想自訂關聯使用的索引鍵，則可以將自訂索引鍵傳給 `hasManyThrough` 方法的第三個與第四個引數。第三個引數為中介 Model 上的外部索引鍵名稱。第四個引數則是最終 Model 的外部索引鍵名稱。第五個引數則為內部索引鍵，而第六個引述則是中介 Model 上的內部索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 490
# File: docs/master/eloquent-relationships.md, line: 490
#. type: Plain text
#, no-wrap
msgid "    class Project extends Model\n"
"    {\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(\n"
"                Deployment::class,\n"
"                Environment::class,\n"
"                'project_id', // Foreign key on the environments table...\n"
"                'environment_id', // Foreign key on the deployments table...\n"
"                'id', // Local key on the projects table...\n"
"                'id' // Local key on the environments table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr "    class Project extends Model\n"
"    {\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(\n"
"                Deployment::class,\n"
"                Environment::class,\n"
"                'project_id', // environments 表上的外部索引鍵...\n"
"                'environment_id', // deployments 表上的外部索引鍵...\n"
"                'id', // projects 表上的內部索引鍵...\n"
"                'id' // environments 表上的內部索引鍵...\n"
"            );\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 492
# File: docs/master/eloquent-relationships.md, line: 492
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many\"></a>\n"
msgstr "<a name=\"many-to-many\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 492
# File: docs/8.x/eloquent-relationships.md, line: 1823
# File: docs/master/eloquent-relationships.md, line: 492
# File: docs/master/eloquent-relationships.md, line: 1823
#. type: Title ###
#, no-wrap
msgid "Many To Many Relationships"
msgstr "Many To Many 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 495
# File: docs/master/eloquent-relationships.md, line: 495
#. type: Plain text
msgid "Many-to-many relations are slightly more complicated than `hasOne` and `hasMany` relationships. An example of a many-to-many relationship is a user that has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of \"Author\" and \"Editor\"; however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users."
msgstr "比起 `hasOne` 或 `hasMany`，多對多關聯稍微複雜一點。一個多對多關聯的例子是：一位使用者可以有多個職位，而這些職位也會被網站中的其他使用者使用。舉例來說，某位使用者可能會被設定職位「作者」與「編輯」，但這些職位也可能會被指派給其他使用者。因此，一位使用者可以有多個職位，而一個職位則可以有多位使用者。"

# File: docs/8.x/eloquent-relationships.md, line: 497
# File: docs/master/eloquent-relationships.md, line: 497
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-table-structure\"></a>\n"
msgstr "<a name=\"many-to-many-table-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 497
# File: docs/8.x/eloquent-relationships.md, line: 717
# File: docs/8.x/eloquent-relationships.md, line: 819
# File: docs/8.x/eloquent-relationships.md, line: 953
# File: docs/master/eloquent-relationships.md, line: 497
# File: docs/master/eloquent-relationships.md, line: 717
# File: docs/master/eloquent-relationships.md, line: 819
# File: docs/master/eloquent-relationships.md, line: 953
#. type: Title ####
#, no-wrap
msgid "Table Structure"
msgstr "資料表結構"

# File: docs/8.x/eloquent-relationships.md, line: 500
# File: docs/master/eloquent-relationships.md, line: 500
#. type: Plain text
msgid "To define this relationship, three database tables are needed: `users`, `roles`, and `role_user`. The `role_user` table is derived from the alphabetical order of the related model names and contains `user_id` and `role_id` columns. This table is used as an intermediate table linking the users and roles."
msgstr "要定義這種關聯，我們需要三張資料表：`users`, `roles`, 與 `role_user`。`role_user` 資料表的名稱是由關聯的 Model 名稱按照字母排序串接而來的，裡面包含了 `user_id` 與 `role_id` 欄位。這張資料表會用來作為關聯使用者與職位的中介資料表。"

# File: docs/8.x/eloquent-relationships.md, line: 502
# File: docs/master/eloquent-relationships.md, line: 502
#. type: Plain text
msgid "Remember, since a role can belong to many users, we cannot simply place a `user_id` column on the `roles` table. This would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple users, the `role_user` table is needed. We can summarize the relationship's table structure like so:"
msgstr "請記得，由於一個職位可以同時關聯到多位使用者，因此我們沒辦法在 `roles` 資料表上設定 `user_id` 欄位。若這麼做的話，一個職位就只能有一位使用者。為了要讓職位能被設定給多位使用者，我們會需要 `role_user` 資料表。我們可以總結一下，資料表的結構會長這樣："

# File: docs/8.x/eloquent-relationships.md, line: 506
# File: docs/8.x/eloquent-relationships.md, line: 728
# File: docs/master/eloquent-relationships.md, line: 506
# File: docs/master/eloquent-relationships.md, line: 728
#. type: Plain text
#, no-wrap
msgid "    users\n"
"        id - integer\n"
"        name - string\n"
msgstr "    users\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 510
# File: docs/master/eloquent-relationships.md, line: 510
#. type: Plain text
#, no-wrap
msgid "    roles\n"
"        id - integer\n"
"        name - string\n"
msgstr "    roles\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 514
# File: docs/master/eloquent-relationships.md, line: 514
#. type: Plain text
#, no-wrap
msgid "    role_user\n"
"        user_id - integer\n"
"        role_id - integer\n"
msgstr "    role_user\n"
"        user_id - integer\n"
"        role_id - integer\n"

# File: docs/8.x/eloquent-relationships.md, line: 516
# File: docs/master/eloquent-relationships.md, line: 516
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-model-structure\"></a>\n"
msgstr "<a name=\"many-to-many-model-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 516
# File: docs/8.x/eloquent-relationships.md, line: 738
# File: docs/8.x/eloquent-relationships.md, line: 840
# File: docs/8.x/eloquent-relationships.md, line: 977
# File: docs/master/eloquent-relationships.md, line: 516
# File: docs/master/eloquent-relationships.md, line: 738
# File: docs/master/eloquent-relationships.md, line: 840
# File: docs/master/eloquent-relationships.md, line: 977
#. type: Title ####
#, no-wrap
msgid "Model Structure"
msgstr "Model 架構"

# File: docs/8.x/eloquent-relationships.md, line: 519
# File: docs/master/eloquent-relationships.md, line: 519
#. type: Plain text
msgid "Many-to-many relationships are defined by writing a method that returns the result of the `belongsToMany` method. The `belongsToMany` method is provided by the `Illuminate\\Database\\Eloquent\\Model` base class that is used by all of your application's Eloquent models. For example, let's define a `roles` method on our `User` model. The first argument passed to this method is the name of the related model class:"
msgstr "我們可以通過撰寫一個回傳 `belongsToMany` 方法執行結果的方法來定義多對多關聯。`belongsToMany` 方法是由 `Illuminate\\Database\\Eloquent\\Model` 基礎類別提供的，你的專案中所有的 Eloquent Model 都使用了這個類別。舉例來說，讓我們來在 `User` Model 上定義一個 `roles` 方法。傳入這個方法的第一個引述是關聯 Model 類別的名稱："

# File: docs/8.x/eloquent-relationships.md, line: 536
# File: docs/master/eloquent-relationships.md, line: 536
#. type: Plain text
#, no-wrap
msgid "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * The roles that belong to the user.\n"
"         */\n"
"        public function roles()\n"
"        {\n"
"            return $this->belongsToMany(Role::class);\n"
"        }\n"
"    }\n"
msgstr "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the phone associated with the user.\n"
"         */\n"
"        public function phone()\n"
"        {\n"
"            return $this->belongsToMany(Phone::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 538
# File: docs/master/eloquent-relationships.md, line: 538
#. type: Plain text
msgid "Once the relationship is defined, you may access the user's roles using the `roles` dynamic relationship property:"
msgstr "定義好關聯後，就可以使用 `roles` 動態關聯屬性來存取該使用者的角色："

# File: docs/8.x/eloquent-relationships.md, line: 540
# File: docs/8.x/eloquent-relationships.md, line: 589
# File: docs/8.x/eloquent-relationships.md, line: 1128
# File: docs/8.x/eloquent-relationships.md, line: 1178
# File: docs/8.x/eloquent-relationships.md, line: 1604
# File: docs/8.x/eloquent-relationships.md, line: 1831
# File: docs/master/eloquent-relationships.md, line: 540
# File: docs/master/eloquent-relationships.md, line: 589
# File: docs/master/eloquent-relationships.md, line: 1128
# File: docs/master/eloquent-relationships.md, line: 1178
# File: docs/master/eloquent-relationships.md, line: 1604
# File: docs/master/eloquent-relationships.md, line: 1831
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\User;\n"
msgstr "    use App\\Models\\User;\n"

# File: docs/8.x/eloquent-relationships.md, line: 542
# File: docs/8.x/eloquent-relationships.md, line: 591
# File: docs/8.x/eloquent-relationships.md, line: 1130
# File: docs/8.x/eloquent-relationships.md, line: 1180
# File: docs/8.x/eloquent-relationships.md, line: 1833
# File: docs/8.x/eloquent-relationships.md, line: 1851
# File: docs/8.x/eloquent-relationships.md, line: 1891
# File: docs/master/eloquent-relationships.md, line: 542
# File: docs/master/eloquent-relationships.md, line: 591
# File: docs/master/eloquent-relationships.md, line: 1130
# File: docs/master/eloquent-relationships.md, line: 1180
# File: docs/master/eloquent-relationships.md, line: 1833
# File: docs/master/eloquent-relationships.md, line: 1851
# File: docs/master/eloquent-relationships.md, line: 1891
#. type: Plain text
#, no-wrap
msgid "    $user = User::find(1);\n"
msgstr "    $user = User::find(1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 546
# File: docs/master/eloquent-relationships.md, line: 546
#. type: Plain text
#, no-wrap
msgid "    foreach ($user->roles as $role) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($user->roles as $role) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 548
# File: docs/master/eloquent-relationships.md, line: 548
#. type: Plain text
msgid "Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `roles` method and continuing to chain conditions onto the query:"
msgstr "由於所有的關聯也同時是 Query Builder，因此我們也能通過呼叫 `roles` 方法並繼續在查詢上串上條件來進一步給關聯加上查詢條件："

# File: docs/8.x/eloquent-relationships.md, line: 550
# File: docs/master/eloquent-relationships.md, line: 550
#. type: Plain text
#, no-wrap
msgid "    $roles = User::find(1)->roles()->orderBy('name')->get();\n"
msgstr "    $roles = User::find(1)->roles()->orderBy('name')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 552
# File: docs/master/eloquent-relationships.md, line: 552
#. type: Plain text
msgid "To determine the table name of the relationship's intermediate table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the `belongsToMany` method:"
msgstr "為了判斷該關聯的中介資料表表名，Eloquent 會將兩個關聯 Model 的名稱按照字母排序串接在一起。不過，這個慣例是可以隨意複寫的，只需要傳入第二個引數給 `belongsToMany` 方法即可："

# File: docs/8.x/eloquent-relationships.md, line: 554
# File: docs/master/eloquent-relationships.md, line: 554
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class, 'role_user');\n"
msgstr "    return $this->belongsToMany(Role::class, 'role_user');\n"

# File: docs/8.x/eloquent-relationships.md, line: 556
# File: docs/master/eloquent-relationships.md, line: 556
#. type: Plain text
msgid "In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by passing additional arguments to the `belongsToMany` method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:"
msgstr "除了自訂中介表的表名外，也可以傳入額外的引數給 `belongsToMany` 來自訂中介表上的欄位名稱。第三個引數目前定義關聯的 Model 的外部索引鍵，而第四個引述則是要連結的 Model 的外部索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 558
# File: docs/master/eloquent-relationships.md, line: 558
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\n"
msgstr "    return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\n"

# File: docs/8.x/eloquent-relationships.md, line: 560
# File: docs/master/eloquent-relationships.md, line: 560
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr "<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 563
# File: docs/master/eloquent-relationships.md, line: 563
#. type: Plain text
msgid "To define the \"inverse\" of a many-to-many relationship, you should define a method on the related model which also returns the result of the `belongsToMany` method. To complete our user / role example, let's define the `users` method on the `Role` model:"
msgstr "若要定義 many-to-many 的「相反」關聯，應先在關聯的 Model 上定義一個同樣回傳 `belongsToMany` 方法結果的方法。接著我們的使用者與角色的例子，我們來在 `Role` Model 上定義 `users` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 580
# File: docs/master/eloquent-relationships.md, line: 580
#. type: Plain text
#, no-wrap
msgid "    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class);\n"
"        }\n"
"    }\n"
msgstr "    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 582
# File: docs/master/eloquent-relationships.md, line: 582
#. type: Plain text
msgid "As you can see, the relationship is defined exactly the same as its `User` model counterpart with the exception of referencing the `App\\Models\\User` model. Since we're reusing the `belongsToMany` method, all of the usual table and key customization options are available when defining the \"inverse\" of many-to-many relationships."
msgstr "如你所見，除了這邊是參照 `App\\Models\\User` 外，關聯定義跟 `User` Model 中對應的部分完全一樣。由於我們使用的還是 `belongsToMany` 方法，因此，在定義「反向」的 many-to-many 關聯時，一樣可以使用一般的資料表與索引鍵自訂選項。"

# File: docs/8.x/eloquent-relationships.md, line: 584
# File: docs/master/eloquent-relationships.md, line: 584
#. type: Plain text
#, no-wrap
msgid "<a name=\"retrieving-intermediate-table-columns\"></a>\n"
msgstr "<a name=\"retrieving-intermediate-table-columns\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 584
# File: docs/master/eloquent-relationships.md, line: 584
#. type: Title ###
#, no-wrap
msgid "Retrieving Intermediate Table Columns"
msgstr "取得中介資料表欄位"

# File: docs/8.x/eloquent-relationships.md, line: 587
# File: docs/master/eloquent-relationships.md, line: 587
#. type: Plain text
msgid "As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our `User` model has many `Role` models that it is related to. After accessing this relationship, we may access the intermediate table using the `pivot` attribute on the models:"
msgstr "讀者可能已經瞭解到，處理 Many-to-Many 關聯時必須要有一張中介資料表。Eloquent 提供了一些非常適用的方法來與中介資料表互動。舉例來說，假設 `User` Model 有許多關聯的 `Role` Model。存取這個關聯後，我們可以使用 Model 上的 `pivot` 屬性來存取中介資料表："

# File: docs/8.x/eloquent-relationships.md, line: 595
# File: docs/master/eloquent-relationships.md, line: 595
#. type: Plain text
#, no-wrap
msgid "    foreach ($user->roles as $role) {\n"
"        echo $role->pivot->created_at;\n"
"    }\n"
msgstr "    foreach ($user->roles as $role) {\n"
"        echo $role->pivot->created_at;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 597
# File: docs/master/eloquent-relationships.md, line: 597
#. type: Plain text
msgid "Notice that each `Role` model we retrieve is automatically assigned a `pivot` attribute. This attribute contains a model representing the intermediate table."
msgstr "可以注意到，我們取得的每個 `Role` 資料表都會自動獲得一個 `pivot` 屬性。這個屬性包含了一個代表中介資料表的 Model。"

# File: docs/8.x/eloquent-relationships.md, line: 599
# File: docs/master/eloquent-relationships.md, line: 599
#. type: Plain text
msgid "By default, only the model keys will be present on the `pivot` model. If your intermediate table contains extra attributes, you must specify them when defining the relationship:"
msgstr "預設情況下，只有 Model 的索引鍵會出現在 `Pivot` Model 上。若中介資料表包含了其他額外的屬性，則需要在定義關聯時指定這些屬性："

# File: docs/8.x/eloquent-relationships.md, line: 601
# File: docs/master/eloquent-relationships.md, line: 601
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\n"
msgstr "    return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\n"

# File: docs/8.x/eloquent-relationships.md, line: 603
# File: docs/master/eloquent-relationships.md, line: 603
#. type: Plain text
msgid "If you would like your intermediate table to have `created_at` and `updated_at` timestamps that are automatically maintained by Eloquent, call the `withTimestamps` method when defining the relationship:"
msgstr "若想讓中介資料表擁有 Eloquent 能自動維護的 `created_at` 與 `updated_at` 時戳，可在定義關聯的時候呼叫 `withTimestamps` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 605
# File: docs/master/eloquent-relationships.md, line: 605
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)->withTimestamps();\n"
msgstr "    return $this->belongsToMany(Role::class)->withTimestamps();\n"

# File: docs/8.x/eloquent-relationships.md, line: 607
# File: docs/master/eloquent-relationships.md, line: 607
#. type: Plain text
#, no-wrap
msgid "> {note} Intermediate tables that utilize Eloquent's automatically maintained timestamps are required to have both `created_at` and `updated_at` timestamp columns.\n"
msgstr "> {note} 使用 Eloquent 自動維護時戳的中介資料表會需要擁有 `created_at` 與 `updated_at` 兩個時戳欄位。\n"

# File: docs/8.x/eloquent-relationships.md, line: 609
# File: docs/master/eloquent-relationships.md, line: 609
#. type: Plain text
#, no-wrap
msgid "<a name=\"customizing-the-pivot-attribute-name\"></a>\n"
msgstr "<a name=\"customizing-the-pivot-attribute-name\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 609
# File: docs/master/eloquent-relationships.md, line: 609
#. type: Title ####
#, no-wrap
msgid "Customizing The `pivot` Attribute Name"
msgstr "自訂 `pivot` 屬性名稱"

# File: docs/8.x/eloquent-relationships.md, line: 612
# File: docs/master/eloquent-relationships.md, line: 612
#. type: Plain text
msgid "As noted previously, attributes from the intermediate table may be accessed on models via the `pivot` attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application."
msgstr "剛才也有提過，我們可以使用 `pivot` 屬性來存取中介資料表的屬性。不過，我們可以自訂這個屬性的名稱以讓其跟貼合在專案中的用途。"

# File: docs/8.x/eloquent-relationships.md, line: 614
# File: docs/master/eloquent-relationships.md, line: 614
#. type: Plain text
msgid "For example, if your application contains users that may subscribe to podcasts, you likely have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table attribute to `subscription` instead of `pivot`. This can be done using the `as` method when defining the relationship:"
msgstr "舉例來說，我們的專案中可能會包含能讓使用者訂閱 Podcast 的功能，我們可能會想在使用者與 Podcast 間使用 Many-to-Many 關聯。在這個例子中，我們可能會想將中介資料表屬性的名稱從 `pivot` 改成 `subscription`。可以在定義關聯時使用 `as` 方法來完成："

# File: docs/8.x/eloquent-relationships.md, line: 618
# File: docs/master/eloquent-relationships.md, line: 618
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscription')\n"
"                    ->withTimestamps();\n"
msgstr "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscription')\n"
"                    ->withTimestamps();\n"

# File: docs/8.x/eloquent-relationships.md, line: 620
# File: docs/master/eloquent-relationships.md, line: 620
#. type: Plain text
msgid "Once the custom intermediate table attribute has been specified, you may access the intermediate table data using the customized name:"
msgstr "指定好自訂的中介資料表屬性後，就可以使用自訂的名稱來存取中介資料表資料："

# File: docs/8.x/eloquent-relationships.md, line: 622
# File: docs/master/eloquent-relationships.md, line: 622
#. type: Plain text
#, no-wrap
msgid "    $users = User::with('podcasts')->get();\n"
msgstr "    $users = User::with('podcasts')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 626
# File: docs/master/eloquent-relationships.md, line: 626
#. type: Plain text
#, no-wrap
msgid "    foreach ($users->flatMap->podcasts as $podcast) {\n"
"        echo $podcast->subscription->created_at;\n"
"    }\n"
msgstr "    foreach ($users->flatMap->podcasts as $podcast) {\n"
"        echo $podcast->subscription->created_at;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 628
# File: docs/master/eloquent-relationships.md, line: 628
#. type: Plain text
#, no-wrap
msgid "<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\n"
msgstr "<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 628
# File: docs/master/eloquent-relationships.md, line: 628
#. type: Title ###
#, no-wrap
msgid "Filtering Queries Via Intermediate Table Columns"
msgstr "通過中介資料表欄位來過濾查詢"

# File: docs/8.x/eloquent-relationships.md, line: 631
# File: docs/master/eloquent-relationships.md, line: 631
#. type: Plain text
msgid "You can also filter the results returned by `belongsToMany` relationship queries using the `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, `wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, and `wherePivotNotNull` methods when defining the relationship:"
msgstr "也可以在定義關聯時使用 `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, `wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, 與 `wherePivotNotNull` 方法來過濾 `belongsToMany` 關聯查詢的回傳結果："

# File: docs/8.x/eloquent-relationships.md, line: 634
# File: docs/master/eloquent-relationships.md, line: 634
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivot('approved', 1);\n"
msgstr "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivot('approved', 1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 637
# File: docs/master/eloquent-relationships.md, line: 637
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotIn('priority', [1, 2]);\n"
msgstr "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotIn('priority', [1, 2]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 640
# File: docs/master/eloquent-relationships.md, line: 640
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotNotIn('priority', [1, 2]);\n"
msgstr "    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotNotIn('priority', [1, 2]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 644
# File: docs/master/eloquent-relationships.md, line: 644
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n"
msgstr "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n"

# File: docs/8.x/eloquent-relationships.md, line: 648
# File: docs/master/eloquent-relationships.md, line: 648
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n"
msgstr "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n"

# File: docs/8.x/eloquent-relationships.md, line: 652
# File: docs/master/eloquent-relationships.md, line: 652
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNull('expired_at');\n"
msgstr "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNull('expired_at');\n"

# File: docs/8.x/eloquent-relationships.md, line: 656
# File: docs/master/eloquent-relationships.md, line: 656
#. type: Plain text
#, no-wrap
msgid "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotNull('expired_at');\n"
msgstr "    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotNull('expired_at');\n"

# File: docs/8.x/eloquent-relationships.md, line: 658
# File: docs/master/eloquent-relationships.md, line: 658
#. type: Plain text
#, no-wrap
msgid "<a name=\"defining-custom-intermediate-table-models\"></a>\n"
msgstr "<a name=\"defining-custom-intermediate-table-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 658
# File: docs/master/eloquent-relationships.md, line: 658
#. type: Title ###
#, no-wrap
msgid "Defining Custom Intermediate Table Models"
msgstr "定義自訂的中介表 Model"

# File: docs/8.x/eloquent-relationships.md, line: 661
# File: docs/master/eloquent-relationships.md, line: 661
#. type: Plain text
msgid "If you would like to define a custom model to represent the intermediate table of your many-to-many relationship, you may call the `using` method when defining the relationship. Custom pivot models give you the opportunity to define additional methods on the pivot model."
msgstr "若想定義一個代表多對多關聯之中介資料表的自訂 Model，則可以在定義關聯時呼叫 `using` 方法。自訂樞紐 Model (Pivot Model) 能讓我們有機會在樞紐 Model 上定義一些額外的方法。"

# File: docs/8.x/eloquent-relationships.md, line: 663
# File: docs/master/eloquent-relationships.md, line: 663
#. type: Plain text
msgid "Custom many-to-many pivot models should extend the `Illuminate\\Database\\Eloquent\\Relations\\Pivot` class while custom polymorphic many-to-many pivot models should extend the `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` class. For example, we may define a `Role` model which uses a custom `RoleUser` pivot model:"
msgstr "要自訂多對多樞紐 Model，則應繼承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 類別。多型多對多的樞紐 Model 則應繼承 `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot`。舉例來說，我們可以定義一個使用了 `RoleUser` 樞紐 Model 的` Role` Model："

# File: docs/8.x/eloquent-relationships.md, line: 680
# File: docs/master/eloquent-relationships.md, line: 680
#. type: Plain text
#, no-wrap
msgid "    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class)->using(RoleUser::class);\n"
"        }\n"
"    }\n"
msgstr "    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class)->using(RoleUser::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 682
# File: docs/master/eloquent-relationships.md, line: 682
#. type: Plain text
msgid "When defining the `RoleUser` model, you should extend the `Illuminate\\Database\\Eloquent\\Relations\\Pivot` class:"
msgstr "定義 `RoleUser` Model 時，應繼承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 類別："

# File: docs/8.x/eloquent-relationships.md, line: 688
# File: docs/master/eloquent-relationships.md, line: 688
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n"

# File: docs/8.x/eloquent-relationships.md, line: 693
# File: docs/master/eloquent-relationships.md, line: 693
#. type: Plain text
#, no-wrap
msgid "    class RoleUser extends Pivot\n"
"    {\n"
"        //\n"
"    }\n"
msgstr "    class RoleUser extends Pivot\n"
"    {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 695
# File: docs/master/eloquent-relationships.md, line: 695
#. type: Plain text
#, no-wrap
msgid "> {note} Pivot models may not use the `SoftDeletes` trait. If you need to soft delete pivot records consider converting your pivot model to an actual Eloquent model.\n"
msgstr "> {note} 樞紐 Model 不能使用 `SoftDeletes` Trait。若有需要對樞紐紀錄作軟刪除，請考慮將樞紐 Model 改寫成真正的 Eloquent Model。\n"

# File: docs/8.x/eloquent-relationships.md, line: 697
# File: docs/master/eloquent-relationships.md, line: 697
#. type: Plain text
#, no-wrap
msgid "<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\n"
msgstr "<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 697
# File: docs/master/eloquent-relationships.md, line: 697
#. type: Title ####
#, no-wrap
msgid "Custom Pivot Models And Incrementing IDs"
msgstr "自訂樞紐 Model 並遞增 ID"

# File: docs/8.x/eloquent-relationships.md, line: 700
# File: docs/master/eloquent-relationships.md, line: 700
#. type: Plain text
msgid "If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an `incrementing` property that is set to `true`."
msgstr "若有定義了使用自訂樞紐 Model 的多對多關聯，且該樞紐 Model 由自動遞增的主索引鍵 (Auto-Incrementing Primary Key)，則應確保這個自訂樞紐 Model 類別由定義一個設為 `true` 的 `incrementing` 屬性。"

# File: docs/8.x/eloquent-relationships.md, line: 707
# File: docs/master/eloquent-relationships.md, line: 707
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Indicates if the IDs are auto-incrementing.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $incrementing = true;\n"
msgstr "    /**\n"
"     * Indicates if the IDs are auto-incrementing.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $incrementing = true;\n"

# File: docs/8.x/eloquent-relationships.md, line: 709
# File: docs/master/eloquent-relationships.md, line: 709
#. type: Plain text
#, no-wrap
msgid "<a name=\"polymorphic-relationships\"></a>\n"
msgstr "<a name=\"polymorphic-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 709
# File: docs/master/eloquent-relationships.md, line: 709
#. type: Title ##
#, no-wrap
msgid "Polymorphic Relationships"
msgstr "Polymorphic (多型) 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 712
# File: docs/master/eloquent-relationships.md, line: 712
#. type: Plain text
msgid "A polymorphic relationship allows the child model to belong to more than one type of model using a single association. For example, imagine you are building an application that allows users to share blog posts and videos. In such an application, a `Comment` model might belong to both the `Post` and `Video` models."
msgstr "使用多型關聯，就能讓子 Model 通過單一關聯來隸屬於多種 Model。舉例來說，假設我們正在製作一個能讓使用者分享部落格貼文與影片的網站。在這種例子中，`Comment` (留言) Model 有可能隸屬於 `Post` (貼文) Model，也可能隸屬於 `Video` (影片) Model。"

# File: docs/8.x/eloquent-relationships.md, line: 714
# File: docs/master/eloquent-relationships.md, line: 714
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-relations\"></a>\n"
msgstr "<a name=\"one-to-one-polymorphic-relations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 714
# File: docs/master/eloquent-relationships.md, line: 714
#. type: Title ###
#, no-wrap
msgid "One To One (Polymorphic)"
msgstr "一對一 (多型)"

# File: docs/8.x/eloquent-relationships.md, line: 717
# File: docs/master/eloquent-relationships.md, line: 717
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-table-structure\"></a>\n"
msgstr "<a name=\"one-to-one-polymorphic-table-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 720
# File: docs/master/eloquent-relationships.md, line: 720
#. type: Plain text
msgid "A one-to-one polymorphic relation is similar to a typical one-to-one relation; however, the child model can belong to more than one type of model using a single association. For example, a blog `Post` and a `User` may share a polymorphic relation to an `Image` model. Using a one-to-one polymorphic relation allows you to have a single table of unique images that may be associated with posts and users. First, let's examine the table structure:"
msgstr "多型的一對一關聯於一般的一對一關聯類似。不過，在這種關聯中的子 Model 可以使用一種關聯來表示出對超過一種 Model 的從屬關係。舉例來說，部落格的 `Post` (貼文) 與 `User` (使用者) 可能會共享一個多型關聯的 `Image` (圖片) Model。使用多型的一對一關聯，就能讓我們製作一張用來儲存不重複圖片的資料表，並將該資料表關聯到貼文跟使用者上。首先，我們來看看下列資料表架構："

# File: docs/8.x/eloquent-relationships.md, line: 724
# File: docs/8.x/eloquent-relationships.md, line: 960
# File: docs/master/eloquent-relationships.md, line: 724
# File: docs/master/eloquent-relationships.md, line: 960
#. type: Plain text
#, no-wrap
msgid "    posts\n"
"        id - integer\n"
"        name - string\n"
msgstr "    posts\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 734
# File: docs/master/eloquent-relationships.md, line: 734
#. type: Plain text
#, no-wrap
msgid "    images\n"
"        id - integer\n"
"        url - string\n"
"        imageable_id - integer\n"
"        imageable_type - string\n"
msgstr "    images\n"
"        id - integer\n"
"        url - string\n"
"        imageable_id - integer\n"
"        imageable_type - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 736
# File: docs/master/eloquent-relationships.md, line: 736
#. type: Plain text
msgid "Note the `imageable_id` and `imageable_type` columns on the `images` table. The `imageable_id` column will contain the ID value of the post or user, while the `imageable_type` column will contain the class name of the parent model. The `imageable_type` column is used by Eloquent to determine which \"type\" of parent model to return when accessing the `imageable` relation. In this case, the column would contain either `App\\Models\\Post` or `App\\Models\\User`."
msgstr "可以注意到 `images` 資料表上的 `imageable_id` 與 `imageable_type` 欄位。`imageable_id` 欄位用來包含貼文或使用者的 ID 值，而 `imageable_type` 欄位則用來包含上層 Model 的類別名稱。`imageable_type` 是用來給 Eloquent 判斷上層 Model 的「型別 (Type)」，以在存取 `imageable` 關聯時能回傳該上層 Model。在這種情況下，這個欄位的內容會是 `App\\Models\\Post` 或 `App\\Models\\User`。"

# File: docs/8.x/eloquent-relationships.md, line: 738
# File: docs/master/eloquent-relationships.md, line: 738
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-model-structure\"></a>\n"
msgstr "<a name=\"one-to-one-polymorphic-model-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 741
# File: docs/8.x/eloquent-relationships.md, line: 843
# File: docs/master/eloquent-relationships.md, line: 741
# File: docs/master/eloquent-relationships.md, line: 843
#. type: Plain text
msgid "Next, let's examine the model definitions needed to build this relationship:"
msgstr "接著，讓我們來看看要製作這種關聯所需要的 Model 定義："

# File: docs/8.x/eloquent-relationships.md, line: 758
# File: docs/master/eloquent-relationships.md, line: 758
#. type: Plain text
#, no-wrap
msgid "    class Image extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent imageable model (user or post).\n"
"         */\n"
"        public function imageable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr "    class Image extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent imageable model (user or post).\n"
"         */\n"
"        public function imageable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 769
# File: docs/master/eloquent-relationships.md, line: 769
#. type: Plain text
#, no-wrap
msgid "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 780
# File: docs/master/eloquent-relationships.md, line: 780
#. type: Plain text
#, no-wrap
msgid "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 782
# File: docs/master/eloquent-relationships.md, line: 782
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr "<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 782
# File: docs/8.x/eloquent-relationships.md, line: 884
# File: docs/8.x/eloquent-relationships.md, line: 1033
# File: docs/master/eloquent-relationships.md, line: 782
# File: docs/master/eloquent-relationships.md, line: 884
# File: docs/master/eloquent-relationships.md, line: 1033
#. type: Title ####
#, no-wrap
msgid "Retrieving The Relationship"
msgstr "取得關聯"

# File: docs/8.x/eloquent-relationships.md, line: 785
# File: docs/master/eloquent-relationships.md, line: 785
#. type: Plain text
msgid "Once your database table and models are defined, you may access the relationships via your models. For example, to retrieve the image for a post, we can access the `image` dynamic relationship property:"
msgstr "定義好資料庫資料表與 Model 後，就可以通過這些 Model 來存取關聯。舉例來說，若要取得一則貼文的圖片，我們可以存取 `image` 動態關聯屬性："

# File: docs/8.x/eloquent-relationships.md, line: 789
# File: docs/8.x/eloquent-relationships.md, line: 891
# File: docs/8.x/eloquent-relationships.md, line: 1040
# File: docs/8.x/eloquent-relationships.md, line: 1742
# File: docs/8.x/eloquent-relationships.md, line: 1750
# File: docs/8.x/eloquent-relationships.md, line: 1771
# File: docs/8.x/eloquent-relationships.md, line: 1785
# File: docs/8.x/eloquent-relationships.md, line: 1793
# File: docs/master/eloquent-relationships.md, line: 789
# File: docs/master/eloquent-relationships.md, line: 891
# File: docs/master/eloquent-relationships.md, line: 1040
# File: docs/master/eloquent-relationships.md, line: 1742
# File: docs/master/eloquent-relationships.md, line: 1750
# File: docs/master/eloquent-relationships.md, line: 1771
# File: docs/master/eloquent-relationships.md, line: 1785
# File: docs/master/eloquent-relationships.md, line: 1793
#. type: Plain text
#, no-wrap
msgid "    $post = Post::find(1);\n"
msgstr "    $post = Post::find(1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 791
# File: docs/master/eloquent-relationships.md, line: 791
#. type: Plain text
#, no-wrap
msgid "    $image = $post->image;\n"
msgstr "    $image = $post->image;\n"

# File: docs/8.x/eloquent-relationships.md, line: 793
# File: docs/master/eloquent-relationships.md, line: 793
#. type: Plain text
msgid "You may retrieve the parent of the polymorphic model by accessing the name of the method that performs the call to `morphTo`. In this case, that is the `imageable` method on the `Image` model. So, we will access that method as a dynamic relationship property:"
msgstr "可以通過存取呼叫 `morphTo` 之方法的名稱來取得多型 Model 的上層 Model。在這個例子中，就是 `Image` Model 的 `imageable` 方法。因此，我們可以用動態關聯屬性來存取該方法："

# File: docs/8.x/eloquent-relationships.md, line: 795
# File: docs/master/eloquent-relationships.md, line: 795
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Image;\n"
msgstr "    use App\\Models\\Image;\n"

# File: docs/8.x/eloquent-relationships.md, line: 797
# File: docs/master/eloquent-relationships.md, line: 797
#. type: Plain text
#, no-wrap
msgid "    $image = Image::find(1);\n"
msgstr "    $image = Image::find(1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 799
# File: docs/master/eloquent-relationships.md, line: 799
#. type: Plain text
#, no-wrap
msgid "    $imageable = $image->imageable;\n"
msgstr "    $imageable = $image->imageable;\n"

# File: docs/8.x/eloquent-relationships.md, line: 801
# File: docs/master/eloquent-relationships.md, line: 801
#. type: Plain text
msgid "The `imageable` relation on the `Image` model will return either a `Post` or `User` instance, depending on which type of model owns the image."
msgstr "依據擁有該圖片的 Model 類型，`Image` Model 上的 `imageable` 關聯會回傳 `Post` 或 `User` 實體。"

# File: docs/8.x/eloquent-relationships.md, line: 803
# File: docs/master/eloquent-relationships.md, line: 803
#. type: Plain text
#, no-wrap
msgid "<a name=\"morph-one-to-one-key-conventions\"></a>\n"
msgstr "<a name=\"morph-one-to-one-key-conventions\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 806
# File: docs/master/eloquent-relationships.md, line: 806
#. type: Plain text
msgid "If necessary, you may specify the name of the \"id\" and \"type\" columns utilized by your polymorphic child model. If you do so, ensure that you always pass the name of the relationship as the first argument to the `morphTo` method. Typically, this value should match the method name, so you may use PHP's `__FUNCTION__` constant:"
msgstr "若有需要，也可以指定多型子 Model 所使用的「id」與「type」欄位名稱。若要自訂這些欄位的名稱，請先確保有將關聯的名稱傳給 `morphTo` 方法的第一個引數。一般來說，這個值應該要與方法名稱相同，因此我們可以使用 PHP 的 `__FUNCTION__` 常數："

# File: docs/8.x/eloquent-relationships.md, line: 814
# File: docs/master/eloquent-relationships.md, line: 814
#. type: Plain text
#, no-wrap
msgid "    /**\n"
"     * Get the model that the image belongs to.\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\n"
"    }\n"
msgstr "    /**\n"
"     * Get the model that the image belongs to.\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 816
# File: docs/master/eloquent-relationships.md, line: 816
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-relations\"></a>\n"
msgstr "<a name=\"one-to-many-polymorphic-relations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 816
# File: docs/master/eloquent-relationships.md, line: 816
#. type: Title ###
#, no-wrap
msgid "One To Many (Polymorphic)"
msgstr "一對多 (多型)"

# File: docs/8.x/eloquent-relationships.md, line: 819
# File: docs/master/eloquent-relationships.md, line: 819
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-table-structure\"></a>\n"
msgstr "<a name=\"one-to-many-polymorphic-table-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 822
# File: docs/master/eloquent-relationships.md, line: 822
#. type: Plain text
msgid "A one-to-many polymorphic relation is similar to a typical one-to-many relation; however, the child model can belong to more than one type of model using a single association. For example, imagine users of your application can \"comment\" on posts and videos. Using polymorphic relationships, you may use a single `comments` table to contain comments for both posts and videos. First, let's examine the table structure required to build this relationship:"
msgstr "One-to-Many 的多型關聯與一般的 One-to-Many 關聯很類似。不過，在多型關聯中，可以使用單一關聯來讓子 Model 可以隸屬於多種類型的 Model。舉例來說，假設有個使用者可以在貼文與影片上「留言」的網站。若使用多型關聯，我們可以使用單一一個 `comments` 表來包含用於貼文與影片的留言。首先，來看看需要建立這種關聯的資料表結構："

# File: docs/8.x/eloquent-relationships.md, line: 827
# File: docs/master/eloquent-relationships.md, line: 827
#. type: Plain text
#, no-wrap
msgid "    posts\n"
"        id - integer\n"
"        title - string\n"
"        body - text\n"
msgstr "    posts\n"
"        id - integer\n"
"        title - string\n"
"        body - text\n"

# File: docs/8.x/eloquent-relationships.md, line: 832
# File: docs/master/eloquent-relationships.md, line: 832
#. type: Plain text
#, no-wrap
msgid "    videos\n"
"        id - integer\n"
"        title - string\n"
"        url - string\n"
msgstr "    videos\n"
"        id - integer\n"
"        title - string\n"
"        url - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 838
# File: docs/master/eloquent-relationships.md, line: 838
#. type: Plain text
#, no-wrap
msgid "    comments\n"
"        id - integer\n"
"        body - text\n"
"        commentable_id - integer\n"
"        commentable_type - string\n"
msgstr "    comments\n"
"        id - integer\n"
"        body - text\n"
"        commentable_id - integer\n"
"        commentable_type - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 840
# File: docs/master/eloquent-relationships.md, line: 840
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-model-structure\"></a>\n"
msgstr "<a name=\"one-to-many-polymorphic-model-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 860
# File: docs/master/eloquent-relationships.md, line: 860
#. type: Plain text
#, no-wrap
msgid "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent commentable model (post or video).\n"
"         */\n"
"        public function commentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent commentable model (post or video).\n"
"         */\n"
"        public function commentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 871
# File: docs/master/eloquent-relationships.md, line: 871
#. type: Plain text
#, no-wrap
msgid "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the post's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the post's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 882
# File: docs/master/eloquent-relationships.md, line: 882
#. type: Plain text
#, no-wrap
msgid "    class Video extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the video's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr "    class Video extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the video's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 884
# File: docs/master/eloquent-relationships.md, line: 884
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr "<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 887
# File: docs/master/eloquent-relationships.md, line: 887
#. type: Plain text
msgid "Once your database table and models are defined, you may access the relationships via your model's dynamic relationship properties. For example, to access all of the comments for a post, we can use the `comments` dynamic property:"
msgstr "定義好資料表與 Model 後，就可以使用 Model 的動態關聯屬性來存取這個關聯。舉例來說，若要存取某個貼文的所有留言，我們可以使用 `comments` 動態屬性："

# File: docs/8.x/eloquent-relationships.md, line: 895
# File: docs/master/eloquent-relationships.md, line: 895
#. type: Plain text
#, no-wrap
msgid "    foreach ($post->comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($post->comments as $comment) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 897
# File: docs/master/eloquent-relationships.md, line: 897
#. type: Plain text
msgid "You may also retrieve the parent of a polymorphic child model by accessing the name of the method that performs the call to `morphTo`. In this case, that is the `commentable` method on the `Comment` model. So, we will access that method as a dynamic relationship property in order to access the comment's parent model:"
msgstr "也可以通過存取呼叫 `morphTo` 之方法的名稱來取得多型子 Model 的上層 Model。在這個例子中，就是 `Comment` Model 的 `commentable` 方法。因此，我們可以用動態關聯屬性來存取該方法以取得留言的上層 Model："

# File: docs/8.x/eloquent-relationships.md, line: 903
# File: docs/master/eloquent-relationships.md, line: 903
#. type: Plain text
#, no-wrap
msgid "    $commentable = $comment->commentable;\n"
msgstr "    $commentable = $comment->commentable;\n"

# File: docs/8.x/eloquent-relationships.md, line: 905
# File: docs/master/eloquent-relationships.md, line: 905
#. type: Plain text
msgid "The `commentable` relation on the `Comment` model will return either a `Post` or `Video` instance, depending on which type of model is the comment's parent."
msgstr "依照不同的留言上層 Model 類型，`Comment` Model 的 `commentable` 關聯回傳的不是 `Post` 實體就是 `Video` 實體。"

# File: docs/8.x/eloquent-relationships.md, line: 907
# File: docs/master/eloquent-relationships.md, line: 907
#. type: Plain text
#, no-wrap
msgid "<a name=\"one-of-many-polymorphic-relations\"></a>\n"
msgstr "<a name=\"one-of-many-polymorphic-relations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 907
# File: docs/master/eloquent-relationships.md, line: 907
#. type: Title ###
#, no-wrap
msgid "One Of Many (Polymorphic)"
msgstr "多中之一 (多型)"

# File: docs/8.x/eloquent-relationships.md, line: 910
# File: docs/master/eloquent-relationships.md, line: 910
#. type: Plain text
msgid "Sometimes a model may have many related models, yet you want to easily retrieve the \"latest\" or \"oldest\" related model of the relationship. For example, a `User` model may be related to many `Image` models, but you want to define a convenient way to interact with the most recent image the user has uploaded. You may accomplish this using the `morphOne` relationship type combined with the `ofMany` methods:"
msgstr "有時候，某個 Model 可能有多個關聯 Model，而我們可能會想取多個關聯 Model 中「最新」或「最舊」的關聯 Model。舉例來說，`User` Model (使用者) 可能會關聯到多個 `Image` Model (圖片)，而我們可能會想定義一種方便的方法來存取使用者最新的圖片。我們可以通過將 `morphOne` 關聯類型與 `ofMany` 方法搭配使用來達成："

# File: docs/8.x/eloquent-relationships.md, line: 911
# File: docs/master/eloquent-relationships.md, line: 911
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's most recent image.\n"
" */\n"
"public function latestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's most recent image.\n"
" */\n"
"public function latestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 923
# File: docs/master/eloquent-relationships.md, line: 923
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's oldest image.\n"
" */\n"
"public function oldestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's oldest image.\n"
" */\n"
"public function oldestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 936
# File: docs/master/eloquent-relationships.md, line: 936
#. type: Plain text
msgid "For example, using the `ofMany` method, you may retrieve the user's most \"liked\" image. The `ofMany` method accepts the sortable column as its first argument and which aggregate function (`min` or `max`) to apply when querying for the related model:"
msgstr "舉例來說，我們可以使用 `ofMany` 方法來去的使用者獲得最多「讚」的圖片。`ofMany` 方法的第一個引數為可排序的欄位，接著則是要套用哪個匯總函式 (`min` 或 `max` 等) 在關聯的 Model 上："

# File: docs/8.x/eloquent-relationships.md, line: 937
# File: docs/master/eloquent-relationships.md, line: 937
#. type: Plain text
#, no-wrap
msgid "/**\n"
" * Get the user's most popular image.\n"
" */\n"
"public function bestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\n"
"}\n"
msgstr "/**\n"
" * Get the user's most popular image.\n"
" */\n"
"public function bestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 948
# File: docs/master/eloquent-relationships.md, line: 948
#. type: Plain text
#, no-wrap
msgid "> {tip} It is possible to construct more advanced \"one of many\" relationships. For more information, please consult the [has one of many documentation](#advanced-has-one-of-many-relationships).\n"
msgstr "> {tip} 還有辦法建立建立更進階的「One of Many」關聯。更多資訊請參考 [Has One of Many 說明文件](#advanced-has-one-of-many-relationships)。\n"

# File: docs/8.x/eloquent-relationships.md, line: 950
# File: docs/master/eloquent-relationships.md, line: 950
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-relations\"></a>\n"
msgstr "<a name=\"many-to-many-polymorphic-relations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 950
# File: docs/master/eloquent-relationships.md, line: 950
#. type: Title ###
#, no-wrap
msgid "Many To Many (Polymorphic)"
msgstr "多對多 (多型)"

# File: docs/8.x/eloquent-relationships.md, line: 953
# File: docs/master/eloquent-relationships.md, line: 953
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-table-structure\"></a>\n"
msgstr "<a name=\"many-to-many-polymorphic-table-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 956
# File: docs/master/eloquent-relationships.md, line: 956
#. type: Plain text
msgid "Many-to-many polymorphic relations are slightly more complicated than \"morph one\" and \"morph many\" relationships. For example, a `Post` model and `Video` model could share a polymorphic relation to a `Tag` model. Using a many-to-many polymorphic relation in this situation would allow your application to have a single table of unique tags that may be associated with posts or videos. First, let's examine the table structure required to build this relationship:"
msgstr "多型的 Many-to-Many 關聯比「Morph One」或「Morph Many」都稍微複雜一點。舉例來說，`Post` Model 與 `Video` Model 可以共用一個多型關聯的 `Tag` Model。在這種情況下使用多型的 Many-to-Many 可以讓我們的專案中只需要一張資料表來儲存獨立的 Tag，就可以關聯給 Post 跟 Video。首先，來看看要建立這種關聯的資料表架構："

# File: docs/8.x/eloquent-relationships.md, line: 964
# File: docs/master/eloquent-relationships.md, line: 964
#. type: Plain text
#, no-wrap
msgid "    videos\n"
"        id - integer\n"
"        name - string\n"
msgstr "    videos\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 968
# File: docs/master/eloquent-relationships.md, line: 968
#. type: Plain text
#, no-wrap
msgid "    tags\n"
"        id - integer\n"
"        name - string\n"
msgstr "    tags\n"
"        id - integer\n"
"        name - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 973
# File: docs/master/eloquent-relationships.md, line: 973
#. type: Plain text
#, no-wrap
msgid "    taggables\n"
"        tag_id - integer\n"
"        taggable_id - integer\n"
"        taggable_type - string\n"
msgstr "    taggables\n"
"        tag_id - integer\n"
"        taggable_id - integer\n"
"        taggable_type - string\n"

# File: docs/8.x/eloquent-relationships.md, line: 975
# File: docs/master/eloquent-relationships.md, line: 975
#. type: Plain text
#, no-wrap
msgid "> {tip} Before diving into polymorphic many-to-many relationships, you may benefit from reading the documentation on typical [many-to-many relationships](#many-to-many).\n"
msgstr "> {tip} 在進一步深入瞭解多型的 Many-to-Many 關聯前，我們建議你先閱讀有關普通 [Many-to-Many 關聯](#many-to-many)的說明文件。\n"

# File: docs/8.x/eloquent-relationships.md, line: 977
# File: docs/master/eloquent-relationships.md, line: 977
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-model-structure\"></a>\n"
msgstr "<a name=\"many-to-many-polymorphic-model-structure\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 980
# File: docs/master/eloquent-relationships.md, line: 980
#. type: Plain text
msgid "Next, we're ready to define the relationships on the models. The `Post` and `Video` models will both contain a `tags` method that calls the `morphToMany` method provided by the base Eloquent model class."
msgstr "接著，我們就可以開始在 Model 上定義關聯了。`Post` 與 `Video` Model 都包含了一個 `tags` 方法，該方法中會呼叫基礎 Eloquent Model 類別中的 `morphToMany` 方法。"

# File: docs/8.x/eloquent-relationships.md, line: 982
# File: docs/master/eloquent-relationships.md, line: 982
#. type: Plain text
msgid "The `morphToMany` method accepts the name of the related model as well as the \"relationship name\". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as \"taggable\":"
msgstr "`morphToMany` 方法接受關聯 Model 的名稱，以及「關聯名稱」。根據我們設定給中介表的名稱以及其中包含的索引鍵，我們可以將關聯推導為「taggable」："

# File: docs/8.x/eloquent-relationships.md, line: 999
# File: docs/master/eloquent-relationships.md, line: 999
#. type: Plain text
#, no-wrap
msgid "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the tags for the post.\n"
"         */\n"
"        public function tags()\n"
"        {\n"
"            return $this->morphToMany(Tag::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr "    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the tags for the post.\n"
"         */\n"
"        public function tags()\n"
"        {\n"
"            return $this->morphToMany(Tag::class, 'taggable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1001
# File: docs/master/eloquent-relationships.md, line: 1001
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr "<a name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1004
# File: docs/master/eloquent-relationships.md, line: 1004
#. type: Plain text
msgid "Next, on the `Tag` model, you should define a method for each of its possible parent models. So, in this example, we will define a `posts` method and a `videos` method. Both of these methods should return the result of the `morphedByMany` method."
msgstr "接著，在 `Tag` Model 中，我們可以為 Tag 的各個可能的上層 Model 定義個別的方法。因此，在這個例子中，我們會定義一個 `posts` 方法與一個 `videos` 方法。這兩個方法都應回傳 `morphedByMany` 方法的結果。"

# File: docs/8.x/eloquent-relationships.md, line: 1006
# File: docs/master/eloquent-relationships.md, line: 1006
#. type: Plain text
msgid "The `morphedByMany` method accepts the name of the related model as well as the \"relationship name\". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as \"taggable\":"
msgstr "`morphedByMany` 方法接受關聯 Model 的名稱，以及「關聯名稱」。根據我們設定給中介表的名稱以及其中包含的索引鍵，我們可以將關聯推導為「taggable」："

# File: docs/8.x/eloquent-relationships.md, line: 1022
# File: docs/master/eloquent-relationships.md, line: 1022
#. type: Plain text
#, no-wrap
msgid "    class Tag extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts that are assigned this tag.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->morphedByMany(Post::class, 'taggable');\n"
"        }\n"
msgstr "    class Tag extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts that are assigned this tag.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->morphedByMany(Post::class, 'taggable');\n"
"        }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1031
# File: docs/master/eloquent-relationships.md, line: 1031
#. type: Plain text
#, no-wrap
msgid "        /**\n"
"         * Get all of the videos that are assigned this tag.\n"
"         */\n"
"        public function videos()\n"
"        {\n"
"            return $this->morphedByMany(Video::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr "        /**\n"
"         * Get all of the videos that are assigned this tag.\n"
"         */\n"
"        public function videos()\n"
"        {\n"
"            return $this->morphedByMany(Video::class, 'taggable');\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1033
# File: docs/master/eloquent-relationships.md, line: 1033
#. type: Plain text
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr "<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1036
# File: docs/master/eloquent-relationships.md, line: 1036
#. type: Plain text
msgid "Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you may use the `tags` dynamic relationship property:"
msgstr "定義好資料庫資料表與 Model 後，就可以通過這些 Model 來存取關聯。舉例來說，若要取得一則貼文的 Tag，我們可以使用 `tags` 動態關聯屬性："

# File: docs/8.x/eloquent-relationships.md, line: 1044
# File: docs/master/eloquent-relationships.md, line: 1044
#. type: Plain text
#, no-wrap
msgid "    foreach ($post->tags as $tag) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($post->tags as $tag) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1046
# File: docs/master/eloquent-relationships.md, line: 1046
#. type: Plain text
msgid "You may retrieve the parent of a polymorphic relation from the polymorphic child model by accessing the name of the method that performs the call to `morphedByMany`. In this case, that is the `posts` or `videos` methods on the `Tag` model:"
msgstr "可以在多型子 Model 中通過存取呼叫 `morphedByMany` 的方法名稱來存取多型關聯的上層 Model。在這個例子中，就是 `Tag` Model 上的 `posts` 與 `videos` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1048
# File: docs/master/eloquent-relationships.md, line: 1048
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Tag;\n"
msgstr "    use App\\Models\\Tag;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1050
# File: docs/master/eloquent-relationships.md, line: 1050
#. type: Plain text
#, no-wrap
msgid "    $tag = Tag::find(1);\n"
msgstr "    $tag = Tag::find(1);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1054
# File: docs/master/eloquent-relationships.md, line: 1054
#. type: Plain text
#, no-wrap
msgid "    foreach ($tag->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($tag->posts as $post) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1058
# File: docs/master/eloquent-relationships.md, line: 1058
#. type: Plain text
#, no-wrap
msgid "    foreach ($tag->videos as $video) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($tag->videos as $video) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1060
# File: docs/master/eloquent-relationships.md, line: 1060
#. type: Plain text
#, no-wrap
msgid "<a name=\"custom-polymorphic-types\"></a>\n"
msgstr "<a name=\"custom-polymorphic-types\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1060
# File: docs/master/eloquent-relationships.md, line: 1060
#. type: Title ###
#, no-wrap
msgid "Custom Polymorphic Types"
msgstr "自訂多型型別"

# File: docs/8.x/eloquent-relationships.md, line: 1063
# File: docs/master/eloquent-relationships.md, line: 1063
#. type: Plain text
msgid "By default, Laravel will use the fully qualified class name to store the \"type\" of the related model. For instance, given the one-to-many relationship example above where a `Comment` model may belong to a `Post` or a `Video` model, the default `commentable_type` would be either `App\\Models\\Post` or `App\\Models\\Video`, respectively. However, you may wish to decouple these values from your application's internal structure."
msgstr "預設情況下，Laravel 會使用類別的完整格式名稱 (Fully Qualified Class Name) 來儲存關聯 Model 的「類型 (Type)」。具體而言，在上述的 One-to-Many 例子中，`Comment` Model 可以隸屬於 `Post` Model、也可以隸屬於 `Video` Model，因此預設的 `commentable_type` 就分別會是 `App\\Models\\Post` 或 `App\\Models\\Video`。不過，開發人員可能會想將這些值從專案的內部結構中解耦 (Decouple) 出來。"

# File: docs/8.x/eloquent-relationships.md, line: 1065
# File: docs/master/eloquent-relationships.md, line: 1065
#. type: Plain text
msgid "For example, instead of using the model names as the \"type\", we may use simple strings such as `post` and `video`. By doing so, the polymorphic \"type\" column values in our database will remain valid even if the models are renamed:"
msgstr "舉例來說，我們可以使用像 `post` 或 `video` 等簡單的字串作為「型別」，而不是使用 Model 名稱。這樣一來，即使我們修改了 Model 的名稱，資料庫中的多型「type」欄位值也會繼續有效："

# File: docs/8.x/eloquent-relationships.md, line: 1067
# File: docs/8.x/eloquent-relationships.md, line: 1078
# File: docs/master/eloquent-relationships.md, line: 1067
# File: docs/master/eloquent-relationships.md, line: 1078
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1072
# File: docs/master/eloquent-relationships.md, line: 1072
#. type: Plain text
#, no-wrap
msgid "    Relation::enforceMorphMap([\n"
"        'post' => 'App\\Models\\Post',\n"
"        'video' => 'App\\Models\\Video',\n"
"    ]);\n"
msgstr "    Relation::enforceMorphMap([\n"
"        'post' => 'App\\Models\\Post',\n"
"        'video' => 'App\\Models\\Video',\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1074
# File: docs/master/eloquent-relationships.md, line: 1074
#. type: Plain text
msgid "You may call the `enforceMorphMap` method in the `boot` method of your `App\\Providers\\AppServiceProvider` class or create a separate service provider if you wish."
msgstr "可以在 `App\\Providers\\AppServiceProvider` 類別或依照需求自行的 Service Provider 中之 `boot` 方法內呼叫 `enforceMorphMap` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1076
# File: docs/master/eloquent-relationships.md, line: 1076
#. type: Plain text
msgid "You may determine the morph alias of a given model at runtime using the model's `getMorphClass` method. Conversely, you may determine the fully-qualified class name associated with a morph alias using the `Relation::getMorphedModel` method:"
msgstr "我們可以使用 Model 的 `getMorphClass` 方法來在執行階段判斷給定 Model 的 Morph 別名。相反的，我們可以使用 `Relation::getMorphedModel` 方法來取得 Morph 別名的完整格式類別名稱："

# File: docs/8.x/eloquent-relationships.md, line: 1080
# File: docs/master/eloquent-relationships.md, line: 1080
#. type: Plain text
#, no-wrap
msgid "    $alias = $post->getMorphClass();\n"
msgstr "    $alias = $post->getMorphClass();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1082
# File: docs/master/eloquent-relationships.md, line: 1082
#. type: Plain text
#, no-wrap
msgid "    $class = Relation::getMorphedModel($alias);\n"
msgstr "    $class = Relation::getMorphedModel($alias);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1084
# File: docs/master/eloquent-relationships.md, line: 1084
#. type: Plain text
#, no-wrap
msgid "> {note} When adding a \"morph map\" to your existing application, every morphable `*_type` column value in your database that still contains a fully-qualified class will need to be converted to its \"map\" name.\n"
msgstr "> {note} 在專案中使用「Morph Map」時，所有的 morphable `*_type` 欄位值還是會保持原本的完整各式類別名稱，需要再更改為其「映射 (Map)」的名稱。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1086
# File: docs/master/eloquent-relationships.md, line: 1086
#. type: Plain text
#, no-wrap
msgid "<a name=\"dynamic-relationships\"></a>\n"
msgstr "<a name=\"dynamic-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1086
# File: docs/master/eloquent-relationships.md, line: 1086
#. type: Title ###
#, no-wrap
msgid "Dynamic Relationships"
msgstr "動態關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1089
# File: docs/master/eloquent-relationships.md, line: 1089
#. type: Plain text
msgid "You may use the `resolveRelationUsing` method to define relations between Eloquent models at runtime. While not typically recommended for normal application development, this may occasionally be useful when developing Laravel packages."
msgstr "可以使用 `resolveRelationUsing` 方法來在執行階段定義 Eloquent Model 間的關聯。雖然對於一般的專案開發並不建議這麼做，但在開發 Laravel 套件的時候偶爾會很實用。"

# File: docs/8.x/eloquent-relationships.md, line: 1091
# File: docs/master/eloquent-relationships.md, line: 1091
#. type: Plain text
msgid "The `resolveRelationUsing` method accepts the desired relationship name as its first argument. The second argument passed to the method should be a closure that accepts the model instance and returns a valid Eloquent relationship definition. Typically, you should configure dynamic relationships within the boot method of a [service provider](/docs/{{version}}/providers):"
msgstr "`resolveRelationUsing` 方法接受自訂的關聯名稱作為其第一個引述。第二個傳入該方法的引數應為閉包，該閉包應接受一個 Model 實體並回傳一個有效的 Eloquent 關聯定義。一般來說，應在某個 [Service Provider](/docs/{{version}}/providers) 內的 boot 方法中定義動態關聯。"

# File: docs/8.x/eloquent-relationships.md, line: 1094
# File: docs/master/eloquent-relationships.md, line: 1094
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Order;\n"
"    use App\\Models\\Customer;\n"
msgstr "    use App\\Models\\Order;\n"
"    use App\\Models\\Customer;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1098
# File: docs/master/eloquent-relationships.md, line: 1098
#. type: Plain text
#, no-wrap
msgid "    Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"        return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"    });\n"
msgstr "    Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"        return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"    });\n"

# File: docs/8.x/eloquent-relationships.md, line: 1100
# File: docs/master/eloquent-relationships.md, line: 1100
#. type: Plain text
#, no-wrap
msgid "> {note} When defining dynamic relationships, always provide explicit key name arguments to the Eloquent relationship methods.\n"
msgstr "> {note} 在定義動態關聯時，請總是提供顯式的索引鍵名稱給 Eloquent 關聯方法。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1102
# File: docs/master/eloquent-relationships.md, line: 1102
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-relations\"></a>\n"
msgstr "<a name=\"querying-relations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1102
# File: docs/master/eloquent-relationships.md, line: 1102
#. type: Title ##
#, no-wrap
msgid "Querying Relations"
msgstr "查詢關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1105
# File: docs/master/eloquent-relationships.md, line: 1105
#. type: Plain text
msgid "Since all Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing a query to load the related models. In addition, all types of Eloquent relationships also serve as [query builders](/docs/{{version}}/queries), allowing you to continue to chain constraints onto the relationship query before finally executing the SQL query against your database."
msgstr "由於所有的 Eloquent 關聯都是以方法來定義的，所以我們可以呼叫這些方法來取得關聯的實體，而不需執行查詢來載入關聯的 Model。此外，每種 Eloquent 關聯都可作為 [Query Builder](/docs/{{version}}/queries) 使用，因此我們也能在最終向資料庫執行 SQL 查詢前往關聯查詢串上一些查詢條件。"

# File: docs/8.x/eloquent-relationships.md, line: 1107
# File: docs/master/eloquent-relationships.md, line: 1107
#. type: Plain text
msgid "For example, imagine a blog application in which a `User` model has many associated `Post` models:"
msgstr "舉例來說，假設我們有一個部落格網站，其中 `User` Model 可以關聯到 `Post` Model："

# File: docs/8.x/eloquent-relationships.md, line: 1124
# File: docs/master/eloquent-relationships.md, line: 1124
#. type: Plain text
#, no-wrap
msgid "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts for the user.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->hasMany(Post::class);\n"
"        }\n"
"    }\n"
msgstr "    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts for the user.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->hasMany(Post::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1126
# File: docs/master/eloquent-relationships.md, line: 1126
#. type: Plain text
msgid "You may query the `posts` relationship and add additional constraints to the relationship like so:"
msgstr "我們可以查詢 `posts` 關聯，並在關聯上像這樣加上額外的條件："

# File: docs/8.x/eloquent-relationships.md, line: 1134
# File: docs/master/eloquent-relationships.md, line: 1134
#. type: Plain text
msgid "You are able to use any of the Laravel [query builder's](/docs/{{version}}/queries) methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you."
msgstr "在關聯上我們可以使用任何的 Laravel [Query Builder](/docs/{{version}}/queries) 方法，因此請確保有先閱讀過 Query Builder 的說明文件以瞭解有哪些方法可以使用。"

# File: docs/8.x/eloquent-relationships.md, line: 1136
# File: docs/master/eloquent-relationships.md, line: 1136
#. type: Plain text
#, no-wrap
msgid "<a name=\"chaining-orwhere-clauses-after-relationships\"></a>\n"
msgstr "<a name=\"chaining-orwhere-clauses-after-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1136
# File: docs/master/eloquent-relationships.md, line: 1136
#. type: Title ####
#, no-wrap
msgid "Chaining `orWhere` Clauses After Relationships"
msgstr "在關聯後方串上 `orWhere` 子句"

# File: docs/8.x/eloquent-relationships.md, line: 1139
# File: docs/master/eloquent-relationships.md, line: 1139
#. type: Plain text
msgid "As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, use caution when chaining `orWhere` clauses onto a relationship, as the `orWhere` clauses will be logically grouped at the same level as the relationship constraint:"
msgstr "像上面的範例中一樣，在進行查詢的時候我們可以自由地往關聯新增查詢。不過，在將 `orWhere` 自居串上關聯時要注意，因為 `orWhere` 自居可能會被邏輯性地分組在與關聯條件相同的層級上："

# File: docs/8.x/eloquent-relationships.md, line: 1144
# File: docs/master/eloquent-relationships.md, line: 1144
#. type: Plain text
#, no-wrap
msgid "    $user->posts()\n"
"            ->where('active', 1)\n"
"            ->orWhere('votes', '>=', 100)\n"
"            ->get();\n"
msgstr "    $user->posts()\n"
"            ->where('active', 1)\n"
"            ->orWhere('votes', '>=', 100)\n"
"            ->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1146
# File: docs/master/eloquent-relationships.md, line: 1146
#. type: Plain text
msgid "The example above will generate the following SQL. As you can see, the `or` clause instructs the query to return _any_ user with greater than 100 votes. The query is no longer constrained to a specific user:"
msgstr "上述的例子會產生下列的 SQL。如你所見，`or` 子句會讓查詢回傳 **所有** 大於 100 得票數的使用者。這個查詢不會被限制在任何特定使用者上："

# File: docs/8.x/eloquent-relationships.md, line: 1147
# File: docs/8.x/eloquent-relationships.md, line: 1166
# File: docs/8.x/eloquent-relationships.md, line: 1489
# File: docs/master/eloquent-relationships.md, line: 1147
# File: docs/master/eloquent-relationships.md, line: 1166
# File: docs/master/eloquent-relationships.md, line: 1489
#. type: Code fence info string
#, no-wrap
msgid "sql"
msgstr "sql"

# File: docs/8.x/eloquent-relationships.md, line: 1147
# File: docs/master/eloquent-relationships.md, line: 1147
#. type: Plain text
#, no-wrap
msgid "select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"
msgstr "select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"

# File: docs/8.x/eloquent-relationships.md, line: 1154
# File: docs/master/eloquent-relationships.md, line: 1154
#. type: Plain text
msgid "In most situations, you should use [logical groups](/docs/{{version}}/queries#logical-grouping) to group the conditional checks between parentheses:"
msgstr "在大多數的情況下，應該使用[邏輯群組](/docs/{{version}}/queries#logical-grouping)以將條件檢查放在括號中進行分組："

# File: docs/8.x/eloquent-relationships.md, line: 1156
# File: docs/8.x/eloquent-relationships.md, line: 1210
# File: docs/8.x/eloquent-relationships.md, line: 1250
# File: docs/8.x/eloquent-relationships.md, line: 1258
# File: docs/8.x/eloquent-relationships.md, line: 1294
# File: docs/8.x/eloquent-relationships.md, line: 1311
# File: docs/8.x/eloquent-relationships.md, line: 1335
# File: docs/8.x/eloquent-relationships.md, line: 1346
# File: docs/master/eloquent-relationships.md, line: 1156
# File: docs/master/eloquent-relationships.md, line: 1210
# File: docs/master/eloquent-relationships.md, line: 1250
# File: docs/master/eloquent-relationships.md, line: 1258
# File: docs/master/eloquent-relationships.md, line: 1294
# File: docs/master/eloquent-relationships.md, line: 1311
# File: docs/master/eloquent-relationships.md, line: 1335
# File: docs/master/eloquent-relationships.md, line: 1346
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Builder;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1163
# File: docs/master/eloquent-relationships.md, line: 1163
#. type: Plain text
#, no-wrap
msgid "    $user->posts()\n"
"            ->where(function (Builder $query) {\n"
"                return $query->where('active', 1)\n"
"                             ->orWhere('votes', '>=', 100);\n"
"            })\n"
"            ->get();\n"
msgstr "    $user->posts()\n"
"            ->where(function (Builder $query) {\n"
"                return $query->where('active', 1)\n"
"                             ->orWhere('votes', '>=', 100);\n"
"            })\n"
"            ->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1165
# File: docs/master/eloquent-relationships.md, line: 1165
#. type: Plain text
msgid "The example above will produce the following SQL. Note that the logical grouping has properly grouped the constraints and the query remains constrained to a specific user:"
msgstr "上述的例子會產生下列 SQL。可以注意到，查詢條件已正確地進行邏輯分組，且查詢有保持限制在特定使用者上："

# File: docs/8.x/eloquent-relationships.md, line: 1166
# File: docs/master/eloquent-relationships.md, line: 1166
#. type: Plain text
#, no-wrap
msgid "select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"
msgstr "select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"

# File: docs/8.x/eloquent-relationships.md, line: 1173
# File: docs/master/eloquent-relationships.md, line: 1173
#. type: Plain text
#, no-wrap
msgid "<a name=\"relationship-methods-vs-dynamic-properties\"></a>\n"
msgstr "<a name=\"relationship-methods-vs-dynamic-properties\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1173
# File: docs/master/eloquent-relationships.md, line: 1173
#. type: Title ###
#, no-wrap
msgid "Relationship Methods Vs. Dynamic Properties"
msgstr "關聯方法 V.s. 動態屬性"

# File: docs/8.x/eloquent-relationships.md, line: 1176
# File: docs/master/eloquent-relationships.md, line: 1176
#. type: Plain text
msgid "If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it were a property. For example, continuing to use our `User` and `Post` example models, we may access all of a user's posts like so:"
msgstr "若不想在 Eloquent 關聯查詢上新增任何額外的查詢條件，則可以直接將關聯作為屬性一樣存取。舉例來說，接續使用我們的 `User` 與 `Post` 範例 Model，我們可以像這樣存取 User 的所有 Post："

# File: docs/8.x/eloquent-relationships.md, line: 1184
# File: docs/master/eloquent-relationships.md, line: 1184
#. type: Plain text
#, no-wrap
msgid "    foreach ($user->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr "    foreach ($user->posts as $post) {\n"
"        //\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1186
# File: docs/master/eloquent-relationships.md, line: 1186
#. type: Plain text
msgid "Dynamic relationship properties perform \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use [eager loading](#eager-loading) to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations."
msgstr "動態屬性會被「延遲載入 (Lazy Loading)」，這表示，這些關聯資料只有在實際存取的時候才會被載入。也因此，開發人員常常會使用[積極式載入](#eager-loading)來預先載入稍後會被存取的關聯。使用預先載入，就可以顯著地降低許多在載入 Model 關聯時會被執行的 SQL 查詢。"

# File: docs/8.x/eloquent-relationships.md, line: 1188
# File: docs/master/eloquent-relationships.md, line: 1188
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-relationship-existence\"></a>\n"
msgstr "<a name=\"querying-relationship-existence\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1188
# File: docs/master/eloquent-relationships.md, line: 1188
#. type: Title ###
#, no-wrap
msgid "Querying Relationship Existence"
msgstr "查詢存在的關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1191
# File: docs/master/eloquent-relationships.md, line: 1191
#. type: Plain text
msgid "When retrieving model records, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the `has` and `orHas` methods:"
msgstr "在取得 Model 紀錄時，我們可能會想依據關聯是否存在來限制查詢結果。舉例來說，假設我們想取得所有至少有一篇留言的部落格貼文。為此，我們可以將關聯的名稱傳入 `has` 或 `orHas` 方法中："

# File: docs/8.x/eloquent-relationships.md, line: 1196
# File: docs/master/eloquent-relationships.md, line: 1196
#. type: Plain text
#, no-wrap
msgid "    // Retrieve all posts that have at least one comment...\n"
"    $posts = Post::has('comments')->get();\n"
msgstr "    // 取得所有至少有一篇留言的文章...\n"
"    $posts = Post::has('comments')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1198
# File: docs/master/eloquent-relationships.md, line: 1198
#. type: Plain text
msgid "You may also specify an operator and count value to further customize the query:"
msgstr "我們也可以指定一個運算子與總數來進一步自訂查詢："

# File: docs/8.x/eloquent-relationships.md, line: 1201
# File: docs/master/eloquent-relationships.md, line: 1201
#. type: Plain text
#, no-wrap
msgid "    // Retrieve all posts that have three or more comments...\n"
"    $posts = Post::has('comments', '>=', 3)->get();\n"
msgstr "    // 取得所有至少有 3 篇留言的文章...\n"
"    $posts = Post::has('comments', '>=', 3)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1203
# File: docs/master/eloquent-relationships.md, line: 1203
#. type: Plain text
msgid "Nested `has` statements may be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment that has at least one image:"
msgstr "可以使用「點 (.)」標記法來撰寫巢狀的 `has` 陳述式。舉例來說，我們可以取得所有至少有一篇含有圖片的留言的部落格貼文："

# File: docs/8.x/eloquent-relationships.md, line: 1206
# File: docs/master/eloquent-relationships.md, line: 1206
#. type: Plain text
#, no-wrap
msgid "    // Retrieve posts that have at least one comment with images...\n"
"    $posts = Post::has('comments.images')->get();\n"
msgstr "    // 取得至少有一篇有圖片的留言的部落格貼文...\n"
"    $posts = Post::has('comments.images')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1208
# File: docs/master/eloquent-relationships.md, line: 1208
#. type: Plain text
msgid "If you need even more power, you may use the `whereHas` and `orWhereHas` methods to define additional query constraints on your `has` queries, such as inspecting the content of a comment:"
msgstr "若需要更多功能，可以使用 `whereHas` 或 `orWhereHas` 方法來在 `has` 查詢上定義額外的查詢條件，如檢查留言的內容等："

# File: docs/8.x/eloquent-relationships.md, line: 1215
# File: docs/master/eloquent-relationships.md, line: 1215
#. type: Plain text
#, no-wrap
msgid "    // Retrieve posts with at least one comment containing words like code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr "    // 取得所有至少有一篇留言的內容 like code% 的貼文...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1220
# File: docs/master/eloquent-relationships.md, line: 1220
#. type: Plain text
#, no-wrap
msgid "    // Retrieve posts with at least ten comments containing words like code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }, '>=', 10)->get();\n"
msgstr "    // 取得所有至少有 10 篇留言的內容 like code% 的貼文...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }, '>=', 10)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1222
# File: docs/master/eloquent-relationships.md, line: 1222
#. type: Plain text
#, no-wrap
msgid "> {note} Eloquent does not currently support querying for relationship existence across databases. The relationships must exist within the same database.\n"
msgstr "> {note} 由於 Eloquent 目前並不支援在多個資料庫間查詢關聯的存否，因此要查詢的關聯必須在同一個資料庫中。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1224
# File: docs/master/eloquent-relationships.md, line: 1224
#. type: Plain text
#, no-wrap
msgid "<a name=\"inline-relationship-existence-queries\"></a>\n"
msgstr "<a name=\"inline-relationship-existence-queries\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1224
# File: docs/master/eloquent-relationships.md, line: 1224
#. type: Title ####
#, no-wrap
msgid "Inline Relationship Existence Queries"
msgstr "內嵌的存在關聯查詢"

# File: docs/8.x/eloquent-relationships.md, line: 1227
# File: docs/master/eloquent-relationships.md, line: 1227
#. type: Plain text
msgid "If you would like to query for a relationship's existence with a single, simple where condition attached to the relationship query, you may find it more convenient to use the `whereRelation` and `whereMorphRelation` methods. For example, we may query for all posts that have unapproved comments:"
msgstr "若想要使用附加在關聯查詢上的簡單且單一的 Where 條件來查詢關聯的存否，那麼用 `whereRelation` 與 `whereMorphRelation` 方法應該會很方便。舉例來說，我們可以查詢所有有未審核 (Unapproved) 留言的貼文："

# File: docs/8.x/eloquent-relationships.md, line: 1231
# File: docs/master/eloquent-relationships.md, line: 1231
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereRelation('comments', 'is_approved', false)->get();\n"
msgstr "    $posts = Post::whereRelation('comments', 'is_approved', false)->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1233
# File: docs/master/eloquent-relationships.md, line: 1233
#. type: Plain text
msgid "Of course, like calls to the query builder's `where` method, you may also specify an operator:"
msgstr "當然，就像呼叫 Query Builder 的 `where` 方法一樣，我們也可以指定運算子："

# File: docs/8.x/eloquent-relationships.md, line: 1237
# File: docs/master/eloquent-relationships.md, line: 1237
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereRelation(\n"
"        'comments', 'created_at', '>=', now()->subHour()\n"
"    )->get();\n"
msgstr "    $posts = Post::whereRelation(\n"
"        'comments', 'created_at', '>=', now()->subHour()\n"
"    )->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1239
# File: docs/master/eloquent-relationships.md, line: 1239
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-relationship-absence\"></a>\n"
msgstr "<a name=\"querying-relationship-absence\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1239
# File: docs/master/eloquent-relationships.md, line: 1239
#. type: Title ###
#, no-wrap
msgid "Querying Relationship Absence"
msgstr "查詢不存在的關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1242
# File: docs/master/eloquent-relationships.md, line: 1242
#. type: Plain text
msgid "When retrieving model records, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that **don't** have any comments. To do so, you may pass the name of the relationship to the `doesntHave` and `orDoesntHave` methods:"
msgstr "在取得 Model 紀錄時，我們可能會想依據關聯的是否不存在來限制查詢結果。舉例來說，假設我們想取得所有 **沒有** 留言的部落格貼文。為此，我們可以將關聯的名稱傳入 `doesntHave` 或 `orDoesntHave` 方法中："

# File: docs/8.x/eloquent-relationships.md, line: 1246
# File: docs/master/eloquent-relationships.md, line: 1246
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::doesntHave('comments')->get();\n"
msgstr "    $posts = Post::doesntHave('comments')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1248
# File: docs/master/eloquent-relationships.md, line: 1248
#. type: Plain text
msgid "If you need even more power, you may use the `whereDoesntHave` and `orWhereDoesntHave` methods to add additional query constraints to your `doesntHave` queries, such as inspecting the content of a comment:"
msgstr "若需要更多功能，可以使用 `whereDoesntHave` 或 `orWhereDoesntHave` 方法來在 `doesntHave` 查詢上加上額外的查詢條件，如檢查留言的內容等："

# File: docs/8.x/eloquent-relationships.md, line: 1254
# File: docs/master/eloquent-relationships.md, line: 1254
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr "    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1256
# File: docs/master/eloquent-relationships.md, line: 1256
#. type: Plain text
msgid "You may use \"dot\" notation to execute a query against a nested relationship. For example, the following query will retrieve all posts that do not have comments; however, posts that have comments from authors that are not banned will be included in the results:"
msgstr "我們也可以使用「點 (.)」標記法來對巢狀關聯進行查詢。舉例來說，下列查詢會取得所有沒有留言的貼文。不過，具有未禁言作者發表留言的文章也會被包含在結果裡面："

# File: docs/8.x/eloquent-relationships.md, line: 1262
# File: docs/master/eloquent-relationships.md, line: 1262
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\n"
"        $query->where('banned', 0);\n"
"    })->get();\n"
msgstr "    $posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\n"
"        $query->where('banned', 0);\n"
"    })->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1264
# File: docs/master/eloquent-relationships.md, line: 1264
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-morph-to-relationships\"></a>\n"
msgstr "<a name=\"querying-morph-to-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1264
# File: docs/master/eloquent-relationships.md, line: 1264
#. type: Title ###
#, no-wrap
msgid "Querying Morph To Relationships"
msgstr "查詢 Morph To 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1267
# File: docs/master/eloquent-relationships.md, line: 1267
#. type: Plain text
msgid "To query the existence of \"morph to\" relationships, you may use the `whereHasMorph` and `whereDoesntHaveMorph` methods. These methods accept the name of the relationship as their first argument. Next, the methods accept the names of the related models that you wish to include in the query. Finally, you may provide a closure which customizes the relationship query:"
msgstr "若要查詢「Morph To」關聯是否存在，可以使用 `whereHasMorph` 或 `whereDoesntHaveMorph` 方法。這些方法都接受關聯名稱作為其第一個引數。接著，這個方法還接受要被包含在查詢裡的關聯 Model 名稱。最後，我們還可以提供用來自訂關聯查詢的閉包："

# File: docs/8.x/eloquent-relationships.md, line: 1272
# File: docs/master/eloquent-relationships.md, line: 1272
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
"    use App\\Models\\Video;\n"
"    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr "    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
"    use App\\Models\\Video;\n"
"    use Illuminate\\Database\\Eloquent\\Builder;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1281
# File: docs/master/eloquent-relationships.md, line: 1281
#. type: Plain text
#, no-wrap
msgid "    // Retrieve comments associated to posts or videos with a title like code%...\n"
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr "    // 取得有關聯到貼文或影片的留言，且留言標題 like code%...\n"
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1290
# File: docs/master/eloquent-relationships.md, line: 1290
#. type: Plain text
#, no-wrap
msgid "    // Retrieve comments associated to posts with a title not like code%...\n"
"    $comments = Comment::whereDoesntHaveMorph(\n"
"        'commentable',\n"
"        Post::class,\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr "    // 取得有關聯到貼文或影片的留言，且留言標題 not like code%...\n"
"    $comments = Comment::whereDoesntHaveMorph(\n"
"        'commentable',\n"
"        Post::class,\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1292
# File: docs/master/eloquent-relationships.md, line: 1292
#. type: Plain text
msgid "You may occasionally need to add query constraints based on the \"type\" of the related polymorphic model. The closure passed to the `whereHasMorph` method may receive a `$type` value as its second argument. This argument allows you to inspect the \"type\" of the query that is being built:"
msgstr "有時候，我們可能會想依據多型關聯 Model 的「類型」來新增查詢條件。傳給 `whereHasMorph` 方法的閉包可接受一個 `$type` 值作為其第二個引述。使用 `$type`引述，就可以檢查正在建立的查詢是什麼「類型」："

# File: docs/8.x/eloquent-relationships.md, line: 1300
# File: docs/master/eloquent-relationships.md, line: 1300
#. type: Plain text
#, no-wrap
msgid "    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query, $type) {\n"
"            $column = $type === Post::class ? 'content' : 'title';\n"
msgstr "    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query, $type) {\n"
"            $column = $type === Post::class ? 'content' : 'title';\n"

# File: docs/8.x/eloquent-relationships.md, line: 1304
# File: docs/master/eloquent-relationships.md, line: 1304
#. type: Plain text
#, no-wrap
msgid "            $query->where($column, 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr "            $query->where($column, 'like', 'code%');\n"
"        }\n"
"    )->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1306
# File: docs/master/eloquent-relationships.md, line: 1306
#. type: Plain text
#, no-wrap
msgid "<a name=\"querying-all-morph-to-related-models\"></a>\n"
msgstr "<a name=\"querying-all-morph-to-related-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1306
# File: docs/master/eloquent-relationships.md, line: 1306
#. type: Title ####
#, no-wrap
msgid "Querying All Related Models"
msgstr "查詢所有關聯的 Model"

# File: docs/8.x/eloquent-relationships.md, line: 1309
# File: docs/master/eloquent-relationships.md, line: 1309
#. type: Plain text
msgid "Instead of passing an array of possible polymorphic models, you may provide `*` as a wildcard value. This will instruct Laravel to retrieve all of the possible polymorphic types from the database. Laravel will execute an additional query in order to perform this operation:"
msgstr "我們可以提供 `*` 作為萬用字元，而不需以陣列列出所有可能的多型 Model。這樣以來 Laravel 就會從資料庫中取得所有可能的多型類型。Laravel 會執行一個額外的查詢來進行此行動："

# File: docs/8.x/eloquent-relationships.md, line: 1315
# File: docs/master/eloquent-relationships.md, line: 1315
#. type: Plain text
#, no-wrap
msgid "    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\n"
"        $query->where('title', 'like', 'foo%');\n"
"    })->get();\n"
msgstr "    $comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\n"
"        $query->where('title', 'like', 'foo%');\n"
"    })->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1317
# File: docs/master/eloquent-relationships.md, line: 1317
#. type: Plain text
#, no-wrap
msgid "<a name=\"aggregating-related-models\"></a>\n"
msgstr "<a name=\"aggregating-related-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1317
# File: docs/master/eloquent-relationships.md, line: 1317
#. type: Title ##
#, no-wrap
msgid "Aggregating Related Models"
msgstr "彙總關聯的 Model"

# File: docs/8.x/eloquent-relationships.md, line: 1320
# File: docs/master/eloquent-relationships.md, line: 1320
#. type: Plain text
#, no-wrap
msgid "<a name=\"counting-related-models\"></a>\n"
msgstr "<a name=\"counting-related-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1320
# File: docs/master/eloquent-relationships.md, line: 1320
#. type: Title ###
#, no-wrap
msgid "Counting Related Models"
msgstr "計數關聯的 Model"

# File: docs/8.x/eloquent-relationships.md, line: 1323
# File: docs/master/eloquent-relationships.md, line: 1323
#. type: Plain text
msgid "Sometimes you may want to count the number of related models for a given relationship without actually loading the models. To accomplish this, you may use the `withCount` method. The `withCount` method will place a `{relation}_count` attribute on the resulting models:"
msgstr "有時候我們可能會想知道給定關聯中關聯 Model 的數量，但又不想真正載入這些 Model。為此，我們可以使用 `withCount` 方法。`withCount` 方法會在查詢結果的 Model 中加上一個 `{關聯}_count` 屬性："

# File: docs/8.x/eloquent-relationships.md, line: 1327
# File: docs/master/eloquent-relationships.md, line: 1327
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::withCount('comments')->get();\n"
msgstr "    $posts = Post::withCount('comments')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1331
# File: docs/master/eloquent-relationships.md, line: 1331
#. type: Plain text
#, no-wrap
msgid "    foreach ($posts as $post) {\n"
"        echo $post->comments_count;\n"
"    }\n"
msgstr "    foreach ($posts as $post) {\n"
"        echo $post->comments_count;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1333
# File: docs/master/eloquent-relationships.md, line: 1333
#. type: Plain text
msgid "By passing an array to the `withCount` method, you may add the \"counts\" for multiple relations as well as add additional constraints to the queries:"
msgstr "只要將陣列傳入 `withCount` 方法，就可以為多個關聯「計數」，或是在查詢上加上額外的查詢條件："

# File: docs/8.x/eloquent-relationships.md, line: 1339
# File: docs/master/eloquent-relationships.md, line: 1339
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }])->get();\n"
msgstr "    $posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1342
# File: docs/master/eloquent-relationships.md, line: 1342
#. type: Plain text
#, no-wrap
msgid "    echo $posts[0]->votes_count;\n"
"    echo $posts[0]->comments_count;\n"
msgstr "    echo $posts[0]->votes_count;\n"
"    echo $posts[0]->comments_count;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1344
# File: docs/master/eloquent-relationships.md, line: 1344
#. type: Plain text
msgid "You may also alias the relationship count result, allowing multiple counts on the same relationship:"
msgstr "也可以為關聯總數結果加上別名，這樣就能對單一關聯計算多次數量："

# File: docs/8.x/eloquent-relationships.md, line: 1353
# File: docs/master/eloquent-relationships.md, line: 1353
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::withCount([\n"
"        'comments',\n"
"        'comments as pending_comments_count' => function (Builder $query) {\n"
"            $query->where('approved', false);\n"
"        },\n"
"    ])->get();\n"
msgstr "    $posts = Post::withCount([\n"
"        'comments',\n"
"        'comments as pending_comments_count' => function (Builder $query) {\n"
"            $query->where('approved', false);\n"
"        },\n"
"    ])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1356
# File: docs/master/eloquent-relationships.md, line: 1356
#. type: Plain text
#, no-wrap
msgid "    echo $posts[0]->comments_count;\n"
"    echo $posts[0]->pending_comments_count;\n"
msgstr "    echo $posts[0]->comments_count;\n"
"    echo $posts[0]->pending_comments_count;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1358
# File: docs/master/eloquent-relationships.md, line: 1358
#. type: Plain text
#, no-wrap
msgid "<a name=\"deferred-count-loading\"></a>\n"
msgstr "<a name=\"deferred-count-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1358
# File: docs/8.x/eloquent-relationships.md, line: 1434
# File: docs/master/eloquent-relationships.md, line: 1358
# File: docs/master/eloquent-relationships.md, line: 1434
#. type: Title ####
#, no-wrap
msgid "Deferred Count Loading"
msgstr "延後 (Deferred) 數量計算的載入"

# File: docs/8.x/eloquent-relationships.md, line: 1361
# File: docs/master/eloquent-relationships.md, line: 1361
#. type: Plain text
msgid "Using the `loadCount` method, you may load a relationship count after the parent model has already been retrieved:"
msgstr "使用 `loadCount` 方法，就可以在上層 Model 已經載入後再接著載入關聯的計數："

# File: docs/8.x/eloquent-relationships.md, line: 1363
# File: docs/master/eloquent-relationships.md, line: 1363
#. type: Plain text
#, no-wrap
msgid "    $book = Book::first();\n"
msgstr "    $book = Book::first();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1365
# File: docs/master/eloquent-relationships.md, line: 1365
#. type: Plain text
#, no-wrap
msgid "    $book->loadCount('genres');\n"
msgstr "    $book->loadCount('genres');\n"

# File: docs/8.x/eloquent-relationships.md, line: 1367
# File: docs/master/eloquent-relationships.md, line: 1367
#. type: Plain text
msgid "If you need to set additional query constraints on the count query, you may pass an array keyed by the relationships you wish to count. The array values should be closures which receive the query builder instance:"
msgstr "若想在計數查詢上設定額外的查詢條件，可以傳入一組陣列，其索引鍵應為要計數的關聯。陣列的值則為一個閉包，用來接收 Query Builder 實體："

# File: docs/8.x/eloquent-relationships.md, line: 1371
# File: docs/master/eloquent-relationships.md, line: 1371
#. type: Plain text
#, no-wrap
msgid "    $book->loadCount(['reviews' => function ($query) {\n"
"        $query->where('rating', 5);\n"
"    }])\n"
msgstr "    $book->loadCount(['reviews' => function ($query) {\n"
"        $query->where('rating', 5);\n"
"    }])\n"

# File: docs/8.x/eloquent-relationships.md, line: 1373
# File: docs/master/eloquent-relationships.md, line: 1373
#. type: Plain text
#, no-wrap
msgid "<a name=\"relationship-counting-and-custom-select-statements\"></a>\n"
msgstr "<a name=\"relationship-counting-and-custom-select-statements\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1373
# File: docs/master/eloquent-relationships.md, line: 1373
#. type: Title ####
#, no-wrap
msgid "Relationship Counting & Custom Select Statements"
msgstr "關聯計數與自訂 Select 陳述式"

# File: docs/8.x/eloquent-relationships.md, line: 1376
# File: docs/master/eloquent-relationships.md, line: 1376
#. type: Plain text
msgid "If you're combining `withCount` with a `select` statement, ensure that you call `withCount` after the `select` method:"
msgstr "若想組合使用 `withCount` 與 `select` 陳述式，請在 `select` 方法後再呼叫 `withCount`："

# File: docs/8.x/eloquent-relationships.md, line: 1380
# File: docs/master/eloquent-relationships.md, line: 1380
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::select(['title', 'body'])\n"
"                    ->withCount('comments')\n"
"                    ->get();\n"
msgstr "    $posts = Post::select(['title', 'body'])\n"
"                    ->withCount('comments')\n"
"                    ->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1382
# File: docs/master/eloquent-relationships.md, line: 1382
#. type: Plain text
#, no-wrap
msgid "<a name=\"other-aggregate-functions\"></a>\n"
msgstr "<a name=\"other-aggregate-functions\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1382
# File: docs/master/eloquent-relationships.md, line: 1382
#. type: Title ###
#, no-wrap
msgid "Other Aggregate Functions"
msgstr "其他彙總函式"

# File: docs/8.x/eloquent-relationships.md, line: 1385
# File: docs/master/eloquent-relationships.md, line: 1385
#. type: Plain text
msgid "In addition to the `withCount` method, Eloquent provides `withMin`, `withMax`, `withAvg`, `withSum`, and `withExists` methods. These methods will place a `{relation}_{function}_{column}` attribute on your resulting models:"
msgstr "除了 `withCount` 方法外，Eloquent 也提供了 `withMin`, `withMax`, `withAvg`, `withSum`, 與 `withExists` 等方法。這些方法會在查詢結果的 Model 上加上一個  `{關聯}_{函式}_{欄位}` 屬性："

# File: docs/8.x/eloquent-relationships.md, line: 1389
# File: docs/master/eloquent-relationships.md, line: 1389
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::withSum('comments', 'votes')->get();\n"
msgstr "    $posts = Post::withSum('comments', 'votes')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1393
# File: docs/master/eloquent-relationships.md, line: 1393
#. type: Plain text
#, no-wrap
msgid "    foreach ($posts as $post) {\n"
"        echo $post->comments_sum_votes;\n"
"    }\n"
msgstr "    foreach ($posts as $post) {\n"
"        echo $post->comments_sum_votes;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1395
# File: docs/master/eloquent-relationships.md, line: 1395
#. type: Plain text
msgid "If you wish to access the result of the aggregate function using another name, you may specify your own alias:"
msgstr "若想使用另一個名稱來存取彙總函式的結果，可自行指定別名："

# File: docs/8.x/eloquent-relationships.md, line: 1397
# File: docs/master/eloquent-relationships.md, line: 1397
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::withSum('comments as total_comments', 'votes')->get();\n"
msgstr "    $posts = Post::withSum('comments as total_comments', 'votes')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1401
# File: docs/master/eloquent-relationships.md, line: 1401
#. type: Plain text
#, no-wrap
msgid "    foreach ($posts as $post) {\n"
"        echo $post->total_comments;\n"
"    }\n"
msgstr "    foreach ($posts as $post) {\n"
"        echo $post->total_comments;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1403
# File: docs/master/eloquent-relationships.md, line: 1403
#. type: Plain text
msgid "Like the `loadCount` method, deferred versions of these methods are also available. These additional aggregate operations may be performed on Eloquent models that have already been retrieved:"
msgstr "與 `loadCount` 方法類似，Eloquent 中也有這些方法的延遲 (Deferred) 版本。可以在已經取得的 Eloquent Model 上進行這些額外的彙總運算："

# File: docs/8.x/eloquent-relationships.md, line: 1405
# File: docs/master/eloquent-relationships.md, line: 1405
#. type: Plain text
#, no-wrap
msgid "    $post = Post::first();\n"
msgstr "    $post = Post::first();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1407
# File: docs/master/eloquent-relationships.md, line: 1407
#. type: Plain text
#, no-wrap
msgid "    $post->loadSum('comments', 'votes');\n"
msgstr "    $post->loadSum('comments', 'votes');\n"

# File: docs/8.x/eloquent-relationships.md, line: 1409
# File: docs/master/eloquent-relationships.md, line: 1409
#. type: Plain text
msgid "If you're combining these aggregate methods with a `select` statement, ensure that you call the aggregate methods after the `select` method:"
msgstr "若想組合使用這些彙總與 `select` 陳述式，請在 `select` 方法後再呼叫這些彙總函式："

# File: docs/8.x/eloquent-relationships.md, line: 1413
# File: docs/master/eloquent-relationships.md, line: 1413
#. type: Plain text
#, no-wrap
msgid "    $posts = Post::select(['title', 'body'])\n"
"                    ->withExists('comments')\n"
"                    ->get();\n"
msgstr "    $posts = Post::select(['title', 'body'])\n"
"                    ->withExists('comments')\n"
"                    ->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1415
# File: docs/master/eloquent-relationships.md, line: 1415
#. type: Plain text
#, no-wrap
msgid "<a name=\"counting-related-models-on-morph-to-relationships\"></a>\n"
msgstr "<a name=\"counting-related-models-on-morph-to-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1415
# File: docs/master/eloquent-relationships.md, line: 1415
#. type: Title ###
#, no-wrap
msgid "Counting Related Models On Morph To Relationships"
msgstr "在 Morph To 關聯上計算關聯 Model 的數量"

# File: docs/8.x/eloquent-relationships.md, line: 1418
# File: docs/master/eloquent-relationships.md, line: 1418
#. type: Plain text
msgid "If you would like to eager load a \"morph to\" relationship, as well as related model counts for the various entities that may be returned by that relationship, you may utilize the `with` method in combination with the `morphTo` relationship's `morphWithCount` method."
msgstr "若想積極式載入「Morph to」關聯、或是關聯 Model 計數等由關聯回傳的功能，可以使用 `morphTo` 關聯的 `morphWithCount` 方法，並搭配 `with` 方法使用。"

# File: docs/8.x/eloquent-relationships.md, line: 1420
# File: docs/master/eloquent-relationships.md, line: 1420
#. type: Plain text
msgid "In this example, let's assume that `Photo` and `Post` models may create `ActivityFeed` models. We will assume the `ActivityFeed` model defines a \"morph to\" relationship named `parentable` that allows us to retrieve the parent `Photo` or `Post` model for a given `ActivityFeed` instance. Additionally, let's assume that `Photo` models \"have many\" `Tag` models and `Post` models \"have many\" `Comment` models."
msgstr "在這個例子中，我們假設 `Photo` 與 `Post` Model 會建立 `ActivityFeed` Model。假設 `ActivityFeed` Model 定義一個名為  `parentable` 的「Morph to」關聯，可讓使用者在某一 `ActivityFeed` 實體上取得上層的 `Photo` 或 `Post` Model。此外，我們也假設 `Photo` Model「Have Many (有多個)」 `Tag` Model，而 `Post` Model「Have Many」`Comment` Model。"

# File: docs/8.x/eloquent-relationships.md, line: 1422
# File: docs/master/eloquent-relationships.md, line: 1422
#. type: Plain text
msgid "Now, let's imagine we want to retrieve `ActivityFeed` instances and eager load the `parentable` parent models for each `ActivityFeed` instance. In addition, we want to retrieve the number of tags that are associated with each parent photo and the number of comments that are associated with each parent post:"
msgstr "接著，來假設我們現在要去的 `ActivityFeed` 實體，並為取得的每個 `ActivityFeed` 實體積極式載入 `parentable` 上層 Model。此外，我們也想知道上層的每張圖片各有多少個 Tag、還有上層的每篇貼文各有多少則留言："

# File: docs/8.x/eloquent-relationships.md, line: 1424
# File: docs/8.x/eloquent-relationships.md, line: 1534
# File: docs/master/eloquent-relationships.md, line: 1424
# File: docs/master/eloquent-relationships.md, line: 1534
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1432
# File: docs/master/eloquent-relationships.md, line: 1432
#. type: Plain text
#, no-wrap
msgid "    $activities = ActivityFeed::with([\n"
"        'parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWithCount([\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['comments'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr "    $activities = ActivityFeed::with([\n"
"        'parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWithCount([\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['comments'],\n"
"            ]);\n"
"        }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1434
# File: docs/master/eloquent-relationships.md, line: 1434
#. type: Plain text
#, no-wrap
msgid "<a name=\"morph-to-deferred-count-loading\"></a>\n"
msgstr "<a name=\"morph-to-deferred-count-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1437
# File: docs/master/eloquent-relationships.md, line: 1437
#. type: Plain text
msgid "Let's assume we have already retrieved a set of `ActivityFeed` models and now we would like to load the nested relationship counts for the various `parentable` models associated with the activity feeds. You may use the `loadMorphCount` method to accomplish this:"
msgstr "假設我們已經取得 `ActivityFeed` Model (活動摘要)，接著，我們想要載入與活動摘要關聯的各種 `parentable` Model 的巢狀關聯數量。我們可以使用 `loadMorphCount` 方法來完成："

# File: docs/8.x/eloquent-relationships.md, line: 1439
# File: docs/master/eloquent-relationships.md, line: 1439
#. type: Plain text
#, no-wrap
msgid "    $activities = ActivityFeed::with('parentable')->get();\n"
msgstr "    $activities = ActivityFeed::with('parentable')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1444
# File: docs/master/eloquent-relationships.md, line: 1444
#. type: Plain text
#, no-wrap
msgid "    $activities->loadMorphCount('parentable', [\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['comments'],\n"
"    ]);\n"
msgstr "    $activities->loadMorphCount('parentable', [\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['comments'],\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1446
# File: docs/master/eloquent-relationships.md, line: 1446
#. type: Plain text
#, no-wrap
msgid "<a name=\"eager-loading\"></a>\n"
msgstr "<a name=\"eager-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1446
# File: docs/master/eloquent-relationships.md, line: 1446
#. type: Title ##
#, no-wrap
msgid "Eager Loading"
msgstr "積極式載入"

# File: docs/8.x/eloquent-relationships.md, line: 1449
# File: docs/master/eloquent-relationships.md, line: 1449
#. type: Plain text
msgid "When accessing Eloquent relationships as properties, the related models are \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the \"N + 1\" query problem. To illustrate the N + 1 query problem, consider a `Book` model that \"belongs to\" to an `Author` model:"
msgstr "以屬性方式存取 Eloquent 關聯時，關聯的 Model 會被「消極式載入 (Lazy Load)」。這表示，直到首次存取該屬性前，關聯資料都不會被載入。不過，Eloquent 也可以在查詢上層 Model 時就「積極式載入 (Eager Load)」關聯。積極式載入可以減少「N + 1」問題。為了示範什麼是 N + 1 問題，我們先假設有個「隸屬於 (Belongs to)」`Author` Model 的 `Book` Model："

# File: docs/8.x/eloquent-relationships.md, line: 1466
# File: docs/master/eloquent-relationships.md, line: 1466
#. type: Plain text
#, no-wrap
msgid "    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
"    }\n"
msgstr "    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1468
# File: docs/master/eloquent-relationships.md, line: 1468
#. type: Plain text
msgid "Now, let's retrieve all books and their authors:"
msgstr "現在，我們來取得所有書籍與其作者："

# File: docs/8.x/eloquent-relationships.md, line: 1470
# File: docs/8.x/eloquent-relationships.md, line: 1644
# File: docs/master/eloquent-relationships.md, line: 1470
# File: docs/master/eloquent-relationships.md, line: 1644
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Book;\n"
msgstr "    use App\\Models\\Book;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1472
# File: docs/8.x/eloquent-relationships.md, line: 1646
# File: docs/master/eloquent-relationships.md, line: 1472
# File: docs/master/eloquent-relationships.md, line: 1646
#. type: Plain text
#, no-wrap
msgid "    $books = Book::all();\n"
msgstr "    $books = Book::all();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1476
# File: docs/8.x/eloquent-relationships.md, line: 1486
# File: docs/master/eloquent-relationships.md, line: 1476
# File: docs/master/eloquent-relationships.md, line: 1486
#. type: Plain text
#, no-wrap
msgid "    foreach ($books as $book) {\n"
"        echo $book->author->name;\n"
"    }\n"
msgstr "    foreach ($books as $book) {\n"
"        echo $book->author->name;\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1478
# File: docs/master/eloquent-relationships.md, line: 1478
#. type: Plain text
msgid "This loop will execute one query to retrieve all of the books within the database table, then another query for each book in order to retrieve the book's author. So, if we have 25 books, the code above would run 26 queries: one for the original book, and 25 additional queries to retrieve the author of each book."
msgstr "這個迴圈會執行一個查詢來取得資料表中所有的書籍，然後每本書都會再執行一個查詢來取得書籍的作者。因此，若我們有 25 本書，上述程式碼就會執行 26 筆資料庫查詢：1 個查詢來取得書籍，另外 25 個額外的查詢來取得每本書的作者。"

# File: docs/8.x/eloquent-relationships.md, line: 1480
# File: docs/master/eloquent-relationships.md, line: 1480
#. type: Plain text
msgid "Thankfully, we can use eager loading to reduce this operation to just two queries. When building a query, you may specify which relationships should be eager loaded using the `with` method:"
msgstr "幸好，我們可以使用積極式載入來把這一連串行動降低為只需要 2 個查詢。在建立查詢時，可以使用 `with` 方法來指定哪個關聯要被積極式載入："

# File: docs/8.x/eloquent-relationships.md, line: 1482
# File: docs/master/eloquent-relationships.md, line: 1482
#. type: Plain text
#, no-wrap
msgid "    $books = Book::with('author')->get();\n"
msgstr "    $books = Book::with('author')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1488
# File: docs/master/eloquent-relationships.md, line: 1488
#. type: Plain text
msgid "For this operation, only two queries will be executed - one query to retrieve all of the books and one query to retrieve all of the authors for all of the books:"
msgstr "這樣一來，就只會執行 2 個查詢 —— 一個查詢去的所有的書籍，另一個查詢則取得所有書籍的作者。"

# File: docs/8.x/eloquent-relationships.md, line: 1489
# File: docs/master/eloquent-relationships.md, line: 1489
#. type: Plain text
#, no-wrap
msgid "select * from books\n\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"
msgstr "select * from books\n\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"

# File: docs/8.x/eloquent-relationships.md, line: 1496
# File: docs/master/eloquent-relationships.md, line: 1496
#. type: Plain text
#, no-wrap
msgid "<a name=\"eager-loading-multiple-relationships\"></a>\n"
msgstr "<a name=\"eager-loading-multiple-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1496
# File: docs/master/eloquent-relationships.md, line: 1496
#. type: Title ####
#, no-wrap
msgid "Eager Loading Multiple Relationships"
msgstr "積極式載入多個關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1499
# File: docs/master/eloquent-relationships.md, line: 1499
#. type: Plain text
msgid "Sometimes you may need to eager load several different relationships. To do so, just pass an array of relationships to the `with` method:"
msgstr "有時候，我們可能需要積極式載入多個不同的關聯。要載入多個不同的關聯，只需要傳入一組包含關聯的陣列給 `with` 方法即可："

# File: docs/8.x/eloquent-relationships.md, line: 1501
# File: docs/master/eloquent-relationships.md, line: 1501
#. type: Plain text
#, no-wrap
msgid "    $books = Book::with(['author', 'publisher'])->get();\n"
msgstr "    $books = Book::with(['author', 'publisher'])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1503
# File: docs/master/eloquent-relationships.md, line: 1503
#. type: Plain text
#, no-wrap
msgid "<a name=\"nested-eager-loading\"></a>\n"
msgstr "<a name=\"nested-eager-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1503
# File: docs/master/eloquent-relationships.md, line: 1503
#. type: Title ####
#, no-wrap
msgid "Nested Eager Loading"
msgstr "巢狀積極式載入"

# File: docs/8.x/eloquent-relationships.md, line: 1506
# File: docs/master/eloquent-relationships.md, line: 1506
#. type: Plain text
msgid "To eager load a relationship's relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts:"
msgstr "若要積極載入關聯的關聯，可以使用「點 (.)」標記法。舉例來說，讓我們來積極載入所有書籍的作者，以及所有作者的聯絡方式 (Contact)："

# File: docs/8.x/eloquent-relationships.md, line: 1508
# File: docs/master/eloquent-relationships.md, line: 1508
#. type: Plain text
#, no-wrap
msgid "    $books = Book::with('author.contacts')->get();\n"
msgstr "    $books = Book::with('author.contacts')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1510
# File: docs/master/eloquent-relationships.md, line: 1510
#. type: Plain text
#, no-wrap
msgid "<a name=\"nested-eager-loading-morphto-relationships\"></a>\n"
msgstr "<a name=\"nested-eager-loading-morphto-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1510
# File: docs/master/eloquent-relationships.md, line: 1510
#. type: Title ####
#, no-wrap
msgid "Nested Eager Loading `morphTo` Relationships"
msgstr "積極載入巢狀的 `morphTo` 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1513
# File: docs/master/eloquent-relationships.md, line: 1513
#. type: Plain text
msgid "If you would like to eager load a `morphTo` relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the `with` method in combination with the `morphTo` relationship's `morphWith` method. To help illustrate this method, let's consider the following model:"
msgstr "若想積極載入 `morphTo` 關聯、或是巢狀的關聯等由 morphTo 關聯回傳的功能，可以使用 `morphTo` 關聯的 `morphWith` 方法，並搭配 `with` 方法使用。為了讓我們更瞭解這個功能，我們先來看看下列 Model："

# File: docs/8.x/eloquent-relationships.md, line: 1528
# File: docs/8.x/eloquent-relationships.md, line: 1682
# File: docs/master/eloquent-relationships.md, line: 1528
# File: docs/master/eloquent-relationships.md, line: 1682
#. type: Plain text
#, no-wrap
msgid "    class ActivityFeed extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent of the activity feed record.\n"
"         */\n"
"        public function parentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr "    class ActivityFeed extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent of the activity feed record.\n"
"         */\n"
"        public function parentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1530
# File: docs/8.x/eloquent-relationships.md, line: 1684
# File: docs/master/eloquent-relationships.md, line: 1530
# File: docs/master/eloquent-relationships.md, line: 1684
#. type: Plain text
msgid "In this example, let's assume `Event`, `Photo`, and `Post` models may create `ActivityFeed` models. Additionally, let's assume that `Event` models belong to a `Calendar` model, `Photo` models are associated with `Tag` models, and `Post` models belong to an `Author` model."
msgstr "在這個例子中，先假設 `Event`, `Photo`, 與 `Post` 會建立 `ActivityFeed` Model。另外，也來假設 `Event` Model 隸屬於 `Calendar` Model，而 `Photo` Model 則與 `Tag` Model 相關聯，然後 `Post` Model 隸屬於 `Author` Model。"

# File: docs/8.x/eloquent-relationships.md, line: 1532
# File: docs/8.x/eloquent-relationships.md, line: 1686
# File: docs/master/eloquent-relationships.md, line: 1532
# File: docs/master/eloquent-relationships.md, line: 1686
#. type: Plain text
msgid "Using these model definitions and relationships, we may retrieve `ActivityFeed` model instances and eager load all `parentable` models and their respective nested relationships:"
msgstr "有了這些 Model 定義與關聯，我們就可以取得 `ActivityFeed` Model 實體，然後積極載入所有 `parentable` Model 與這些 `parentable` Model 的巢狀關聯："

# File: docs/8.x/eloquent-relationships.md, line: 1543
# File: docs/master/eloquent-relationships.md, line: 1543
#. type: Plain text
#, no-wrap
msgid "    $activities = ActivityFeed::query()\n"
"        ->with(['parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWith([\n"
"                Event::class => ['calendar'],\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['author'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr "    $activities = ActivityFeed::query()\n"
"        ->with(['parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWith([\n"
"                Event::class => ['calendar'],\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['author'],\n"
"            ]);\n"
"        }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1545
# File: docs/master/eloquent-relationships.md, line: 1545
#. type: Plain text
#, no-wrap
msgid "<a name=\"eager-loading-specific-columns\"></a>\n"
msgstr "<a name=\"eager-loading-specific-columns\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1545
# File: docs/master/eloquent-relationships.md, line: 1545
#. type: Title ####
#, no-wrap
msgid "Eager Loading Specific Columns"
msgstr "積極載入特定欄位"

# File: docs/8.x/eloquent-relationships.md, line: 1548
# File: docs/master/eloquent-relationships.md, line: 1548
#. type: Plain text
msgid "You may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to specify which columns of the relationship you would like to retrieve:"
msgstr "有時候，我們可能並不像取得關聯的所有欄位。為此，Eloquent 能讓我們指定要取得關聯的哪些欄位："

# File: docs/8.x/eloquent-relationships.md, line: 1550
# File: docs/master/eloquent-relationships.md, line: 1550
#. type: Plain text
#, no-wrap
msgid "    $books = Book::with('author:id,name,book_id')->get();\n"
msgstr "    $books = Book::with('author:id,name,book_id')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1552
# File: docs/master/eloquent-relationships.md, line: 1552
#. type: Plain text
#, no-wrap
msgid "> {note} When using this feature, you should always include the `id` column and any relevant foreign key columns in the list of columns you wish to retrieve.\n"
msgstr "> {note} 使用這個功能時，請務必在欄位列表中包含 `id` 欄位以及其他相關的外部索引鍵欄位。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1554
# File: docs/master/eloquent-relationships.md, line: 1554
#. type: Plain text
#, no-wrap
msgid "<a name=\"eager-loading-by-default\"></a>\n"
msgstr "<a name=\"eager-loading-by-default\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1554
# File: docs/master/eloquent-relationships.md, line: 1554
#. type: Title ####
#, no-wrap
msgid "Eager Loading By Default"
msgstr "預設積極載入"

# File: docs/8.x/eloquent-relationships.md, line: 1557
# File: docs/master/eloquent-relationships.md, line: 1557
#. type: Plain text
msgid "Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define a `$with` property on the model:"
msgstr "對於某些 Model，我們可能會希望這個 Model 總是能載入一些關聯。為此，我們可以在這種 Model 上定義一個 `$with` 屬性："

# File: docs/8.x/eloquent-relationships.md, line: 1572
# File: docs/master/eloquent-relationships.md, line: 1572
#. type: Plain text
#, no-wrap
msgid "    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * The relationships that should always be loaded.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $with = ['author'];\n"
msgstr "    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * The relationships that should always be loaded.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $with = ['author'];\n"

# File: docs/8.x/eloquent-relationships.md, line: 1580
# File: docs/master/eloquent-relationships.md, line: 1580
#. type: Plain text
#, no-wrap
msgid "        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
msgstr "        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1589
# File: docs/master/eloquent-relationships.md, line: 1589
#. type: Plain text
#, no-wrap
msgid "        /**\n"
"         * Get the genre of the book.\n"
"         */\n"
"        public function genre()\n"
"        {\n"
"            return $this->belongsTo(Genre::class);\n"
"        }\n"
"    }\n"
msgstr "        /**\n"
"         * Get the genre of the book.\n"
"         */\n"
"        public function genre()\n"
"        {\n"
"            return $this->belongsTo(Genre::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1591
# File: docs/master/eloquent-relationships.md, line: 1591
#. type: Plain text
msgid "If you would like to remove an item from the `$with` property for a single query, you may use the `without` method:"
msgstr "若想為單一查詢移除 `$with` 屬性中的某個項目，可以使用 `without` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1593
# File: docs/master/eloquent-relationships.md, line: 1593
#. type: Plain text
#, no-wrap
msgid "    $books = Book::without('author')->get();\n"
msgstr "    $books = Book::without('author')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1595
# File: docs/master/eloquent-relationships.md, line: 1595
#. type: Plain text
msgid "If you would like to override all items within the `$with` property for a single query, you may use the `withOnly` method:"
msgstr "若想為單一查詢複寫 `$with` 屬性中的所有項目，可以使用 `withOnly` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1597
# File: docs/master/eloquent-relationships.md, line: 1597
#. type: Plain text
#, no-wrap
msgid "    $books = Book::withOnly('genre')->get();\n"
msgstr "    $books = Book::withOnly('genre')->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1599
# File: docs/master/eloquent-relationships.md, line: 1599
#. type: Plain text
#, no-wrap
msgid "<a name=\"constraining-eager-loads\"></a>\n"
msgstr "<a name=\"constraining-eager-loads\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1599
# File: docs/master/eloquent-relationships.md, line: 1599
#. type: Title ###
#, no-wrap
msgid "Constraining Eager Loads"
msgstr "包含查詢條件的積極載入"

# File: docs/8.x/eloquent-relationships.md, line: 1602
# File: docs/master/eloquent-relationships.md, line: 1602
#. type: Plain text
msgid "Sometimes you may wish to eager load a relationship but also specify additional query conditions for the eager loading query. You can accomplish this by passing an array of relationships to the `with` method where the array key is a relationship name and the array value is a closure that adds additional constraints to the eager loading query:"
msgstr "在積極載入關聯時，我們有時候可能會希望能給積極載入查詢指定額外的查詢條件。可以通過傳入一組包含關聯的陣列給 `with` 方法來達成。這個陣列的索引鍵應為關聯的名稱，而陣列值則為要給積極載入查詢加上額外查詢條件的閉包："

# File: docs/8.x/eloquent-relationships.md, line: 1608
# File: docs/master/eloquent-relationships.md, line: 1608
#. type: Plain text
#, no-wrap
msgid "    $users = User::with(['posts' => function ($query) {\n"
"        $query->where('title', 'like', '%code%');\n"
"    }])->get();\n"
msgstr "    $users = User::with(['posts' => function ($query) {\n"
"        $query->where('title', 'like', '%code%');\n"
"    }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1610
# File: docs/master/eloquent-relationships.md, line: 1610
#. type: Plain text
msgid "In this example, Eloquent will only eager load posts where the post's `title` column contains the word `code`. You may call other [query builder](/docs/{{version}}/queries) methods to further customize the eager loading operation:"
msgstr "在這個例子中，Eloquent 只會積極載入 `title` 欄位含有關鍵字 `code` 的文章。你還可以呼叫其他的 [Query Builder](/docs/{{version}}/queries) 方法來進一步自訂積極式載入："

# File: docs/8.x/eloquent-relationships.md, line: 1614
# File: docs/master/eloquent-relationships.md, line: 1614
#. type: Plain text
#, no-wrap
msgid "    $users = User::with(['posts' => function ($query) {\n"
"        $query->orderBy('created_at', 'desc');\n"
"    }])->get();\n"
msgstr "    $users = User::with(['posts' => function ($query) {\n"
"        $query->orderBy('created_at', 'desc');\n"
"    }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1616
# File: docs/master/eloquent-relationships.md, line: 1616
#. type: Plain text
#, no-wrap
msgid "> {note} The `limit` and `take` query builder methods may not be used when constraining eager loads.\n"
msgstr "> {note} 積極式載入不能使用 `limit` 與 `take` Query Builder 方法來作條件限制。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1618
# File: docs/master/eloquent-relationships.md, line: 1618
#. type: Plain text
#, no-wrap
msgid "<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\n"
msgstr "<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1618
# File: docs/master/eloquent-relationships.md, line: 1618
#. type: Title ####
#, no-wrap
msgid "Constraining Eager Loading Of `morphTo` Relationships"
msgstr "包含查詢條件的 `morphTo` 關聯積極載入"

# File: docs/8.x/eloquent-relationships.md, line: 1621
# File: docs/master/eloquent-relationships.md, line: 1621
#. type: Plain text
msgid "If you are eager loading a `morphTo` relationship, Eloquent will run multiple queries to fetch each type of related model. You may add additional constraints to each of these queries using the `MorphTo` relation's `constrain` method:"
msgstr "在積極載入 `morphTo` 關聯時，Eloquent 會為關聯 Model 的每個類型都執行多筆查詢。我們可以使用 `MorphTo` 關聯的 `constrain` 方法來對這些查詢分別加上額外的查詢條件："

# File: docs/8.x/eloquent-relationships.md, line: 1624
# File: docs/master/eloquent-relationships.md, line: 1624
#. type: Plain text
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Builder;\n"
"    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr "    use Illuminate\\Database\\Eloquent\\Builder;\n"
"    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1635
# File: docs/master/eloquent-relationships.md, line: 1635
#. type: Plain text
#, no-wrap
msgid "    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->constrain([\n"
"            Post::class => function (Builder $query) {\n"
"                $query->whereNull('hidden_at');\n"
"            },\n"
"            Video::class => function (Builder $query) {\n"
"                $query->where('type', 'educational');\n"
"            },\n"
"        ]);\n"
"    }])->get();\n"
msgstr "    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->constrain([\n"
"            Post::class => function (Builder $query) {\n"
"                $query->whereNull('hidden_at');\n"
"            },\n"
"            Video::class => function (Builder $query) {\n"
"                $query->where('type', 'educational');\n"
"            },\n"
"        ]);\n"
"    }])->get();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1637
# File: docs/master/eloquent-relationships.md, line: 1637
#. type: Plain text
msgid "In this example, Eloquent will only eager load posts that have not been hidden and videos have a `type` value of \"educational\"."
msgstr "在這個範例中，Eloquent 只會積極載入非隱藏的貼文，以及 `type` 值不是「educational」的影片。"

# File: docs/8.x/eloquent-relationships.md, line: 1639
# File: docs/master/eloquent-relationships.md, line: 1639
#. type: Plain text
#, no-wrap
msgid "<a name=\"lazy-eager-loading\"></a>\n"
msgstr "<a name=\"lazy-eager-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1639
# File: docs/master/eloquent-relationships.md, line: 1639
#. type: Title ###
#, no-wrap
msgid "Lazy Eager Loading"
msgstr "消極的積極式載入"

# File: docs/8.x/eloquent-relationships.md, line: 1642
# File: docs/master/eloquent-relationships.md, line: 1642
#. type: Plain text
msgid "Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:"
msgstr "有時候，我們可能需要在已取得上層 Model 後才積極載入某個關聯。舉例來說，當想動態決定是否要載入關聯 Model 時，這種功能特別適合："

# File: docs/8.x/eloquent-relationships.md, line: 1650
# File: docs/master/eloquent-relationships.md, line: 1650
#. type: Plain text
#, no-wrap
msgid "    if ($someCondition) {\n"
"        $books->load('author', 'publisher');\n"
"    }\n"
msgstr "    if ($someCondition) {\n"
"        $books->load('author', 'publisher');\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1652
# File: docs/master/eloquent-relationships.md, line: 1652
#. type: Plain text
msgid "If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be closure instances which receive the query instance:"
msgstr "若想在積極載入查詢上設定額外的查詢條件，可以傳入一組陣列，其索引鍵應為要載入的關聯。陣列的值則為一個閉包，用來接收 Query Builder 實體："

# File: docs/8.x/eloquent-relationships.md, line: 1656
# File: docs/master/eloquent-relationships.md, line: 1656
#. type: Plain text
#, no-wrap
msgid "    $author->load(['books' => function ($query) {\n"
"        $query->orderBy('published_date', 'asc');\n"
"    }]);\n"
msgstr "    $author->load(['books' => function ($query) {\n"
"        $query->orderBy('published_date', 'asc');\n"
"    }]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1658
# File: docs/master/eloquent-relationships.md, line: 1658
#. type: Plain text
msgid "To load a relationship only when it has not already been loaded, use the `loadMissing` method:"
msgstr "若想只在某個關聯未被載入時才載入該關聯，可使用 `loadMissing` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1660
# File: docs/master/eloquent-relationships.md, line: 1660
#. type: Plain text
#, no-wrap
msgid "    $book->loadMissing('author');\n"
msgstr "    $book->loadMissing('author');\n"

# File: docs/8.x/eloquent-relationships.md, line: 1662
# File: docs/master/eloquent-relationships.md, line: 1662
#. type: Plain text
#, no-wrap
msgid "<a name=\"nested-lazy-eager-loading-morphto\"></a>\n"
msgstr "<a name=\"nested-lazy-eager-loading-morphto\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1662
# File: docs/master/eloquent-relationships.md, line: 1662
#. type: Title ####
#, no-wrap
msgid "Nested Lazy Eager Loading & `morphTo`"
msgstr "巢狀之消極的積極載入與 `morphTo`"

# File: docs/8.x/eloquent-relationships.md, line: 1665
# File: docs/master/eloquent-relationships.md, line: 1665
#. type: Plain text
msgid "If you would like to eager load a `morphTo` relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the `loadMorph` method."
msgstr "若想積極式載入 `morphTo` 關聯、或是關聯 Model 的巢狀關聯等由 morphTo 關聯所回傳的功能，可以使用 `loadMorph` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1667
# File: docs/master/eloquent-relationships.md, line: 1667
#. type: Plain text
msgid "This method accepts the name of the `morphTo` relationship as its first argument, and an array of model / relationship pairs as its second argument. To help illustrate this method, let's consider the following model:"
msgstr "這個方法的第一個引數是 `morphTo` 關聯的名稱，第二個引數則是一組包含 Model / 關聯配對的陣列。為了說明這個功能，先來看看下列 Model："

# File: docs/8.x/eloquent-relationships.md, line: 1694
# File: docs/master/eloquent-relationships.md, line: 1694
#. type: Plain text
#, no-wrap
msgid "    $activities = ActivityFeed::with('parentable')\n"
"        ->get()\n"
"        ->loadMorph('parentable', [\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"
msgstr "    $activities = ActivityFeed::with('parentable')\n"
"        ->get()\n"
"        ->loadMorph('parentable', [\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1696
# File: docs/master/eloquent-relationships.md, line: 1696
#. type: Plain text
#, no-wrap
msgid "<a name=\"preventing-lazy-loading\"></a>\n"
msgstr "<a name=\"preventing-lazy-loading\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1696
# File: docs/master/eloquent-relationships.md, line: 1696
#. type: Title ###
#, no-wrap
msgid "Preventing Lazy Loading"
msgstr "預防消極載入"

# File: docs/8.x/eloquent-relationships.md, line: 1699
# File: docs/master/eloquent-relationships.md, line: 1699
#. type: Plain text
msgid "As previously discussed, eager loading relationships can often provide significant performance benefits to your application. Therefore, if you would like, you may instruct Laravel to always prevent the lazy loading of relationships. To accomplish this, you may invoke the `preventLazyLoading` method offered by the base Eloquent model class. Typically, you should call this method within the `boot` method of your application's `AppServiceProvider` class."
msgstr "前面也說明過，對你的專案來說，積極載入關聯通常可以顯著提升效能。因此，我們可能會希望讓 Laravel 總是避免消極式載入關聯。為此，我們可以呼叫基礎 Eloquent Model 上的 `preventLazyLoading` 方法。一般來說，應該在你的專案中 `AppServiceProvider` 類別的 `boot` 方法內呼叫這個方法。"

# File: docs/8.x/eloquent-relationships.md, line: 1701
# File: docs/master/eloquent-relationships.md, line: 1701
#. type: Plain text
msgid "The `preventLazyLoading` method accepts an optional boolean argument that indicates if lazy loading should be prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code:"
msgstr "`preventLazyLoading` 方法接受一個可選的布林引數，用來判斷是否應防止消極式載入。舉例來說，我們肯跟會希望只在非正式環境下才進用消極式載入，這樣一來，就算正式環境上的程式碼內不小心有個消極式載入的關聯，正式環境也可以正常運作："

# File: docs/8.x/eloquent-relationships.md, line: 1702
# File: docs/master/eloquent-relationships.md, line: 1702
#. type: Plain text
#, no-wrap
msgid "use Illuminate\\Database\\Eloquent\\Model;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Model::preventLazyLoading(! $this->app->isProduction());\n"
"}\n"
msgstr "use Illuminate\\Database\\Eloquent\\Model;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Model::preventLazyLoading(! $this->app->isProduction());\n"
"}\n"

# File: docs/8.x/eloquent-relationships.md, line: 1717
# File: docs/master/eloquent-relationships.md, line: 1717
#. type: Plain text
msgid "After preventing lazy loading, Eloquent will throw a `Illuminate\\Database\\LazyLoadingViolationException` exception when your application attempts to lazy load any Eloquent relationship."
msgstr "阻止消極式載入後，當程式嘗試要消極載入任何 Eloquent 關聯時，Eloquent 會擲回一個 `Illuminate\\Database\\LazyLoadingViolationException` 例外。"

# File: docs/8.x/eloquent-relationships.md, line: 1719
# File: docs/master/eloquent-relationships.md, line: 1719
#. type: Plain text
msgid "You may customize the behavior of lazy loading violations using the `handleLazyLoadingViolationsUsing` method. For example, using this method, you may instruct lazy loading violations to only be logged instead of interrupting the application's execution with exceptions:"
msgstr "可以使用 `handleLazyLoadingViolationsUsing` 方法來自訂當發生消極載入時要如何處置。舉例來說，我們可以使用這個方法來讓 Laravel 在遇到消極載入的時候紀錄到日誌，而不是使用例外在終止程式的執行："

# File: docs/8.x/eloquent-relationships.md, line: 1720
# File: docs/master/eloquent-relationships.md, line: 1720
#. type: Plain text
#, no-wrap
msgid "Model::handleLazyLoadingViolationUsing(function ($model, $relation) {\n"
"    $class = get_class($model);\n\n"
"    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\n"
"});\n"
msgstr "Model::handleLazyLoadingViolationUsing(function ($model, $relation) {\n"
"    $class = get_class($model);\n\n"
"    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\n"
"});\n"

# File: docs/8.x/eloquent-relationships.md, line: 1729
# File: docs/master/eloquent-relationships.md, line: 1729
#. type: Plain text
#, no-wrap
msgid "<a name=\"inserting-and-updating-related-models\"></a>\n"
msgstr "<a name=\"inserting-and-updating-related-models\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1729
# File: docs/master/eloquent-relationships.md, line: 1729
#. type: Title ##
#, no-wrap
msgid "Inserting & Updating Related Models"
msgstr "插入與更新關聯的 Model"

# File: docs/8.x/eloquent-relationships.md, line: 1732
# File: docs/master/eloquent-relationships.md, line: 1732
#. type: Plain text
#, no-wrap
msgid "<a name=\"the-save-method\"></a>\n"
msgstr "<a name=\"the-save-method\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1732
# File: docs/master/eloquent-relationships.md, line: 1732
#. type: Title ###
#, no-wrap
msgid "The `save` Method"
msgstr "`save` 方法"

# File: docs/8.x/eloquent-relationships.md, line: 1735
# File: docs/master/eloquent-relationships.md, line: 1735
#. type: Plain text
msgid "Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to add a new comment to a post. Instead of manually setting the `post_id` attribute on the `Comment` model you may insert the comment using the relationship's `save` method:"
msgstr "Eloquent 提供了一些方便的方法來給關聯新增新 Model。舉例來說，我們可能會需要給貼文新增新留言。比起手動在 `Comment` Model 上設定 `post_id`，我們可以使用關聯的 `save` Model 來插入留言："

# File: docs/8.x/eloquent-relationships.md, line: 1738
# File: docs/master/eloquent-relationships.md, line: 1738
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
msgstr "    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1740
# File: docs/master/eloquent-relationships.md, line: 1740
#. type: Plain text
#, no-wrap
msgid "    $comment = new Comment(['message' => 'A new comment.']);\n"
msgstr "    $comment = new Comment(['message' => 'A new comment.']);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1744
# File: docs/8.x/eloquent-relationships.md, line: 1759
# File: docs/master/eloquent-relationships.md, line: 1744
# File: docs/master/eloquent-relationships.md, line: 1759
#. type: Plain text
#, no-wrap
msgid "    $post->comments()->save($comment);\n"
msgstr "    $post->comments()->save($comment);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1746
# File: docs/master/eloquent-relationships.md, line: 1746
#. type: Plain text
msgid "Note that we did not access the `comments` relationship as a dynamic property. Instead, we called the `comments` method to obtain an instance of the relationship. The `save` method will automatically add the appropriate `post_id` value to the new `Comment` model."
msgstr "請注意，我們不是以動態屬性的方式來存取 `comment` 關聯，而是呼叫 `comments` 方法來取得關聯的實體。`save` 方法會自動為新建立的 `Comment` Model 加上適當的 `post_id` 值。"

# File: docs/8.x/eloquent-relationships.md, line: 1748
# File: docs/master/eloquent-relationships.md, line: 1748
#. type: Plain text
msgid "If you need to save multiple related models, you may use the `saveMany` method:"
msgstr "若有需要保存多個關聯 Model，可以使用 `saveMany` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1755
# File: docs/master/eloquent-relationships.md, line: 1755
#. type: Plain text
#, no-wrap
msgid "    $post->comments()->saveMany([\n"
"        new Comment(['message' => 'A new comment.']),\n"
"        new Comment(['message' => 'Another new comment.']),\n"
"    ]);\n"
msgstr "    $post->comments()->saveMany([\n"
"        new Comment(['message' => 'A new comment.']),\n"
"        new Comment(['message' => 'Another new comment.']),\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1757
# File: docs/master/eloquent-relationships.md, line: 1757
#. type: Plain text
msgid "The `save` and `saveMany` methods will persist the given model instances, but will not add the newly persisted models to any in-memory relationships that are already loaded onto the parent model. If you plan on accessing the relationship after using the `save` or `saveMany` methods, you may wish to use the `refresh` method to reload the model and its relationships:"
msgstr "`save` 與 `saveMany` 會將 Model 實體保存起來。不過，保存好的 Model 並不會被加到上層 Model 中已經載入到記憶體的關聯。在使用 `save` 或 `saveMany` 方法後，若有打算要存取這些關聯，可使用 `refresh` 方法來重新載入 Model 與其關聯："

# File: docs/8.x/eloquent-relationships.md, line: 1761
# File: docs/master/eloquent-relationships.md, line: 1761
#. type: Plain text
#, no-wrap
msgid "    $post->refresh();\n"
msgstr "    $post->refresh();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1764
# File: docs/master/eloquent-relationships.md, line: 1764
#. type: Plain text
#, no-wrap
msgid "    // All comments, including the newly saved comment...\n"
"    $post->comments;\n"
msgstr "    // 所有留言，包含新保存的留言...\n"
"    $post->comments;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1766
# File: docs/master/eloquent-relationships.md, line: 1766
#. type: Plain text
#, no-wrap
msgid "<a name=\"the-push-method\"></a>\n"
msgstr "<a name=\"the-push-method\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1766
# File: docs/master/eloquent-relationships.md, line: 1766
#. type: Title ####
#, no-wrap
msgid "Recursively Saving Models & Relationships"
msgstr "遞歸保存 Model 與關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1769
# File: docs/master/eloquent-relationships.md, line: 1769
#. type: Plain text
msgid "If you would like to `save` your model and all of its associated relationships, you may use the `push` method. In this example, the `Post` model will be saved as well as its comments and the comment's authors:"
msgstr "若想讓 `save` 方法保存 Model 與其所有相關的關聯 Model，可以使用 `push` 方法。在這個例子中，`Post` Model、`Post` Model 的留言、留言的作者等都會一起被保存："

# File: docs/8.x/eloquent-relationships.md, line: 1774
# File: docs/master/eloquent-relationships.md, line: 1774
#. type: Plain text
#, no-wrap
msgid "    $post->comments[0]->message = 'Message';\n"
"    $post->comments[0]->author->name = 'Author Name';\n"
msgstr "    $post->comments[0]->message = 'Message';\n"
"    $post->comments[0]->author->name = 'Author Name';\n"

# File: docs/8.x/eloquent-relationships.md, line: 1776
# File: docs/master/eloquent-relationships.md, line: 1776
#. type: Plain text
#, no-wrap
msgid "    $post->push();\n"
msgstr "    $post->push();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1778
# File: docs/master/eloquent-relationships.md, line: 1778
#. type: Plain text
#, no-wrap
msgid "<a name=\"the-create-method\"></a>\n"
msgstr "<a name=\"the-create-method\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1778
# File: docs/master/eloquent-relationships.md, line: 1778
#. type: Title ###
#, no-wrap
msgid "The `create` Method"
msgstr "`create` 方法"

# File: docs/8.x/eloquent-relationships.md, line: 1781
# File: docs/master/eloquent-relationships.md, line: 1781
#. type: Plain text
msgid "In addition to the `save` and `saveMany` methods, you may also use the `create` method, which accepts an array of attributes, creates a model, and inserts it into the database. The difference between `save` and `create` is that `save` accepts a full Eloquent model instance while `create` accepts a plain PHP `array`. The newly created model will be returned by the `create` method:"
msgstr "除了 `save` 跟 `saveMany` 方法外，也可以使用 `create` 方法來建立 Model 並插入資料庫。`create` 方法接受一組包含屬性的陣列。`save` 與 `create` 間不同的地方在於：`save` 接收完整的 Eloquent Model 實體，而 `create` 接收的是純 PHP 的 `array`。`create` 方法會回傳新建立的 Model："

# File: docs/8.x/eloquent-relationships.md, line: 1789
# File: docs/master/eloquent-relationships.md, line: 1789
#. type: Plain text
#, no-wrap
msgid "    $comment = $post->comments()->create([\n"
"        'message' => 'A new comment.',\n"
"    ]);\n"
msgstr "    $comment = $post->comments()->create([\n"
"        'message' => 'A new comment.',\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1791
# File: docs/master/eloquent-relationships.md, line: 1791
#. type: Plain text
msgid "You may use the `createMany` method to create multiple related models:"
msgstr "可以使用 `createMany` 方法來建立多個關聯的 Model："

# File: docs/8.x/eloquent-relationships.md, line: 1798
# File: docs/master/eloquent-relationships.md, line: 1798
#. type: Plain text
#, no-wrap
msgid "    $post->comments()->createMany([\n"
"        ['message' => 'A new comment.'],\n"
"        ['message' => 'Another new comment.'],\n"
"    ]);\n"
msgstr "    $post->comments()->createMany([\n"
"        ['message' => 'A new comment.'],\n"
"        ['message' => 'Another new comment.'],\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1800
# File: docs/master/eloquent-relationships.md, line: 1800
#. type: Plain text
msgid "You may also use the `findOrNew`, `firstOrNew`, `firstOrCreate`, and `updateOrCreate` methods to [create and update models on relationships](/docs/{{version}}/eloquent#upserts)."
msgstr "也可以使用 `findOrNew`, `firstOrNew`, `firstOrCreate`, 與 `updateOrCreate` 等方法來[在關聯上建立並更新 Model](/docs/{{version}}/eloquent#upserts)。"

# File: docs/8.x/eloquent-relationships.md, line: 1802
# File: docs/master/eloquent-relationships.md, line: 1802
#. type: Plain text
#, no-wrap
msgid "> {tip} Before using the `create` method, be sure to review the [mass assignment](/docs/{{version}}/eloquent#mass-assignment) documentation.\n"
msgstr "> {tip} 在使用 `create` 方法前，請先閱讀[大量賦值](/docs/{{version}}/eloquent#mass-assignment)的說明文件。\n"

# File: docs/8.x/eloquent-relationships.md, line: 1804
# File: docs/master/eloquent-relationships.md, line: 1804
#. type: Plain text
#, no-wrap
msgid "<a name=\"updating-belongs-to-relationships\"></a>\n"
msgstr "<a name=\"updating-belongs-to-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1804
# File: docs/master/eloquent-relationships.md, line: 1804
#. type: Title ###
#, no-wrap
msgid "Belongs To Relationships"
msgstr "Belongs To 關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1807
# File: docs/master/eloquent-relationships.md, line: 1807
#. type: Plain text
msgid "If you would like to assign a child model to a new parent model, you may use the `associate` method. In this example, the `User` model defines a `belongsTo` relationship to the `Account` model. This `associate` method will set the foreign key on the child model:"
msgstr "若想將子 Model 指派給新的上層 Model，可以使用 `associate` 方法。在這個例子中，`User` Model 定義了一個連到 `Account` Model 的 `belongsTo` 關聯。`associate` 方法會在子 Model 上設定外部索引鍵："

# File: docs/8.x/eloquent-relationships.md, line: 1809
# File: docs/master/eloquent-relationships.md, line: 1809
#. type: Plain text
#, no-wrap
msgid "    use App\\Models\\Account;\n"
msgstr "    use App\\Models\\Account;\n"

# File: docs/8.x/eloquent-relationships.md, line: 1811
# File: docs/master/eloquent-relationships.md, line: 1811
#. type: Plain text
#, no-wrap
msgid "    $account = Account::find(10);\n"
msgstr "    $account = Account::find(10);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1813
# File: docs/master/eloquent-relationships.md, line: 1813
#. type: Plain text
#, no-wrap
msgid "    $user->account()->associate($account);\n"
msgstr "    $user->account()->associate($account);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1815
# File: docs/8.x/eloquent-relationships.md, line: 1821
# File: docs/master/eloquent-relationships.md, line: 1815
# File: docs/master/eloquent-relationships.md, line: 1821
#. type: Plain text
#, no-wrap
msgid "    $user->save();\n"
msgstr "    $user->save();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1817
# File: docs/master/eloquent-relationships.md, line: 1817
#. type: Plain text
msgid "To remove a parent model from a child model, you may use the `dissociate` method. This method will set the relationship's foreign key to `null`:"
msgstr "若要從子 Model 上移除上層 Model，可以使用 `dissociate` 方法。這個方法會將關聯的外部索引鍵設為 `null`："

# File: docs/8.x/eloquent-relationships.md, line: 1819
# File: docs/master/eloquent-relationships.md, line: 1819
#. type: Plain text
#, no-wrap
msgid "    $user->account()->dissociate();\n"
msgstr "    $user->account()->dissociate();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1823
# File: docs/master/eloquent-relationships.md, line: 1823
#. type: Plain text
#, no-wrap
msgid "<a name=\"updating-many-to-many-relationships\"></a>\n"
msgstr "<a name=\"updating-many-to-many-relationships\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1826
# File: docs/master/eloquent-relationships.md, line: 1826
#. type: Plain text
#, no-wrap
msgid "<a name=\"attaching-detaching\"></a>\n"
msgstr "<a name=\"attaching-detaching\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1826
# File: docs/master/eloquent-relationships.md, line: 1826
#. type: Title ####
#, no-wrap
msgid "Attaching / Detaching"
msgstr "附加 / 解除附加"

# File: docs/8.x/eloquent-relationships.md, line: 1829
# File: docs/master/eloquent-relationships.md, line: 1829
#. type: Plain text
msgid "Eloquent also provides methods to make working with many-to-many relationships more convenient. For example, let's imagine a user can have many roles and a role can have many users. You may use the `attach` method to attach a role to a user by inserting a record in the relationship's intermediate table:"
msgstr "Eloquent 還提供一些能讓處理多對多關聯更方便的方法。舉例來說，先假設一個使用者 (User) 可以有多個職位 (Role)，而一個職位可以有多個使用者。可以使用 `attach` 方法來將某個職位附加到使用者身上，`attach` 會在關聯的中介資料表上插入一筆紀錄來完成："

# File: docs/8.x/eloquent-relationships.md, line: 1835
# File: docs/master/eloquent-relationships.md, line: 1835
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->attach($roleId);\n"
msgstr "    $user->roles()->attach($roleId);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1837
# File: docs/master/eloquent-relationships.md, line: 1837
#. type: Plain text
msgid "When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table:"
msgstr "在把關聯附加到 Model 上時，可以傳入一組陣列，包含額外要被插入到中介資料表上的資料："

# File: docs/8.x/eloquent-relationships.md, line: 1839
# File: docs/master/eloquent-relationships.md, line: 1839
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->attach($roleId, ['expires' => $expires]);\n"
msgstr "    $user->roles()->attach($roleId, ['expires' => $expires]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1841
# File: docs/master/eloquent-relationships.md, line: 1841
#. type: Plain text
msgid "Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the `detach` method. The `detach` method will delete the appropriate record out of the intermediate table; however, both models will remain in the database:"
msgstr "有時候，我們還會需要從使用者身上移除某個職位。若要移除 Many-to-Many 關聯的紀錄，請使用 `detach` 方法。`detach` 方法會從中介資料表上移除相應的紀錄。不過，使用者跟職位兩個 Model 都還會保留在資料庫中："

# File: docs/8.x/eloquent-relationships.md, line: 1844
# File: docs/master/eloquent-relationships.md, line: 1844
#. type: Plain text
#, no-wrap
msgid "    // Detach a single role from the user...\n"
"    $user->roles()->detach($roleId);\n"
msgstr "    // 從使用者上移除單一職位...\n"
"    $user->roles()->detach($roleId);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1847
# File: docs/master/eloquent-relationships.md, line: 1847
#. type: Plain text
#, no-wrap
msgid "    // Detach all roles from the user...\n"
"    $user->roles()->detach();\n"
msgstr "    // 從使用者上移除所有職位...\n"
"    $user->roles()->detach();\n"

# File: docs/8.x/eloquent-relationships.md, line: 1849
# File: docs/master/eloquent-relationships.md, line: 1849
#. type: Plain text
msgid "For convenience, `attach` and `detach` also accept arrays of IDs as input:"
msgstr "為了更方便使用，`attach` 與 `detach` 也能接受一組包含 ID 的陣列作為輸入："

# File: docs/8.x/eloquent-relationships.md, line: 1853
# File: docs/master/eloquent-relationships.md, line: 1853
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->detach([1, 2, 3]);\n"
msgstr "    $user->roles()->detach([1, 2, 3]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1858
# File: docs/master/eloquent-relationships.md, line: 1858
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->attach([\n"
"        1 => ['expires' => $expires],\n"
"        2 => ['expires' => $expires],\n"
"    ]);\n"
msgstr "    $user->roles()->attach([\n"
"        1 => ['expires' => $expires],\n"
"        2 => ['expires' => $expires],\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1860
# File: docs/master/eloquent-relationships.md, line: 1860
#. type: Plain text
#, no-wrap
msgid "<a name=\"syncing-associations\"></a>\n"
msgstr "<a name=\"syncing-associations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1860
# File: docs/master/eloquent-relationships.md, line: 1860
#. type: Title ####
#, no-wrap
msgid "Syncing Associations"
msgstr "同步關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1863
# File: docs/master/eloquent-relationships.md, line: 1863
#. type: Plain text
msgid "You may also use the `sync` method to construct many-to-many associations. The `sync` method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table:"
msgstr "可以使用 `sync` 方法來設定 Many-to-Many 關聯。`sync` 方法接受一組包含 ID 的陣列，用以插入中介資料表。中介資料表中若有不在此陣列中的 ID 則會被移除。因此，完成這個操作後，中介資料表中就只會有給定陣列中的 ID："

# File: docs/8.x/eloquent-relationships.md, line: 1865
# File: docs/master/eloquent-relationships.md, line: 1865
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->sync([1, 2, 3]);\n"
msgstr "    $user->roles()->sync([1, 2, 3]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1867
# File: docs/master/eloquent-relationships.md, line: 1867
#. type: Plain text
msgid "You may also pass additional intermediate table values with the IDs:"
msgstr "也可以使用 ID 來傳入額外的中介資料表值："

# File: docs/8.x/eloquent-relationships.md, line: 1869
# File: docs/master/eloquent-relationships.md, line: 1869
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"
msgstr "    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1871
# File: docs/master/eloquent-relationships.md, line: 1871
#. type: Plain text
msgid "If you would like to insert the same intermediate table values with each of the synced model IDs, you may use the `syncWithPivotValues` method:"
msgstr "如喔想為每個同步的 Model ID 都插入相同的中介資料表值，則可以使用 `syncWithPivotValue` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1873
# File: docs/master/eloquent-relationships.md, line: 1873
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\n"
msgstr "    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1875
# File: docs/master/eloquent-relationships.md, line: 1875
#. type: Plain text
msgid "If you do not want to detach existing IDs that are missing from the given array, you may use the `syncWithoutDetaching` method:"
msgstr "若想從給定陣列中移除現有的 ID，則可以使用 `syncWithoutDetaching` 方法："

# File: docs/8.x/eloquent-relationships.md, line: 1877
# File: docs/master/eloquent-relationships.md, line: 1877
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->syncWithoutDetaching([1, 2, 3]);\n"
msgstr "    $user->roles()->syncWithoutDetaching([1, 2, 3]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1879
# File: docs/master/eloquent-relationships.md, line: 1879
#. type: Plain text
#, no-wrap
msgid "<a name=\"toggling-associations\"></a>\n"
msgstr "<a name=\"toggling-associations\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1879
# File: docs/master/eloquent-relationships.md, line: 1879
#. type: Title ####
#, no-wrap
msgid "Toggling Associations"
msgstr "切換關聯"

# File: docs/8.x/eloquent-relationships.md, line: 1882
# File: docs/master/eloquent-relationships.md, line: 1882
#. type: Plain text
msgid "The many-to-many relationship also provides a `toggle` method which \"toggles\" the attachment status of the given related model IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached:"
msgstr "Many-to-Many 關聯還提供了一個 `toggle` 方法，可以用來「切換 (Toggle)」給定關聯 Model ID 的附加狀態。若給定的 ID 目前是已附加的狀態，則該 ID 會被解除附加。反之，若目前未附加，則會被附加上去："

# File: docs/8.x/eloquent-relationships.md, line: 1884
# File: docs/master/eloquent-relationships.md, line: 1884
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->toggle([1, 2, 3]);\n"
msgstr "    $user->roles()->toggle([1, 2, 3]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1886
# File: docs/master/eloquent-relationships.md, line: 1886
#. type: Plain text
#, no-wrap
msgid "<a name=\"updating-a-record-on-the-intermediate-table\"></a>\n"
msgstr "<a name=\"updating-a-record-on-the-intermediate-table\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1886
# File: docs/master/eloquent-relationships.md, line: 1886
#. type: Title ####
#, no-wrap
msgid "Updating A Record On The Intermediate Table"
msgstr "更新中介資料表上的紀錄"

# File: docs/8.x/eloquent-relationships.md, line: 1889
# File: docs/master/eloquent-relationships.md, line: 1889
#. type: Plain text
msgid "If you need to update an existing row in your relationship's intermediate table, you may use the `updateExistingPivot` method. This method accepts the intermediate record foreign key and an array of attributes to update:"
msgstr "若想更新關聯的中介資料表上現有的紀錄，可以使用 `updateExistingPivot` 方法。這個方法接受中介資料表的外部索引鍵以及一組包含要更新屬性的陣列："

# File: docs/8.x/eloquent-relationships.md, line: 1895
# File: docs/master/eloquent-relationships.md, line: 1895
#. type: Plain text
#, no-wrap
msgid "    $user->roles()->updateExistingPivot($roleId, [\n"
"        'active' => false,\n"
"    ]);\n"
msgstr "    $user->roles()->updateExistingPivot($roleId, [\n"
"        'active' => false,\n"
"    ]);\n"

# File: docs/8.x/eloquent-relationships.md, line: 1897
# File: docs/master/eloquent-relationships.md, line: 1897
#. type: Plain text
#, no-wrap
msgid "<a name=\"touching-parent-timestamps\"></a>\n"
msgstr "<a name=\"touching-parent-timestamps\"></a>\n"

# File: docs/8.x/eloquent-relationships.md, line: 1897
# File: docs/master/eloquent-relationships.md, line: 1897
#. type: Title ##
#, no-wrap
msgid "Touching Parent Timestamps"
msgstr "更新上層的時戳"

# File: docs/8.x/eloquent-relationships.md, line: 1900
# File: docs/master/eloquent-relationships.md, line: 1900
#. type: Plain text
msgid "When a model defines a `belongsTo` or `belongsToMany` relationship to another model, such as a `Comment` which belongs to a `Post`, it is sometimes helpful to update the parent's timestamp when the child model is updated."
msgstr "若某 Model 有定義對另一個 Model 的 `belongsTo` 或 `belongsToMany` 關聯 —— 如 `Comment` Model 隸屬於 `Post` Model 等 —— 有時候，若能在子 Model 更新時也一併更新上層 Model 的時戳會很實用。"

# File: docs/8.x/eloquent-relationships.md, line: 1902
# File: docs/master/eloquent-relationships.md, line: 1902
#. type: Plain text
msgid "For example, when a `Comment` model is updated, you may want to automatically \"touch\" the `updated_at` timestamp of the owning `Post` so that it is set to the current date and time. To accomplish this, you may add a `touches` property to your child model containing the names of the relationships that should have their `updated_at` timestamps updated when the child model is updated:"
msgstr "舉例來說，當 `Comment` Model 更新後，我們可能會想自動「更新 (Touch)」擁有該 `Comment` 的 `Post` Model 上的 `updated_at` 時戳，將該時戳設為目前的日期與時間。為此，我們可以在子 Model 內新增一個 `touches` 屬性，其中包含關聯的名稱。當子 Model 更新後，這些關聯的 `updated_at` 時戳也會一起更新："

# File: docs/8.x/eloquent-relationships.md, line: 1917
# File: docs/master/eloquent-relationships.md, line: 1917
#. type: Plain text
#, no-wrap
msgid "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * All of the relationships to be touched.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $touches = ['post'];\n"
msgstr "    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * All of the relationships to be touched.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $touches = ['post'];\n"

# File: docs/8.x/eloquent-relationships.md, line: 1926
# File: docs/master/eloquent-relationships.md, line: 1926
#. type: Plain text
#, no-wrap
msgid "        /**\n"
"         * Get the post that the comment belongs to.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr "        /**\n"
"         * Get the post that the comment belongs to.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"

# File: docs/8.x/eloquent-relationships.md, line: 1927
# File: docs/master/eloquent-relationships.md, line: 1927
#. type: Plain text
#, no-wrap
msgid "> {note} Parent model timestamps will only be updated if the child model is updated using Eloquent's `save` method.\n"
msgstr "> {note} 只有在使用 Eloquent 的 `save` 方法來更新子 Model 時，才會更新上傳 Model 的時戳。\n"

