msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/routing.pot\n"
"X-Crowdin-File-ID: 141\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2022-03-04 09:30\n"

#: docs/8.x/routing.md:block 1 (header)
msgid "Routing"
msgstr "路由"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Basic Routing](#basic-routing)"
msgstr "[基礎路由](#basic-routing)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Redirect Routes](#redirect-routes)"
msgstr "[重新導向的 Route](#redirect-routes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[View Routes](#view-routes)"
msgstr "[View Route](#view-routes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Parameters](#route-parameters)"
msgstr "[Route 參數](#route-parameters)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Required Parameters](#required-parameters)"
msgstr "[必填參數](#required-parameters)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Optional Parameters](#parameters-optional-parameters)"
msgstr "[可選參數](#parameters-optional-parameters)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Regular Expression Constraints](#parameters-regular-expression-constraints)"
msgstr "[正規表示式的條件限制](#parameters-regular-expression-constraints)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Named Routes](#named-routes)"
msgstr "[命名 Route](#named-routes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Groups](#route-groups)"
msgstr "[Route 群組](#route-groups)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Middleware](#route-group-middleware)"
msgstr "[Middleware](#route-group-middleware)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Controllers](#route-group-controllers)"
msgstr "[Controller](#route-group-controllers)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Subdomain Routing](#route-group-subdomain-routing)"
msgstr "[子網域的路由](#route-group-subdomain-routing)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Prefixes](#route-group-prefixes)"
msgstr "[Route 前置詞](#route-group-prefixes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Name Prefixes](#route-group-name-prefixes)"
msgstr "[Route 名稱的前置詞](#route-group-name-prefixes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Model Binding](#route-model-binding)"
msgstr "[Route 的 Model 繫結](#route-model-binding)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Implicit Binding](#implicit-binding)"
msgstr "[隱式繫結](#implicit-binding)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Explicit Binding](#explicit-binding)"
msgstr "[顯式繫結](#explicit-binding)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Fallback Routes](#fallback-routes)"
msgstr "[遞補 Route](#fallback-routes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Rate Limiting](#rate-limiting)"
msgstr "[頻率限制](#rate-limiting)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Defining Rate Limiters](#defining-rate-limiters)"
msgstr "[定義 Rate Limiter](#defining-rate-limiters)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Attaching Rate Limiters To Routes](#attaching-rate-limiters-to-routes)"
msgstr "[在 Route 上附加 Rate Limiter](#attaching-rate-limiters-to-routes)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Form Method Spoofing](#form-method-spoofing)"
msgstr "[Form Method 的模擬](#form-method-spoofing)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Accessing The Current Route](#accessing-the-current-route)"
msgstr "[存取目前 Route](#accessing-the-current-route)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Cross-Origin Resource Sharing (CORS)](#cors)"
msgstr "[跨原始來源資源共用 (CORS, Cross-Origin Resource Sharing)(#cors)"

#: docs/8.x/routing.md:block 2 (unordered list)
msgid "[Route Caching](#route-caching)"
msgstr "[Route 快取](#route-caching)"

#: docs/8.x/routing.md:block 4 (header)
msgid "Basic Routing"
msgstr "基礎路由"

#: docs/8.x/routing.md:block 5 (paragraph)
msgid "The most basic Laravel routes accept a URI and a closure, providing a very simple and expressive method of defining routes and behavior without complicated routing configuration files:"
msgstr "最基礎的 Laravel Route (路由) 就是接受一個 URI 與一個閉包，我們可以使用簡單直觀的方法來定義 Route 與其行為，而不需複雜 Route 設定檔："

#: docs/8.x/routing.md:block 6 (code)
msgid "use Illuminate\\Support\\Facades\\Route;\n\n"
"Route::get('/greeting', function () {\n"
"    return 'Hello World';\n"
"});\n"
msgstr "use Illuminate\\Support\\Facades\\Route;\n\n"
"Route::get('/greeting', function () {\n"
"    return 'Hello World';\n"
"});\n"

#: docs/8.x/routing.md:block 8 (header)
msgid "The Default Route Files"
msgstr "預設的 Route 檔案"

#: docs/8.x/routing.md:block 9 (paragraph)
msgid "All Laravel routes are defined in your route files, which are located in the `routes` directory. These files are automatically loaded by your application's `App\\Providers\\RouteServiceProvider`. The `routes/web.php` file defines routes that are for your web interface. These routes are assigned the `web` middleware group, which provides features like session state and CSRF protection. The routes in `routes/api.php` are stateless and are assigned the `api` middleware group."
msgstr "Laravel 中所有的 Route 都在 Route 檔案中定義，這些檔案位在 `routes` 目錄下。這些檔案會由專案中的 `App\\Providers\\RouteServiceProvider` 自動載入。`routes/web.php` 檔案中定義了網頁介面的 Route。這些 Route 被指派到 `web` Middleware 群組中，該 Middleware 群組提供了一些如 Session 狀態與 CSRF 保護等功能。`routes/api.php` 是無狀態的 (Stateless)，裡面的 Route 會被指派給 `api` Middleware 群組。"

#: docs/8.x/routing.md:block 10 (paragraph)
msgid "For most applications, you will begin by defining routes in your `routes/web.php` file. The routes defined in `routes/web.php` may be accessed by entering the defined route's URL in your browser. For example, you may access the following route by navigating to `http://example.com/user` in your browser:"
msgstr "對於大多數的程式來說，我們會在 `routes/web.php` 檔案中定義 Route。我們可以在瀏覽器中打開 Route 定義的 URL 來存取 `routes/web.php` 中定義的路由。舉例來說，我們可以在瀏覽器中打開 `http://example.com/user` 來存取下來路由："

#: docs/8.x/routing.md:block 11 (code)
msgid "use App\\Http\\Controllers\\UserController;\n\n"
"Route::get('/user', [UserController::class, 'index']);\n"
msgstr "use App\\Http\\Controllers\\UserController;\n\n"
"Route::get('/user', [UserController::class, 'index']);\n"

#: docs/8.x/routing.md:block 12 (paragraph)
msgid "Routes defined in the `routes/api.php` file are nested within a route group by the `RouteServiceProvider`. Within this group, the `/api` URI prefix is automatically applied so you do not need to manually apply it to every route in the file. You may modify the prefix and other route group options by modifying your `RouteServiceProvider` class."
msgstr "`routes/api.php` 檔案中定義的 Route 放在巢狀放置在 `RouteServiceProvider` 中的 Route 群組內。在這個群組中，Laravel 會自動加上 `/api` URI 前置詞 (Prefix)，因此在這個檔案中，我們不需手動在所有 Route 前方加上 `/api`。我們也可以修改 `RouteServiceProvider` 類別來修改這個前置詞以及其他一些 Route 群組的選項。"

#: docs/8.x/routing.md:block 14 (header)
msgid "Available Router Methods"
msgstr "可用的 Router 方法"

#: docs/8.x/routing.md:block 15 (paragraph)
msgid "The router allows you to register routes that respond to any HTTP verb:"
msgstr "使用 Router 就能讓我們註冊能回應任何 HTTP 動詞的 Route："

#: docs/8.x/routing.md:block 16 (code)
msgid "Route::get($uri, $callback);\n"
"Route::post($uri, $callback);\n"
"Route::put($uri, $callback);\n"
"Route::patch($uri, $callback);\n"
"Route::delete($uri, $callback);\n"
"Route::options($uri, $callback);\n"
msgstr "Route::get($uri, $callback);\n"
"Route::post($uri, $callback);\n"
"Route::put($uri, $callback);\n"
"Route::patch($uri, $callback);\n"
"Route::delete($uri, $callback);\n"
"Route::options($uri, $callback);\n"

#: docs/8.x/routing.md:block 17 (paragraph)
msgid "Sometimes you may need to register a route that responds to multiple HTTP verbs. You may do so using the `match` method. Or, you may even register a route that responds to all HTTP verbs using the `any` method:"
msgstr "有時候，我們可能需要註冊一個能回應多個 HTTP 動詞的 Route。這時可以使用 `match` 方法。或者，我們甚至可以使用 `any` 方法來註冊一個回應所有 HTTP 動詞的 Route："

#: docs/8.x/routing.md:block 18 (code)
msgid "Route::match(['get', 'post'], '/', function () {\n"
"    //\n"
"});\n\n"
"Route::any('/', function () {\n"
"    //\n"
"});\n"
msgstr "Route::match(['get', 'post'], '/', function () {\n"
"    //\n"
"});\n\n"
"Route::any('/', function () {\n"
"    //\n"
"});\n"

#: docs/8.x/routing.md:block 19 (quote)
msgid "{tip} When defining multiple routes that share the same URI, routes using the `get`, `post`, `put`, `patch`, `delete`, and `options` methods should be defined before routes using the `any`, `match`, and `redirect` methods. This ensures the incoming request is matched with the correct route."
msgstr "{tip} 註冊多個共享同 URI 的 Route 時，應將這些 `any`, `match`, 與 `redirect` 方法的 Route 定義在 `get`, `post`, `put`, `patch`, `delete`, 與 `options` 方法定義之前。這樣一來可以確保連入的 Request 被配對到正確的 Route 上。"

#: docs/8.x/routing.md:block 21 (header)
msgid "Dependency Injection"
msgstr "相依性插入"

#: docs/8.x/routing.md:block 22 (paragraph)
msgid "You may type-hint any dependencies required by your route in your route's callback signature. The declared dependencies will automatically be resolved and injected into the callback by the Laravel [service container](/docs/{{version}}/container). For example, you may type-hint the `Illuminate\\Http\\Request` class to have the current HTTP request automatically injected into your route callback:"
msgstr "可以在 Route 的回呼簽章 (Signature) 上型別提示 (Type-Hint) 任何 Route 所需的相依性。Laravel 的 [Service Container](/docs/{{version}}/container) 會自動解析並插入所定義的相依性。舉例來說，我們可以型別提示 `Illuminate\\Http\\Request` 並自動插入到 Route 回呼中，該類別代表目前的 HTTP Request："

#: docs/8.x/routing.md:block 23 (code)
msgid "use Illuminate\\Http\\Request;\n\n"
"Route::get('/users', function (Request $request) {\n"
"    // ...\n"
"});\n"
msgstr "use Illuminate\\Http\\Request;\n\n"
"Route::get('/users', function (Request $request) {\n"
"    // ...\n"
"});\n"

#: docs/8.x/routing.md:block 25 (header)
msgid "CSRF Protection"
msgstr "CSRF 保護"

#: docs/8.x/routing.md:block 26 (paragraph)
msgid "Remember, any HTML forms pointing to `POST`, `PUT`, `PATCH`, or `DELETE` routes that are defined in the `web` routes file should include a CSRF token field. Otherwise, the request will be rejected. You can read more about CSRF protection in the [CSRF documentation](/docs/{{version}}/csrf):"
msgstr "請記得，當 HTML 表單指向 `web` Route 檔的 `POST`, `PUT`, `PATCH`, 與 `DELETE` Route 時，都應包含一個 CSRF 權杖欄位。若未包含權杖欄位，則該 Request 會被拒絕。更多有關 CSRF 保護的資訊可以參考 [CSRF 說明文件](/docs/{{version}}/csrf)："

#: docs/8.x/routing.md:block 27 (code)
msgid "<form method=\"POST\" action=\"/profile\">\n"
"    @csrf\n"
"    ...\n"
"</form>\n"
msgstr "<form method=\"POST\" action=\"/profile\">\n"
"    @csrf\n"
"    ...\n"
"</form>\n"

#: docs/8.x/routing.md:block 29 (header)
msgid "Redirect Routes"
msgstr "重新導向的 Route"

#: docs/8.x/routing.md:block 30 (paragraph)
msgid "If you are defining a route that redirects to another URI, you may use the `Route::redirect` method. This method provides a convenient shortcut so that you do not have to define a full route or controller for performing a simple redirect:"
msgstr "若想定義可以重新導向到另一個 URI 的 Route，可以使用 `Route::redirect` 方法。這個方法提供了一個方便的捷徑，讓你不需要為了簡單的重新導向定義完整的 Route 或 Controller："

#: docs/8.x/routing.md:block 31 (code)
msgid "Route::redirect('/here', '/there');\n"
msgstr "Route::redirect('/here', '/there');\n"

#: docs/8.x/routing.md:block 32 (paragraph)
msgid "By default, `Route::redirect` returns a `302` status code. You may customize the status code using the optional third parameter:"
msgstr "預設情況下，`Route::redirect` 回傳 `302` 狀態碼。我們可以使用可選的第三個參數來自訂狀態碼："

#: docs/8.x/routing.md:block 33 (code)
msgid "Route::redirect('/here', '/there', 301);\n"
msgstr "Route::redirect('/here', '/there', 301);\n"

#: docs/8.x/routing.md:block 34 (paragraph)
msgid "Or, you may use the `Route::permanentRedirect` method to return a `301` status code:"
msgstr "或者，我們也可以使用 `Route::permanentRedirect` 方法來回傳 `301` 狀態碼："

#: docs/8.x/routing.md:block 35 (code)
msgid "Route::permanentRedirect('/here', '/there');\n"
msgstr "Route::permanentRedirect('/here', '/there');\n"

#: docs/8.x/routing.md:block 36 (quote)
msgid "{note} When using route parameters in redirect routes, the following parameters are reserved by Laravel and cannot be used: `destination` and `status`."
msgstr "{note} 在重新導向 Route 中使用 Route 參數時，有幾個參數名稱是 Laravel 的保留字，無法使用：`destination` 與 `status`。"

#: docs/8.x/routing.md:block 38 (header)
msgid "View Routes"
msgstr "View 的 Route"

#: docs/8.x/routing.md:block 39 (paragraph)
msgid "If your route only needs to return a [view](/docs/{{version}}/views), you may use the `Route::view` method. Like the `redirect` method, this method provides a simple shortcut so that you do not have to define a full route or controller. The `view` method accepts a URI as its first argument and a view name as its second argument. In addition, you may provide an array of data to pass to the view as an optional third argument:"
msgstr "若某個 Route 只需要回傳一個 [View](/docs/{{version}}/views)，則可以使用 `Route::view` 方法。與 `redirect` 方法類似，這個方法提供了一個簡單的捷徑，能讓我們不需定義完整的 Route 或 Controller。`view` 方法接受一個 URI 作為其第一個引數，而第二個引數則是 View 的名稱。此外，也可以提供一組陣列，其中包含要傳給 View 的資料，並作為可選的第三個引數傳入："

#: docs/8.x/routing.md:block 40 (code)
msgid "Route::view('/welcome', 'welcome');\n\n"
"Route::view('/welcome', 'welcome', ['name' => 'Taylor']);\n"
msgstr "Route::view('/welcome', 'welcome');\n\n"
"Route::view('/welcome', 'welcome', ['name' => 'Taylor']);\n"

#: docs/8.x/routing.md:block 41 (quote)
msgid "{note} When using route parameters in view routes, the following parameters are reserved by Laravel and cannot be used: `view`, `data`, `status`, and `headers`."
msgstr "{note} 在 View 的 Route 中使用 Route 參數時，有幾個參數名稱是 Laravel 的保留字，無法使用：`view`、`data`、`status`、`header`。"

#: docs/8.x/routing.md:block 43 (header)
msgid "Route Parameters"
msgstr "Route 參數"

#: docs/8.x/routing.md:block 45 (header)
msgid "Required Parameters"
msgstr "必填參數"

#: docs/8.x/routing.md:block 46 (paragraph)
msgid "Sometimes you will need to capture segments of the URI within your route. For example, you may need to capture a user's ID from the URL. You may do so by defining route parameters:"
msgstr "在 Route 中，有時候我們會想從 URI 中擷取一個片段。舉例來說，我們可能會需要從 URI 中擷取出使用者的 ID。為此，我們可以定義 Route 參數："

#: docs/8.x/routing.md:block 47 (code)
msgid "Route::get('/user/{id}', function ($id) {\n"
"    return 'User '.$id;\n"
"});\n"
msgstr "Route::get('/user/{id}', function ($id) {\n"
"    return 'User '.$id;\n"
"});\n"

#: docs/8.x/routing.md:block 48 (paragraph)
msgid "You may define as many route parameters as required by your route:"
msgstr "根據 Route 的需求，我們可以定義不限數量的 Route 參數："

#: docs/8.x/routing.md:block 49 (code)
msgid "Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {\n"
"    //\n"
"});\n"
msgstr "Route::get('/posts/{post}/comments/{comment}', function ($postId, $commentId) {\n"
"    //\n"
"});\n"

#: docs/8.x/routing.md:block 50 (paragraph)
msgid "Route parameters are always encased within `{}` braces and should consist of alphabetic characters. Underscores (`_`) are also acceptable within route parameter names. Route parameters are injected into route callbacks / controllers based on their order - the names of the route callback / controller arguments do not matter."
msgstr "Route 參數必須要包裝在 `{}` 大括號中，且只能使用字母。在 Route 參數名稱中也可以使用 (`_`)。Route 參數會依照順序插入到 Route 的回呼或 Controller 上 —— Route 的回呼或 Controller 中的名稱並不影響。"

#: docs/8.x/routing.md:block 52 (header)
msgid "Parameters & Dependency Injection"
msgstr "參數與相依性插入"

#: docs/8.x/routing.md:block 53 (paragraph)
msgid "If your route has dependencies that you would like the Laravel service container to automatically inject into your route's callback, you should list your route parameters after your dependencies:"
msgstr "若你的 Route 有使用讓 Laravel Service Container 自動插入到 Route 回呼的相依性的話，請將 Route 參數列在相依性之後："

#: docs/8.x/routing.md:block 54 (code)
msgid "use Illuminate\\Http\\Request;\n\n"
"Route::get('/user/{id}', function (Request $request, $id) {\n"
"    return 'User '.$id;\n"
"});\n"
msgstr "use Illuminate\\Http\\Request;\n\n"
"Route::get('/user/{id}', function (Request $request, $id) {\n"
"    return 'User '.$id;\n"
"});\n"

#: docs/8.x/routing.md:block 56 (header)
msgid "Optional Parameters"
msgstr "可選的參數"

#: docs/8.x/routing.md:block 57 (paragraph)
msgid "Occasionally you may need to specify a route parameter that may not always be present in the URI. You may do so by placing a `?` mark after the parameter name. Make sure to give the route's corresponding variable a default value:"
msgstr "有時候，我們可能會讓某個 Route 參數不需要出現在每個 URI 上。為此，我們可以在參數名稱後方放置一個 `?` 符號。請先確定這個 Route 中對應的變數有預設值："

#: docs/8.x/routing.md:block 58 (code)
msgid "Route::get('/user/{name?}', function ($name = null) {\n"
"    return $name;\n"
"});\n\n"
"Route::get('/user/{name?}', function ($name = 'John') {\n"
"    return $name;\n"
"});\n"
msgstr "Route::get('/user/{name?}', function ($name = null) {\n"
"    return $name;\n"
"});\n\n"
"Route::get('/user/{name?}', function ($name = 'John') {\n"
"    return $name;\n"
"});\n"

#: docs/8.x/routing.md:block 60 (header)
msgid "Regular Expression Constraints"
msgstr "正規表示式條件"

#: docs/8.x/routing.md:block 61 (paragraph)
msgid "You may constrain the format of your route parameters using the `where` method on a route instance. The `where` method accepts the name of the parameter and a regular expression defining how the parameter should be constrained:"
msgstr "可以在 Route 實體上使用 `where` 方法來規定 Route 參數的格式。`where` 方法接受一個參數名稱、以及一個用來規範參數格式的正規表示式："

#: docs/8.x/routing.md:block 62 (code)
msgid "Route::get('/user/{name}', function ($name) {\n"
"    //\n"
"})->where('name', '[A-Za-z]+');\n\n"
"Route::get('/user/{id}', function ($id) {\n"
"    //\n"
"})->where('id', '[0-9]+');\n\n"
"Route::get('/user/{id}/{name}', function ($id, $name) {\n"
"    //\n"
"})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);\n"
msgstr "Route::get('/user/{name}', function ($name) {\n"
"    //\n"
"})->where('name', '[A-Za-z]+');\n\n"
"Route::get('/user/{id}', function ($id) {\n"
"    //\n"
"})->where('id', '[0-9]+');\n\n"
"Route::get('/user/{id}/{name}', function ($id, $name) {\n"
"    //\n"
"})->where(['id' => '[0-9]+', 'name' => '[a-z]+']);\n"

#: docs/8.x/routing.md:block 63 (paragraph)
msgid "For convenience, some commonly used regular expression patterns have helper methods that allow you to quickly add pattern constraints to your routes:"
msgstr "為了方便起見，一些常用的正規式都有輔助方法，可以讓你快速將這些格式套用到 Route 上："

#: docs/8.x/routing.md:block 64 (code)
msgid "Route::get('/user/{id}/{name}', function ($id, $name) {\n"
"    //\n"
"})->whereNumber('id')->whereAlpha('name');\n\n"
"Route::get('/user/{name}', function ($name) {\n"
"    //\n"
"})->whereAlphaNumeric('name');\n\n"
"Route::get('/user/{id}', function ($id) {\n"
"    //\n"
"})->whereUuid('id');\n"
msgstr "Route::get('/user/{id}/{name}', function ($id, $name) {\n"
"    //\n"
"})->whereNumber('id')->whereAlpha('name');\n\n"
"Route::get('/user/{name}', function ($name) {\n"
"    //\n"
"})->whereAlphaNumeric('name');\n\n"
"Route::get('/user/{id}', function ($id) {\n"
"    //\n"
"})->whereUuid('id');\n"

#: docs/8.x/routing.md:block 65 (paragraph)
msgid "If the incoming request does not match the route pattern constraints, a 404 HTTP response will be returned."
msgstr "若連入 Request 不符合 Route 的格式限制，則會回傳 404 HTTP Response。"

#: docs/8.x/routing.md:block 67 (header)
msgid "Global Constraints"
msgstr "全域條件限制"

#: docs/8.x/routing.md:block 68 (paragraph)
msgid "If you would like a route parameter to always be constrained by a given regular expression, you may use the `pattern` method. You should define these patterns in the `boot` method of your `App\\Providers\\RouteServiceProvider` class:"
msgstr "若想以某個正規式規範所有相同的 Route 參數，可以使用 `pattern` 方法。可以在專案的 `App\\Providers\\RouteServiceProvider` 類別中 `boot` 方法內定義這些格式："

#: docs/8.x/routing.md:block 69 (code)
msgid "/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::pattern('id', '[0-9]+');\n"
"}\n"
msgstr "/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::pattern('id', '[0-9]+');\n"
"}\n"

#: docs/8.x/routing.md:block 70 (paragraph)
msgid "Once the pattern has been defined, it is automatically applied to all routes using that parameter name:"
msgstr "定義好之後，這個規則會自動套用到有使用這個參數名稱的 Route："

#: docs/8.x/routing.md:block 71 (code)
msgid "Route::get('/user/{id}', function ($id) {\n"
"    // Only executed if {id} is numeric...\n"
"});\n"
msgstr "Route::get('/user/{id}', function ($id) {\n"
"    // 只會在 {id} 為數字時執行...\n"
"});\n"

#: docs/8.x/routing.md:block 73 (header)
msgid "Encoded Forward Slashes"
msgstr "編碼斜線"

#: docs/8.x/routing.md:block 74 (paragraph)
msgid "The Laravel routing component allows all characters except `/` to be present within route parameter values. You must explicitly allow `/` to be part of your placeholder using a `where` condition regular expression:"
msgstr "Laravel 的路由元件能接受除了 `/` 外的所有字元出現在 Route 的參數值內。請使用 `where` 正規表示式條件來顯式允許 `/` 出現在預留位置中："

#: docs/8.x/routing.md:block 75 (code)
msgid "Route::get('/search/{search}', function ($search) {\n"
"    return $search;\n"
"})->where('search', '.*');\n"
msgstr "Route::get('/search/{search}', function ($search) {\n"
"    return $search;\n"
"})->where('search', '.*');\n"

#: docs/8.x/routing.md:block 76 (quote)
msgid "{note} Encoded forward slashes are only supported within the last route segment."
msgstr "{note} 只有最後一個 Route 片段才支援編碼斜線。"

#: docs/8.x/routing.md:block 78 (header)
msgid "Named Routes"
msgstr "命名的 Route"

#: docs/8.x/routing.md:block 79 (paragraph)
msgid "Named routes allow the convenient generation of URLs or redirects for specific routes. You may specify a name for a route by chaining the `name` method onto the route definition:"
msgstr "命名 Route 可以方便地未特定 Route 產生 URL 或重新導向。我們可以通過在 Route 定義後方串上 `name` 方法來為 Route 指定名稱："

#: docs/8.x/routing.md:block 80 (code)
msgid "Route::get('/user/profile', function () {\n"
"    //\n"
"})->name('profile');\n"
msgstr "Route::get('/user/profile', function () {\n"
"    //\n"
"})->name('profile');\n"

#: docs/8.x/routing.md:block 81 (paragraph)
msgid "You may also specify route names for controller actions:"
msgstr "也可以為 Controller 動作指定 Route 名稱："

#: docs/8.x/routing.md:block 82 (code)
msgid "Route::get(\n"
"    '/user/profile',\n"
"    [UserProfileController::class, 'show']\n"
")->name('profile');\n"
msgstr "Route::get(\n"
"    '/user/profile',\n"
"    [UserProfileController::class, 'show']\n"
")->name('profile');\n"

#: docs/8.x/routing.md:block 83 (quote)
msgid "{note} Route names should always be unique."
msgstr "{note} Route 名稱不可重複。"

#: docs/8.x/routing.md:block 85 (header)
msgid "Generating URLs To Named Routes"
msgstr "產生命名 Route 的 URL"

#: docs/8.x/routing.md:block 86 (paragraph)
msgid "Once you have assigned a name to a given route, you may use the route's name when generating URLs or redirects via Laravel's `route` and `redirect` helper functions:"
msgstr "給某個 Route 指定好名稱後，我們就可以使用 Laravel 的 `route` 與 `redirect` 輔助函式來在產生 URL 或重新導向時使用 Route 的名稱："

#: docs/8.x/routing.md:block 87 (code)
msgid "// Generating URLs...\n"
"$url = route('profile');\n\n"
"// Generating Redirects...\n"
"return redirect()->route('profile');\n"
msgstr "// 產生 URL...\n"
"$url = route('profile');\n\n"
"// 產生重新導向...\n"
"return redirect()->route('profile');\n"

#: docs/8.x/routing.md:block 88 (paragraph)
msgid "If the named route defines parameters, you may pass the parameters as the second argument to the `route` function. The given parameters will automatically be inserted into the generated URL in their correct positions:"
msgstr "若命名 Route 有定義參數，則可以將這些參數作為第二個引數傳給 `route` 函式。傳入的參數會自動依照正確位置插入到產生的 URL 裡："

#: docs/8.x/routing.md:block 89 (code)
msgid "Route::get('/user/{id}/profile', function ($id) {\n"
"    //\n"
"})->name('profile');\n\n"
"$url = route('profile', ['id' => 1]);\n"
msgstr "Route::get('/user/{id}/profile', function ($id) {\n"
"    //\n"
"})->name('profile');\n\n"
"$url = route('profile', ['id' => 1]);\n"

#: docs/8.x/routing.md:block 90 (paragraph)
msgid "If you pass additional parameters in the array, those key / value pairs will automatically be added to the generated URL's query string:"
msgstr "若該陣列中有傳入額外的參數，則這些額外的索引鍵 / 值配對會自動被插入到產生的 URL 中之查詢字串 (Query String) 上："

#: docs/8.x/routing.md:block 91 (code)
msgid "Route::get('/user/{id}/profile', function ($id) {\n"
"    //\n"
"})->name('profile');\n\n"
"$url = route('profile', ['id' => 1, 'photos' => 'yes']);\n\n"
"// /user/1/profile?photos=yes\n"
msgstr "Route::get('/user/{id}/profile', function ($id) {\n"
"    //\n"
"})->name('profile');\n\n"
"$url = route('profile', ['id' => 1, 'photos' => 'yes']);\n\n"
"// /user/1/profile?photos=yes\n"

#: docs/8.x/routing.md:block 92 (quote)
msgid "{tip} Sometimes, you may wish to specify request-wide default values for URL parameters, such as the current locale. To accomplish this, you may use the [`URL::defaults` method](/docs/{{version}}/urls#default-values)."
msgstr "{tip} 有時候，我們可能會想為 URL 引數指定 Request 層級的預設值，例如目前使用的語系等。為此，可以使用 [`URL::defaults` 方法](/docs/{{version}}/urls#default-values)。"

#: docs/8.x/routing.md:block 94 (header)
msgid "Inspecting The Current Route"
msgstr "檢查目前 Route"

#: docs/8.x/routing.md:block 95 (paragraph)
msgid "If you would like to determine if the current request was routed to a given named route, you may use the `named` method on a Route instance. For example, you may check the current route name from a route middleware:"
msgstr "若想判斷目前的 Request 是否有被路由到給定的命名 Route 上，可以使用 Route 實體上的 `named` 方法。舉例來說，我們可以從某個 Route 的 \n"
"Middleware 上檢查目前的 Route 名稱："

#: docs/8.x/routing.md:block 96 (code)
msgid "/**\n"
" * Handle an incoming request.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @param  \\Closure  $next\n"
" * @return mixed\n"
" */\n"
"public function handle($request, Closure $next)\n"
"{\n"
"    if ($request->route()->named('profile')) {\n"
"        //\n"
"    }\n\n"
"    return $next($request);\n"
"}\n"
msgstr "/**\n"
" * Handle an incoming request.\n"
" *\n"
" * @param  \\Illuminate\\Http\\Request  $request\n"
" * @param  \\Closure  $next\n"
" * @return mixed\n"
" */\n"
"public function handle($request, Closure $next)\n"
"{\n"
"    if ($request->route()->named('profile')) {\n"
"        //\n"
"    }\n\n"
"    return $next($request);\n"
"}\n"

#: docs/8.x/routing.md:block 98 (header)
msgid "Route Groups"
msgstr "Route 群組"

#: docs/8.x/routing.md:block 99 (paragraph)
msgid "Route groups allow you to share route attributes, such as middleware, across a large number of routes without needing to define those attributes on each individual route."
msgstr "使用 Route 群組，我們就可以在多個 Route 間共享相同的 Route 參數（如：使用相同的 Middleware），而不需要手動在個別 Route 上定義這些參數。"

#: docs/8.x/routing.md:block 100 (paragraph)
msgid "Nested groups attempt to intelligently \"merge\" attributes with their parent group. Middleware and `where` conditions are merged while names and prefixes are appended. Namespace delimiters and slashes in URI prefixes are automatically added where appropriate."
msgstr "巢狀群組會嘗試智慧地將屬性「合併」到上層群組中。Middleware 與 `where` 條件會被合併，而命名 Route 的名稱則會被作為前置詞放到前面。Laravel 會自動在適當的時候往 URI 前方插入 Namespace 分隔符號或斜線。"

#: docs/8.x/routing.md:block 102 (header)
msgid "Middleware"
msgstr "Middleware"

#: docs/8.x/routing.md:block 103 (paragraph)
msgid "To assign [middleware](/docs/{{version}}/middleware) to all routes within a group, you may use the `middleware` method before defining the group. Middleware are executed in the order they are listed in the array:"
msgstr "若要將 [Middleware](/docs/{{version}}/middleware) 設定給群組中的所有 Route，可以在定義群組前使用 `middleware` 方法。Middleware 會以陣列中列出的順序執行："

#: docs/8.x/routing.md:block 104 (code)
msgid "Route::middleware(['first', 'second'])->group(function () {\n"
"    Route::get('/', function () {\n"
"        // Uses first & second middleware...\n"
"    });\n\n"
"    Route::get('/user/profile', function () {\n"
"        // Uses first & second middleware...\n"
"    });\n"
"});\n"
msgstr "Route::middleware(['first', 'second'])->group(function () {\n"
"    Route::get('/', function () {\n"
"        // 使用 first 與 second Middleware...\n"
"    });\n\n"
"    Route::get('/user/profile', function () {\n"
"        // 使用 first 與 second Middleware...\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 106 (header)
msgid "Controllers"
msgstr "Controller"

#: docs/8.x/routing.md:block 107 (paragraph)
msgid "If a group of routes all utilize the same [controller](/docs/{{version}}/controllers), you may use the `controller` method to define the common controller for all of the routes within the group. Then, when defining the routes, you only need to provide the controller method that they invoke:"
msgstr "若有一組 Route 全部都使用了相同的 [Controller](/docs/{{version}}/controllers)，則我們可以使用 `controller` 方法來在路由群組中為所有的路由定義通用的 Controller。定義好之後，當定義路由時，就只需要提供要叫用的 Controller 方法即可："

#: docs/8.x/routing.md:block 108 (code)
msgid "use App\\Http\\Controllers\\OrderController;\n\n"
"Route::controller(OrderController::class)->group(function () {\n"
"    Route::get('/orders/{id}', 'show');\n"
"    Route::post('/orders', 'store');\n"
"});\n"
msgstr "use App\\Http\\Controllers\\OrderController;\n\n"
"Route::controller(OrderController::class)->group(function () {\n"
"    Route::get('/orders/{id}', 'show');\n"
"    Route::post('/orders', 'store');\n"
"});\n"

#: docs/8.x/routing.md:block 110 (header)
msgid "Subdomain Routing"
msgstr "子網域路由"

#: docs/8.x/routing.md:block 111 (paragraph)
msgid "Route groups may also be used to handle subdomain routing. Subdomains may be assigned route parameters just like route URIs, allowing you to capture a portion of the subdomain for usage in your route or controller. The subdomain may be specified by calling the `domain` method before defining the group:"
msgstr "Route 群組也可以用來處理子網域路由。我們可以像在設定 Route URI 一樣，在Route 參數內指派子網域。這樣一來我們就可以在 Route 或 Controller 內取得子網域的部分。可以通過在定義群組前呼叫 `domain` 來指定子網域："

#: docs/8.x/routing.md:block 112 (code)
msgid "Route::domain('{account}.example.com')->group(function () {\n"
"    Route::get('user/{id}', function ($account, $id) {\n"
"        //\n"
"    });\n"
"});\n"
msgstr "Route::domain('{account}.example.com')->group(function () {\n"
"    Route::get('user/{id}', function ($account, $id) {\n"
"        //\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 113 (quote)
msgid "{note} In order to ensure your subdomain routes are reachable, you should register subdomain routes before registering root domain routes. This will prevent root domain routes from overwriting subdomain routes which have the same URI path."
msgstr "{note} 為了確保子網域 Route 有效，請在註冊任何根網域 Route 前先註冊子網域 Route。這樣可以避免根網域的 Route 去複寫到子網域 Route 中有相同 URI 路徑的 Route。"

#: docs/8.x/routing.md:block 115 (header)
msgid "Route Prefixes"
msgstr "Route 前置詞"

#: docs/8.x/routing.md:block 116 (paragraph)
msgid "The `prefix` method may be used to prefix each route in the group with a given URI. For example, you may want to prefix all route URIs within the group with `admin`:"
msgstr "可以使用 `prefix` 方法來為群組中的每個 Route 都加上給定 URI 的前置詞。舉例來說，我們可能會想把某個群組中的所有 Route URI 都加上 `admin` 前置詞："

#: docs/8.x/routing.md:block 117 (code)
msgid "Route::prefix('admin')->group(function () {\n"
"    Route::get('/users', function () {\n"
"        // Matches The \"/admin/users\" URL\n"
"    });\n"
"});\n"
msgstr "Route::prefix('admin')->group(function () {\n"
"    Route::get('/users', function () {\n"
"        // 配對到「/admin/users」URL\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 119 (header)
msgid "Route Name Prefixes"
msgstr "命名 Route 的名稱前置詞"

#: docs/8.x/routing.md:block 120 (paragraph)
msgid "The `name` method may be used to prefix each route name in the group with a given string. For example, you may want to prefix all of the grouped route's names with `admin`. The given string is prefixed to the route name exactly as it is specified, so we will be sure to provide the trailing `.` character in the prefix:"
msgstr "可以使用 `name` 方法來給群組中的每個 Route 名稱都加上給定字串的前置詞。舉例來說，我們可能會想給群組 Route 中的所有 Route 名稱都加上 `admin` 前置詞。給定字串會直接以指定時的樣子被加到 Route 名稱上。因此，請確保有在前置詞後方加上 `.` 字元："

#: docs/8.x/routing.md:block 121 (code)
msgid "Route::name('admin.')->group(function () {\n"
"    Route::get('/users', function () {\n"
"        // Route assigned name \"admin.users\"...\n"
"    })->name('users');\n"
"});\n"
msgstr "Route::name('admin.')->group(function () {\n"
"    Route::get('/users', function () {\n"
"        // Route 被指派名稱為「admin.users」...\n"
"    })->name('users');\n"
"});\n"

#: docs/8.x/routing.md:block 123 (header)
msgid "Route Model Binding"
msgstr "Route 的 Model 繫結"

#: docs/8.x/routing.md:block 124 (paragraph)
msgid "When injecting a model ID to a route or controller action, you will often query the database to retrieve the model that corresponds to that ID. Laravel route model binding provides a convenient way to automatically inject the model instances directly into your routes. For example, instead of injecting a user's ID, you can inject the entire `User` model instance that matches the given ID."
msgstr "在將 Model ID 插入到 Route 或 Controller 動作時，我們常常會需要查詢資料庫來取得相應於該 ID 的 Model。Laravel 的 Route Model 繫結提供了能自動將 Model 實體插入到 Route 中的方便方法。舉例來說，我們可以插入符合給定 ID 的整個 `User` Model 實體，而不是插入使用者的 ID。"

#: docs/8.x/routing.md:block 126 (header)
msgid "Implicit Binding"
msgstr "隱式繫結"

#: docs/8.x/routing.md:block 127 (paragraph)
msgid "Laravel automatically resolves Eloquent models defined in routes or controller actions whose type-hinted variable names match a route segment name. For example:"
msgstr "當 Route 或 Controller 動作中定義的變數名稱符合某個 Route 片段名稱，且該變數有型別提示時，Laravel 會自動解析 Eloquent Model。舉例來說："

#: docs/8.x/routing.md:block 128 (code)
msgid "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    return $user->email;\n"
"});\n"
msgstr "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    return $user->email;\n"
"});\n"

#: docs/8.x/routing.md:block 129 (paragraph)
msgid "Since the `$user` variable is type-hinted as the `App\\Models\\User` Eloquent model and the variable name matches the `{user}` URI segment, Laravel will automatically inject the model instance that has an ID matching the corresponding value from the request URI. If a matching model instance is not found in the database, a 404 HTTP response will automatically be generated."
msgstr "由於 `$user` 變數有型別提示為 `App\\Models\\User` Eloquent Model，且該變數名稱符合 `{user}` URI 片段，因此 Laravel 會自動將 ID 符合 Request URI 中相應值的 Model 實體插入進去。若資料庫中找不到對應的 Model 實體，則會自動產生 404 HTTP Response。"

#: docs/8.x/routing.md:block 130 (paragraph)
msgid "Of course, implicit binding is also possible when using controller methods. Again, note the `{user}` URI segment matches the `$user` variable in the controller which contains an `App\\Models\\User` type-hint:"
msgstr "當然，在使用 Controller 方法時也能使用隱式繫結。再強調一次，必須注意 `{user}` URI 片段要符合 Controller 中有 `App\\Models\\User` 型別提示的 `$user` 變數："

#: docs/8.x/routing.md:block 131 (code)
msgid "use App\\Http\\Controllers\\UserController;\n"
"use App\\Models\\User;\n\n"
"// Route definition...\n"
"Route::get('/users/{user}', [UserController::class, 'show']);\n\n"
"// Controller method definition...\n"
"public function show(User $user)\n"
"{\n"
"    return view('user.profile', ['user' => $user]);\n"
"}\n"
msgstr "use App\\Http\\Controllers\\UserController;\n"
"use App\\Models\\User;\n\n"
"// Route 定義...\n"
"Route::get('/users/{user}', [UserController::class, 'show']);\n\n"
"// Controller 方法定義...\n"
"public function show(User $user)\n"
"{\n"
"    return view('user.profile', ['user' => $user]);\n"
"}\n"

#: docs/8.x/routing.md:block 133 (header)
msgid "Soft Deleted Models"
msgstr "軟刪除的 Model"

#: docs/8.x/routing.md:block 134 (paragraph)
msgid "Typically, implicit model binding will not retrieve models that have been [soft deleted](/docs/{{version}}/eloquent#soft-deleting). However, you may instruct the implicit binding to retrieve these models by chaining the `withTrashed` method onto your route's definition:"
msgstr "一般來說，隱式型別細節不會去的被[軟刪除](/docs/{{version}}/eloquent#soft-deleting)的 Model。不過，我們也可以在 Route 的定義後方串上 `withTrashed` 方法來讓隱式型別綁定取得這些 Model："

#: docs/8.x/routing.md:block 135 (code)
msgid "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    return $user->email;\n"
"})->withTrashed();\n"
msgstr "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    return $user->email;\n"
"})->withTrashed();\n"

#: docs/8.x/routing.md:block 137 (header)
msgid "Customizing The Key"
msgstr "自訂索引鍵"

#: docs/8.x/routing.md:block 138 (paragraph)
msgid "Sometimes you may wish to resolve Eloquent models using a column other than `id`. To do so, you may specify the column in the route parameter definition:"
msgstr "有時候，我們可能會像讓 Eloquent 解析 `id` 以外的其他欄位。為此，可以在 Route 的參數定義中指定這個欄位："

#: docs/8.x/routing.md:block 139 (code)
msgid "use App\\Models\\Post;\n\n"
"Route::get('/posts/{post:slug}', function (Post $post) {\n"
"    return $post;\n"
"});\n"
msgstr "use App\\Models\\Post;\n\n"
"Route::get('/posts/{post:slug}', function (Post $post) {\n"
"    return $post;\n"
"});\n"

#: docs/8.x/routing.md:block 140 (paragraph)
msgid "If you would like model binding to always use a database column other than `id` when retrieving a given model class, you may override the `getRouteKeyName` method on the Eloquent model:"
msgstr "若想讓 Model 繫結在給定 Model 類別上總是使用 `id` 以外的其他欄位，可以在 Eloquent Model 上複寫 `getRouteKeyName` 方法："

#: docs/8.x/routing.md:block 141 (code)
msgid "/**\n"
" * Get the route key for the model.\n"
" *\n"
" * @return string\n"
" */\n"
"public function getRouteKeyName()\n"
"{\n"
"    return 'slug';\n"
"}\n"
msgstr "/**\n"
" * Get the route key for the model.\n"
" *\n"
" * @return string\n"
" */\n"
"public function getRouteKeyName()\n"
"{\n"
"    return 'slug';\n"
"}\n"

#: docs/8.x/routing.md:block 143 (header)
msgid "Custom Keys & Scoping"
msgstr "自訂索引鍵與作用範圍"

#: docs/8.x/routing.md:block 144 (paragraph)
msgid "When implicitly binding multiple Eloquent models in a single route definition, you may wish to scope the second Eloquent model such that it must be a child of the previous Eloquent model. For example, consider this route definition that retrieves a blog post by slug for a specific user:"
msgstr "當我們在單一 Route 定義中隱式繫結多個 Eloquent Model 時，我們可以限定第二個 Eloquent Model 一定要是前一個 Eloquent Model 的子 Model。舉例來說，假設有下列這樣通過 Slug 取得特定使用者的部落格貼文的 Route 定義："

#: docs/8.x/routing.md:block 145 (code)
msgid "use App\\Models\\Post;\n"
"use App\\Models\\User;\n\n"
"Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\n"
"    return $post;\n"
"});\n"
msgstr "use App\\Models\\Post;\n"
"use App\\Models\\User;\n\n"
"Route::get('/users/{user}/posts/{post:slug}', function (User $user, Post $post) {\n"
"    return $post;\n"
"});\n"

#: docs/8.x/routing.md:block 146 (paragraph)
msgid "When using a custom keyed implicit binding as a nested route parameter, Laravel will automatically scope the query to retrieve the nested model by its parent using conventions to guess the relationship name on the parent. In this case, it will be assumed that the `User` model has a relationship named `posts` (the plural form of the route parameter name) which can be used to retrieve the `Post` model."
msgstr "當使用自訂鍵值的隱式繫結作為巢狀路由參數時，Laravel 會自動以慣例推測其上層 Model 上的關聯名稱來將限制巢狀 Model 的查詢範圍。在這個例子中，Laravel 會假設 `User` Model 有個名為 `posts` 的關聯 (即路由參數名稱的複數形)，該關聯將用於取得 `Post` Model。"

#: docs/8.x/routing.md:block 147 (paragraph)
msgid "If you wish, you may instruct Laravel to scope \"child\" bindings even when a custom key is not provided. To do so, you may invoke the `scopeBindings` method when defining your route:"
msgstr "若有需要的話，就算沒有提供自訂索引鍵，我們還是可以告訴 Laravel 要如何限定「子」繫結的限定。為此，我們可以在定義 Route 時叫用 `scopeBindings` 方法："

#: docs/8.x/routing.md:block 148 (code)
msgid "use App\\Models\\Post;\n"
"use App\\Models\\User;\n\n"
"Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\n"
"    return $post;\n"
"})->scopeBindings();\n"
msgstr "use App\\Models\\Post;\n"
"use App\\Models\\User;\n\n"
"Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\n"
"    return $post;\n"
"})->scopeBindings();\n"

#: docs/8.x/routing.md:block 149 (paragraph)
msgid "Or, you may instruct an entire group of route definitions to use scoped bindings:"
msgstr "或者，也可以讓整個 Route 定義群組使用限定範圍的繫結："

#: docs/8.x/routing.md:block 150 (code)
msgid "Route::scopeBindings()->group(function () {\n"
"    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\n"
"        return $post;\n"
"    });\n"
"});\n"
msgstr "Route::scopeBindings()->group(function () {\n"
"    Route::get('/users/{user}/posts/{post}', function (User $user, Post $post) {\n"
"        return $post;\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 152 (header)
msgid "Customizing Missing Model Behavior"
msgstr "自訂找不到 Model 的行為"

#: docs/8.x/routing.md:block 153 (paragraph)
msgid "Typically, a 404 HTTP response will be generated if an implicitly bound model is not found. However, you may customize this behavior by calling the `missing` method when defining your route. The `missing` method accepts a closure that will be invoked if an implicitly bound model can not be found:"
msgstr "通常來說，若找不到隱式繫結的 Model 時會產生一個 404 HTTP 回應。不過，可以在定義 Route 時呼叫 `missing` 方法來自訂這個行為。`missing` 方法接受一個閉包，該閉包會在找不到隱式繫結的 Model 時被叫用："

#: docs/8.x/routing.md:block 154 (code)
msgid "use App\\Http\\Controllers\\LocationsController;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Redirect;\n\n"
"Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])\n"
"        ->name('locations.view')\n"
"        ->missing(function (Request $request) {\n"
"            return Redirect::route('locations.index');\n"
"        });\n"
msgstr "use App\\Http\\Controllers\\LocationsController;\n"
"use Illuminate\\Http\\Request;\n"
"use Illuminate\\Support\\Facades\\Redirect;\n\n"
"Route::get('/locations/{location:slug}', [LocationsController::class, 'show'])\n"
"        ->name('locations.view')\n"
"        ->missing(function (Request $request) {\n"
"            return Redirect::route('locations.index');\n"
"        });\n"

#: docs/8.x/routing.md:block 156 (header)
msgid "Explicit Binding"
msgstr "顯式繫結"

#: docs/8.x/routing.md:block 157 (paragraph)
msgid "You are not required to use Laravel's implicit, convention based model resolution in order to use model binding. You can also explicitly define how route parameters correspond to models. To register an explicit binding, use the router's `model` method to specify the class for a given parameter. You should define your explicit model bindings at the beginning of the `boot` method of your `RouteServiceProvider` class:"
msgstr "Model 繫結不一定要使用 Laravel 的隱式的，隱式繫結是基於慣例的 Model 解析。我們也可以顯式定義 Route 參數要怎麼對應到 Model。若要註冊顯式細節，請使用 Router 的 `model` 方法來為給定參數指定類別。應在 `RouteServiceProvider` 類別中 `boot` 方法內的開頭定義顯式 Model 繫結："

#: docs/8.x/routing.md:block 158 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::model('user', User::class);\n\n"
"    // ...\n"
"}\n"
msgstr "use App\\Models\\User;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::model('user', User::class);\n\n"
"    // ...\n"
"}\n"

#: docs/8.x/routing.md:block 159 (paragraph)
msgid "Next, define a route that contains a `{user}` parameter:"
msgstr "接著，請定義含有 `{user}` 參數的 Route："

#: docs/8.x/routing.md:block 160 (code)
msgid "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    //\n"
"});\n"
msgstr "use App\\Models\\User;\n\n"
"Route::get('/users/{user}', function (User $user) {\n"
"    //\n"
"});\n"

#: docs/8.x/routing.md:block 161 (paragraph)
msgid "Since we have bound all `{user}` parameters to the `App\\Models\\User` model, an instance of that class will be injected into the route. So, for example, a request to `users/1` will inject the `User` instance from the database which has an ID of `1`."
msgstr "我們已經將所有 `{user}` 參數繫結到 `App\\Models\\User` Model 上了。`User` Model 的實體會被插入到這個 Route 中。因此，舉例來說，對 `users/1` 的 Request 將會插入一個資料庫中 ID 為 `1` 的 `User` 實體。"

#: docs/8.x/routing.md:block 162 (paragraph)
msgid "If a matching model instance is not found in the database, a 404 HTTP response will be automatically generated."
msgstr "若資料庫中找不到相符合的 Model 實體，則會自動產生 404 HTTP Response。"

#: docs/8.x/routing.md:block 164 (header)
msgid "Customizing The Resolution Logic"
msgstr "自訂解析邏輯"

#: docs/8.x/routing.md:block 165 (paragraph)
msgid "If you wish to define your own model binding resolution logic, you may use the `Route::bind` method. The closure you pass to the `bind` method will receive the value of the URI segment and should return the instance of the class that should be injected into the route. Again, this customization should take place in the `boot` method of your application's `RouteServiceProvider`:"
msgstr "若想定義你自己的 Model 繫結解析邏輯，則可以使用 `Route::bind` 方法。我們可以傳入一個閉包給 `bind` 方法，用來接受 URI 片段中的值，並回應要插入到 Route 中的類別實體。同樣的，這個自訂邏輯應放在專案的 `RouteServiceProvider` 中 `boot` 方法內："

#: docs/8.x/routing.md:block 166 (code)
msgid "use App\\Models\\User;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::bind('user', function ($value) {\n"
"        return User::where('name', $value)->firstOrFail();\n"
"    });\n\n"
"    // ...\n"
"}\n"
msgstr "use App\\Models\\User;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"/**\n"
" * Define your route model bindings, pattern filters, etc.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Route::bind('user', function ($value) {\n"
"        return User::where('name', $value)->firstOrFail();\n"
"    });\n\n"
"    // ...\n"
"}\n"

#: docs/8.x/routing.md:block 167 (paragraph)
msgid "Alternatively, you may override the `resolveRouteBinding` method on your Eloquent model. This method will receive the value of the URI segment and should return the instance of the class that should be injected into the route:"
msgstr "或者，我們也可以在 Eloquent Model 上複寫 `resolveRouteBinding` 方法。這個方法會接收 URI 片段中的值，並應回傳要插入到 Route 中的類別實體："

#: docs/8.x/routing.md:block 168 (code)
msgid "/**\n"
" * Retrieve the model for a bound value.\n"
" *\n"
" * @param  mixed  $value\n"
" * @param  string|null  $field\n"
" * @return \\Illuminate\\Database\\Eloquent\\Model|null\n"
" */\n"
"public function resolveRouteBinding($value, $field = null)\n"
"{\n"
"    return $this->where('name', $value)->firstOrFail();\n"
"}\n"
msgstr "/**\n"
" * Retrieve the model for a bound value.\n"
" *\n"
" * @param  mixed  $value\n"
" * @param  string|null  $field\n"
" * @return \\Illuminate\\Database\\Eloquent\\Model|null\n"
" */\n"
"public function resolveRouteBinding($value, $field = null)\n"
"{\n"
"    return $this->where('name', $value)->firstOrFail();\n"
"}\n"

#: docs/8.x/routing.md:block 169 (paragraph)
msgid "If a route is utilizing [implicit binding scoping](#implicit-model-binding-scoping), the `resolveChildRouteBinding` method will be used to resolve the child binding of the parent model:"
msgstr "如有 Route 是使用[限定範圍的隱式細節](#implicit-model-binding-scoping)，則在解析上層 Model 的子繫結時會使用 `resolveChildRouteBinding` 方法："

#: docs/8.x/routing.md:block 170 (code)
msgid "/**\n"
" * Retrieve the child model for a bound value.\n"
" *\n"
" * @param  string  $childType\n"
" * @param  mixed  $value\n"
" * @param  string|null  $field\n"
" * @return \\Illuminate\\Database\\Eloquent\\Model|null\n"
" */\n"
"public function resolveChildRouteBinding($childType, $value, $field)\n"
"{\n"
"    return parent::resolveChildRouteBinding($childType, $value, $field);\n"
"}\n"
msgstr "/**\n"
" * Retrieve the child model for a bound value.\n"
" *\n"
" * @param  string  $childType\n"
" * @param  mixed  $value\n"
" * @param  string|null  $field\n"
" * @return \\Illuminate\\Database\\Eloquent\\Model|null\n"
" */\n"
"public function resolveChildRouteBinding($childType, $value, $field)\n"
"{\n"
"    return parent::resolveChildRouteBinding($childType, $value, $field);\n"
"}\n"

#: docs/8.x/routing.md:block 172 (header)
msgid "Fallback Routes"
msgstr "遞補的 Route"

#: docs/8.x/routing.md:block 173 (paragraph)
msgid "Using the `Route::fallback` method, you may define a route that will be executed when no other route matches the incoming request. Typically, unhandled requests will automatically render a \"404\" page via your application's exception handler. However, since you would typically define the `fallback` route within your `routes/web.php` file, all middleware in the `web` middleware group will apply to the route. You are free to add additional middleware to this route as needed:"
msgstr "使用 `Route::fallback` 方法，就可以定義當沒有其他 Route 符合連入 Request 時要執行的 Route。一般來說，專案中的例外處理常式會自動幫未處理的 Request 會轉譯出「404」頁面。不過，因為我們通常會在 `routes/web.php` 檔案中定義 `fallback` Route，因此在 `web` Middleware 群組中的所有 Middleware 也會被套用到該 Route 中。有需要的話也可以為這個 Route 定義額外的 Middleware："

#: docs/8.x/routing.md:block 174 (code)
msgid "Route::fallback(function () {\n"
"    //\n"
"});\n"
msgstr "Route::fallback(function () {\n"
"    //\n"
"});\n"

#: docs/8.x/routing.md:block 175 (quote)
msgid "{note} The fallback route should always be the last route registered by your application."
msgstr "{note} 遞補的 Route 應該要保持為專案中最後一個註冊的 Route。"

#: docs/8.x/routing.md:block 177 (header)
msgid "Rate Limiting"
msgstr "頻率限制"

#: docs/8.x/routing.md:block 179 (header)
msgid "Defining Rate Limiters"
msgstr "定義 Rate Limiter (頻率限制程式)"

#: docs/8.x/routing.md:block 180 (paragraph)
msgid "Laravel includes powerful and customizable rate limiting services that you may utilize to restrict the amount of traffic for a given route or group of routes. To get started, you should define rate limiter configurations that meet your application's needs. Typically, this should be done within the `configureRateLimiting` method of your application's `App\\Providers\\RouteServiceProvider` class."
msgstr "Laravel 中包含了強大且可客製化的頻率限制服務，可以用來為給定的 Route 或 Route 群組限制流量。要開始使用頻率限制，我們需要先依照專案需求定義 Rate Limiter (頻率限制程式) 的設定。一般來說，應在 `App\\Providers\\RouteServiceProvider` 類別的 `configureRateLimiting` 方法中定義。"

#: docs/8.x/routing.md:block 181 (paragraph)
msgid "Rate limiters are defined using the `RateLimiter` facade's `for` method. The `for` method accepts a rate limiter name and a closure that returns the limit configuration that should apply to routes that are assigned to the rate limiter. Limit configuration are instances of the `Illuminate\\Cache\\RateLimiting\\Limit` class. This class contains helpful \"builder\" methods so that you can quickly define your limit. The rate limiter name may be any string you wish:"
msgstr "使用 `RateLimiter` Facade 的 `for` 方法來定義 Rate Limiter。`for` 方法接受 Rate Limiter 的名稱以及一個閉包。該閉包應回傳用來套用到指派了這個 Rate Limiter 上的 Route 所需要的頻率限制設定。頻率限制的設定使用 `Illuminate\\Cache\\RateLimiting\\Limit` 類別的實體。這個實體中包含了實用的「建構程式 (Builder)」，可讓你快速定義限制。Rate Limiter 的名稱可以為任意字串："

#: docs/8.x/routing.md:block 182 (code)
msgid "use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"use Illuminate\\Support\\Facades\\RateLimiter;\n\n"
"/**\n"
" * Configure the rate limiters for the application.\n"
" *\n"
" * @return void\n"
" */\n"
"protected function configureRateLimiting()\n"
"{\n"
"    RateLimiter::for('global', function (Request $request) {\n"
"        return Limit::perMinute(1000);\n"
"    });\n"
"}\n"
msgstr "use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"use Illuminate\\Support\\Facades\\RateLimiter;\n\n"
"/**\n"
" * Configure the rate limiters for the application.\n"
" *\n"
" * @return void\n"
" */\n"
"protected function configureRateLimiting()\n"
"{\n"
"    RateLimiter::for('global', function (Request $request) {\n"
"        return Limit::perMinute(1000);\n"
"    });\n"
"}\n"

#: docs/8.x/routing.md:block 183 (paragraph)
msgid "If the incoming request exceeds the specified rate limit, a response with a 429 HTTP status code will automatically be returned by Laravel. If you would like to define your own response that should be returned by a rate limit, you may use the `response` method:"
msgstr "若連入的 Request 超過了指定的頻率限制，Laravel 會自動回傳一個 429 HTTP 狀態碼。若想自訂頻率限制回傳的 Response，可使用 `response` 方法："

#: docs/8.x/routing.md:block 184 (code)
msgid "RateLimiter::for('global', function (Request $request) {\n"
"    return Limit::perMinute(1000)->response(function () {\n"
"        return response('Custom response...', 429);\n"
"    });\n"
"});\n"
msgstr "RateLimiter::for('global', function (Request $request) {\n"
"    return Limit::perMinute(1000)->response(function () {\n"
"        return response('Custom response...', 429);\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 185 (paragraph)
msgid "Since rate limiter callbacks receive the incoming HTTP request instance, you may build the appropriate rate limit dynamically based on the incoming request or authenticated user:"
msgstr "由於頻率限制程式的回呼會接收連入 HTTP Request 實體，因此我們可以依據連入 Request 或登入使用者來動態調整適當的頻率限制："

#: docs/8.x/routing.md:block 186 (code)
msgid "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()->vipCustomer()\n"
"                ? Limit::none()\n"
"                : Limit::perMinute(100);\n"
"});\n"
msgstr "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()->vipCustomer()\n"
"                ? Limit::none()\n"
"                : Limit::perMinute(100);\n"
"});\n"

#: docs/8.x/routing.md:block 188 (header)
msgid "Segmenting Rate Limits"
msgstr "區塊化的頻率限制"

#: docs/8.x/routing.md:block 189 (paragraph)
msgid "Sometimes you may wish to segment rate limits by some arbitrary value. For example, you may wish to allow users to access a given route 100 times per minute per IP address. To accomplish this, you may use the `by` method when building your rate limit:"
msgstr "有時候，我們可能會像依照某個值來做分區的頻率限制。舉例來說，我們可能會想讓某個使用者在每個 IP 位址上每分鐘只能存取某個 Route 100 次。為此，可以在設定頻率限制時使用 `by` 方法："

#: docs/8.x/routing.md:block 190 (code)
msgid "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()->vipCustomer()\n"
"                ? Limit::none()\n"
"                : Limit::perMinute(100)->by($request->ip());\n"
"});\n"
msgstr "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()->vipCustomer()\n"
"                ? Limit::none()\n"
"                : Limit::perMinute(100)->by($request->ip());\n"
"});\n"

#: docs/8.x/routing.md:block 191 (paragraph)
msgid "To illustrate this feature using another example, we can limit access to the route to 100 times per minute per authenticated user ID or 10 times per minute per IP address for guests:"
msgstr "我們來看看另一個使用這個功能的例子。我們可以像這樣限制某個 Route 對已登入使用者的限制時 100 次/分鐘，而未登入使用者則是 10 次/分鐘："

#: docs/8.x/routing.md:block 192 (code)
msgid "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()\n"
"                ? Limit::perMinute(100)->by($request->user()->id)\n"
"                : Limit::perMinute(10)->by($request->ip());\n"
"});\n"
msgstr "RateLimiter::for('uploads', function (Request $request) {\n"
"    return $request->user()\n"
"                ? Limit::perMinute(100)->by($request->user()->id)\n"
"                : Limit::perMinute(10)->by($request->ip());\n"
"});\n"

#: docs/8.x/routing.md:block 194 (header)
msgid "Multiple Rate Limits"
msgstr "多個頻率限制"

#: docs/8.x/routing.md:block 195 (paragraph)
msgid "If needed, you may return an array of rate limits for a given rate limiter configuration. Each rate limit will be evaluated for the route based on the order they are placed within the array:"
msgstr "當然，對於某個 Rate Limiter 的設定，我們也可以回傳一組包含頻率限制的陣列。每個頻率限制會依據陣列中的順序被套用在 Route 上："

#: docs/8.x/routing.md:block 196 (code)
msgid "RateLimiter::for('login', function (Request $request) {\n"
"    return [\n"
"        Limit::perMinute(500),\n"
"        Limit::perMinute(3)->by($request->input('email')),\n"
"    ];\n"
"});\n"
msgstr "RateLimiter::for('login', function (Request $request) {\n"
"    return [\n"
"        Limit::perMinute(500),\n"
"        Limit::perMinute(3)->by($request->input('email')),\n"
"    ];\n"
"});\n"

#: docs/8.x/routing.md:block 198 (header)
msgid "Attaching Rate Limiters To Routes"
msgstr "將 Rate Limiter 附加到 Route 上"

#: docs/8.x/routing.md:block 199 (paragraph)
msgid "Rate limiters may be attached to routes or route groups using the `throttle` [middleware](/docs/{{version}}/middleware). The throttle middleware accepts the name of the rate limiter you wish to assign to the route:"
msgstr "可以使用 `throttle` [Middleware](/docs/{{version}}/middleware) 來將 Rate Limiter 附加到 Route 或 Route 群組上。這個 Throttle Middleware 接受欲指派給 Route 的 Rate Limiter 名稱："

#: docs/8.x/routing.md:block 200 (code)
msgid "Route::middleware(['throttle:uploads'])->group(function () {\n"
"    Route::post('/audio', function () {\n"
"        //\n"
"    });\n\n"
"    Route::post('/video', function () {\n"
"        //\n"
"    });\n"
"});\n"
msgstr "Route::middleware(['throttle:uploads'])->group(function () {\n"
"    Route::post('/audio', function () {\n"
"        //\n"
"    });\n\n"
"    Route::post('/video', function () {\n"
"        //\n"
"    });\n"
"});\n"

#: docs/8.x/routing.md:block 202 (header)
msgid "Throttling With Redis"
msgstr "使用 Redis 來做頻率限制"

#: docs/8.x/routing.md:block 203 (paragraph)
msgid "Typically, the `throttle` middleware is mapped to the `Illuminate\\Routing\\Middleware\\ThrottleRequests` class. This mapping is defined in your application's HTTP kernel (`App\\Http\\Kernel`). However, if you are using Redis as your application's cache driver, you may wish to change this mapping to use the `Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis` class. This class is more efficient at managing rate limiting using Redis:"
msgstr "一般來說，`throttle` Middleware 被映射到 `Illuminate\\Routing\\Middleware\\ThrottleRequests` 類別。這個映射定義在程式的 HTTP Kernel (`App\\Http\\Kernel`) 中。不過，如果你使用 Redis 來作為快取的 Driver，則可以將這個映射改為使用 `Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis` 類別。這個類別能更有效率地使用 Redis 來管理頻率限制："

#: docs/8.x/routing.md:block 204 (code)
msgid "'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\n"
msgstr "'throttle' => \\Illuminate\\Routing\\Middleware\\ThrottleRequestsWithRedis::class,\n"

#: docs/8.x/routing.md:block 206 (header)
msgid "Form Method Spoofing"
msgstr "表單方法的變更"

#: docs/8.x/routing.md:block 207 (paragraph)
msgid "HTML forms do not support `PUT`, `PATCH`, or `DELETE` actions. So, when defining `PUT`, `PATCH`, or `DELETE` routes that are called from an HTML form, you will need to add a hidden `_method` field to the form. The value sent with the `_method` field will be used as the HTTP request method:"
msgstr "HTML 表單不支援 `PUT`, `PATCH`, 與 `DELETE` 動作，因此，當我們在定義會由 HTML 表單呼叫的 `PUT`, `PATCH`, 或 `DELETE` Route 時，我們需要在表單內加上一個隱藏的 `_method` 欄位。包含在 `_method` 欄位裡的值會被當作 HTTP Request 方法使用："

#: docs/8.x/routing.md:block 208 (code)
msgid "<form action=\"/example\" method=\"POST\">\n"
"    <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n"
"    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\n"
"</form>\n"
msgstr "<form action=\"/example\" method=\"POST\">\n"
"    <input type=\"hidden\" name=\"_method\" value=\"PUT\">\n"
"    <input type=\"hidden\" name=\"_token\" value=\"{{ csrf_token() }}\">\n"
"</form>\n"

#: docs/8.x/routing.md:block 209 (paragraph)
msgid "For convenience, you may use the `@method` [Blade directive](/docs/{{version}}/blade) to generate the `_method` input field:"
msgstr "為了方便起見，也可以使用 `@method` [Blade 指示詞](/docs/{{version}}/blade)來產生 `_method` 輸入欄位："

#: docs/8.x/routing.md:block 210 (code)
msgid "<form action=\"/example\" method=\"POST\">\n"
"    @method('PUT')\n"
"    @csrf\n"
"</form>\n"
msgstr "<form action=\"/example\" method=\"POST\">\n"
"    @method('PUT')\n"
"    @csrf\n"
"</form>\n"

#: docs/8.x/routing.md:block 212 (header)
msgid "Accessing The Current Route"
msgstr "存取目前的 Route"

#: docs/8.x/routing.md:block 213 (paragraph)
msgid "You may use the `current`, `currentRouteName`, and `currentRouteAction` methods on the `Route` facade to access information about the route handling the incoming request:"
msgstr "可以使用 `Route` Facade 上的 `current`, `currentRouteName` 與 `currentRouteAction` 方法來存取有關處理本次連入 Request 的 Route 資訊："

#: docs/8.x/routing.md:block 214 (code)
msgid "use Illuminate\\Support\\Facades\\Route;\n\n"
"$route = Route::current(); // Illuminate\\Routing\\Route\n"
"$name = Route::currentRouteName(); // string\n"
"$action = Route::currentRouteAction(); // string\n"
msgstr "use Illuminate\\Support\\Facades\\Route;\n\n"
"$route = Route::current(); // Illuminate\\Routing\\Route\n"
"$name = Route::currentRouteName(); // string\n"
"$action = Route::currentRouteAction(); // string\n"

#: docs/8.x/routing.md:block 215 (paragraph)
msgid "You may refer to the API documentation for both the [underlying class of the Route facade](https://laravel.com/api/{{version}}/Illuminate/Routing/Router.html) and [Route instance](https://laravel.com/api/{{version}}/Illuminate/Routing/Route.html) to review all of the methods that are available on the router and route classes."
msgstr "請參考 [Route Facade 底層的類別](https://laravel.com/api/{{version}}/Illuminate/Routing/Router.html)與 [Route 實體](https://laravel.com/api/{{version}}/Illuminate/Routing/Route.html)的 API 說明文件以瞭解 Router 與 Route 類別提供的全部方法。"

#: docs/8.x/routing.md:block 217 (header)
msgid "Cross-Origin Resource Sharing (CORS)"
msgstr "跨原始來源資源共用 (CORS, Cross-Origin Resource Sharing)"

#: docs/8.x/routing.md:block 218 (paragraph)
msgid "Laravel can automatically respond to CORS `OPTIONS` HTTP requests with values that you configure. All CORS settings may be configured in your application's `config/cors.php` configuration file. The `OPTIONS` requests will automatically be handled by the `HandleCors` [middleware](/docs/{{version}}/middleware) that is included by default in your global middleware stack. Your global middleware stack is located in your application's HTTP kernel (`App\\Http\\Kernel`)."
msgstr "Laravel 會自動依照你設定的值來回應 CORS 的 `OPTIONS` HTTP Request。可以在專案的 `config/cors.php` 設定檔中設定所有的 CORS 設定。 `HandleCors` [Middleware](/docs/{{version}}/middleware) 會自動處理 `OPTIONS` Request，該 Middleware 預設包含在全域的 Middleware Stack 中。全域的 Middleware Stack 存在 HTTP Kernel (`App\\Http\\Kernel`) 中。"

#: docs/8.x/routing.md:block 219 (quote)
msgid "{tip} For more information on CORS and CORS headers, please consult the [MDN web documentation on CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)."
msgstr "{tip} 更多有關 CORS 與 CORS 標頭的資訊，請參考 [MDN 網頁說明文件上的 CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS#The_HTTP_response_headers)。"

#: docs/8.x/routing.md:block 221 (header)
msgid "Route Caching"
msgstr "Route 的快取"

#: docs/8.x/routing.md:block 222 (paragraph)
msgid "When deploying your application to production, you should take advantage of Laravel's route cache. Using the route cache will drastically decrease the amount of time it takes to register all of your application's routes. To generate a route cache, execute the `route:cache` Artisan command:"
msgstr "在將專案部署到正式環境時，應使用 Laravel 的 Route 快取功能。使用 Route 快取就能大大地降低註冊所有 Route 所需的時間。要產生 Route 快取，請執行 `route:cache` Artisan 指令："

#: docs/8.x/routing.md:block 223 (code)
msgid "php artisan route:cache\n"
msgstr "php artisan route:cache\n"

#: docs/8.x/routing.md:block 224 (paragraph)
msgid "After running this command, your cached routes file will be loaded on every request. Remember, if you add any new routes you will need to generate a fresh route cache. Because of this, you should only run the `route:cache` command during your project's deployment."
msgstr "執行這個指令後，每個 Request 都會自動載入快取的 Route 檔。請記得，當新增新 Route 後，必須重新產生 Route 快取。因此，應在進行專案部署的時候才執行 `route:cache` 指令。"

#: docs/8.x/routing.md:block 225 (paragraph)
msgid "You may use the `route:clear` command to clear the route cache:"
msgstr "可以使用 `route:clear` 指令來清除 Route 快取："

#: docs/8.x/routing.md:block 226 (code)
msgid "php artisan route:clear\n"
msgstr "php artisan route:clear\n"

#: docs/9.x/routing.md:block 2 (unordered list)
msgid "[The Route List](#the-route-list)"
msgstr ""

#: docs/9.x/routing.md:block 2 (unordered list)
msgid "[Implicit Enum Binding](#implicit-enum-binding)"
msgstr "[隱式 Enum 繫結](#implicit-enum-binding)"

#: docs/9.x/routing.md:block 43 (header)
msgid "The Route List"
msgstr ""

#: docs/9.x/routing.md:block 44 (paragraph)
msgid "The `route:list` Artisan command can easily provide an overview of all of the routes that are defined by your application:"
msgstr ""

#: docs/9.x/routing.md:block 45 (code)
msgid "php artisan route:list\n"
msgstr ""

#: docs/9.x/routing.md:block 46 (paragraph)
msgid "By default, the route middleware that are assigned to each route will not be displayed in the `route:list` output; however, you can instruct Laravel to display the route middleware by adding the `-v` option to the command:"
msgstr ""

#: docs/9.x/routing.md:block 47 (code)
msgid "php artisan route:list -v\n"
msgstr ""

#: docs/9.x/routing.md:block 48 (paragraph)
msgid "In addition, you may instruct Laravel to hide any routes that are defined by third-party packages by providing the `--except-vendor` option when executing the `route:list` command:"
msgstr ""

#: docs/9.x/routing.md:block 49 (code)
msgid "php artisan route:list --except-vendor\n"
msgstr ""

#: docs/9.x/routing.md:block 164 (header)
msgid "Implicit Enum Binding"
msgstr "隱式 Enum 繫結"

#: docs/9.x/routing.md:block 165 (paragraph)
msgid "PHP 8.1 introduced support for [Enums](https://www.php.net/manual/en/language.enumerations.backed.php). To compliment this feature, Laravel allows you to type-hint an Enum on your route definition and Laravel will only invoke the route if that route segment corresponds to a valid Enum value. Otherwise, a 404 HTTP response will be returned automatically. For example, given the following Enum:"
msgstr "PHP 8.1 新增了對 [Enum](https://www.php.net/manual/en/language.enumerations.backed.php) 的支援。為了配合這個功能，Laravel 中提供了能在 Route 定義中對 Enum 進行型別提示的功能。加上型別提示後，只有當網址中的相應的 Route 片段為有效的 Enum 時，Laravel 才會叫用該 Route。若不是有效的 Enum 值，則會自動回傳 404 HTTP Response。舉例來說，假設有下列 Enum："

#: docs/9.x/routing.md:block 166 (code)
msgid "<?php\n\n"
"namespace App\\Enums;\n\n"
"enum Category: string\n"
"{\n"
"    case Fruits = 'fruits';\n"
"    case People = 'people';\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Enums;\n\n"
"enum Category: string\n"
"{\n"
"    case Fruits = 'fruits';\n"
"    case People = 'people';\n"
"}\n"

#: docs/9.x/routing.md:block 167 (paragraph)
msgid "You may define a route that will only be invoked if the `{category}` route segment is `fruits` or `people`. Otherwise, Laravel will return a 404 HTTP response:"
msgstr "我們可以定義一個只有當 `{category}` 路由片段為 `fruits` 或 `people` 時才會被叫用的路由。若為其他值，Laravel 會回傳 HTTP 404 Response："

#: docs/9.x/routing.md:block 168 (code)
msgid "use App\\Enums\\Category;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"Route::get('/categories/{category}', function (Category $category) {\n"
"    return $category->value;\n"
"});\n"
msgstr "use App\\Enums\\Category;\n"
"use Illuminate\\Support\\Facades\\Route;\n\n"
"Route::get('/categories/{category}', function (Category $category) {\n"
"    return $category->value;\n"
"});\n"

