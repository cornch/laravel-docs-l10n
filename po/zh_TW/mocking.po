msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/mocking.pot\n"
"X-Crowdin-File-ID: 107\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2024-11-30 08:39\n"

# H1
#: ./docs/8.x/mocking.md:1
#: ./docs/9.x/mocking.md:1
#: ./docs/10.x/mocking.md:1
#: ./docs/11.x/mocking.md:1
#: ./docs/master/mocking.md:1
msgid "Mocking"
msgstr ""

# P
#: ./docs/8.x/mocking.md:3
#: ./docs/9.x/mocking.md:3
#: ./docs/10.x/mocking.md:3
#: ./docs/11.x/mocking.md:3
#: ./docs/master/mocking.md:3
msgid "[Introduction](#introduction)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:4
#: ./docs/9.x/mocking.md:4
#: ./docs/10.x/mocking.md:4
#: ./docs/11.x/mocking.md:4
#: ./docs/master/mocking.md:4
msgid "[Mocking Objects](#mocking-objects)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:5
#: ./docs/9.x/mocking.md:5
#: ./docs/10.x/mocking.md:5
#: ./docs/11.x/mocking.md:5
#: ./docs/master/mocking.md:5
msgid "[Mocking Facades](#mocking-facades)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:6
#: ./docs/9.x/mocking.md:6
#: ./docs/10.x/mocking.md:6
#: ./docs/11.x/mocking.md:6
#: ./docs/master/mocking.md:6
msgid "[Facade Spies](#facade-spies)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:7
#: ./docs/9.x/mocking.md:7
msgid "[Bus Fake](#bus-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:8
#: ./docs/9.x/mocking.md:8
msgid "[Job Chains](#bus-job-chains)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:9
#: ./docs/9.x/mocking.md:9
msgid "[Job Batches](#job-batches)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:10
#: ./docs/9.x/mocking.md:10
msgid "[Event Fake](#event-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:11
#: ./docs/9.x/mocking.md:11
msgid "[Scoped Event Fakes](#scoped-event-fakes)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:12
#: ./docs/9.x/mocking.md:12
msgid "[HTTP Fake](#http-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:13
#: ./docs/9.x/mocking.md:13
msgid "[Mail Fake](#mail-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:14
#: ./docs/9.x/mocking.md:14
msgid "[Notification Fake](#notification-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:15
#: ./docs/9.x/mocking.md:15
msgid "[Queue Fake](#queue-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:16
#: ./docs/9.x/mocking.md:16
msgid "[Job Chains](#job-chains)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:17
#: ./docs/9.x/mocking.md:17
msgid "[Storage Fake](#storage-fake)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:18
#: ./docs/9.x/mocking.md:18
#: ./docs/10.x/mocking.md:7
#: ./docs/11.x/mocking.md:7
#: ./docs/master/mocking.md:7
msgid "[Interacting With Time](#interacting-with-time)"
msgstr ""

# P
#: ./docs/8.x/mocking.md:20
#: ./docs/9.x/mocking.md:20
#: ./docs/10.x/mocking.md:9
#: ./docs/11.x/mocking.md:9
#: ./docs/master/mocking.md:9
#~ msgid "<a name=\"introduction\"></a>"
#~ msgstr ""

# CODE
# CODE: php tab=PHPUnit
#: ./docs/10.x/mocking.md:21
#: ./docs/11.x/mocking.md:36
#: ./docs/master/mocking.md:36
msgid "use App\\Service;\n"
"use Mockery;\n"
"use Mockery\\MockInterface;\n\n"
"public function test_something_can_be_mocked(): void\n"
"{\n"
"    $this->instance(\n"
"        Service::class,\n"
"        Mockery::mock(Service::class, function (MockInterface $mock) {\n"
"            $mock->shouldReceive('process')->once();\n"
"        })\n"
"    );\n"
"}"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/mocking.md:21
#: ./docs/master/mocking.md:21
msgid "use App\\Service;\n"
"use Mockery;\n"
"use Mockery\\MockInterface;\n\n"
"test('something can be mocked', function () {\n"
"    $this->instance(\n"
"        Service::class,\n"
"        Mockery::mock(Service::class, function (MockInterface $mock) {\n"
"            $mock->shouldReceive('process')->once();\n"
"        })\n"
"    );\n"
"});"
msgstr ""

# H2
#: ./docs/8.x/mocking.md:21
#: ./docs/9.x/mocking.md:21
#: ./docs/10.x/mocking.md:10
#: ./docs/11.x/mocking.md:10
#: ./docs/master/mocking.md:10
msgid "Introduction"
msgstr ""

# P
#: ./docs/8.x/mocking.md:23
#: ./docs/9.x/mocking.md:23
#: ./docs/10.x/mocking.md:12
#: ./docs/11.x/mocking.md:12
#: ./docs/master/mocking.md:12
msgid "When testing Laravel applications, you may wish to \"mock\" certain aspects of your application so they are not actually executed during a given test. For example, when testing a controller that dispatches an event, you may wish to mock the event listeners so they are not actually executed during the test. This allows you to only test the controller's HTTP response without worrying about the execution of the event listeners since the event listeners can be tested in their own test case."
msgstr ""

# P
#: ./docs/8.x/mocking.md:25
#: ./docs/9.x/mocking.md:25
#: ./docs/10.x/mocking.md:14
#: ./docs/11.x/mocking.md:14
#: ./docs/master/mocking.md:14
msgid "Laravel provides helpful methods for mocking events, jobs, and other facades out of the box. These helpers primarily provide a convenience layer over Mockery so you do not have to manually make complicated Mockery method calls."
msgstr ""

# P
#: ./docs/8.x/mocking.md:27
#: ./docs/9.x/mocking.md:27
#: ./docs/10.x/mocking.md:16
#: ./docs/11.x/mocking.md:16
#: ./docs/master/mocking.md:16
#~ msgid "<a name=\"mocking-objects\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:28
#: ./docs/9.x/mocking.md:28
#: ./docs/10.x/mocking.md:17
#: ./docs/11.x/mocking.md:17
#: ./docs/master/mocking.md:17
msgid "Mocking Objects"
msgstr ""

# P
#: ./docs/8.x/mocking.md:30
#: ./docs/9.x/mocking.md:30
#: ./docs/10.x/mocking.md:19
#: ./docs/11.x/mocking.md:19
#: ./docs/master/mocking.md:19
msgid "When mocking an object that is going to be injected into your application via Laravel's [service container](/docs/{{version}}/container), you will need to bind your mocked instance into the container as an `instance` binding. This will instruct the container to use your mocked instance of the object instead of constructing the object itself:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:32
#: ./docs/9.x/mocking.md:32
msgid "use App\\Service;\n"
"use Mockery;\n"
"use Mockery\\MockInterface;\n\n"
"public function test_something_can_be_mocked()\n"
"{\n"
"    $this->instance(\n"
"        Service::class,\n"
"        Mockery::mock(Service::class, function (MockInterface $mock) {\n"
"            $mock->shouldReceive('process')->once();\n"
"        })\n"
"    );\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:46
#: ./docs/9.x/mocking.md:46
#: ./docs/10.x/mocking.md:35
#: ./docs/11.x/mocking.md:52
#: ./docs/master/mocking.md:52
msgid "In order to make this more convenient, you may use the `mock` method that is provided by Laravel's base test case class. For example, the following example is equivalent to the example above:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:48
#: ./docs/9.x/mocking.md:48
#: ./docs/10.x/mocking.md:37
#: ./docs/11.x/mocking.md:54
#: ./docs/master/mocking.md:54
msgid "use App\\Service;\n"
"use Mockery\\MockInterface;\n\n"
"$mock = $this->mock(Service::class, function (MockInterface $mock) {\n"
"    $mock->shouldReceive('process')->once();\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:55
#: ./docs/9.x/mocking.md:55
#: ./docs/10.x/mocking.md:44
#: ./docs/11.x/mocking.md:61
#: ./docs/master/mocking.md:61
msgid "You may use the `partialMock` method when you only need to mock a few methods of an object. The methods that are not mocked will be executed normally when called:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:57
#: ./docs/9.x/mocking.md:57
#: ./docs/10.x/mocking.md:46
#: ./docs/11.x/mocking.md:63
#: ./docs/master/mocking.md:63
msgid "use App\\Service;\n"
"use Mockery\\MockInterface;\n\n"
"$mock = $this->partialMock(Service::class, function (MockInterface $mock) {\n"
"    $mock->shouldReceive('process')->once();\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:64
#: ./docs/9.x/mocking.md:64
#: ./docs/10.x/mocking.md:53
#: ./docs/11.x/mocking.md:70
#: ./docs/master/mocking.md:70
msgid "Similarly, if you want to [spy](http://docs.mockery.io/en/latest/reference/spies.html) on an object, Laravel's base test case class offers a `spy` method as a convenient wrapper around the `Mockery::spy` method. Spies are similar to mocks; however, spies record any interaction between the spy and the code being tested, allowing you to make assertions after the code is executed:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:66
#: ./docs/9.x/mocking.md:66
#: ./docs/10.x/mocking.md:55
#: ./docs/11.x/mocking.md:72
#: ./docs/master/mocking.md:72
msgid "use App\\Service;\n\n"
"$spy = $this->spy(Service::class);\n\n"
"// ...\n\n"
"$spy->shouldHaveReceived('process');"
msgstr ""

# CODE
#: ./docs/10.x/mocking.md:68
#: ./docs/11.x/mocking.md:85
#: ./docs/master/mocking.md:85
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Support\\Facades\\Cache;\n\n"
"class UserController extends Controller\n"
"{\n"
"    /**\n"
"     * Retrieve a list of all users of the application.\n"
"     */\n"
"    public function index(): array\n"
"    {\n"
"        $value = Cache::get('key');\n\n"
"        return [\n"
"            // ...\n"
"        ];\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:74
#: ./docs/9.x/mocking.md:74
#: ./docs/10.x/mocking.md:63
#: ./docs/11.x/mocking.md:80
#: ./docs/master/mocking.md:80
#~ msgid "<a name=\"mocking-facades\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:75
#: ./docs/9.x/mocking.md:75
#: ./docs/10.x/mocking.md:64
#: ./docs/11.x/mocking.md:81
#: ./docs/master/mocking.md:81
msgid "Mocking Facades"
msgstr ""

# P
#: ./docs/8.x/mocking.md:77
#: ./docs/9.x/mocking.md:77
#: ./docs/10.x/mocking.md:66
#: ./docs/11.x/mocking.md:83
#: ./docs/master/mocking.md:83
msgid "Unlike traditional static method calls, [facades](/docs/{{version}}/facades) (including [real-time facades](/docs/{{version}}/facades#real-time-facades)) may be mocked. This provides a great advantage over traditional static methods and grants you the same testability that you would have if you were using traditional dependency injection. When testing, you may often want to mock a call to a Laravel facade that occurs in one of your controllers. For example, consider the following controller action:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:79
#: ./docs/9.x/mocking.md:79
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use Illuminate\\Support\\Facades\\Cache;\n\n"
"class UserController extends Controller\n"
"{\n"
"    /**\n"
"     * Retrieve a list of all users of the application.\n"
"     *\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function index()\n"
"    {\n"
"        $value = Cache::get('key');\n\n"
"        //\n"
"    }\n"
"}"
msgstr ""

# CODE
# CODE: php tab=PHPUnit
#: ./docs/10.x/mocking.md:91
#: ./docs/11.x/mocking.md:125
#: ./docs/master/mocking.md:125
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use Illuminate\\Support\\Facades\\Cache;\n"
"use Tests\\TestCase;\n\n"
"class UserControllerTest extends TestCase\n"
"{\n"
"    public function test_get_index(): void\n"
"    {\n"
"        Cache::shouldReceive('get')\n"
"                    ->once()\n"
"                    ->with('key')\n"
"                    ->andReturn('value');\n\n"
"        $response = $this->get('/users');\n\n"
"        // ...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:100
#: ./docs/9.x/mocking.md:100
#: ./docs/10.x/mocking.md:89
#: ./docs/11.x/mocking.md:106
#: ./docs/master/mocking.md:106
msgid "We can mock the call to the `Cache` facade by using the `shouldReceive` method, which will return an instance of a [Mockery](https://github.com/padraic/mockery) mock. Since facades are actually resolved and managed by the Laravel [service container](/docs/{{version}}/container), they have much more testability than a typical static class. For example, let's mock our call to the `Cache` facade's `get` method:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:102
#: ./docs/9.x/mocking.md:102
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Cache;\n"
"use Tests\\TestCase;\n\n"
"class UserControllerTest extends TestCase\n"
"{\n"
"    public function testGetIndex()\n"
"    {\n"
"        Cache::shouldReceive('get')\n"
"                    ->once()\n"
"                    ->with('key')\n"
"                    ->andReturn('value');\n\n"
"        $response = $this->get('/users');\n\n"
"        // ...\n"
"    }\n"
"}"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/mocking.md:108
#: ./docs/master/mocking.md:108
msgid "<?php\n\n"
"use Illuminate\\Support\\Facades\\Cache;\n\n"
"test('get index', function () {\n"
"    Cache::shouldReceive('get')\n"
"                ->once()\n"
"                ->with('key')\n"
"                ->andReturn('value');\n\n"
"    $response = $this->get('/users');\n\n"
"    // ...\n"
"});"
msgstr ""

# CODE
# CODE: php tab=PHPUnit
#: ./docs/10.x/mocking.md:121
#: ./docs/11.x/mocking.md:173
#: ./docs/master/mocking.md:173
msgid "use Illuminate\\Support\\Facades\\Cache;\n\n"
"public function test_values_are_be_stored_in_cache(): void\n"
"{\n"
"    Cache::spy();\n\n"
"    $response = $this->get('/');\n\n"
"    $response->assertStatus(200);\n\n"
"    Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:126
#: ./docs/9.x/mocking.md:127
#: ./docs/10.x/mocking.md:114
#: ./docs/11.x/mocking.md:150
#: ./docs/master/mocking.md:150
msgid "You should not mock the `Request` facade. Instead, pass the input you desire into the [HTTP testing methods](/docs/{{version}}/http-tests) such as `get` and `post` when running your test. Likewise, instead of mocking the `Config` facade, call the `Config::set` method in your tests."
msgstr ""

# P
#: ./docs/8.x/mocking.md:128
#: ./docs/9.x/mocking.md:129
#: ./docs/10.x/mocking.md:116
#: ./docs/11.x/mocking.md:152
#: ./docs/master/mocking.md:152
#~ msgid "<a name=\"facade-spies\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/mocking.md:129
#: ./docs/9.x/mocking.md:130
#: ./docs/10.x/mocking.md:117
#: ./docs/11.x/mocking.md:153
#: ./docs/master/mocking.md:153
msgid "Facade Spies"
msgstr ""

# P
#: ./docs/8.x/mocking.md:131
#: ./docs/9.x/mocking.md:132
#: ./docs/10.x/mocking.md:119
#: ./docs/11.x/mocking.md:155
#: ./docs/master/mocking.md:155
msgid "If you would like to [spy](http://docs.mockery.io/en/latest/reference/spies.html) on a facade, you may call the `spy` method on the corresponding facade. Spies are similar to mocks; however, spies record any interaction between the spy and the code being tested, allowing you to make assertions after the code is executed:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:133
#: ./docs/9.x/mocking.md:134
msgid "use Illuminate\\Support\\Facades\\Cache;\n\n"
"public function test_values_are_be_stored_in_cache()\n"
"{\n"
"    Cache::spy();\n\n"
"    $response = $this->get('/');\n\n"
"    $response->assertStatus(200);\n\n"
"    Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/mocking.md:139
msgid "use Illuminate\\Support\\Carbon;\n\n"
"public function test_time_can_be_manipulated(): void\n"
"{\n"
"    // Travel into the future...\n"
"    $this->travel(5)->milliseconds();\n"
"    $this->travel(5)->seconds();\n"
"    $this->travel(5)->minutes();\n"
"    $this->travel(5)->hours();\n"
"    $this->travel(5)->days();\n"
"    $this->travel(5)->weeks();\n"
"    $this->travel(5)->years();\n\n"
"    // Travel into the past...\n"
"    $this->travel(-5)->hours();\n\n"
"    // Travel to an explicit time...\n"
"    $this->travelTo(now()->subHours(6));\n\n"
"    // Return back to the present time...\n"
"    $this->travelBack();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:146
#: ./docs/9.x/mocking.md:147
#~ msgid "<a name=\"bus-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:147
#: ./docs/9.x/mocking.md:148
msgid "Bus Fake"
msgstr ""

# P
#: ./docs/8.x/mocking.md:149
#: ./docs/9.x/mocking.md:150
msgid "When testing code that dispatches jobs, you typically want to assert that a given job was dispatched but not actually queue or execute the job. This is because the job's execution can normally be tested in a separate test class."
msgstr ""

# P
#: ./docs/8.x/mocking.md:151
#: ./docs/9.x/mocking.md:152
msgid "You may use the `Bus` facade's `fake` method to prevent jobs from being dispatched to the queue. Then, after executing the code under test, you may inspect which jobs the application attempted to dispatch using the `assertDispatched` and `assertNotDispatched` methods:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:153
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Jobs\\ShipOrder;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Bus::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that a job was dispatched...\n"
"        Bus::assertDispatched(ShipOrder::class);\n\n"
"        // Assert a job was not dispatched...\n"
"        Bus::assertNotDispatched(AnotherJob::class);\n\n"
"        // Assert that a job was dispatched synchronously...\n"
"        Bus::assertDispatchedSync(AnotherJob::class);\n\n"
"        // Assert that a job was not dipatched synchronously...\n"
"        Bus::assertNotDispatchedSync(AnotherJob::class);\n\n"
"        // Assert that a job was dispatched after the response was sent...\n"
"        Bus::assertDispatchedAfterResponse(AnotherJob::class);\n\n"
"        // Assert a job was not dispatched after response was sent...\n"
"        Bus::assertNotDispatchedAfterResponse(AnotherJob::class);\n\n"
"        // Assert no jobs were dispatched...\n"
"        Bus::assertNothingDispatched();\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:154
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Jobs\\ShipOrder;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Bus::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that a job was dispatched...\n"
"        Bus::assertDispatched(ShipOrder::class);\n\n"
"        // Assert a job was not dispatched...\n"
"        Bus::assertNotDispatched(AnotherJob::class);\n\n"
"        // Assert that a job was dispatched synchronously...\n"
"        Bus::assertDispatchedSync(AnotherJob::class);\n\n"
"        // Assert that a job was not dispatched synchronously...\n"
"        Bus::assertNotDispatchedSync(AnotherJob::class);\n\n"
"        // Assert that a job was dispatched after the response was sent...\n"
"        Bus::assertDispatchedAfterResponse(AnotherJob::class);\n\n"
"        // Assert a job was not dispatched after response was sent...\n"
"        Bus::assertNotDispatchedAfterResponse(AnotherJob::class);\n\n"
"        // Assert no jobs were dispatched...\n"
"        Bus::assertNothingDispatched();\n"
"    }\n"
"}"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/mocking.md:157
#: ./docs/master/mocking.md:157
msgid "<?php\n\n"
"use Illuminate\\Support\\Facades\\Cache;\n\n"
"test('values are be stored in cache', function () {\n"
"    Cache::spy();\n\n"
"    $response = $this->get('/');\n\n"
"    $response->assertStatus(200);\n\n"
"    Cache::shouldHaveReceived('put')->once()->with('name', 'Taylor', 10);\n"
"});"
msgstr ""

# P
#: ./docs/10.x/mocking.md:162
#: ./docs/11.x/mocking.md:238
#: ./docs/master/mocking.md:238
msgid "You may also provide a closure to the various time travel methods. The closure will be invoked with time frozen at the specified time. Once the closure has executed, time will resume as normal:"
msgstr ""

# CODE
#: ./docs/10.x/mocking.md:164
#: ./docs/11.x/mocking.md:240
#: ./docs/master/mocking.md:240
msgid "$this->travel(5)->days(function () {\n"
"    // Test something five days into the future...\n"
"});\n\n"
"$this->travelTo(now()->subDays(10), function () {\n"
"    // Test something during a given moment...\n"
"});"
msgstr ""

# P
#: ./docs/10.x/mocking.md:172
#: ./docs/11.x/mocking.md:248
#: ./docs/master/mocking.md:248
msgid "The `freezeTime` method may be used to freeze the current time. Similarly, the `freezeSecond` method will freeze the current time but at the start of the current second:"
msgstr ""

# CODE
#: ./docs/10.x/mocking.md:174
#: ./docs/11.x/mocking.md:250
#: ./docs/master/mocking.md:250
msgid "use Illuminate\\Support\\Carbon;\n\n"
"// Freeze time and resume normal time after executing closure...\n"
"$this->freezeTime(function (Carbon $time) {\n"
"    // ...\n"
"});\n\n"
"// Freeze time at the current second and resume normal time after executing closure...\n"
"$this->freezeSecond(function (Carbon $time) {\n"
"    // ...\n"
"})"
msgstr ""

# P
#: ./docs/10.x/mocking.md:186
#: ./docs/11.x/mocking.md:262
#: ./docs/master/mocking.md:262
msgid "As you would expect, all of the methods discussed above are primarily useful for testing time sensitive application behavior, such as locking inactive posts on a discussion forum:"
msgstr ""

# CODE
#: ./docs/10.x/mocking.md:188
msgid "use App\\Models\\Thread;\n\n"
"public function test_forum_threads_lock_after_one_week_of_inactivity()\n"
"{\n"
"    $thread = Thread::factory()->create();\n"
"    \n"
"    $this->travel(1)->week();\n"
"    \n"
"    $this->assertTrue($thread->isLockedByInactivity());\n"
"}"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/mocking.md:193
#: ./docs/master/mocking.md:193
msgid "test('time can be manipulated', function () {\n"
"    // Travel into the future...\n"
"    $this->travel(5)->milliseconds();\n"
"    $this->travel(5)->seconds();\n"
"    $this->travel(5)->minutes();\n"
"    $this->travel(5)->hours();\n"
"    $this->travel(5)->days();\n"
"    $this->travel(5)->weeks();\n"
"    $this->travel(5)->years();\n\n"
"    // Travel into the past...\n"
"    $this->travel(-5)->hours();\n\n"
"    // Travel to an explicit time...\n"
"    $this->travelTo(now()->subHours(6));\n\n"
"    // Return back to the present time...\n"
"    $this->travelBack();\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:194
#: ./docs/9.x/mocking.md:195
msgid "You may pass a closure to the available methods in order to assert that a job was dispatched that passes a given \"truth test\". If at least one job was dispatched that passes the given truth test then the assertion will be successful. For example, you may wish to assert that a job was dispatched for a specific order:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:196
#: ./docs/9.x/mocking.md:197
msgid "Bus::assertDispatched(function (ShipOrder $job) use ($order) {\n"
"    return $job->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:200
#: ./docs/9.x/mocking.md:224
#~ msgid "<a name=\"bus-job-chains\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/mocking.md:201
#: ./docs/8.x/mocking.md:543
#: ./docs/9.x/mocking.md:225
#: ./docs/9.x/mocking.md:630
msgid "Job Chains"
msgstr ""

# P
#: ./docs/9.x/mocking.md:201
#~ msgid "<a name=\"faking-a-subset-of-jobs\"></a>"
#~ msgstr ""

# H4
#: ./docs/9.x/mocking.md:202
msgid "Faking A Subset Of Jobs"
msgstr ""

# P
#: ./docs/8.x/mocking.md:203
#: ./docs/9.x/mocking.md:227
msgid "The `Bus` facade's `assertChained` method may be used to assert that a [chain of jobs](/docs/{{version}}/queues#job-chaining) was dispatched. The `assertChained` method accepts an array of chained jobs as its first argument:"
msgstr ""

# P
#: ./docs/9.x/mocking.md:204
msgid "If you only want to prevent certain jobs from being dispatched, you may pass the jobs that should be faked to the `fake` method:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:205
#: ./docs/9.x/mocking.md:229
msgid "use App\\Jobs\\RecordShipment;\n"
"use App\\Jobs\\ShipOrder;\n"
"use App\\Jobs\\UpdateInventory;\n"
"use Illuminate\\Support\\Facades\\Bus;\n\n"
"Bus::assertChained([\n"
"    ShipOrder::class,\n"
"    RecordShipment::class,\n"
"    UpdateInventory::class\n"
"]);"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:206
msgid "/**\n"
" * Test order process.\n"
" */\n"
"public function test_orders_can_be_shipped()\n"
"{\n"
"    Bus::fake([\n"
"        ShipOrder::class,\n"
"    ]);\n\n"
"    // ...\n"
"}"
msgstr ""

# CODE: php tab=PHPUnit
#: ./docs/11.x/mocking.md:215
#: ./docs/master/mocking.md:215
msgid "public function test_time_can_be_manipulated(): void\n"
"{\n"
"    // Travel into the future...\n"
"    $this->travel(5)->milliseconds();\n"
"    $this->travel(5)->seconds();\n"
"    $this->travel(5)->minutes();\n"
"    $this->travel(5)->hours();\n"
"    $this->travel(5)->days();\n"
"    $this->travel(5)->weeks();\n"
"    $this->travel(5)->years();\n\n"
"    // Travel into the past...\n"
"    $this->travel(-5)->hours();\n\n"
"    // Travel to an explicit time...\n"
"    $this->travelTo(now()->subHours(6));\n\n"
"    // Return back to the present time...\n"
"    $this->travelBack();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:216
#: ./docs/8.x/mocking.md:557
#: ./docs/9.x/mocking.md:240
#: ./docs/9.x/mocking.md:644
msgid "As you can see in the example above, the array of chained jobs may be an array of the job's class names. However, you may also provide an array of actual job instances. When doing so, Laravel will ensure that the job instances are of the same class and have the same property values of the chained jobs dispatched by your application:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:218
#: ./docs/9.x/mocking.md:242
msgid "Bus::assertChained([\n"
"    new ShipOrder,\n"
"    new RecordShipment,\n"
"    new UpdateInventory,\n"
"]);"
msgstr ""

# P
#: ./docs/9.x/mocking.md:218
msgid "You may fake all jobs except for a set of specified jobs using the `except` method:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:220
msgid "Bus::fake()->except([\n"
"    ShipOrder::class,\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/mocking.md:224
#: ./docs/9.x/mocking.md:248
#~ msgid "<a name=\"job-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/mocking.md:225
#: ./docs/9.x/mocking.md:249
msgid "Job Batches"
msgstr ""

# P
#: ./docs/8.x/mocking.md:227
#: ./docs/9.x/mocking.md:251
msgid "The `Bus` facade's `assertBatched` method may be used to assert that a [batch of jobs](/docs/{{version}}/queues#job-batching) was dispatched. The closure given to the `assertBatched` method receives an instance of `Illuminate\\Bus\\PendingBatch`, which may be used to inspect the jobs within the batch:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:229
#: ./docs/9.x/mocking.md:253
msgid "use Illuminate\\Bus\\PendingBatch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n\n"
"Bus::assertBatched(function (PendingBatch $batch) {\n"
"    return $batch->name == 'import-csv' &&\n"
"           $batch->jobs->count() === 10;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:237
#: ./docs/9.x/mocking.md:273
#~ msgid "<a name=\"event-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:238
#: ./docs/9.x/mocking.md:274
msgid "Event Fake"
msgstr ""

# P
#: ./docs/8.x/mocking.md:240
#: ./docs/9.x/mocking.md:276
msgid "When testing code that dispatches events, you may wish to instruct Laravel to not actually execute the event's listeners. Using the `Event` facade's `fake` method, you may prevent listeners from executing, execute the code under test, and then assert which events were dispatched by your application using the `assertDispatched`, `assertNotDispatched`, and `assertNothingDispatched` methods:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:242
#: ./docs/9.x/mocking.md:278
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Events\\OrderFailedToShip;\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    /**\n"
"     * Test order shipping.\n"
"     */\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Event::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that an event was dispatched...\n"
"        Event::assertDispatched(OrderShipped::class);\n\n"
"        // Assert an event was dispatched twice...\n"
"        Event::assertDispatched(OrderShipped::class, 2);\n\n"
"        // Assert an event was not dispatched...\n"
"        Event::assertNotDispatched(OrderFailedToShip::class);\n\n"
"        // Assert that no events were dispatched...\n"
"        Event::assertNothingDispatched();\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/mocking.md:261
#~ msgid "<a name=\"testing-job-batch-interaction\"></a>"
#~ msgstr ""

# H4
#: ./docs/9.x/mocking.md:262
msgid "Testing Job / Batch Interaction"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/mocking.md:264
#: ./docs/master/mocking.md:264
msgid "use App\\Models\\Thread;\n\n"
"test('forum threads lock after one week of inactivity', function () {\n"
"    $thread = Thread::factory()->create();\n\n"
"    $this->travel(1)->week();\n\n"
"    expect($thread->isLockedByInactivity())->toBeTrue();\n"
"});"
msgstr ""

# P
#: ./docs/9.x/mocking.md:264
msgid "In addition, you may occasionally need to test an individual job's interaction with its underlying batch. For example, you may need to test if a job cancelled further processing for its batch. To accomplish this, you need to assign a fake batch to the job via the `withFakeBatch` method. The `withFakeBatch` method returns a tuple containing the job instance and the fake batch:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:266
msgid "[$job, $batch] = (new ShipOrder)->withFakeBatch();\n\n"
"$job->handle();\n\n"
"$this->assertTrue($batch->cancelled());\n"
"$this->assertEmpty($batch->added);"
msgstr ""

# CODE: php tab=PHPUnit
#: ./docs/11.x/mocking.md:276
#: ./docs/master/mocking.md:276
msgid "use App\\Models\\Thread;\n\n"
"public function test_forum_threads_lock_after_one_week_of_inactivity()\n"
"{\n"
"    $thread = Thread::factory()->create();\n\n"
"    $this->travel(1)->week();\n\n"
"    $this->assertTrue($thread->isLockedByInactivity());\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:278
#: ./docs/9.x/mocking.md:314
msgid "You may pass a closure to the `assertDispatched` or `assertNotDispatched` methods in order to assert that an event was dispatched that passes a given \"truth test\". If at least one event was dispatched that passes the given truth test then the assertion will be successful:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:280
#: ./docs/9.x/mocking.md:316
msgid "Event::assertDispatched(function (OrderShipped $event) use ($order) {\n"
"    return $event->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:284
#: ./docs/9.x/mocking.md:320
msgid "If you would simply like to assert that an event listener is listening to a given event, you may use the `assertListening` method:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:286
#: ./docs/9.x/mocking.md:322
msgid "Event::assertListening(\n"
"    OrderShipped::class,\n"
"    SendShipmentNotification::class\n"
");"
msgstr ""

# P
#: ./docs/8.x/mocking.md:291
#: ./docs/9.x/mocking.md:328
msgid "After calling `Event::fake()`, no event listeners will be executed. So, if your tests use model factories that rely on events, such as creating a UUID during a model's `creating` event, you should call `Event::fake()` **after** using your factories."
msgstr ""

# P
#: ./docs/8.x/mocking.md:293
#: ./docs/9.x/mocking.md:330
#~ msgid "<a name=\"faking-a-subset-of-events\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/mocking.md:294
#: ./docs/9.x/mocking.md:331
msgid "Faking A Subset Of Events"
msgstr ""

# P
#: ./docs/8.x/mocking.md:296
#: ./docs/9.x/mocking.md:333
msgid "If you only want to fake event listeners for a specific set of events, you may pass them to the `fake` or `fakeFor` method:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:298
#: ./docs/9.x/mocking.md:335
msgid "/**\n"
" * Test order process.\n"
" */\n"
"public function test_orders_can_be_processed()\n"
"{\n"
"    Event::fake([\n"
"        OrderCreated::class,\n"
"    ]);\n\n"
"    $order = Order::factory()->create();\n\n"
"    Event::assertDispatched(OrderCreated::class);\n\n"
"    // Other events are dispatched as normal...\n"
"    $order->update([...]);\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:315
#: ./docs/9.x/mocking.md:358
#~ msgid "<a name=\"scoped-event-fakes\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/mocking.md:316
#: ./docs/9.x/mocking.md:359
msgid "Scoped Event Fakes"
msgstr ""

# P
#: ./docs/8.x/mocking.md:318
#: ./docs/9.x/mocking.md:361
msgid "If you only want to fake event listeners for a portion of your test, you may use the `fakeFor` method:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:320
#: ./docs/9.x/mocking.md:363
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Events\\OrderCreated;\n"
"use App\\Models\\Order;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    /**\n"
"     * Test order process.\n"
"     */\n"
"    public function test_orders_can_be_processed()\n"
"    {\n"
"        $order = Event::fakeFor(function () {\n"
"            $order = Order::factory()->create();\n\n"
"            Event::assertDispatched(OrderCreated::class);\n\n"
"            return $order;\n"
"        });\n\n"
"        // Events are dispatched as normal and observers will run ...\n"
"        $order->update([...]);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:351
#: ./docs/9.x/mocking.md:394
#~ msgid "<a name=\"http-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:352
#: ./docs/9.x/mocking.md:395
msgid "HTTP Fake"
msgstr ""

# P
#: ./docs/9.x/mocking.md:352
msgid "You may fake all events except for a set of specified events using the `except` method:"
msgstr ""

# P
#: ./docs/8.x/mocking.md:354
#: ./docs/9.x/mocking.md:397
msgid "The `Http` facade's `fake` method allows you to instruct the HTTP client to return stubbed / dummy responses when requests are made. For more information on faking outgoing HTTP requests, please consult the [HTTP Client testing documentation](/docs/{{version}}/http-client#testing)."
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:354
msgid "Event::fake()->except([\n"
"    OrderCreated::class,\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/mocking.md:356
#: ./docs/9.x/mocking.md:399
#~ msgid "<a name=\"mail-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:357
#: ./docs/9.x/mocking.md:400
msgid "Mail Fake"
msgstr ""

# P
#: ./docs/8.x/mocking.md:359
#: ./docs/9.x/mocking.md:402
msgid "You may use the `Mail` facade's `fake` method to prevent mail from being sent. Typically, sending mail is unrelated to the code you are actually testing. Most likely, it is sufficient to simply assert that Laravel was instructed to send a given mailable."
msgstr ""

# P
#: ./docs/8.x/mocking.md:361
#: ./docs/9.x/mocking.md:404
msgid "After calling the `Mail` facade's `fake` method, you may then assert that [mailables](/docs/{{version}}/mail) were instructed to be sent to users and even inspect the data the mailables received:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:363
#: ./docs/9.x/mocking.md:406
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Mail\\OrderShipped;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Mail;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Mail::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that no mailables were sent...\n"
"        Mail::assertNothingSent();\n\n"
"        // Assert that a mailable was sent...\n"
"        Mail::assertSent(OrderShipped::class);\n\n"
"        // Assert a mailable was sent twice...\n"
"        Mail::assertSent(OrderShipped::class, 2);\n\n"
"        // Assert a mailable was not sent...\n"
"        Mail::assertNotSent(AnotherMailable::class);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:395
#: ./docs/9.x/mocking.md:438
msgid "If you are queueing mailables for delivery in the background, you should use the `assertQueued` method instead of `assertSent`:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:397
#: ./docs/9.x/mocking.md:440
msgid "Mail::assertQueued(OrderShipped::class);\n\n"
"Mail::assertNotQueued(OrderShipped::class);\n\n"
"Mail::assertNothingQueued();"
msgstr ""

# P
#: ./docs/8.x/mocking.md:403
#: ./docs/9.x/mocking.md:446
msgid "You may pass a closure to the `assertSent`, `assertNotSent`, `assertQueued`, or `assertNotQueued` methods in order to assert that a mailable was sent that passes a given \"truth test\". If at least one mailable was sent that passes the given truth test then the assertion will be successful:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:405
#: ./docs/9.x/mocking.md:448
msgid "Mail::assertSent(function (OrderShipped $mail) use ($order) {\n"
"    return $mail->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:409
msgid "When calling the `Mail` facade's assertion methods, the mailable instance accepted by the provided closure exposes helpful methods for examining the recipients of the mailable:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:411
msgid "Mail::assertSent(OrderShipped::class, function ($mail) use ($user) {\n"
"    return $mail->hasTo($user->email) &&\n"
"           $mail->hasCc('...') &&\n"
"           $mail->hasBcc('...');\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:417
#: ./docs/9.x/mocking.md:487
msgid "You may have noticed that there are two methods for asserting that mail was not sent: `assertNotSent` and `assertNotQueued`. Sometimes you may wish to assert that no mail was sent **or** queued. To accomplish this, you may use the `assertNothingOutgoing` and `assertNotOutgoing` methods:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:419
#: ./docs/9.x/mocking.md:489
msgid "Mail::assertNothingOutgoing();\n\n"
"Mail::assertNotOutgoing(function (OrderShipped $mail) use ($order) {\n"
"    return $mail->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:425
#: ./docs/9.x/mocking.md:500
#~ msgid "<a name=\"notification-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:426
#: ./docs/9.x/mocking.md:501
msgid "Notification Fake"
msgstr ""

# P
#: ./docs/8.x/mocking.md:428
#: ./docs/9.x/mocking.md:503
msgid "You may use the `Notification` facade's `fake` method to prevent notifications from being sent. Typically, sending notifications is unrelated to the code you are actually testing. Most likely, it is sufficient to simply assert that Laravel was instructed to send a given notification."
msgstr ""

# P
#: ./docs/8.x/mocking.md:430
#: ./docs/9.x/mocking.md:505
msgid "After calling the `Notification` facade's `fake` method, you may then assert that [notifications](/docs/{{version}}/notifications) were instructed to be sent to users and even inspect the data the notifications received:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:432
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Notifications\\OrderShipped;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Notification::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that no notifications were sent...\n"
"        Notification::assertNothingSent();\n\n"
"        // Assert a notification was sent to the given users...\n"
"        Notification::assertSentTo(\n"
"            [$user], OrderShipped::class\n"
"        );\n\n"
"        // Assert a notification was not sent...\n"
"        Notification::assertNotSentTo(\n"
"            [$user], AnotherNotification::class\n"
"        );\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/mocking.md:452
msgid "When calling the `Mail` facade's assertion methods, the mailable instance accepted by the provided closure exposes helpful methods for examining the mailable:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:454
msgid "Mail::assertSent(OrderShipped::class, function ($mail) use ($user) {\n"
"    return $mail->hasTo($user->email) &&\n"
"           $mail->hasCc('...') &&\n"
"           $mail->hasBcc('...') &&\n"
"           $mail->hasReplyTo('...') &&\n"
"           $mail->hasFrom('...') &&\n"
"           $mail->hasSubject('...');\n"
"});"
msgstr ""

# P
#: ./docs/9.x/mocking.md:463
msgid "The mailable instance also includes several helpful methods for examining the attachments on a mailable:"
msgstr ""

# P
#: ./docs/8.x/mocking.md:465
#: ./docs/9.x/mocking.md:543
msgid "You may pass a closure to the `assertSentTo` or `assertNotSentTo` methods in order to assert that a notification was sent that passes a given \"truth test\". If at least one notification was sent that passes the given truth test then the assertion will be successful:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:465
msgid "use Illuminate\\Mail\\Mailables\\Attachment;\n\n"
"Mail::assertSent(OrderShipped::class, function ($mail) {\n"
"    return $mail->hasAttachment(\n"
"        Attachment::fromPath('/path/to/file')\n"
"                ->as('name.pdf')\n"
"                ->withMime('application/pdf')\n"
"    );\n"
"});\n\n"
"Mail::assertSent(OrderShipped::class, function ($mail) {\n"
"    return $mail->hasAttachment(\n"
"        Attachment::fromStorageDisk('s3', '/path/to/file')\n"
"    );\n"
"});\n\n"
"Mail::assertSent(OrderShipped::class, function ($mail) use ($pdfData) {\n"
"    return $mail->hasAttachment(\n"
"        Attachment::fromData(fn () => $pdfData, 'name.pdf')\n"
"    );\n"
"});"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:467
#: ./docs/9.x/mocking.md:545
msgid "Notification::assertSentTo(\n"
"    $user,\n"
"    function (OrderShipped $notification, $channels) use ($order) {\n"
"        return $notification->order->id === $order->id;\n"
"    }\n"
");"
msgstr ""

# P
#: ./docs/8.x/mocking.md:474
#: ./docs/9.x/mocking.md:552
#~ msgid "<a name=\"on-demand-notifications\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/mocking.md:475
#: ./docs/9.x/mocking.md:553
msgid "On-Demand Notifications"
msgstr ""

# P
#: ./docs/8.x/mocking.md:477
msgid "If the code you are testing sends [on-demand notifications](/docs/{{version}}/notifications#on-demand-notifications), you will need to assert that the notification was sent to an `Illuminate\\Notifications\\AnonymousNotifiable` instance:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:479
msgid "use Illuminate\\Notifications\\AnonymousNotifiable;\n\n"
"Notification::assertSentTo(\n"
"    new AnonymousNotifiable, OrderShipped::class\n"
");"
msgstr ""

# P
#: ./docs/8.x/mocking.md:485
msgid "By passing a closure as the third argument to the notification assertion methods, you may determine if an on-demand notification was sent to the correct \"route\" address:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:487
msgid "Notification::assertSentTo(\n"
"    new AnonymousNotifiable,\n"
"    OrderShipped::class,\n"
"    function ($notification, $channels, $notifiable) use ($user) {\n"
"        return $notifiable->routes['mail'] === $user->email;\n"
"    }\n"
");"
msgstr ""

# P
#: ./docs/8.x/mocking.md:495
#: ./docs/9.x/mocking.md:568
#~ msgid "<a name=\"queue-fake\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/mocking.md:495
#~ msgid "<a name=\"testing-mailable-content\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:496
#: ./docs/9.x/mocking.md:569
msgid "Queue Fake"
msgstr ""

# H4
#: ./docs/9.x/mocking.md:496
msgid "Testing Mailable Content"
msgstr ""

# P
#: ./docs/8.x/mocking.md:498
#: ./docs/9.x/mocking.md:571
msgid "You may use the `Queue` facade's `fake` method to prevent queued jobs from being pushed to the queue. Most likely, it is sufficient to simply assert that Laravel was instructed to push a given job to the queue since the queued jobs themselves may be tested in another test class."
msgstr ""

# P
#: ./docs/9.x/mocking.md:498
msgid "We suggest testing the content of your mailables separately from your tests that assert that a given mailable was \"sent\" to a specific user. To learn how to test the content of your mailables, check out our documentation on the [testing mailables](/docs/{{version}}/mail#testing-mailables)."
msgstr ""

# P
#: ./docs/8.x/mocking.md:500
#: ./docs/9.x/mocking.md:573
msgid "After calling the `Queue` facade's `fake` method, you may then assert that the application attempted to push jobs to the queue:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:502
#: ./docs/9.x/mocking.md:575
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Jobs\\AnotherJob;\n"
"use App\\Jobs\\FinalJob;\n"
"use App\\Jobs\\ShipOrder;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Queue::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that no jobs were pushed...\n"
"        Queue::assertNothingPushed();\n\n"
"        // Assert a job was pushed to a given queue...\n"
"        Queue::assertPushedOn('queue-name', ShipOrder::class);\n\n"
"        // Assert a job was pushed twice...\n"
"        Queue::assertPushed(ShipOrder::class, 2);\n\n"
"        // Assert a job was not pushed...\n"
"        Queue::assertNotPushed(AnotherJob::class);\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:507
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use App\\Notifications\\OrderShipped;\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped()\n"
"    {\n"
"        Notification::fake();\n\n"
"        // Perform order shipping...\n\n"
"        // Assert that no notifications were sent...\n"
"        Notification::assertNothingSent();\n\n"
"        // Assert a notification was sent to the given users...\n"
"        Notification::assertSentTo(\n"
"            [$user], OrderShipped::class\n"
"        );\n\n"
"        // Assert a notification was not sent...\n"
"        Notification::assertNotSentTo(\n"
"            [$user], AnotherNotification::class\n"
"        );\n\n"
"        // Assert that a given number of notifications were sent...\n"
"        Notification::assertCount(3);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:536
#: ./docs/9.x/mocking.md:609
msgid "You may pass a closure to the `assertPushed` or `assertNotPushed` methods in order to assert that a job was pushed that passes a given \"truth test\". If at least one job was pushed that passes the given truth test then the assertion will be successful:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:538
#: ./docs/9.x/mocking.md:611
msgid "Queue::assertPushed(function (ShipOrder $job) use ($order) {\n"
"    return $job->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/8.x/mocking.md:542
#: ./docs/9.x/mocking.md:629
#~ msgid "<a name=\"job-chains\"></a>"
#~ msgstr ""

# P
#: ./docs/8.x/mocking.md:545
#: ./docs/9.x/mocking.md:632
msgid "The `Queue` facade's `assertPushedWithChain` and `assertPushedWithoutChain` methods may be used to inspect the job chain of a pushed job. The `assertPushedWithChain` method accepts the primary job as its first argument and an array of chained jobs as its second argument:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:547
#: ./docs/9.x/mocking.md:634
msgid "use App\\Jobs\\RecordShipment;\n"
"use App\\Jobs\\ShipOrder;\n"
"use App\\Jobs\\UpdateInventory;\n"
"use Illuminate\\Support\\Facades\\Queue;\n\n"
"Queue::assertPushedWithChain(ShipOrder::class, [\n"
"    RecordShipment::class,\n"
"    UpdateInventory::class\n"
"]);"
msgstr ""

# P
#: ./docs/9.x/mocking.md:555
msgid "If the code you are testing sends [on-demand notifications](/docs/{{version}}/notifications#on-demand-notifications), you can test that the on-demand notification was sent via the `assertSentOnDemand` method:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:557
msgid "Notification::assertSentOnDemand(OrderShipped::class);"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:559
#: ./docs/9.x/mocking.md:646
msgid "Queue::assertPushedWithChain(ShipOrder::class, [\n"
"    new RecordShipment,\n"
"    new UpdateInventory,\n"
"]);"
msgstr ""

# P
#: ./docs/9.x/mocking.md:559
msgid "By passing a closure as the second argument to the `assertSentOnDemand` method, you may determine if an on-demand notification was sent to the correct \"route\" address:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:561
msgid "Notification::assertSentOnDemand(\n"
"    OrderShipped::class,\n"
"    function ($notification, $channels, $notifiable) use ($user) {\n"
"        return $notifiable->routes['mail'] === $user->email;\n"
"    }\n"
");"
msgstr ""

# P
#: ./docs/8.x/mocking.md:564
#: ./docs/9.x/mocking.md:651
msgid "You may use the `assertPushedWithoutChain` method to assert that a job was pushed without a chain of jobs:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:566
#: ./docs/9.x/mocking.md:653
msgid "Queue::assertPushedWithoutChain(ShipOrder::class);"
msgstr ""

# P
#: ./docs/8.x/mocking.md:568
#: ./docs/9.x/mocking.md:655
#~ msgid "<a name=\"storage-fake\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:569
#: ./docs/9.x/mocking.md:656
msgid "Storage Fake"
msgstr ""

# P
#: ./docs/8.x/mocking.md:571
#: ./docs/9.x/mocking.md:658
msgid "The `Storage` facade's `fake` method allows you to easily generate a fake disk that, combined with the file generation utilities of the `Illuminate\\Http\\UploadedFile` class, greatly simplifies the testing of file uploads. For example:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:573
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Http\\UploadedFile;\n"
"use Illuminate\\Support\\Facades\\Storage;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_albums_can_be_uploaded()\n"
"    {\n"
"        Storage::fake('photos');\n\n"
"        $response = $this->json('POST', '/photos', [\n"
"            UploadedFile::fake()->image('photo1.jpg'),\n"
"            UploadedFile::fake()->image('photo2.jpg')\n"
"        ]);\n\n"
"        // Assert one or more files were stored...\n"
"        Storage::disk('photos')->assertExists('photo1.jpg');\n"
"        Storage::disk('photos')->assertExists(['photo1.jpg', 'photo2.jpg']);\n\n"
"        // Assert one or more files were not stored...\n"
"        Storage::disk('photos')->assertMissing('missing.jpg');\n"
"        Storage::disk('photos')->assertMissing(['missing.jpg', 'non-existing.jpg']);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/mocking.md:604
msgid "For more information on testing file uploads, you may consult the [HTTP testing documentation's information on file uploads](/docs/{{version}}/http-tests#testing-file-uploads)."
msgstr ""

# P
#: ./docs/8.x/mocking.md:606
msgid "By default, the `fake` method will delete all files in its temporary directory. If you would like to keep these files, you may use the \"persistentFake\" method instead."
msgstr ""

# P
#: ./docs/8.x/mocking.md:608
#: ./docs/9.x/mocking.md:699
#: ./docs/10.x/mocking.md:134
#: ./docs/11.x/mocking.md:188
#: ./docs/master/mocking.md:188
#~ msgid "<a name=\"interacting-with-time\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/mocking.md:609
#: ./docs/9.x/mocking.md:700
#: ./docs/10.x/mocking.md:135
#: ./docs/11.x/mocking.md:189
#: ./docs/master/mocking.md:189
msgid "Interacting With Time"
msgstr ""

# P
#: ./docs/8.x/mocking.md:611
#: ./docs/9.x/mocking.md:702
#: ./docs/10.x/mocking.md:137
#: ./docs/11.x/mocking.md:191
#: ./docs/master/mocking.md:191
msgid "When testing, you may occasionally need to modify the time returned by helpers such as `now` or `Illuminate\\Support\\Carbon::now()`. Thankfully, Laravel's base feature test class includes helpers that allow you to manipulate the current time:"
msgstr ""

# CODE
#: ./docs/8.x/mocking.md:613
msgid "public function testTimeCanBeManipulated()\n"
"{\n"
"    // Travel into the future...\n"
"    $this->travel(5)->milliseconds();\n"
"    $this->travel(5)->seconds();\n"
"    $this->travel(5)->minutes();\n"
"    $this->travel(5)->hours();\n"
"    $this->travel(5)->days();\n"
"    $this->travel(5)->weeks();\n"
"    $this->travel(5)->years();\n\n"
"    // Travel into the past...\n"
"    $this->travel(-5)->hours();\n\n"
"    // Travel to an explicit time...\n"
"    $this->travelTo(now()->subHours(6));\n\n"
"    // Return back to the present time...\n"
"    $this->travelBack();\n"
"}"
msgstr ""

# P
#: ./docs/9.x/mocking.md:615
msgid "If you only need to fake specific jobs while allowing your other jobs to execute normally, you may pass the class names of the jobs that should be faked to the `fake` method:"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:617
msgid "public function test_orders_can_be_shipped()\n"
"{\n"
"    Queue::fake([\n"
"        ShipOrder::class,\n"
"    ]);\n"
"    \n"
"    // Perform order shipping...\n\n"
"    // Assert a job was pushed twice...\n"
"    Queue::assertPushed(ShipOrder::class, 2);\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:660
msgid "<?php\n\n"
"namespace Tests\\Feature;\n\n"
"use Illuminate\\Foundation\\Testing\\RefreshDatabase;\n"
"use Illuminate\\Foundation\\Testing\\WithoutMiddleware;\n"
"use Illuminate\\Http\\UploadedFile;\n"
"use Illuminate\\Support\\Facades\\Storage;\n"
"use Tests\\TestCase;\n\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_albums_can_be_uploaded()\n"
"    {\n"
"        Storage::fake('photos');\n\n"
"        $response = $this->json('POST', '/photos', [\n"
"            UploadedFile::fake()->image('photo1.jpg'),\n"
"            UploadedFile::fake()->image('photo2.jpg')\n"
"        ]);\n\n"
"        // Assert one or more files were stored...\n"
"        Storage::disk('photos')->assertExists('photo1.jpg');\n"
"        Storage::disk('photos')->assertExists(['photo1.jpg', 'photo2.jpg']);\n\n"
"        // Assert one or more files were not stored...\n"
"        Storage::disk('photos')->assertMissing('missing.jpg');\n"
"        Storage::disk('photos')->assertMissing(['missing.jpg', 'non-existing.jpg']);\n\n"
"        // Assert that a given directory is empty...\n"
"        Storage::disk('photos')->assertDirectoryEmpty('/wallpapers');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/mocking.md:694
msgid "By default, the `fake` method will delete all files in its temporary directory. If you would like to keep these files, you may use the \"persistentFake\" method instead. For more information on testing file uploads, you may consult the [HTTP testing documentation's information on file uploads](/docs/{{version}}/http-tests#testing-file-uploads)."
msgstr ""

# P
#: ./docs/9.x/mocking.md:697
msgid "The `image` method requires the [GD extension](https://www.php.net/manual/en/book.image.php)."
msgstr ""

# CODE
#: ./docs/9.x/mocking.md:704
msgid "use Illuminate\\Support\\Carbon;\n\n"
"public function testTimeCanBeManipulated()\n"
"{\n"
"    // Travel into the future...\n"
"    $this->travel(5)->milliseconds();\n"
"    $this->travel(5)->seconds();\n"
"    $this->travel(5)->minutes();\n"
"    $this->travel(5)->hours();\n"
"    $this->travel(5)->days();\n"
"    $this->travel(5)->weeks();\n"
"    $this->travel(5)->years();\n\n"
"    // Freeze time and resume normal time after executing closure...\n"
"    $this->freezeTime(function (Carbon $time) {\n"
"        // ...\n"
"    });\n\n"
"    // Travel into the past...\n"
"    $this->travel(-5)->hours();\n\n"
"    // Travel to an explicit time...\n"
"    $this->travelTo(now()->subHours(6));\n\n"
"    // Return back to the present time...\n"
"    $this->travelBack();\n"
"}"
msgstr ""

