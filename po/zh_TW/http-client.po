msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"Language: zh_TW\n"
"Language-Team: Chinese Traditional\n"
"PO-Revision-Date: 2024-06-30 08:27\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Project-Id-Version: laravel-docs\n"
"X-Crowdin-File: /main/templates/http-client.pot\n"
"X-Crowdin-File-ID: 85\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"

# H1
#: ./docs/8.x/http-client.md:1
#: ./docs/9.x/http-client.md:1
#: ./docs/10.x/http-client.md:1
#: ./docs/11.x/http-client.md:1
#: ./docs/master/http-client.md:1
msgid "HTTP Client"
msgstr "HTTP 用戶端"

# P
#: ./docs/8.x/http-client.md:3
#: ./docs/9.x/http-client.md:3
#: ./docs/10.x/http-client.md:3
#: ./docs/11.x/http-client.md:3
#: ./docs/master/http-client.md:3
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

# P
#: ./docs/8.x/http-client.md:4
#: ./docs/9.x/http-client.md:4
#: ./docs/10.x/http-client.md:4
#: ./docs/11.x/http-client.md:4
#: ./docs/master/http-client.md:4
msgid "[Making Requests](#making-requests)"
msgstr "[建立 Request](#making-requests)"

# P
#: ./docs/8.x/http-client.md:5
#: ./docs/9.x/http-client.md:5
#: ./docs/10.x/http-client.md:5
#: ./docs/11.x/http-client.md:5
#: ./docs/master/http-client.md:5
msgid "[Request Data](#request-data)"
msgstr "[Request 資料](#request-data)"

# P
#: ./docs/8.x/http-client.md:6
#: ./docs/9.x/http-client.md:6
#: ./docs/10.x/http-client.md:6
#: ./docs/11.x/http-client.md:6
#: ./docs/master/http-client.md:6
msgid "[Headers](#headers)"
msgstr "[標頭 (Header)](#headers)"

# P
#: ./docs/8.x/http-client.md:7
#: ./docs/9.x/http-client.md:7
#: ./docs/10.x/http-client.md:7
#: ./docs/11.x/http-client.md:7
#: ./docs/master/http-client.md:7
msgid "[Authentication](#authentication)"
msgstr "[身份認證](#authentication)"

# P
#: ./docs/8.x/http-client.md:8
#: ./docs/9.x/http-client.md:8
#: ./docs/10.x/http-client.md:8
#: ./docs/11.x/http-client.md:8
#: ./docs/master/http-client.md:8
msgid "[Timeout](#timeout)"
msgstr "[逾時](#timeout)"

# P
#: ./docs/8.x/http-client.md:9
#: ./docs/9.x/http-client.md:9
#: ./docs/10.x/http-client.md:9
#: ./docs/11.x/http-client.md:9
#: ./docs/master/http-client.md:9
msgid "[Retries](#retries)"
msgstr "[重試](#retries)"

# P
#: ./docs/8.x/http-client.md:10
#: ./docs/9.x/http-client.md:10
#: ./docs/10.x/http-client.md:10
#: ./docs/11.x/http-client.md:10
#: ./docs/master/http-client.md:10
msgid "[Error Handling](#error-handling)"
msgstr "[錯誤處理](#error-handling)"

# P
#: ./docs/8.x/http-client.md:11
#: ./docs/9.x/http-client.md:12
#: ./docs/10.x/http-client.md:12
#: ./docs/11.x/http-client.md:12
#: ./docs/master/http-client.md:12
msgid "[Guzzle Options](#guzzle-options)"
msgstr "[Guzzle 選項](#guzzle-options)"

# P
#: ./docs/9.x/http-client.md:11
#: ./docs/10.x/http-client.md:11
#: ./docs/11.x/http-client.md:11
#: ./docs/master/http-client.md:11
msgid "[Guzzle Middleware](#guzzle-middleware)"
msgstr "[Guzzle Middleware](#guzzle-middleware)"

# P
#: ./docs/8.x/http-client.md:12
#: ./docs/9.x/http-client.md:13
#: ./docs/10.x/http-client.md:13
#: ./docs/11.x/http-client.md:13
#: ./docs/master/http-client.md:13
msgid "[Concurrent Requests](#concurrent-requests)"
msgstr "[同時進行的 Request](#concurrent-requests)"

# P
#: ./docs/8.x/http-client.md:13
#: ./docs/9.x/http-client.md:14
#: ./docs/10.x/http-client.md:14
#: ./docs/11.x/http-client.md:14
#: ./docs/master/http-client.md:14
msgid "[Macros](#macros)"
msgstr "[Macro](#macros)"

# P
#: ./docs/8.x/http-client.md:14
#: ./docs/9.x/http-client.md:15
#: ./docs/10.x/http-client.md:15
#: ./docs/11.x/http-client.md:15
#: ./docs/master/http-client.md:15
msgid "[Testing](#testing)"
msgstr "[測試](#testing)"

# P
#: ./docs/8.x/http-client.md:15
#: ./docs/9.x/http-client.md:16
#: ./docs/10.x/http-client.md:16
#: ./docs/11.x/http-client.md:16
#: ./docs/master/http-client.md:16
msgid "[Faking Responses](#faking-responses)"
msgstr "[模擬 Response](#faking-responses)"

# P
#: ./docs/8.x/http-client.md:16
#: ./docs/9.x/http-client.md:17
#: ./docs/10.x/http-client.md:17
#: ./docs/11.x/http-client.md:17
#: ./docs/master/http-client.md:17
msgid "[Inspecting Requests](#inspecting-requests)"
msgstr "[攔截 Request](#inspecting-requests)"

# P
#: ./docs/8.x/http-client.md:17
#: ./docs/9.x/http-client.md:19
#: ./docs/10.x/http-client.md:19
#: ./docs/11.x/http-client.md:19
#: ./docs/master/http-client.md:19
msgid "[Events](#events)"
msgstr "[事件](#events)"

# P
#: ./docs/9.x/http-client.md:18
#: ./docs/10.x/http-client.md:18
#: ./docs/11.x/http-client.md:18
#: ./docs/master/http-client.md:18
msgid "[Preventing Stray Requests](#preventing-stray-requests)"
msgstr "[避免漏掉的 Request](#preventing-stray-requests)"

# P
#: ./docs/8.x/http-client.md:19
#: ./docs/9.x/http-client.md:21
#: ./docs/10.x/http-client.md:21
#: ./docs/11.x/http-client.md:21
#: ./docs/master/http-client.md:21
#~ msgid "<a name=\"introduction\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/http-client.md:20
#: ./docs/9.x/http-client.md:22
#: ./docs/10.x/http-client.md:22
#: ./docs/11.x/http-client.md:22
#: ./docs/master/http-client.md:22
msgid "Introduction"
msgstr "簡介"

# P
#: ./docs/8.x/http-client.md:22
#: ./docs/9.x/http-client.md:24
#: ./docs/10.x/http-client.md:24
#: ./docs/11.x/http-client.md:24
#: ./docs/master/http-client.md:24
msgid "Laravel provides an expressive, minimal API around the [Guzzle HTTP client](http://docs.guzzlephp.org/en/stable/), allowing you to quickly make outgoing HTTP requests to communicate with other web applications. Laravel's wrapper around Guzzle is focused on its most common use cases and a wonderful developer experience."
msgstr "Laravel 為 [Guzzle HTTP 用戶端](http://docs.guzzlephp.org/en/stable/)提供了一個語意化的極簡 API，能讓我們快速建立外連 HTTP Request 來與其他 Web App 通訊。Laravel 的 Guzzle 包裝著重於各個常見的使用情境，並提供優秀的^[開發人員經驗](Developer Experience)。"

# P
#: ./docs/8.x/http-client.md:24
#: ./docs/9.x/http-client.md:26
#: ./docs/10.x/http-client.md:26
msgid "Before getting started, you should ensure that you have installed the Guzzle package as a dependency of your application. By default, Laravel automatically includes this dependency. However, if you have previously removed the package, you may install it again via Composer:"
msgstr "在開始前，先確保有將 Guzzle 套件安裝為專案的相依性套件。預設情況下，Laravel 已自動包含了這個相依性套件，但若你之前有將其移除，請使用 Composer 再安裝一次："

# CODE
# CODE: shell
#: ./docs/8.x/http-client.md:26
#: ./docs/9.x/http-client.md:28
#: ./docs/10.x/http-client.md:28
msgid "composer require guzzlehttp/guzzle"
msgstr ""

# P
#: ./docs/8.x/http-client.md:28
#: ./docs/9.x/http-client.md:32
#: ./docs/10.x/http-client.md:32
#: ./docs/11.x/http-client.md:26
#: ./docs/master/http-client.md:26
#~ msgid "<a name=\"making-requests\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/http-client.md:29
#: ./docs/9.x/http-client.md:33
#: ./docs/10.x/http-client.md:33
#: ./docs/11.x/http-client.md:27
#: ./docs/master/http-client.md:27
msgid "Making Requests"
msgstr "建立 Request"

# P
#: ./docs/8.x/http-client.md:31
#: ./docs/9.x/http-client.md:35
#: ./docs/10.x/http-client.md:35
#: ./docs/11.x/http-client.md:29
#: ./docs/master/http-client.md:29
msgid "To make requests, you may use the `head`, `get`, `post`, `put`, `patch`, and `delete` methods provided by the `Http` facade. First, let's examine how to make a basic `GET` request to another URL:"
msgstr "若要建立 Request，可以使用 `Http` Facade 提供的 `head`、`get`、`post`、`put`、`patch`、`delete` 等方法。首先，我們先看看要查詢另一個 URL 的基礎 `GET` Request 怎麼建立："

# CODE
#: ./docs/8.x/http-client.md:33
#: ./docs/9.x/http-client.md:37
#: ./docs/10.x/http-client.md:37
#: ./docs/11.x/http-client.md:31
#: ./docs/master/http-client.md:31
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"$response = Http::get('http://example.com');"
msgstr ""

# CODE
#: ./docs/11.x/http-client.md:37
msgid ""
"$response->body() : string;\n"
"$response->json($key = null, $default = null) : mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->resource() : resource;\n"
"$response->status() : int;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;"
msgstr ""

# P
#: ./docs/8.x/http-client.md:37
#: ./docs/9.x/http-client.md:41
#: ./docs/10.x/http-client.md:41
#: ./docs/11.x/http-client.md:35
#: ./docs/master/http-client.md:35
msgid "The `get` method returns an instance of `Illuminate\\Http\\Client\\Response`, which provides a variety of methods that may be used to inspect the response:"
msgstr "`get` 方法會回傳 `Illuminate\\Http\\Client\\Response` 的實體，該實體提供了許多用來取得 Response 資訊的方法："

# CODE
#: ./docs/8.x/http-client.md:39
msgid ""
"$response->body() : string;\n"
"$response->json($key = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->ok() : bool;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->serverError() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:43
#: ./docs/10.x/http-client.md:43
#: ./docs/master/http-client.md:37
msgid ""
"$response->body() : string;\n"
"$response->json($key = null, $default = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;"
msgstr ""

# P
#: ./docs/8.x/http-client.md:53
#: ./docs/9.x/http-client.md:55
#: ./docs/10.x/http-client.md:55
#: ./docs/11.x/http-client.md:50
#: ./docs/master/http-client.md:49
msgid "The `Illuminate\\Http\\Client\\Response` object also implements the PHP `ArrayAccess` interface, allowing you to access JSON response data directly on the response:"
msgstr "`Illuminate\\Http\\Client\\Response` 物件也實作了 PHP 的 `ArrayAccess` 實體，能讓我們直接在 Response 上存取 JSON Response 資料："

# CODE
#: ./docs/8.x/http-client.md:55
#: ./docs/9.x/http-client.md:57
#: ./docs/10.x/http-client.md:57
#: ./docs/11.x/http-client.md:52
#: ./docs/master/http-client.md:51
msgid "return Http::get('http://example.com/users/1')['name'];"
msgstr ""

# P
#: ./docs/8.x/http-client.md:57
#: ./docs/9.x/http-client.md:92
#: ./docs/10.x/http-client.md:92
#: ./docs/11.x/http-client.md:87
#: ./docs/master/http-client.md:86
#~ msgid "<a name=\"dumping-requests\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:58
#: ./docs/9.x/http-client.md:93
#: ./docs/10.x/http-client.md:93
#: ./docs/11.x/http-client.md:88
#: ./docs/master/http-client.md:87
msgid "Dumping Requests"
msgstr "傾印 Request"

# P
#: ./docs/9.x/http-client.md:59
#: ./docs/10.x/http-client.md:59
#: ./docs/11.x/http-client.md:54
#: ./docs/master/http-client.md:53
msgid "In addition to the response methods listed above, the following methods may be used to determine if the response has a given status code:"
msgstr "除了上述所列的 Response 方法外，也可以使用下列方法來判斷 Response 是否有給定的狀態碼："

# P
#: ./docs/8.x/http-client.md:60
#: ./docs/9.x/http-client.md:95
#: ./docs/10.x/http-client.md:95
#: ./docs/11.x/http-client.md:90
#: ./docs/master/http-client.md:89
msgid "If you would like to dump the outgoing request instance before it is sent and terminate the script's execution, you may add the `dd` method to the beginning of your request definition:"
msgstr "若想在送出 Request 前傾印連外 Request 並終止指令碼執行，可在 Request 定義的最前方加上 `dd` 方法："

# CODE
#: ./docs/9.x/http-client.md:61
#: ./docs/10.x/http-client.md:61
#: ./docs/11.x/http-client.md:56
#: ./docs/master/http-client.md:55
msgid ""
"$response->ok() : bool;                  // 200 OK\n"
"$response->created() : bool;             // 201 Created\n"
"$response->accepted() : bool;            // 202 Accepted\n"
"$response->noContent() : bool;           // 204 No Content\n"
"$response->movedPermanently() : bool;    // 301 Moved Permanently\n"
"$response->found() : bool;               // 302 Found\n"
"$response->badRequest() : bool;          // 400 Bad Request\n"
"$response->unauthorized() : bool;        // 401 Unauthorized\n"
"$response->paymentRequired() : bool;     // 402 Payment Required\n"
"$response->forbidden() : bool;           // 403 Forbidden\n"
"$response->notFound() : bool;            // 404 Not Found\n"
"$response->requestTimeout() : bool;      // 408 Request Timeout\n"
"$response->conflict() : bool;            // 409 Conflict\n"
"$response->unprocessableEntity() : bool; // 422 Unprocessable Entity\n"
"$response->tooManyRequests() : bool;     // 429 Too Many Requests\n"
"$response->serverError() : bool;         // 500 Internal Server Error"
msgstr ""

# CODE
#: ./docs/8.x/http-client.md:62
#: ./docs/9.x/http-client.md:97
#: ./docs/10.x/http-client.md:97
#: ./docs/11.x/http-client.md:92
#: ./docs/master/http-client.md:91
msgid "return Http::dd()->get('http://example.com');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:64
#: ./docs/9.x/http-client.md:99
#: ./docs/10.x/http-client.md:99
#: ./docs/11.x/http-client.md:94
#: ./docs/master/http-client.md:93
#~ msgid "<a name=\"request-data\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:65
#: ./docs/9.x/http-client.md:100
#: ./docs/10.x/http-client.md:100
#: ./docs/11.x/http-client.md:95
#: ./docs/master/http-client.md:94
msgid "Request Data"
msgstr "Request 資料"

# P
#: ./docs/8.x/http-client.md:67
#: ./docs/9.x/http-client.md:102
#: ./docs/10.x/http-client.md:102
#: ./docs/11.x/http-client.md:97
#: ./docs/master/http-client.md:96
msgid "Of course, it is common when making `POST`, `PUT`, and `PATCH` requests to send additional data with your request, so these methods accept an array of data as their second argument. By default, data will be sent using the `application/json` content type:"
msgstr "當然，我們也很常使用 `POST`、`PUT`、`PATCH` 等 Request 來在 Request 上傳送額外資料，所以這些方法接受資料陣列作為第二個引數。預設情況下，資料會使用 `application/json` ^[Content Type](內容型別) 來傳送："

# CODE
#: ./docs/8.x/http-client.md:69
#: ./docs/9.x/http-client.md:104
#: ./docs/10.x/http-client.md:104
#: ./docs/11.x/http-client.md:99
#: ./docs/master/http-client.md:98
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"$response = Http::post('http://example.com/users', [\n"
"    'name' => 'Steve',\n"
"    'role' => 'Network Administrator',\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:76
#: ./docs/9.x/http-client.md:111
#: ./docs/10.x/http-client.md:111
#: ./docs/11.x/http-client.md:106
#: ./docs/master/http-client.md:105
#~ msgid "<a name=\"get-request-query-parameters\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:77
#: ./docs/9.x/http-client.md:112
#: ./docs/10.x/http-client.md:112
#: ./docs/11.x/http-client.md:107
#: ./docs/master/http-client.md:106
msgid "GET Request Query Parameters"
msgstr "GET Request 查詢參數"

# CODE: php
#: ./docs/11.x/http-client.md:78
#: ./docs/master/http-client.md:77
msgid ""
"Http::withUrlParameters([\n"
"    'endpoint' => 'https://laravel.com',\n"
"    'page' => 'docs',\n"
"    'version' => '11.x',\n"
"    'topic' => 'validation',\n"
"])->get('{+endpoint}/{page}/{version}/{topic}');"
msgstr ""

# P
#: ./docs/9.x/http-client.md:78
#: ./docs/10.x/http-client.md:78
#: ./docs/11.x/http-client.md:73
#: ./docs/master/http-client.md:72
#~ msgid "<a name=\"uri-templates\"></a>"
#~ msgstr ""

# P
#: ./docs/8.x/http-client.md:79
#: ./docs/9.x/http-client.md:114
#: ./docs/10.x/http-client.md:114
#: ./docs/11.x/http-client.md:109
#: ./docs/master/http-client.md:108
msgid "When making `GET` requests, you may either append a query string to the URL directly or pass an array of key / value pairs as the second argument to the `get` method:"
msgstr "在產生 `GET` Request 時，可以直接將^[查詢字串](Query String)加到 URL 上，或是傳入一組索引鍵 / 值配對的陣列作為 `get` 方法的第二個引數："

# H4
#: ./docs/9.x/http-client.md:79
#: ./docs/10.x/http-client.md:79
#: ./docs/11.x/http-client.md:74
#: ./docs/master/http-client.md:73
msgid "URI Templates"
msgstr "URI 樣板"

# CODE
#: ./docs/8.x/http-client.md:81
#: ./docs/9.x/http-client.md:116
#: ./docs/10.x/http-client.md:116
#: ./docs/11.x/http-client.md:111
#: ./docs/master/http-client.md:110
msgid ""
"$response = Http::get('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'page' => 1,\n"
"]);"
msgstr ""

# P
#: ./docs/9.x/http-client.md:81
#: ./docs/10.x/http-client.md:81
#: ./docs/11.x/http-client.md:76
#: ./docs/master/http-client.md:75
msgid "The HTTP client also allows you to construct request URLs using the [URI template specification](https://www.rfc-editor.org/rfc/rfc6570). To define the URL parameters that can be expanded by your URI template, you may use the `withUrlParameters` method:"
msgstr "在 HTTP Client 中，也可使用 [URI 樣板規格 (URI Template Specification)](https://www.rfc-editor.org/rfc/rfc6570)來建立 Request URL。若要定義可由 URI 樣板展開的 URL 參數，請使用 `withUrlParameters` 方法："

# CODE: php
#: ./docs/9.x/http-client.md:83
#: ./docs/10.x/http-client.md:83
msgid ""
"Http::withUrlParameters([\n"
"    'endpoint' => 'https://laravel.com',\n"
"    'page' => 'docs',\n"
"    'version' => '9.x',\n"
"    'topic' => 'validation',\n"
"])->get('{+endpoint}/{page}/{version}/{topic}');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:86
#: ./docs/9.x/http-client.md:121
#: ./docs/10.x/http-client.md:128
#: ./docs/11.x/http-client.md:123
#: ./docs/master/http-client.md:122
#~ msgid "<a name=\"sending-form-url-encoded-requests\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:87
#: ./docs/9.x/http-client.md:122
#: ./docs/10.x/http-client.md:129
#: ./docs/11.x/http-client.md:124
#: ./docs/master/http-client.md:123
msgid "Sending Form URL Encoded Requests"
msgstr "傳送 Form URL Encoded 的 Request"

# P
#: ./docs/8.x/http-client.md:89
#: ./docs/9.x/http-client.md:124
#: ./docs/10.x/http-client.md:131
#: ./docs/11.x/http-client.md:126
#: ./docs/master/http-client.md:125
msgid "If you would like to send data using the `application/x-www-form-urlencoded` content type, you should call the `asForm` method before making your request:"
msgstr "若想使用 `application/x-www-form-urlencoded` Content Type 來傳送資料的話，請在建立 Request 前呼叫 `asForm` 方法："

# CODE
#: ./docs/8.x/http-client.md:91
#: ./docs/9.x/http-client.md:126
#: ./docs/10.x/http-client.md:133
#: ./docs/11.x/http-client.md:128
#: ./docs/master/http-client.md:127
msgid ""
"$response = Http::asForm()->post('http://example.com/users', [\n"
"    'name' => 'Sara',\n"
"    'role' => 'Privacy Consultant',\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:96
#: ./docs/9.x/http-client.md:131
#: ./docs/10.x/http-client.md:138
#: ./docs/11.x/http-client.md:133
#: ./docs/master/http-client.md:132
#~ msgid "<a name=\"sending-a-raw-request-body\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:97
#: ./docs/9.x/http-client.md:132
msgid "Sending A Raw Request Body"
msgstr "傳送原始 Request 內文"

# P
#: ./docs/8.x/http-client.md:99
#: ./docs/9.x/http-client.md:134
#: ./docs/10.x/http-client.md:141
#: ./docs/11.x/http-client.md:136
#: ./docs/master/http-client.md:135
msgid "You may use the `withBody` method if you would like to provide a raw request body when making a request. The content type may be provided via the method's second argument:"
msgstr "在建立 Request 時，若想提供^[原始 Request 內文](Raw Request Body)，可使用 `withBody` 方法。可以在該方法的第二個引數上提供 Content Type："

# CODE
#: ./docs/8.x/http-client.md:101
#: ./docs/9.x/http-client.md:136
#: ./docs/10.x/http-client.md:143
#: ./docs/11.x/http-client.md:138
#: ./docs/master/http-client.md:137
msgid ""
"$response = Http::withBody(\n"
"    base64_encode($photo), 'image/jpeg'\n"
")->post('http://example.com/photo');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:105
#: ./docs/9.x/http-client.md:140
#: ./docs/10.x/http-client.md:147
#: ./docs/11.x/http-client.md:142
#: ./docs/master/http-client.md:141
#~ msgid "<a name=\"multi-part-requests\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:106
#: ./docs/9.x/http-client.md:141
#: ./docs/10.x/http-client.md:148
#: ./docs/11.x/http-client.md:143
#: ./docs/master/http-client.md:142
msgid "Multi-Part Requests"
msgstr "Multi-Part 的 Request"

# P
#: ./docs/8.x/http-client.md:108
#: ./docs/9.x/http-client.md:143
msgid "If you would like to send files as multi-part requests, you should call the `attach` method before making your request. This method accepts the name of the file and its contents. If needed, you may provide a third argument which will be considered the file's filename:"
msgstr "若想使用 Multi-Part 的 Request 來傳送檔案的話，請在建立 Request 前呼叫 `attach` 方法。該方法接受檔案的欄位名稱、以及檔案的內容。若有需要，也可以提供第三個引數，該引數會被當作檔案名稱："

# CODE
#: ./docs/8.x/http-client.md:110
#: ./docs/9.x/http-client.md:145
msgid ""
"$response = Http::attach(\n"
"    'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\n"
")->post('http://example.com/attachments');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:114
#: ./docs/9.x/http-client.md:149
#: ./docs/10.x/http-client.md:156
#: ./docs/11.x/http-client.md:151
#: ./docs/master/http-client.md:150
msgid "Instead of passing the raw contents of a file, you may pass a stream resource:"
msgstr "除了直接傳入檔案的原始內容外，也可以傳入一個 ^[Stream Resource](串流資源)："

# CODE
#: ./docs/8.x/http-client.md:116
#: ./docs/9.x/http-client.md:151
#: ./docs/10.x/http-client.md:158
#: ./docs/11.x/http-client.md:153
#: ./docs/master/http-client.md:152
msgid ""
"$photo = fopen('photo.jpg', 'r');\n"
"\n"
"$response = Http::attach(\n"
"    'attachment', $photo, 'photo.jpg'\n"
")->post('http://example.com/attachments');"
msgstr ""

# P
#: ./docs/10.x/http-client.md:121
#: ./docs/11.x/http-client.md:116
#: ./docs/master/http-client.md:115
msgid "Alternatively, the `withQueryParameters` method may be used:"
msgstr "或者，可使用 `withQueryParameters` 方法："

# P
#: ./docs/8.x/http-client.md:122
#: ./docs/9.x/http-client.md:157
#: ./docs/10.x/http-client.md:164
#: ./docs/11.x/http-client.md:159
#: ./docs/master/http-client.md:158
#~ msgid "<a name=\"headers\"></a>"
#~ msgstr ""

# CODE
#: ./docs/10.x/http-client.md:123
#: ./docs/11.x/http-client.md:118
#: ./docs/master/http-client.md:117
msgid ""
"Http::retry(3, 100)->withQueryParameters([\n"
"    'name' => 'Taylor',\n"
"    'page' => 1,\n"
"])->get('http://example.com/users')"
msgstr ""

# H3
#: ./docs/8.x/http-client.md:123
#: ./docs/9.x/http-client.md:158
#: ./docs/10.x/http-client.md:165
#: ./docs/11.x/http-client.md:160
#: ./docs/master/http-client.md:159
msgid "Headers"
msgstr "標頭"

# P
#: ./docs/8.x/http-client.md:125
#: ./docs/9.x/http-client.md:160
#: ./docs/10.x/http-client.md:167
#: ./docs/11.x/http-client.md:162
#: ./docs/master/http-client.md:161
msgid "Headers may be added to requests using the `withHeaders` method. This `withHeaders` method accepts an array of key / value pairs:"
msgstr "可以使用 `withHeaders` 方法來將^[標頭](Header)加到 Request 上。`withHeaders` 方法接受一組索引鍵 / 值配對的陣列："

# CODE
#: ./docs/8.x/http-client.md:127
#: ./docs/9.x/http-client.md:162
#: ./docs/10.x/http-client.md:169
#: ./docs/11.x/http-client.md:164
#: ./docs/master/http-client.md:163
msgid ""
"$response = Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"    'X-Second' => 'bar'\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:134
#: ./docs/9.x/http-client.md:169
#: ./docs/10.x/http-client.md:176
#: ./docs/11.x/http-client.md:171
#: ./docs/master/http-client.md:170
msgid "You may use the `accept` method to specify the content type that your application is expecting in response to your request:"
msgstr "可以使用 `accept` 方法來指定你的程式預期所預期 Response 的 Content Type："

# CODE
#: ./docs/8.x/http-client.md:136
#: ./docs/9.x/http-client.md:171
#: ./docs/10.x/http-client.md:178
#: ./docs/11.x/http-client.md:173
#: ./docs/master/http-client.md:172
msgid "$response = Http::accept('application/json')->get('http://example.com/users');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:138
#: ./docs/9.x/http-client.md:173
#: ./docs/10.x/http-client.md:180
#: ./docs/11.x/http-client.md:175
#: ./docs/master/http-client.md:174
msgid "For convenience, you may use the `acceptJson` method to quickly specify that your application expects the `application/json` content type in response to your request:"
msgstr "為了方便起見，可以使用 `acceptJson` 方法來快速指定要預期 Response 的 Content Type 是 `application/json`："

# H4
#: ./docs/10.x/http-client.md:139
#: ./docs/11.x/http-client.md:134
#: ./docs/master/http-client.md:133
msgid "Sending a Raw Request Body"
msgstr ""

# CODE
#: ./docs/8.x/http-client.md:140
#: ./docs/9.x/http-client.md:175
#: ./docs/10.x/http-client.md:182
#: ./docs/11.x/http-client.md:177
#: ./docs/master/http-client.md:176
msgid "$response = Http::acceptJson()->get('http://example.com/users');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:142
#: ./docs/9.x/http-client.md:177
#: ./docs/10.x/http-client.md:196
#: ./docs/11.x/http-client.md:191
#: ./docs/master/http-client.md:190
#~ msgid "<a name=\"authentication\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:143
#: ./docs/9.x/http-client.md:178
#: ./docs/10.x/http-client.md:197
#: ./docs/11.x/http-client.md:192
#: ./docs/master/http-client.md:191
msgid "Authentication"
msgstr "身分驗證"

# P
#: ./docs/8.x/http-client.md:145
#: ./docs/9.x/http-client.md:180
#: ./docs/10.x/http-client.md:199
#: ./docs/11.x/http-client.md:194
#: ./docs/master/http-client.md:193
msgid "You may specify basic and digest authentication credentials using the `withBasicAuth` and `withDigestAuth` methods, respectively:"
msgstr "可以使用 `withBasicAuth` 方法來指定使用 Basic 身分驗證的^[認證](Credential)，或是使用 `withDigestAuth` 方法來指定 Digest 身分驗證的認證："

# CODE
#: ./docs/8.x/http-client.md:147
msgid ""
"// Basic authentication...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);\n"
"\n"
"// Digest authentication...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);"
msgstr ""

# P
#: ./docs/10.x/http-client.md:150
#: ./docs/11.x/http-client.md:145
#: ./docs/master/http-client.md:144
msgid "If you would like to send files as multi-part requests, you should call the `attach` method before making your request. This method accepts the name of the file and its contents. If needed, you may provide a third argument which will be considered the file's filename, while a fourth argument may be used to provide headers associated with the file:"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:152
#: ./docs/11.x/http-client.md:147
#: ./docs/master/http-client.md:146
msgid ""
"$response = Http::attach(\n"
"    'attachment', file_get_contents('photo.jpg'), 'photo.jpg', ['Content-Type' => 'image/jpeg']\n"
")->post('http://example.com/attachments');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:153
#: ./docs/9.x/http-client.md:188
#: ./docs/10.x/http-client.md:207
#: ./docs/11.x/http-client.md:202
#: ./docs/master/http-client.md:201
#~ msgid "<a name=\"bearer-tokens\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:154
#: ./docs/9.x/http-client.md:189
#: ./docs/10.x/http-client.md:208
#: ./docs/11.x/http-client.md:203
#: ./docs/master/http-client.md:202
msgid "Bearer Tokens"
msgstr "Bearer 權杖"

# P
#: ./docs/8.x/http-client.md:156
#: ./docs/9.x/http-client.md:191
#: ./docs/10.x/http-client.md:210
#: ./docs/11.x/http-client.md:205
#: ./docs/master/http-client.md:204
msgid "If you would like to quickly add a bearer token to the request's `Authorization` header, you may use the `withToken` method:"
msgstr "若想快速在 Request 的 `Authorization` 標頭中加上 Bearer ^[權杖](Token)，可使用 `withToken` 方法："

# CODE
#: ./docs/8.x/http-client.md:158
msgid "$response = Http::withToken('token')->post(...);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:160
#: ./docs/9.x/http-client.md:195
#: ./docs/10.x/http-client.md:214
#: ./docs/11.x/http-client.md:209
#: ./docs/master/http-client.md:208
#~ msgid "<a name=\"timeout\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:161
#: ./docs/9.x/http-client.md:196
#: ./docs/10.x/http-client.md:215
#: ./docs/11.x/http-client.md:210
#: ./docs/master/http-client.md:209
msgid "Timeout"
msgstr "逾時"

# P
#: ./docs/8.x/http-client.md:163
#: ./docs/9.x/http-client.md:198
msgid "The `timeout` method may be used to specify the maximum number of seconds to wait for a response:"
msgstr "可使用 `timeout` 方法來為 Response 指定最多要等待的秒數："

# CODE
#: ./docs/8.x/http-client.md:165
msgid "$response = Http::timeout(3)->get(...);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:167
#: ./docs/9.x/http-client.md:202
#: ./docs/10.x/http-client.md:221
#: ./docs/11.x/http-client.md:216
#: ./docs/master/http-client.md:215
msgid "If the given timeout is exceeded, an instance of `Illuminate\\Http\\Client\\ConnectionException` will  be thrown."
msgstr ""

# P
#: ./docs/8.x/http-client.md:169
#: ./docs/9.x/http-client.md:208
#: ./docs/10.x/http-client.md:227
#: ./docs/11.x/http-client.md:222
#: ./docs/master/http-client.md:221
#~ msgid "<a name=\"retries\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:170
#: ./docs/9.x/http-client.md:209
#: ./docs/10.x/http-client.md:228
#: ./docs/11.x/http-client.md:223
#: ./docs/master/http-client.md:222
msgid "Retries"
msgstr "重試"

# P
#: ./docs/8.x/http-client.md:172
msgid "If you would like HTTP client to automatically retry the request if a client or server error occurs, you may use the `retry` method. The `retry` method accepts the maximum number of times the request should be attempted and the number of milliseconds that Laravel should wait in between attempts:"
msgstr "若想讓 HTTP 用戶端在發生用戶端錯誤或伺服器端錯誤時自動重試，可以使用 `retry` 方法。`retry` 方法接受該 Request 要重試的最大次數，以及每次重試間要等待多少毫秒："

# CODE
#: ./docs/8.x/http-client.md:174
msgid "$response = Http::retry(3, 100)->post(...);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:176
#: ./docs/9.x/http-client.md:215
#: ./docs/10.x/http-client.md:246
#: ./docs/11.x/http-client.md:241
#: ./docs/master/http-client.md:240
msgid "If needed, you may pass a third argument to the `retry` method. The third argument should be a callable that determines if the retries should actually be attempted. For example, you may wish to only retry the request if the initial request encounters an `ConnectionException`:"
msgstr "若有需要，可以傳入第三個引數給 `retry` 方法。第三個引數應為一個 Callable，用來判斷是否要重試。舉例來說，我們可以判斷只在 Request 遇到 `ConnectionException` 時才重試："

# CODE
#: ./docs/8.x/http-client.md:178
msgid ""
"$response = Http::retry(3, 100, function ($exception) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(...);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:182
msgid "If all of the requests fail, an instance of `Illuminate\\Http\\Client\\RequestException` will be thrown."
msgstr "若所有的 Request 都執行失敗，會擲回 `Illuminate\\Http\\Client\\RequestException` 實體。"

# CODE
#: ./docs/9.x/http-client.md:182
#: ./docs/10.x/http-client.md:201
#: ./docs/11.x/http-client.md:196
#: ./docs/master/http-client.md:195
msgid ""
"// Basic authentication...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);\n"
"\n"
"// Digest authentication...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);"
msgstr ""

# P
#: ./docs/10.x/http-client.md:184
#: ./docs/11.x/http-client.md:179
#: ./docs/master/http-client.md:178
msgid "The `withHeaders` method merges new headers into the request's existing headers. If needed, you may replace all of the headers entirely using the `replaceHeaders` method:"
msgstr "`withHeaders` 方法會將新的 Header 合併到該 Request 中已存在的 Header。若有需要，可使用 `replaceHeaders` 方法來講整個 Header 取代掉："

# P
#: ./docs/8.x/http-client.md:184
#: ./docs/9.x/http-client.md:240
#: ./docs/10.x/http-client.md:278
#: ./docs/11.x/http-client.md:273
#: ./docs/master/http-client.md:272
#~ msgid "<a name=\"error-handling\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:185
#: ./docs/9.x/http-client.md:241
#: ./docs/10.x/http-client.md:279
#: ./docs/11.x/http-client.md:274
#: ./docs/master/http-client.md:273
msgid "Error Handling"
msgstr "錯誤處理"

# CODE: php
#: ./docs/10.x/http-client.md:186
#: ./docs/11.x/http-client.md:181
#: ./docs/master/http-client.md:180
msgid ""
"$response = Http::withHeaders([\n"
"    'X-Original' => 'foo',\n"
"])->replaceHeaders([\n"
"    'X-Replacement' => 'bar',\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:187
#: ./docs/9.x/http-client.md:243
#: ./docs/10.x/http-client.md:281
#: ./docs/11.x/http-client.md:276
#: ./docs/master/http-client.md:275
msgid "Unlike Guzzle's default behavior, Laravel's HTTP client wrapper does not throw exceptions on client or server errors (`400` and `500` level responses from servers). You may determine if one of these errors was returned using the `successful`, `clientError`, or `serverError` methods:"
msgstr "與 Guzzle 預設的行為不同，Laravel 的 HTTP 用戶端在遇到用戶端錯誤或伺服器端錯誤時 (即，伺服器回傳 `4XX` 與 `5XX` 等級的錯誤)，不會擲回 Exception。我們可以使用 `successful`、`clientError`、`serverError` 等方法來判斷是否遇到這類錯誤："

# CODE
#: ./docs/8.x/http-client.md:189
#: ./docs/9.x/http-client.md:245
#: ./docs/10.x/http-client.md:283
#: ./docs/11.x/http-client.md:278
#: ./docs/master/http-client.md:277
msgid ""
"// Determine if the status code is >= 200 and < 300...\n"
"$response->successful();\n"
"\n"
"// Determine if the status code is >= 400...\n"
"$response->failed();\n"
"\n"
"// Determine if the response has a 400 level status code...\n"
"$response->clientError();\n"
"\n"
"// Determine if the response has a 500 level status code...\n"
"$response->serverError();\n"
"\n"
"// Immediately execute the given callback if there was a client or server error...\n"
"$response->onError(callable $callback);"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:193
#: ./docs/10.x/http-client.md:212
#: ./docs/11.x/http-client.md:207
#: ./docs/master/http-client.md:206
msgid "$response = Http::withToken('token')->post(/* ... */);"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:200
#: ./docs/10.x/http-client.md:219
#: ./docs/11.x/http-client.md:214
#: ./docs/master/http-client.md:213
msgid "$response = Http::timeout(3)->get(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:204
#: ./docs/9.x/http-client.md:260
#: ./docs/10.x/http-client.md:298
#: ./docs/11.x/http-client.md:293
#: ./docs/master/http-client.md:292
#~ msgid "<a name=\"throwing-exceptions\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/http-client.md:204
#: ./docs/10.x/http-client.md:223
#: ./docs/11.x/http-client.md:218
#: ./docs/master/http-client.md:217
msgid "You may specify the maximum number of seconds to wait while trying to connect to a server using the `connectTimeout` method:"
msgstr "可以使用 `connectTimeout` 方法來指定嘗試連線到伺服器時要等待的最大秒數："

# H4
#: ./docs/8.x/http-client.md:205
#: ./docs/9.x/http-client.md:261
#: ./docs/10.x/http-client.md:299
#: ./docs/11.x/http-client.md:294
#: ./docs/master/http-client.md:293
msgid "Throwing Exceptions"
msgstr "擲回 Exception"

# CODE
#: ./docs/9.x/http-client.md:206
#: ./docs/10.x/http-client.md:225
#: ./docs/11.x/http-client.md:220
#: ./docs/master/http-client.md:219
msgid "$response = Http::connectTimeout(3)->get(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:207
#: ./docs/9.x/http-client.md:263
#: ./docs/10.x/http-client.md:301
#: ./docs/11.x/http-client.md:296
#: ./docs/master/http-client.md:295
msgid "If you have a response instance and would like to throw an instance of `Illuminate\\Http\\Client\\RequestException` if the response status code indicates a client or server error, you may use the `throw` or `throwIf` methods:"
msgstr "假設有個 Response 實體，而我們想在該 Response 的狀態碼為伺服器端或用戶端錯誤時擲回 `Illuminate\\Http\\Client\\RequestException`，則可以使用 `throw` 或 `throwIf` 方法："

# CODE
#: ./docs/8.x/http-client.md:209
msgid ""
"$response = Http::post(...);\n"
"\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n"
"\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n"
"\n"
"return $response['user']['id'];"
msgstr ""

# P
#: ./docs/9.x/http-client.md:211
#: ./docs/10.x/http-client.md:230
#: ./docs/11.x/http-client.md:225
#: ./docs/master/http-client.md:224
msgid "If you would like the HTTP client to automatically retry the request if a client or server error occurs, you may use the `retry` method. The `retry` method accepts the maximum number of times the request should be attempted and the number of milliseconds that Laravel should wait in between attempts:"
msgstr "若想讓 HTTP 用戶端在發生用戶端錯誤或伺服器端錯誤時自動重試，可以使用 `retry` 方法。`retry` 方法接受該 Request 要重試的最大次數，以及每次重試間要等待多少毫秒："

# CODE
#: ./docs/9.x/http-client.md:213
#: ./docs/10.x/http-client.md:232
#: ./docs/11.x/http-client.md:227
#: ./docs/master/http-client.md:226
msgid "$response = Http::retry(3, 100)->post(/* ... */);"
msgstr ""

# P
#: ./docs/10.x/http-client.md:217
#: ./docs/11.x/http-client.md:212
#: ./docs/master/http-client.md:211
msgid "The `timeout` method may be used to specify the maximum number of seconds to wait for a response. By default, the HTTP client will timeout after 30 seconds:"
msgstr "`timeout` 方法可用來指定該 Response 最長應等待多久。預設情況下，HTTP Client 會在 30 秒後逾時："

# CODE
#: ./docs/9.x/http-client.md:217
msgid ""
"$response = Http::retry(3, 100, function ($exception, $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:219
#: ./docs/9.x/http-client.md:290
#: ./docs/10.x/http-client.md:330
#: ./docs/11.x/http-client.md:325
#: ./docs/master/http-client.md:324
msgid "The `Illuminate\\Http\\Client\\RequestException` instance has a public `$response` property which will allow you to inspect the returned response."
msgstr "`Illuminate\\Http\\Client\\RequestException` 實體有個 `$response` 公用屬性，我們可以使用該屬性來取得回傳的 Response。"

# P
#: ./docs/8.x/http-client.md:221
#: ./docs/9.x/http-client.md:292
#: ./docs/10.x/http-client.md:332
#: ./docs/11.x/http-client.md:327
#: ./docs/master/http-client.md:326
msgid "The `throw` method returns the response instance if no error occurred, allowing you to chain other operations onto the `throw` method:"
msgstr "如果沒有發生錯誤，`throw` 方法會回傳 Response 實體，能讓我們在 `throw` 方法後繼續串上其他操作："

# P
#: ./docs/9.x/http-client.md:221
#: ./docs/10.x/http-client.md:255
#: ./docs/11.x/http-client.md:250
#: ./docs/master/http-client.md:249
msgid "If a request attempt fails, you may wish to make a change to the request before a new attempt is made. You can achieve this by modifying the request argument provided to the callable you provided to the `retry` method. For example, you might want to retry the request with a new authorization token if the first attempt returned an authentication error:"
msgstr "若 Request 查詢失敗，我們可能會想在進行新嘗試前對 Request 做點修改。若要在重新嘗試前對 Request 做修改，我們只需要將提供 `retry` 方法的 Request 引數更改為 Callable 即可。舉例來說，在第一次嘗試回傳身份驗證錯誤時，我們可能會想以新的 Authorization Token 來重試該 Request："

# CODE
#: ./docs/8.x/http-client.md:223
msgid "return Http::post(...)->throw()->json();"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:223
msgid ""
"$response = Http::withToken($this->getToken())->retry(2, 0, function ($exception, $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n"
"\n"
"    $request->withToken($this->getNewToken());\n"
"\n"
"    return true;\n"
"})->post(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:225
#: ./docs/9.x/http-client.md:296
#: ./docs/10.x/http-client.md:336
#: ./docs/11.x/http-client.md:331
#: ./docs/master/http-client.md:330
msgid "If you would like to perform some additional logic before the exception is thrown, you may pass a closure to the `throw` method. The exception will be thrown automatically after the closure is invoked, so you do not need to re-throw the exception from within the closure:"
msgstr "若想在 Exception 被擲回前加上其他額外的邏輯，可傳入一個閉包給 `throw` 方法。叫用閉包後，就會自動擲回 Exception，因此我們不需要在閉包內重新擲回 Exception："

# CODE
#: ./docs/8.x/http-client.md:227
msgid ""
"return Http::post(...)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();"
msgstr ""

# P
#: ./docs/8.x/http-client.md:231
#: ./docs/9.x/http-client.md:335
#: ./docs/10.x/http-client.md:391
#: ./docs/11.x/http-client.md:386
#: ./docs/master/http-client.md:385
#~ msgid "<a name=\"guzzle-options\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:232
#: ./docs/9.x/http-client.md:336
#: ./docs/10.x/http-client.md:392
#: ./docs/11.x/http-client.md:387
#: ./docs/master/http-client.md:386
msgid "Guzzle Options"
msgstr "Guzzle 選項"

# P
#: ./docs/9.x/http-client.md:233
#: ./docs/10.x/http-client.md:271
#: ./docs/11.x/http-client.md:266
#: ./docs/master/http-client.md:265
msgid "If all of the requests fail, an instance of `Illuminate\\Http\\Client\\RequestException` will be thrown. If you would like to disable this behavior, you may provide a `throw` argument with a value of `false`. When disabled, the last response received by the client will be returned after all retries have been attempted:"
msgstr "若 Request 執行失敗，會擲回一個 `Illuminate\\Http\\Client\\RequestException` 實體。若想禁用這個行為，可傳入 `false` 給 `throw` 引數。當禁用擲回 Exception 時，會回傳所有重試中用戶端收到的最後一個 Response："

# P
#: ./docs/10.x/http-client.md:234
#: ./docs/11.x/http-client.md:229
#: ./docs/master/http-client.md:228
msgid "If you would like to manually calculate the number of milliseconds to sleep between attempts, you may pass a closure as the second argument to the `retry` method:"
msgstr ""

# P
#: ./docs/8.x/http-client.md:234
#: ./docs/9.x/http-client.md:338
#: ./docs/10.x/http-client.md:394
msgid "You may specify additional [Guzzle request options](http://docs.guzzlephp.org/en/stable/request-options.html) using the `withOptions` method. The `withOptions` method accepts an array of key / value pairs:"
msgstr "我們可以使用 `withOptions` 方法來指定額外的 [Guzzle Request 選項](http://docs.guzzlephp.org/en/stable/request-options.html)。`withOptions` 方法接受一組索引鍵 / 值配對的陣列："

# CODE
#: ./docs/9.x/http-client.md:235
#: ./docs/10.x/http-client.md:273
#: ./docs/11.x/http-client.md:268
#: ./docs/master/http-client.md:267
msgid "$response = Http::retry(3, 100, throw: false)->post(/* ... */);"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:236
#: ./docs/11.x/http-client.md:231
#: ./docs/master/http-client.md:230
msgid ""
"use Exception;\n"
"\n"
"$response = Http::retry(3, function (int $attempt, Exception $exception) {\n"
"    return $attempt * 100;\n"
"})->post(/* ... */);"
msgstr ""

# CODE
#: ./docs/8.x/http-client.md:236
#: ./docs/9.x/http-client.md:340
#: ./docs/10.x/http-client.md:396
#: ./docs/11.x/http-client.md:391
#: ./docs/master/http-client.md:390
msgid ""
"$response = Http::withOptions([\n"
"    'debug' => true,\n"
"])->get('http://example.com/users');"
msgstr ""

# P
#: ./docs/9.x/http-client.md:238
#: ./docs/10.x/http-client.md:276
#: ./docs/11.x/http-client.md:271
#: ./docs/master/http-client.md:270
msgid "If all of the requests fail because of a connection issue, a `Illuminate\\Http\\Client\\ConnectionException` will still be thrown even when the `throw` argument is set to `false`."
msgstr "若所有的 Request 都因為連線問題而失敗，即使 `throw` 引數設為 `false`，還是會擲回 `Illuminate\\Http\\Client\\ConnectionException`。"

# P
#: ./docs/8.x/http-client.md:240
#: ./docs/9.x/http-client.md:344
#: ./docs/10.x/http-client.md:400
#: ./docs/11.x/http-client.md:414
#: ./docs/master/http-client.md:413
#~ msgid "<a name=\"concurrent-requests\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/http-client.md:241
#: ./docs/9.x/http-client.md:345
#: ./docs/10.x/http-client.md:401
#: ./docs/11.x/http-client.md:415
#: ./docs/master/http-client.md:414
msgid "Concurrent Requests"
msgstr "同時進行的 Request"

# P
#: ./docs/10.x/http-client.md:242
#: ./docs/11.x/http-client.md:237
#: ./docs/master/http-client.md:236
msgid "For convenience, you may also provide an array as the first argument to the `retry` method. This array will be used to determine how many milliseconds to sleep between subsequent attempts:"
msgstr ""

# P
#: ./docs/8.x/http-client.md:243
#: ./docs/9.x/http-client.md:347
#: ./docs/10.x/http-client.md:403
#: ./docs/11.x/http-client.md:417
#: ./docs/master/http-client.md:416
msgid "Sometimes, you may wish to make multiple HTTP requests concurrently. In other words, you want several requests to be dispatched at the same time instead of issuing the requests sequentially. This can lead to substantial performance improvements when interacting with slow HTTP APIs."
msgstr "有時候，我們可能會想同時進行多個 HTTP Request。換句話說，不是依序執行 Request，而是同時分派多個 Request。同時執行多個 Request 的話，在處理速度慢的 HTTP API 時就可以大幅提升效能。"

# CODE
#: ./docs/10.x/http-client.md:244
#: ./docs/11.x/http-client.md:239
#: ./docs/master/http-client.md:238
msgid "$response = Http::retry([100, 200])->post(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:245
#: ./docs/9.x/http-client.md:349
#: ./docs/10.x/http-client.md:405
#: ./docs/11.x/http-client.md:419
#: ./docs/master/http-client.md:418
msgid "Thankfully, you may accomplish this using the `pool` method. The `pool` method accepts a closure which receives an `Illuminate\\Http\\Client\\Pool` instance, allowing you to easily add requests to the request pool for dispatching:"
msgstr "所幸，我們只要使用 `pool` 方法就能達成。`pool` 方法接受一個閉包，該閉包會收到 `Illuminate\\Http\\Client\\Pool` 實體，能讓我們輕鬆地將 Request 加到 ^[Request Pool](請求集區) 以作分派："

# CODE
#: ./docs/8.x/http-client.md:247
#: ./docs/9.x/http-client.md:351
#: ./docs/10.x/http-client.md:407
#: ./docs/11.x/http-client.md:421
#: ./docs/master/http-client.md:420
msgid ""
"use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->get('http://localhost/first'),\n"
"    $pool->get('http://localhost/second'),\n"
"    $pool->get('http://localhost/third'),\n"
"]);\n"
"\n"
"return $responses[0]->ok() &&\n"
"       $responses[1]->ok() &&\n"
"       $responses[2]->ok();"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:248
#: ./docs/11.x/http-client.md:243
#: ./docs/master/http-client.md:242
msgid ""
"use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n"
"\n"
"$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:257
#: ./docs/11.x/http-client.md:252
#: ./docs/master/http-client.md:251
msgid ""
"use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n"
"use Illuminate\\Http\\Client\\RequestException;\n"
"\n"
"$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n"
"\n"
"    $request->withToken($this->getNewToken());\n"
"\n"
"    return true;\n"
"})->post(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:260
#: ./docs/9.x/http-client.md:364
#: ./docs/10.x/http-client.md:420
#: ./docs/11.x/http-client.md:434
#: ./docs/master/http-client.md:433
msgid "As you can see, each response instance can be accessed based on the order it was added to the pool. If you wish, you can name the requests using the `as` method, which allows you to access the corresponding responses by name:"
msgstr "就像這樣，我們可以依據加入 Pool 的順序來存取每個 Response 實體。若有需要的話，也可以使用 `as` 方法來為 Request 命名，好讓我們能使用名稱來存取對應的 Response："

# CODE
#: ./docs/8.x/http-client.md:262
#: ./docs/9.x/http-client.md:366
#: ./docs/10.x/http-client.md:422
#: ./docs/11.x/http-client.md:436
#: ./docs/master/http-client.md:435
msgid ""
"use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->as('first')->get('http://localhost/first'),\n"
"    $pool->as('second')->get('http://localhost/second'),\n"
"    $pool->as('third')->get('http://localhost/third'),\n"
"]);\n"
"\n"
"return $responses['first']->ok();"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:265
msgid ""
"$response = Http::post(/* ... */);\n"
"\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n"
"\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n"
"\n"
"// Throw an exception if an error occurred and the given closure resolves to true...\n"
"$response->throwIf(fn ($response) => true);\n"
"\n"
"// Throw an exception if an error occurred and the given condition is false...\n"
"$response->throwUnless($condition);\n"
"\n"
"// Throw an exception if an error occurred and the given closure resolves to false...\n"
"$response->throwUnless(fn ($response) => false);\n"
"\n"
"// Throw an exception if the response has a specific status code...\n"
"$response->throwIfStatus(403);\n"
"\n"
"// Throw an exception unless the response has a specific status code...\n"
"$response->throwUnlessStatus(200);\n"
"\n"
"return $response['user']['id'];"
msgstr ""

# P
#: ./docs/8.x/http-client.md:273
#: ./docs/9.x/http-client.md:377
#: ./docs/10.x/http-client.md:453
#: ./docs/11.x/http-client.md:467
#: ./docs/master/http-client.md:466
#~ msgid "<a name=\"macros\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/http-client.md:274
#: ./docs/9.x/http-client.md:378
#: ./docs/10.x/http-client.md:454
#: ./docs/11.x/http-client.md:468
#: ./docs/master/http-client.md:467
msgid "Macros"
msgstr "Macro"

# P
#: ./docs/8.x/http-client.md:276
#: ./docs/9.x/http-client.md:380
#: ./docs/10.x/http-client.md:456
#: ./docs/11.x/http-client.md:470
#: ./docs/master/http-client.md:469
msgid "The Laravel HTTP client allows you to define \"macros\", which can serve as a fluent, expressive mechanism to configure common request paths and headers when interacting with services throughout your application. To get started, you may define the macro within the `boot` method of your application's `App\\Providers\\AppServiceProvider` class:"
msgstr "Laravel HTTP 用戶端支援定義「^[Macro](巨集)」。通過 Macro，我們就能通過一些流暢且語義化的機制來在專案中為一些服務設定常用的 Request 路徑與標頭。若要開始使用 Macro，我們可以在專案的 `App\\Providers\\AppServiceProvider` 內 `boot` 方法中定義 Macro："

# CODE: php
#: ./docs/8.x/http-client.md:278
#: ./docs/9.x/http-client.md:382
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:294
#: ./docs/10.x/http-client.md:334
#: ./docs/11.x/http-client.md:329
#: ./docs/master/http-client.md:328
msgid "return Http::post(/* ... */)->throw()->json();"
msgstr ""

# P
#: ./docs/8.x/http-client.md:296
#: ./docs/9.x/http-client.md:400
#: ./docs/10.x/http-client.md:474
#: ./docs/11.x/http-client.md:488
#: ./docs/master/http-client.md:487
msgid "Once your macro has been configured, you may invoke it from anywhere in your application to create a pending request with the specified configuration:"
msgstr "設定好 Macro 後，就可以在任何地方叫用這個 Macro，以使用指定的設定來建立 Request："

# CODE: php
#: ./docs/8.x/http-client.md:298
#: ./docs/9.x/http-client.md:402
#: ./docs/10.x/http-client.md:476
#: ./docs/11.x/http-client.md:490
#: ./docs/master/http-client.md:489
msgid "$response = Http::github()->get('/');"
msgstr ""

# CODE
#: ./docs/9.x/http-client.md:298
msgid ""
"return Http::post(/* ... */)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();"
msgstr ""

# P
#: ./docs/8.x/http-client.md:302
#: ./docs/9.x/http-client.md:406
#: ./docs/10.x/http-client.md:480
#: ./docs/11.x/http-client.md:494
#: ./docs/master/http-client.md:493
#~ msgid "<a name=\"testing\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/http-client.md:302
#: ./docs/10.x/http-client.md:345
#: ./docs/11.x/http-client.md:340
#: ./docs/master/http-client.md:339
#~ msgid "<a name=\"guzzle-middleware\"></a>"
#~ msgstr ""

# CODE
#: ./docs/10.x/http-client.md:303
#: ./docs/11.x/http-client.md:298
#: ./docs/master/http-client.md:297
msgid ""
"use Illuminate\\Http\\Client\\Response;\n"
"\n"
"$response = Http::post(/* ... */);\n"
"\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n"
"\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n"
"\n"
"// Throw an exception if an error occurred and the given closure resolves to true...\n"
"$response->throwIf(fn (Response $response) => true);\n"
"\n"
"// Throw an exception if an error occurred and the given condition is false...\n"
"$response->throwUnless($condition);\n"
"\n"
"// Throw an exception if an error occurred and the given closure resolves to false...\n"
"$response->throwUnless(fn (Response $response) => false);\n"
"\n"
"// Throw an exception if the response has a specific status code...\n"
"$response->throwIfStatus(403);\n"
"\n"
"// Throw an exception unless the response has a specific status code...\n"
"$response->throwUnlessStatus(200);\n"
"\n"
"return $response['user']['id'];"
msgstr ""

# H2
#: ./docs/8.x/http-client.md:303
#: ./docs/9.x/http-client.md:407
#: ./docs/10.x/http-client.md:481
#: ./docs/11.x/http-client.md:495
#: ./docs/master/http-client.md:494
msgid "Testing"
msgstr "測試"

# H3
#: ./docs/9.x/http-client.md:303
#: ./docs/10.x/http-client.md:346
#: ./docs/11.x/http-client.md:341
#: ./docs/master/http-client.md:340
msgid "Guzzle Middleware"
msgstr "Guzzle Middleware"

# P
#: ./docs/8.x/http-client.md:305
msgid "Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's HTTP wrapper is no exception. The `Http` facade's `fake` method allows you to instruct the HTTP client to return stubbed / dummy responses when requests are made."
msgstr "許多 Laravel 的服務都提供了能讓我們輕鬆撰寫測試的功能，而 Laravel 的 HTTP 包裝也不例外。`Http` Facade 的 `fake` 方法能讓我們指定 HTTP 用戶端在建立 Request 後回傳一組虛擬的 Response。"

# P
#: ./docs/9.x/http-client.md:305
msgid "Since Laravel's HTTP client is powered by Guzzle, you may take advantage of [Guzzle Middleware](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html) to manipulate the outgoing request or inspect the incoming response. To manipulate the outgoing request, register a Guzzle middleware via the `withMiddleware` method in combination with Guzzle's `mapRequest` middleware factory:"
msgstr "由於 Laravel 的 HTTP 用戶端使用 Guzzle，因此我們也可以使用 [Guzzle 的 Middleware 功能](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html)來對修改連外 Request，或是檢查連入的 Response。若要修改連外的 Request，可使用 `withMiddleware` 方法來註冊 Guzzle Middleware，並搭配使用 Guzzle 的 `mapRequest` Middleware Factory："

# P
#: ./docs/8.x/http-client.md:307
#: ./docs/9.x/http-client.md:411
#: ./docs/10.x/http-client.md:485
#: ./docs/11.x/http-client.md:499
#: ./docs/master/http-client.md:498
#~ msgid "<a name=\"faking-responses\"></a>"
#~ msgstr ""

# CODE
#: ./docs/9.x/http-client.md:307
msgid ""
"use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\RequestInterface;\n"
"\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapRequest(function (RequestInterface $request) {\n"
"        $request = $request->withHeader('X-Example', 'Value');\n"
"        \n"
"        return $request;\n"
"    })\n"
")->get('http://example.com');"
msgstr ""

# H3
#: ./docs/8.x/http-client.md:308
#: ./docs/9.x/http-client.md:412
#: ./docs/10.x/http-client.md:486
#: ./docs/11.x/http-client.md:500
#: ./docs/master/http-client.md:499
msgid "Faking Responses"
msgstr "^[模擬](Fake) Response"

# P
#: ./docs/8.x/http-client.md:310
#: ./docs/9.x/http-client.md:414
#: ./docs/10.x/http-client.md:488
#: ./docs/11.x/http-client.md:502
#: ./docs/master/http-client.md:501
msgid "For example, to instruct the HTTP client to return empty, `200` status code responses for every request, you may call the `fake` method with no arguments:"
msgstr "舉例來說，若要讓 HTTP 用戶端為每個 Request 回傳 `200` 狀態碼的空 Response，可呼叫 `fake` 方法，然後不傳入任何引數："

# CODE
#: ./docs/8.x/http-client.md:312
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::fake();\n"
"\n"
"$response = Http::post(...);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:318
msgid "When faking requests, HTTP client middleware are not executed. You should define expectations for faked responses as if these middleware have run correctly."
msgstr ""

# P
#: ./docs/9.x/http-client.md:319
msgid "Likewise, you can inspect the incoming HTTP response by registering a middleware via the `withMiddleware` method in combination with Guzzle's `mapResponse` middleware factory:"
msgstr "類似地，我們也可以將 `withMiddleware` 方法與 Guzzle 的 `mapResponse` Middleware Factory 搭配使用來註冊用於檢查連入 HTTP Request 的 Middleware："

# P
#: ./docs/8.x/http-client.md:320
#: ./docs/9.x/http-client.md:422
#: ./docs/10.x/http-client.md:496
#: ./docs/11.x/http-client.md:510
#: ./docs/master/http-client.md:509
#~ msgid "<a name=\"faking-specific-urls\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:321
#: ./docs/9.x/http-client.md:423
#: ./docs/10.x/http-client.md:497
#: ./docs/11.x/http-client.md:511
#: ./docs/master/http-client.md:510
msgid "Faking Specific URLs"
msgstr "模擬執行 URL"

# CODE
#: ./docs/9.x/http-client.md:321
msgid ""
"use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\ResponseInterface;\n"
"\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapResponse(function (ResponseInterface $response) {\n"
"        $header = $response->getHeader('X-Example');\n"
"\n"
"        // ...\n"
"        \n"
"        return $response;\n"
"    })\n"
")->get('http://example.com');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:323
#: ./docs/9.x/http-client.md:425
#: ./docs/10.x/http-client.md:499
#: ./docs/11.x/http-client.md:513
#: ./docs/master/http-client.md:512
msgid "Alternatively, you may pass an array to the `fake` method. The array's keys should represent URL patterns that you wish to fake and their associated responses. The `*` character may be used as a wildcard character. Any requests made to URLs that have not been faked will actually be executed. You may use the `Http` facade's `response` method to construct stub / fake responses for these endpoints:"
msgstr "或者，我們也可以傳入一組陣列給 `fake` 方法。該陣列的索引鍵代表要模擬的 URL，對應的值則為 Response。可使用 `*` 字元來當作萬用字元。當 Request 的 URL 不在模擬列表內時，就會被實際執行。可以使用 `Http` Facade 的 `response` 方法來為這些^[Endpoint](端點)建立虛擬的 Response："

# CODE
#: ./docs/8.x/http-client.md:325
#: ./docs/9.x/http-client.md:427
#: ./docs/10.x/http-client.md:501
#: ./docs/11.x/http-client.md:515
#: ./docs/master/http-client.md:514
msgid ""
"Http::fake([\n"
"    // Stub a JSON response for GitHub endpoints...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),\n"
"\n"
"    // Stub a string response for Google endpoints...\n"
"    'google.com/*' => Http::response('Hello World', 200, $headers),\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:333
#: ./docs/9.x/http-client.md:435
#: ./docs/10.x/http-client.md:509
#: ./docs/11.x/http-client.md:523
#: ./docs/master/http-client.md:522
msgid "If you would like to specify a fallback URL pattern that will stub all unmatched URLs, you may use a single `*` character:"
msgstr "若想為所有不符合的 URL 建立一個遞補用 URL 規則，只要使用單一 `*` 字元即可："

# CODE
#: ./docs/8.x/http-client.md:335
#: ./docs/9.x/http-client.md:437
#: ./docs/10.x/http-client.md:511
#: ./docs/11.x/http-client.md:525
#: ./docs/master/http-client.md:524
msgid ""
"Http::fake([\n"
"    // Stub a JSON response for GitHub endpoints...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),\n"
"\n"
"    // Stub a string response for all other endpoints...\n"
"    '*' => Http::response('Hello World', 200, ['Headers']),\n"
"]);"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:338
#: ./docs/11.x/http-client.md:333
#: ./docs/master/http-client.md:332
msgid ""
"use Illuminate\\Http\\Client\\Response;\n"
"use Illuminate\\Http\\Client\\RequestException;\n"
"\n"
"return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) {\n"
"    // ...\n"
"})->json();"
msgstr ""

# P
#: ./docs/8.x/http-client.md:343
#: ./docs/9.x/http-client.md:445
#: ./docs/10.x/http-client.md:519
#: ./docs/11.x/http-client.md:542
#: ./docs/master/http-client.md:532
#~ msgid "<a name=\"faking-response-sequences\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:344
#: ./docs/9.x/http-client.md:446
#: ./docs/10.x/http-client.md:520
#: ./docs/11.x/http-client.md:543
#: ./docs/master/http-client.md:533
msgid "Faking Response Sequences"
msgstr "模擬 Response 序列"

# P
#: ./docs/8.x/http-client.md:346
#: ./docs/9.x/http-client.md:448
#: ./docs/10.x/http-client.md:522
#: ./docs/11.x/http-client.md:545
#: ./docs/master/http-client.md:535
msgid "Sometimes you may need to specify that a single URL should return a series of fake responses in a specific order. You may accomplish this using the `Http::sequence` method to build the responses:"
msgstr "有時候我們需要讓單一 URL 以固定的順序回傳一系列模擬的 Response。我們可以使用 `Http::sequence`  方法來建立 Request："

# P
#: ./docs/10.x/http-client.md:348
#: ./docs/11.x/http-client.md:343
#: ./docs/master/http-client.md:342
msgid "Since Laravel's HTTP client is powered by Guzzle, you may take advantage of [Guzzle Middleware](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html) to manipulate the outgoing request or inspect the incoming response. To manipulate the outgoing request, register a Guzzle middleware via the `withRequestMiddleware` method:"
msgstr "由於 Laravel 的 HTTP 用戶端使用 Guzzle，因此我們也可以使用 [Guzzle 的 Middleware 功能](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html)來對修改連外 Request，或是檢查連入的 Response。若要修改連外的 Request，可使用 `withRequestMiddleware ` 方法來註冊 Guzzle Middleware："

# CODE
#: ./docs/8.x/http-client.md:348
#: ./docs/9.x/http-client.md:450
#: ./docs/10.x/http-client.md:524
#: ./docs/11.x/http-client.md:547
#: ./docs/master/http-client.md:537
msgid ""
"Http::fake([\n"
"    // Stub a series of responses for GitHub endpoints...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->pushStatus(404),\n"
"]);"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:350
#: ./docs/11.x/http-client.md:345
#: ./docs/master/http-client.md:344
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\RequestInterface;\n"
"\n"
"$response = Http::withRequestMiddleware(\n"
"    function (RequestInterface $request) {\n"
"        return $request->withHeader('X-Example', 'Value');\n"
"    }\n"
")->get('http://example.com');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:356
msgid "When all of the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception. If you would like to specify a default response that should be returned when a sequence is empty, you may use the `whenEmpty` method:"
msgstr "用完 Response 序列內的所有 Response 後，接下來再建立 Request 就會導致 Response 系列擲回一個 Exception。若想指定當序列為空時要回傳的預設 Response，可使用 `whenEmpty` 方法："

# CODE
#: ./docs/8.x/http-client.md:358
#: ./docs/9.x/http-client.md:460
#: ./docs/10.x/http-client.md:534
#: ./docs/11.x/http-client.md:557
#: ./docs/master/http-client.md:547
msgid ""
"Http::fake([\n"
"    // Stub a series of responses for GitHub endpoints...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->whenEmpty(Http::response()),\n"
"]);"
msgstr ""

# P
#: ./docs/10.x/http-client.md:359
#: ./docs/11.x/http-client.md:354
#: ./docs/master/http-client.md:353
msgid "Likewise, you can inspect the incoming HTTP response by registering a middleware via the `withResponseMiddleware` method:"
msgstr "類似地，我們也可以使用 `withResponseMiddleware` 方法來註冊 Middleware 以檢查連入的 HTTP Response："

# CODE
#: ./docs/10.x/http-client.md:361
#: ./docs/11.x/http-client.md:356
#: ./docs/master/http-client.md:355
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\ResponseInterface;\n"
"\n"
"$response = Http::withResponseMiddleware(\n"
"    function (ResponseInterface $response) {\n"
"        $header = $response->getHeader('X-Example');\n"
"\n"
"        // ...\n"
"\n"
"        return $response;\n"
"    }\n"
")->get('http://example.com');"
msgstr ""

# P
#: ./docs/8.x/http-client.md:366
#: ./docs/9.x/http-client.md:468
#: ./docs/10.x/http-client.md:542
#: ./docs/11.x/http-client.md:565
#: ./docs/master/http-client.md:555
msgid "If you would like to fake a sequence of responses but do not need to specify a specific URL pattern that should be faked, you may use the `Http::fakeSequence` method:"
msgstr "若想模擬一系列的 Response，但又不想指定要模擬的特定 URL 格式，可使用 `Http::fakeSequence`  方法："

# CODE
#: ./docs/8.x/http-client.md:368
#: ./docs/9.x/http-client.md:470
#: ./docs/10.x/http-client.md:544
#: ./docs/11.x/http-client.md:567
#: ./docs/master/http-client.md:557
msgid ""
"Http::fakeSequence()\n"
"        ->push('Hello World', 200)\n"
"        ->whenEmpty(Http::response());"
msgstr ""

# P
#: ./docs/8.x/http-client.md:372
#: ./docs/9.x/http-client.md:474
#: ./docs/10.x/http-client.md:548
#: ./docs/11.x/http-client.md:571
#: ./docs/master/http-client.md:561
#~ msgid "<a name=\"fake-callback\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/http-client.md:373
#: ./docs/9.x/http-client.md:475
#: ./docs/10.x/http-client.md:549
#: ./docs/11.x/http-client.md:572
#: ./docs/master/http-client.md:562
msgid "Fake Callback"
msgstr "模擬回呼"

# P
#: ./docs/10.x/http-client.md:374
#: ./docs/11.x/http-client.md:369
#: ./docs/master/http-client.md:368
#~ msgid "<a name=\"global-middleware\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/http-client.md:375
#: ./docs/11.x/http-client.md:370
#: ./docs/master/http-client.md:369
msgid "Global Middleware"
msgstr "全域 Middleware"

# P
#: ./docs/8.x/http-client.md:375
#: ./docs/9.x/http-client.md:477
#: ./docs/11.x/http-client.md:574
#: ./docs/master/http-client.md:564
msgid "If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a closure to the `fake` method. This closure will receive an instance of `Illuminate\\Http\\Client\\Request` and should return a response instance. Within your closure, you may perform whatever logic is necessary to determine what type of response to return:"
msgstr "若某些 Endpoint 需要使用比較複雜的邏輯來判斷要回傳什麼 Response 的話，可傳入一個閉包給 `fake` 方法。該閉包會收到一組 `Illuminate\\Http\\Client\\Request` 的實體，而該閉包必須回傳 Response 實體。在這個閉包內，我們就可以任意加上邏輯來判斷要回傳什麼類型的 Response："

# P
#: ./docs/10.x/http-client.md:377
#: ./docs/11.x/http-client.md:372
#: ./docs/master/http-client.md:371
msgid "Sometimes, you may want to register a middleware that applies to every outgoing request and incoming response. To accomplish this, you may use the `globalRequestMiddleware` and `globalResponseMiddleware` methods. Typically, these methods should be invoked in the `boot` method of your application's `AppServiceProvider`:"
msgstr "有時候，我們會想註冊套用到每個連外 Request 與連入 Response 的 Middleware。這時候，我們可以使用 `globalRequestMiddleware` 與 `globalResponseMiddleware` 方法。一般來說，這些方法應在專案的 `AppServiceProvider` 中 `boot` 方法內呼叫："

# CODE
#: ./docs/8.x/http-client.md:377
msgid ""
"Http::fake(function ($request) {\n"
"    return Http::response('Hello World', 200);\n"
"});"
msgstr ""

# CODE: php
#: ./docs/10.x/http-client.md:379
#: ./docs/11.x/http-client.md:374
#: ./docs/master/http-client.md:373
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::globalRequestMiddleware(fn ($request) => $request->withHeader(\n"
"    'User-Agent', 'Example Application/1.0'\n"
"));\n"
"\n"
"Http::globalResponseMiddleware(fn ($response) => $response->withHeader(\n"
"    'X-Finished-At', now()->toDateTimeString()\n"
"));"
msgstr ""

# P
#: ./docs/8.x/http-client.md:381
#: ./docs/9.x/http-client.md:504
#: ./docs/10.x/http-client.md:578
#: ./docs/11.x/http-client.md:601
#: ./docs/master/http-client.md:591
#~ msgid "<a name=\"inspecting-requests\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/http-client.md:382
#: ./docs/9.x/http-client.md:505
#: ./docs/10.x/http-client.md:579
#: ./docs/11.x/http-client.md:602
#: ./docs/master/http-client.md:592
msgid "Inspecting Requests"
msgstr "檢查 Request"

# P
#: ./docs/8.x/http-client.md:384
#: ./docs/9.x/http-client.md:507
#: ./docs/10.x/http-client.md:581
#: ./docs/11.x/http-client.md:604
#: ./docs/master/http-client.md:594
msgid "When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your application is sending the correct data or headers. You may accomplish this by calling the `Http::assertSent` method after calling `Http::fake`."
msgstr "在模擬 Response 時，有時候我們會需要檢查用戶端收到的 Request，以確保程式有傳送正確的資料。可以在呼叫 `Http::fake` 之前先呼叫 `Http::assertSent` 方法來檢查。"

# P
#: ./docs/8.x/http-client.md:386
#: ./docs/9.x/http-client.md:509
#: ./docs/10.x/http-client.md:583
#: ./docs/11.x/http-client.md:606
#: ./docs/master/http-client.md:596
msgid "The `assertSent` method accepts a closure which will receive an `Illuminate\\Http\\Client\\Request` instance and should return a boolean value indicating if the request matches your expectations. In order for the test to pass, at least one request must have been issued matching the given expectations:"
msgstr "`assertSent` 方法接受一組閉包，該閉包會收到 `Illuminate\\Http\\Client\\Request` 的實體，而該閉包應回傳用來表示 Request 是否符合預期的布林值。若要讓測試通過，提供的 Request 中就必須至少有一個是符合給定預期條件的："

# CODE
#: ./docs/8.x/http-client.md:388
#: ./docs/9.x/http-client.md:511
#: ./docs/10.x/http-client.md:585
#: ./docs/11.x/http-client.md:608
#: ./docs/master/http-client.md:598
msgid ""
"use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::fake();\n"
"\n"
"Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n"
"\n"
"Http::assertSent(function (Request $request) {\n"
"    return $request->hasHeader('X-First', 'foo') &&\n"
"           $request->url() == 'http://example.com/users' &&\n"
"           $request['name'] == 'Taylor' &&\n"
"           $request['role'] == 'Developer';\n"
"});"
msgstr ""

# P
#: ./docs/11.x/http-client.md:389
#: ./docs/master/http-client.md:388
msgid "You may specify additional [Guzzle request options](http://docs.guzzlephp.org/en/stable/request-options.html) for an outgoing request using the `withOptions` method. The `withOptions` method accepts an array of key / value pairs:"
msgstr ""

# P
#: ./docs/11.x/http-client.md:395
#: ./docs/master/http-client.md:394
#~ msgid "<a name=\"global-options\"></a>"
#~ msgstr ""

# H4
#: ./docs/11.x/http-client.md:396
#: ./docs/master/http-client.md:395
msgid "Global Options"
msgstr ""

# P
#: ./docs/11.x/http-client.md:398
#: ./docs/master/http-client.md:397
msgid "To configure default options for every outgoing request, you may utilize the `globalOptions` method. Typically, this method should be invoked from the `boot` method of your application's `AppServiceProvider`:"
msgstr ""

# CODE: php
#: ./docs/11.x/http-client.md:400
#: ./docs/master/http-client.md:399
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Http::globalOptions([\n"
"        'allow_redirects' => false,\n"
"    ]);\n"
"}"
msgstr ""

# P
#: ./docs/8.x/http-client.md:407
#: ./docs/9.x/http-client.md:530
#: ./docs/10.x/http-client.md:604
#: ./docs/11.x/http-client.md:627
#: ./docs/master/http-client.md:617
msgid "If needed, you may assert that a specific request was not sent using the `assertNotSent` method:"
msgstr "若有需要，可以使用 `assertNotSent` 方法來判斷特定 Request 是否未被送出："

# CODE
#: ./docs/8.x/http-client.md:409
#: ./docs/9.x/http-client.md:532
#: ./docs/10.x/http-client.md:606
#: ./docs/11.x/http-client.md:629
#: ./docs/master/http-client.md:619
msgid ""
"use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::fake();\n"
"\n"
"Http::post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n"
"\n"
"Http::assertNotSent(function (Request $request) {\n"
"    return $request->url() === 'http://example.com/posts';\n"
"});"
msgstr ""

# P
#: ./docs/9.x/http-client.md:409
#: ./docs/10.x/http-client.md:483
#: ./docs/11.x/http-client.md:497
#: ./docs/master/http-client.md:496
msgid "Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's HTTP client is no exception. The `Http` facade's `fake` method allows you to instruct the HTTP client to return stubbed / dummy responses when requests are made."
msgstr "許多 Laravel 的服務都提供了能讓我們輕鬆撰寫測試的功能，而 Laravel 的 HTTP 用戶端也不例外。`Http` Facade 的 `fake` 方法能讓我們指定 HTTP 用戶端在建立 Request 後回傳一組虛擬的 Response。"

# CODE
#: ./docs/9.x/http-client.md:416
#: ./docs/10.x/http-client.md:490
#: ./docs/11.x/http-client.md:504
#: ./docs/master/http-client.md:503
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::fake();\n"
"\n"
"$response = Http::post(/* ... */);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:423
#: ./docs/9.x/http-client.md:546
#: ./docs/10.x/http-client.md:620
#: ./docs/11.x/http-client.md:643
#: ./docs/master/http-client.md:633
msgid "You may use the `assertSentCount` method to assert how many requests were \"sent\" during the test:"
msgstr "可以使用 `assertSentCount` 方法來判斷在測試時「送出」了多少個 Request："

# CODE
#: ./docs/8.x/http-client.md:425
#: ./docs/9.x/http-client.md:548
#: ./docs/10.x/http-client.md:622
#: ./docs/11.x/http-client.md:645
#: ./docs/master/http-client.md:635
msgid ""
"Http::fake();\n"
"\n"
"Http::assertSentCount(5);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:429
#: ./docs/9.x/http-client.md:552
#: ./docs/10.x/http-client.md:626
#: ./docs/11.x/http-client.md:649
#: ./docs/master/http-client.md:639
msgid "Or, you may use the `assertNothingSent` method to assert that no requests were sent during the test:"
msgstr "或者，也可以使用 `assertNothingSent` 方法來判斷在測試時是否未送出任何 Request："

# CODE
#: ./docs/8.x/http-client.md:431
#: ./docs/9.x/http-client.md:554
#: ./docs/10.x/http-client.md:628
#: ./docs/11.x/http-client.md:651
#: ./docs/master/http-client.md:641
msgid ""
"Http::fake();\n"
"\n"
"Http::assertNothingSent();"
msgstr ""

# P
#: ./docs/10.x/http-client.md:433
#: ./docs/11.x/http-client.md:447
#: ./docs/master/http-client.md:446
#~ msgid "<a name=\"customizing-concurrent-requests\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/http-client.md:434
#: ./docs/11.x/http-client.md:448
#: ./docs/master/http-client.md:447
msgid "Customizing Concurrent Requests"
msgstr "自定同時進行的 Request"

# P
#: ./docs/8.x/http-client.md:435
#: ./docs/9.x/http-client.md:597
#: ./docs/10.x/http-client.md:671
#: ./docs/11.x/http-client.md:694
#: ./docs/master/http-client.md:684
#~ msgid "<a name=\"events\"></a>"
#~ msgstr ""

# P
#: ./docs/10.x/http-client.md:436
#: ./docs/11.x/http-client.md:450
#: ./docs/master/http-client.md:449
msgid "The `pool` method cannot be chained with other HTTP client methods such as the `withHeaders` or `middleware` methods. If you want to apply custom headers or middleware to pooled requests, you should configure those options on each request in the pool:"
msgstr "`pool` 方法不能與其他如 `withHeaders` 或 `middleware` 等 HTTP Client 方法一起串連使用。若想講自定 Header 或 Middleware 套用到放在 Pool 中的 Request，則必須將這些選項設定到 Pool 中的各個 Request："

# H2
#: ./docs/8.x/http-client.md:436
#: ./docs/9.x/http-client.md:598
#: ./docs/10.x/http-client.md:672
#: ./docs/11.x/http-client.md:695
#: ./docs/master/http-client.md:685
msgid "Events"
msgstr "事件"

# CODE: php
#: ./docs/10.x/http-client.md:438
#: ./docs/11.x/http-client.md:452
#: ./docs/master/http-client.md:451
msgid ""
"use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"$headers = [\n"
"    'X-Example' => 'example',\n"
"];\n"
"\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->withHeaders($headers)->get('http://laravel.test/test'),\n"
"    $pool->withHeaders($headers)->get('http://laravel.test/test'),\n"
"    $pool->withHeaders($headers)->get('http://laravel.test/test'),\n"
"]);"
msgstr ""

# P
#: ./docs/8.x/http-client.md:438
#: ./docs/9.x/http-client.md:600
#: ./docs/10.x/http-client.md:674
#: ./docs/11.x/http-client.md:697
#: ./docs/master/http-client.md:687
msgid "Laravel fires three events during the process of sending HTTP requests. The `RequestSending` event is fired prior to a request being sent, while the `ResponseReceived` event is fired after a response is received for a given request. The `ConnectionFailed` event is fired if no response is received for a given request."
msgstr "在傳送 HTTP Request 的過程中，Laravel 會觸發三個事件。在送出 Request 前會觸發 `RequestSending` 事件，而給定 Request 收到 Response 後會觸發 `ResponseReceived` 事件。若給定的 Request 未收到 Response，會觸發 `ConnectionFailed` 事件。"

# P
#: ./docs/8.x/http-client.md:440
#: ./docs/9.x/http-client.md:602
#: ./docs/10.x/http-client.md:676
msgid "The `RequestSending` and `ConnectionFailed` events both contain a public `$request` property that you may use to inspect the `Illuminate\\Http\\Client\\Request` instance. Likewise, the `ResponseReceived` event contains a `$request` property as well as a `$response` property which may be used to inspect the `Illuminate\\Http\\Client\\Response` instance. You may register event listeners for this event in your `App\\Providers\\EventServiceProvider` service provider:"
msgstr "`RequestSending` 與 `ConnectionFailed` 事件都有一個 `$request` 共用屬性，可以通過這個屬性來取得 `Illuminate\\Http\\Client\\Request` 實體。而 `ResponseReceived` 事件中也有一個 `$request` 公開屬性，以及一個可用來取得  `Illuminate\\Http\\Client\\Response` 實體的 `$response` 公開屬性。可以在 `App\\Providers\\EventServiceProvider` Service Provider 中為這些 Event 註冊 Listener："

# CODE
#: ./docs/8.x/http-client.md:442
#: ./docs/9.x/http-client.md:604
#: ./docs/10.x/http-client.md:678
msgid ""
"/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    'Illuminate\\Http\\Client\\Events\\RequestSending' => [\n"
"        'App\\Listeners\\LogRequestSending',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ResponseReceived' => [\n"
"        'App\\Listeners\\LogResponseReceived',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ConnectionFailed' => [\n"
"        'App\\Listeners\\LogConnectionFailed',\n"
"    ],\n"
"];"
msgstr ""

# CODE: php
#: ./docs/10.x/http-client.md:458
#: ./docs/11.x/http-client.md:472
#: ./docs/master/http-client.md:471
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/9.x/http-client.md:458
#: ./docs/10.x/http-client.md:532
#: ./docs/11.x/http-client.md:555
#: ./docs/master/http-client.md:545
msgid "When all the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception. If you would like to specify a default response that should be returned when a sequence is empty, you may use the `whenEmpty` method:"
msgstr "用完 Response 序列內的所有 Response 後，若之後又建立新的 Request，就會導致 Response 序列擲回 Exception。若想指定當序列為空時要回傳的預設 Response，可使用 `whenEmpty` 方法："

# CODE
#: ./docs/9.x/http-client.md:479
#: ./docs/11.x/http-client.md:576
#: ./docs/master/http-client.md:566
msgid ""
"use Illuminate\\Http\\Client\\Request;\n"
"\n"
"Http::fake(function (Request $request) {\n"
"    return Http::response('Hello World', 200);\n"
"});"
msgstr ""

# P
#: ./docs/9.x/http-client.md:485
#: ./docs/10.x/http-client.md:559
#: ./docs/11.x/http-client.md:582
#: ./docs/master/http-client.md:572
#~ msgid "<a name=\"preventing-stray-requests\"></a>"
#~ msgstr ""

# H3
#: ./docs/9.x/http-client.md:486
#: ./docs/10.x/http-client.md:560
#: ./docs/11.x/http-client.md:583
#: ./docs/master/http-client.md:573
msgid "Preventing Stray Requests"
msgstr "避免漏掉的 Request"

# P
#: ./docs/9.x/http-client.md:488
#: ./docs/10.x/http-client.md:562
#: ./docs/11.x/http-client.md:585
#: ./docs/master/http-client.md:575
msgid "If you would like to ensure that all requests sent via the HTTP client have been faked throughout your individual test or complete test suite, you can call the `preventStrayRequests` method. After calling this method, any requests that do not have a corresponding fake response will throw an exception rather than making the actual HTTP request:"
msgstr "若要確保在個別測試或整個測試套件中，所有使用 HTTP 用戶端的 Request 都有被 Fake 到，則可以使用 `preventStrayRequests` 方法。呼叫該方法後，若有任何找不到對應 Fake Response 的 Request，就不會產生實際的 HTTP Request，而會擲回 Exception："

# CODE
#: ./docs/9.x/http-client.md:490
#: ./docs/10.x/http-client.md:564
#: ./docs/11.x/http-client.md:587
#: ./docs/master/http-client.md:577
msgid ""
"use Illuminate\\Support\\Facades\\Http;\n"
"\n"
"Http::preventStrayRequests();\n"
"\n"
"Http::fake([\n"
"    'github.com/*' => Http::response('ok'),\n"
"]);\n"
"\n"
"// An \"ok\" response is returned...\n"
"Http::get('https://github.com/laravel/framework');\n"
"\n"
"// An exception is thrown...\n"
"Http::get('https://laravel.com');"
msgstr ""

# P
#: ./docs/11.x/http-client.md:533
#~ msgid "<a name=\"faking-connection-exceptions\"></a>"
#~ msgstr ""

# H4
#: ./docs/11.x/http-client.md:534
msgid "Faking Connection Exceptions"
msgstr ""

# P
#: ./docs/11.x/http-client.md:536
msgid "Sometimes you may need to test your application's behavior if the HTTP client encounters an `Illuminate\\Http\\Client\\ConnectionException` when attempting to make a request. You can instruct the HTTP client to throw a connection exception using the `failedConnection` method:"
msgstr ""

# CODE
#: ./docs/11.x/http-client.md:538
msgid ""
"Http::fake([\n"
"    'github.com/*' => Http::failedConnection(),\n"
"]);"
msgstr ""

# P
#: ./docs/10.x/http-client.md:551
msgid "If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a closure to the `fake` method. This closure will receive an instance of `Illuminate\\Http\\Client\\Request` as well as an array of options. The closure should return a response instance. Within your closure, you may perform whatever logic is necessary to determine what type of response to return:"
msgstr ""

# CODE
#: ./docs/10.x/http-client.md:553
msgid ""
"use Illuminate\\Http\\Client\\Request;\n"
"\n"
"Http::fake(function (Request $request, array $options) {\n"
"    return Http::response('Hello World', 200);\n"
"});"
msgstr ""

# P
#: ./docs/9.x/http-client.md:558
#: ./docs/10.x/http-client.md:632
#: ./docs/11.x/http-client.md:655
#: ./docs/master/http-client.md:645
#~ msgid "<a name=\"recording-requests-and-responses\"></a>"
#~ msgstr ""

# H4
#: ./docs/9.x/http-client.md:559
#: ./docs/10.x/http-client.md:633
#: ./docs/11.x/http-client.md:656
#: ./docs/master/http-client.md:646
msgid "Recording Requests / Responses"
msgstr "記錄 Request 或 Response"

# P
#: ./docs/9.x/http-client.md:561
#: ./docs/10.x/http-client.md:635
#: ./docs/11.x/http-client.md:658
#: ./docs/master/http-client.md:648
msgid "You may use the `recorded` method to gather all requests and their corresponding responses. The `recorded` method returns a collection of arrays that contains instances of `Illuminate\\Http\\Client\\Request` and `Illuminate\\Http\\Client\\Response`:"
msgstr "可以使用 `recorded` 方法來取得所有的 Request 與其對應的 Response。`recorded` 方法會回傳一組陣列的 Collection，其內容為 `Illuminate\\Http\\Client\\Request` 與 `Illuminate\\Http\\Client\\Response` 的實體："

# CODE: php
#: ./docs/9.x/http-client.md:563
#: ./docs/10.x/http-client.md:637
#: ./docs/11.x/http-client.md:660
#: ./docs/master/http-client.md:650
msgid ""
"Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n"
"\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n"
"\n"
"$recorded = Http::recorded();\n"
"\n"
"[$request, $response] = $recorded[0];"
msgstr ""

# P
#: ./docs/9.x/http-client.md:577
#: ./docs/10.x/http-client.md:651
#: ./docs/11.x/http-client.md:674
#: ./docs/master/http-client.md:664
msgid "Additionally, the `recorded` method accepts a closure which will receive an instance of `Illuminate\\Http\\Client\\Request` and `Illuminate\\Http\\Client\\Response` and may be used to filter request / response pairs based on your expectations:"
msgstr "此外，也可傳入閉包給 `recorded` 方法，該閉包會收到 `Illuminate\\Http\\Client\\Request` 與 `Illuminate\\Http\\Client\\Response` 的實體。可以傳入閉包來依據需求過濾 Request／Response 配對："

# CODE: php
#: ./docs/9.x/http-client.md:579
#: ./docs/10.x/http-client.md:653
#: ./docs/11.x/http-client.md:676
#: ./docs/master/http-client.md:666
msgid ""
"use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Http\\Client\\Response;\n"
"\n"
"Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n"
"\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n"
"\n"
"$recorded = Http::recorded(function (Request $request, Response $response) {\n"
"    return $request->url() !== 'https://laravel.com' &&\n"
"           $response->successful();\n"
"});"
msgstr ""

# P
#: ./docs/11.x/http-client.md:699
#: ./docs/master/http-client.md:689
msgid "The `RequestSending` and `ConnectionFailed` events both contain a public `$request` property that you may use to inspect the `Illuminate\\Http\\Client\\Request` instance. Likewise, the `ResponseReceived` event contains a `$request` property as well as a `$response` property which may be used to inspect the `Illuminate\\Http\\Client\\Response` instance. You may create [event listeners](/docs/{{version}}/events) for these events within your application:"
msgstr ""

# CODE
#: ./docs/11.x/http-client.md:701
#: ./docs/master/http-client.md:691
msgid ""
"use Illuminate\\Http\\Client\\Events\\RequestSending;\n"
"\n"
"class LogRequest\n"
"{\n"
"    /**\n"
"     * Handle the given event.\n"
"     */\n"
"    public function handle(RequestSending $event): void\n"
"    {\n"
"        // $event->request ...\n"
"    }\n"
"}"
msgstr ""
