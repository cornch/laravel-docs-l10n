msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/http-client.pot\n"
"X-Crowdin-File-ID: 85\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2023-02-11 12:59\n"

#: docs/10.x/http-client.md:block 1 (header)
msgid "HTTP Client"
msgstr "HTTP 用戶端"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Making Requests](#making-requests)"
msgstr "[建立 Request](#making-requests)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Request Data](#request-data)"
msgstr "[Request 資料](#request-data)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Headers](#headers)"
msgstr "[標頭 (Header)](#headers)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Authentication](#authentication)"
msgstr "[身份認證](#authentication)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Timeout](#timeout)"
msgstr "[逾時](#timeout)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Retries](#retries)"
msgstr "[重試](#retries)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Error Handling](#error-handling)"
msgstr "[錯誤處理](#error-handling)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Guzzle Middleware](#guzzle-middleware)"
msgstr "[Guzzle Middleware](#guzzle-middleware)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Guzzle Options](#guzzle-options)"
msgstr "[Guzzle 選項](#guzzle-options)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Concurrent Requests](#concurrent-requests)"
msgstr "[同時進行的 Request](#concurrent-requests)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Macros](#macros)"
msgstr "[Macro](#macros)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Testing](#testing)"
msgstr "[測試](#testing)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Faking Responses](#faking-responses)"
msgstr "[模擬 Response](#faking-responses)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Inspecting Requests](#inspecting-requests)"
msgstr "[攔截 Request](#inspecting-requests)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Preventing Stray Requests](#preventing-stray-requests)"
msgstr "[避免漏掉的 Request](#preventing-stray-requests)"

#: docs/10.x/http-client.md:block 2 (unordered list)
msgid "[Events](#events)"
msgstr "[事件](#events)"

#: docs/10.x/http-client.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/10.x/http-client.md:block 5 (paragraph)
msgid "Laravel provides an expressive, minimal API around the [Guzzle HTTP client](http://docs.guzzlephp.org/en/stable/), allowing you to quickly make outgoing HTTP requests to communicate with other web applications. Laravel's wrapper around Guzzle is focused on its most common use cases and a wonderful developer experience."
msgstr "Laravel 為 [Guzzle HTTP 用戶端](http://docs.guzzlephp.org/en/stable/)提供了一個語系化的極簡 API，能讓我們快速建立外連 HTTP Request 來與其他 Web App 通訊。Laravel 的 Guzzle 包裝著重於各個常見的使用情境，並提供優秀的^[開發人員經驗](Developer Experience)。"

#: docs/10.x/http-client.md:block 6 (paragraph)
msgid "Before getting started, you should ensure that you have installed the Guzzle package as a dependency of your application. By default, Laravel automatically includes this dependency. However, if you have previously removed the package, you may install it again via Composer:"
msgstr "在開始前，先確保有將 Guzzle 套件安裝為專案的相依性套件。預設情況下，Laravel 已自動包含了這個相依性套件，但若你之前有將其移除，請使用 Composer 再安裝一次："

#: docs/10.x/http-client.md:block 7 (code)
msgid "composer require guzzlehttp/guzzle\n"
msgstr "composer require guzzlehttp/guzzle\n"

#: docs/10.x/http-client.md:block 9 (header)
msgid "Making Requests"
msgstr "建立 Request"

#: docs/10.x/http-client.md:block 10 (paragraph)
msgid "To make requests, you may use the `head`, `get`, `post`, `put`, `patch`, and `delete` methods provided by the `Http` facade. First, let's examine how to make a basic `GET` request to another URL:"
msgstr "若要建立 Request，可以使用 `Http` Facade 提供的 `head`、`get`、`post`、`put`、`patch`、`delete` 等方法。首先，我們先看看要查詢另一個 URL 的基礎 `GET` Request 怎麼建立："

#: docs/10.x/http-client.md:block 11 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"$response = Http::get('http://example.com');\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"$response = Http::get('http://example.com');\n"

#: docs/10.x/http-client.md:block 12 (paragraph)
msgid "The `get` method returns an instance of `Illuminate\\Http\\Client\\Response`, which provides a variety of methods that may be used to inspect the response:"
msgstr "`get` 方法會回傳 `Illuminate\\Http\\Client\\Response` 的實體，該實體提供了許多用來取得 Response 資訊的方法："

#: docs/10.x/http-client.md:block 13 (code)
msgid "$response->body() : string;\n"
"$response->json($key = null, $default = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"
msgstr "$response->body() : string;\n"
"$response->json($key = null, $default = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"

#: docs/10.x/http-client.md:block 14 (paragraph)
msgid "The `Illuminate\\Http\\Client\\Response` object also implements the PHP `ArrayAccess` interface, allowing you to access JSON response data directly on the response:"
msgstr "`Illuminate\\Http\\Client\\Response` 物件也實作了 PHP 的 `ArrayAccess` 實體，能讓我們直接在 Response 上存取 JSON Response 資料："

#: docs/10.x/http-client.md:block 15 (code)
msgid "return Http::get('http://example.com/users/1')['name'];\n"
msgstr "return Http::get('http://example.com/users/1')['name'];\n"

#: docs/10.x/http-client.md:block 16 (paragraph)
msgid "In addition to the response methods listed above, the following methods may be used to determine if the response has a given status code:"
msgstr "除了上述所列的 Response 方法外，也可以使用下列方法來判斷 Response 是否有給定的狀態碼："

#: docs/10.x/http-client.md:block 17 (code)
msgid "$response->ok() : bool;                  // 200 OK\n"
"$response->created() : bool;             // 201 Created\n"
"$response->accepted() : bool;            // 202 Accepted\n"
"$response->noContent() : bool;           // 204 No Content\n"
"$response->movedPermanently() : bool;    // 301 Moved Permanently\n"
"$response->found() : bool;               // 302 Found\n"
"$response->badRequest() : bool;          // 400 Bad Request\n"
"$response->unauthorized() : bool;        // 401 Unauthorized\n"
"$response->paymentRequired() : bool;     // 402 Payment Required\n"
"$response->forbidden() : bool;           // 403 Forbidden\n"
"$response->notFound() : bool;            // 404 Not Found\n"
"$response->requestTimeout() : bool;      // 408 Request Timeout\n"
"$response->conflict() : bool;            // 409 Conflict\n"
"$response->unprocessableEntity() : bool; // 422 Unprocessable Entity\n"
"$response->tooManyRequests() : bool;     // 429 Too Many Requests\n"
"$response->serverError() : bool;         // 500 Internal Server Error\n"
msgstr "$response->ok() : bool;                  // 200 OK\n"
"$response->created() : bool;             // 201 Created\n"
"$response->accepted() : bool;            // 202 Accepted\n"
"$response->noContent() : bool;           // 204 No Content\n"
"$response->movedPermanently() : bool;    // 301 Moved Permanently\n"
"$response->found() : bool;               // 302 Found\n"
"$response->badRequest() : bool;          // 400 Bad Request\n"
"$response->unauthorized() : bool;        // 401 Unauthorized\n"
"$response->paymentRequired() : bool;     // 402 Payment Required\n"
"$response->forbidden() : bool;           // 403 Forbidden\n"
"$response->notFound() : bool;            // 404 Not Found\n"
"$response->requestTimeout() : bool;      // 408 Request Timeout\n"
"$response->conflict() : bool;            // 409 Conflict\n"
"$response->unprocessableEntity() : bool; // 422 Unprocessable Entity\n"
"$response->tooManyRequests() : bool;     // 429 Too Many Requests\n"
"$response->serverError() : bool;         // 500 Internal Server Error\n"

#: docs/10.x/http-client.md:block 19 (header)
msgid "URI Templates"
msgstr "URI 樣板"

#: docs/10.x/http-client.md:block 20 (paragraph)
msgid "The HTTP client also allows you to construct request URLs using the [URI template specification](https://www.rfc-editor.org/rfc/rfc6570). To define the URL parameters that can be expanded by your URI template, you may use the `withUrlParameters` method:"
msgstr "在 HTTP Client 中，也可使用 [URI 樣板規格 (URI Template Specification)](https://www.rfc-editor.org/rfc/rfc6570)來建立 Request URL。若要定義可由 URI 樣板展開的 URL 參數，請使用 `withUrlParameters` 方法："

#: docs/10.x/http-client.md:block 21 (code)
msgid "Http::withUrlParameters([\n"
"    'endpoint' => 'https://laravel.com',\n"
"    'page' => 'docs',\n"
"    'version' => '9.x',\n"
"    'topic' => 'validation',\n"
"])->get('{+endpoint}/{page}/{version}/{topic}');\n"
msgstr "Http::withUrlParameters([\n"
"    'endpoint' => 'https://laravel.com',\n"
"    'page' => 'docs',\n"
"    'version' => '9.x',\n"
"    'topic' => 'validation',\n"
"])->get('{+endpoint}/{page}/{version}/{topic}');\n"

#: docs/10.x/http-client.md:block 23 (header)
msgid "Dumping Requests"
msgstr "傾印 Request"

#: docs/10.x/http-client.md:block 24 (paragraph)
msgid "If you would like to dump the outgoing request instance before it is sent and terminate the script's execution, you may add the `dd` method to the beginning of your request definition:"
msgstr "若想在送出 Request 前傾印連外 Request 並終止指令碼執行，可在 Request 定義的最前方加上 `dd` 方法："

#: docs/10.x/http-client.md:block 25 (code)
msgid "return Http::dd()->get('http://example.com');\n"
msgstr "return Http::dd()->get('http://example.com');\n"

#: docs/10.x/http-client.md:block 27 (header)
msgid "Request Data"
msgstr "Request 資料"

#: docs/10.x/http-client.md:block 28 (paragraph)
msgid "Of course, it is common when making `POST`, `PUT`, and `PATCH` requests to send additional data with your request, so these methods accept an array of data as their second argument. By default, data will be sent using the `application/json` content type:"
msgstr "當然，我們也很常使用 `POST`、`PUT`、`PATCH` 等 Request 來在 Request 上傳送額外資料，所以這些方法接受資料陣列作為第二個引數。預設情況下，資料會使用 `application/json` ^[Content Type](內容型別) 來傳送："

#: docs/10.x/http-client.md:block 29 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"$response = Http::post('http://example.com/users', [\n"
"    'name' => 'Steve',\n"
"    'role' => 'Network Administrator',\n"
"]);\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"$response = Http::post('http://example.com/users', [\n"
"    'name' => 'Steve',\n"
"    'role' => 'Network Administrator',\n"
"]);\n"

#: docs/10.x/http-client.md:block 31 (header)
msgid "GET Request Query Parameters"
msgstr "GET Request 查詢參數"

#: docs/10.x/http-client.md:block 32 (paragraph)
msgid "When making `GET` requests, you may either append a query string to the URL directly or pass an array of key / value pairs as the second argument to the `get` method:"
msgstr "在產生 `GET` Request 時，可以直接將^[查詢字串](Query String)加到 URL 上，或是傳入一組索引鍵 / 值配對的陣列作為 `get` 方法的第二個引數："

#: docs/10.x/http-client.md:block 33 (code)
msgid "$response = Http::get('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'page' => 1,\n"
"]);\n"
msgstr "$response = Http::get('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'page' => 1,\n"
"]);\n"

#: docs/10.x/http-client.md:block 35 (header)
msgid "Sending Form URL Encoded Requests"
msgstr "傳送 Form URL Encoded 的 Request"

#: docs/10.x/http-client.md:block 36 (paragraph)
msgid "If you would like to send data using the `application/x-www-form-urlencoded` content type, you should call the `asForm` method before making your request:"
msgstr "若想使用 `application/x-www-form-urlencoded` Content Type 來傳送資料的話，請在建立 Request 前呼叫 `asForm` 方法："

#: docs/10.x/http-client.md:block 37 (code)
msgid "$response = Http::asForm()->post('http://example.com/users', [\n"
"    'name' => 'Sara',\n"
"    'role' => 'Privacy Consultant',\n"
"]);\n"
msgstr "$response = Http::asForm()->post('http://example.com/users', [\n"
"    'name' => 'Sara',\n"
"    'role' => 'Privacy Consultant',\n"
"]);\n"

#: docs/10.x/http-client.md:block 39 (header)
msgid "Sending A Raw Request Body"
msgstr "傳送原始 Request 內文"

#: docs/10.x/http-client.md:block 40 (paragraph)
msgid "You may use the `withBody` method if you would like to provide a raw request body when making a request. The content type may be provided via the method's second argument:"
msgstr "在建立 Request 時，若想提供^[原始 Request 內文](Raw Request Body)，可使用 `withBody` 方法。可以在該方法的第二個引數上提供 Content Type："

#: docs/10.x/http-client.md:block 41 (code)
msgid "$response = Http::withBody(\n"
"    base64_encode($photo), 'image/jpeg'\n"
")->post('http://example.com/photo');\n"
msgstr "$response = Http::withBody(\n"
"    base64_encode($photo), 'image/jpeg'\n"
")->post('http://example.com/photo');\n"

#: docs/10.x/http-client.md:block 43 (header)
msgid "Multi-Part Requests"
msgstr "Multi-Part 的 Request"

#: docs/10.x/http-client.md:block 44 (paragraph)
msgid "If you would like to send files as multi-part requests, you should call the `attach` method before making your request. This method accepts the name of the file and its contents. If needed, you may provide a third argument which will be considered the file's filename:"
msgstr "若想使用 Multi-Part 的 Request 來傳送檔案的話，請在建立 Request 前呼叫 `attach` 方法。該方法接受檔案的欄位名稱、以及檔案的內容。若有需要，也可以提供第三個引數，該引數會被當作檔案名稱："

#: docs/10.x/http-client.md:block 45 (code)
msgid "$response = Http::attach(\n"
"    'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\n"
")->post('http://example.com/attachments');\n"
msgstr "$response = Http::attach(\n"
"    'attachment', file_get_contents('photo.jpg'), 'photo.jpg'\n"
")->post('http://example.com/attachments');\n"

#: docs/10.x/http-client.md:block 46 (paragraph)
msgid "Instead of passing the raw contents of a file, you may pass a stream resource:"
msgstr "除了直接傳入檔案的原始內容外，也可以傳入一個 ^[Stream Resource](串流資源)："

#: docs/10.x/http-client.md:block 47 (code)
msgid "$photo = fopen('photo.jpg', 'r');\n\n"
"$response = Http::attach(\n"
"    'attachment', $photo, 'photo.jpg'\n"
")->post('http://example.com/attachments');\n"
msgstr "$photo = fopen('photo.jpg', 'r');\n\n"
"$response = Http::attach(\n"
"    'attachment', $photo, 'photo.jpg'\n"
")->post('http://example.com/attachments');\n"

#: docs/10.x/http-client.md:block 49 (header)
msgid "Headers"
msgstr "標頭"

#: docs/10.x/http-client.md:block 50 (paragraph)
msgid "Headers may be added to requests using the `withHeaders` method. This `withHeaders` method accepts an array of key / value pairs:"
msgstr "可以使用 `withHeaders` 方法來將^[標頭](Header)加到 Request 上。`withHeaders` 方法接受一組索引鍵 / 值配對的陣列："

#: docs/10.x/http-client.md:block 51 (code)
msgid "$response = Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"    'X-Second' => 'bar'\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"]);\n"
msgstr "$response = Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"    'X-Second' => 'bar'\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"]);\n"

#: docs/10.x/http-client.md:block 52 (paragraph)
msgid "You may use the `accept` method to specify the content type that your application is expecting in response to your request:"
msgstr "可以使用 `accept` 方法來指定你的程式預期所預期 Response 的 Content Type："

#: docs/10.x/http-client.md:block 53 (code)
msgid "$response = Http::accept('application/json')->get('http://example.com/users');\n"
msgstr "$response = Http::accept('application/json')->get('http://example.com/users');\n"

#: docs/10.x/http-client.md:block 54 (paragraph)
msgid "For convenience, you may use the `acceptJson` method to quickly specify that your application expects the `application/json` content type in response to your request:"
msgstr "為了方便起見，可以使用 `acceptJson` 方法來快速指定要預期 Response 的 Content Type 是 `application/json`："

#: docs/10.x/http-client.md:block 55 (code)
msgid "$response = Http::acceptJson()->get('http://example.com/users');\n"
msgstr "$response = Http::acceptJson()->get('http://example.com/users');\n"

#: docs/10.x/http-client.md:block 57 (header)
msgid "Authentication"
msgstr "身分驗證"

#: docs/10.x/http-client.md:block 58 (paragraph)
msgid "You may specify basic and digest authentication credentials using the `withBasicAuth` and `withDigestAuth` methods, respectively:"
msgstr "可以使用 `withBasicAuth` 方法來指定使用 Basic 身分驗證的^[認證](Credential)，或是使用 `withDigestAuth` 方法來指定 Digest 身分驗證的認證："

#: docs/10.x/http-client.md:block 59 (code)
msgid "// Basic authentication...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);\n\n"
"// Digest authentication...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);\n"
msgstr "// Basic 身份認證...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(/* ... */);\n\n"
"// Digest 身份認證...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 61 (header)
msgid "Bearer Tokens"
msgstr "Bearer 權杖"

#: docs/10.x/http-client.md:block 62 (paragraph)
msgid "If you would like to quickly add a bearer token to the request's `Authorization` header, you may use the `withToken` method:"
msgstr "若想快速在 Request 的 `Authorization` 標頭中加上 Bearer ^[權杖](Token)，可使用 `withToken` 方法："

#: docs/10.x/http-client.md:block 63 (code)
msgid "$response = Http::withToken('token')->post(/* ... */);\n"
msgstr "$response = Http::withToken('token')->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 65 (header)
msgid "Timeout"
msgstr "逾時"

#: docs/10.x/http-client.md:block 66 (paragraph)
msgid "The `timeout` method may be used to specify the maximum number of seconds to wait for a response:"
msgstr "可使用 `timeout` 方法來為 Response 指定最多要等待的秒數："

#: docs/10.x/http-client.md:block 67 (code)
msgid "$response = Http::timeout(3)->get(/* ... */);\n"
msgstr "$response = Http::timeout(3)->get(/* ... */);\n"

#: docs/10.x/http-client.md:block 68 (paragraph)
msgid "If the given timeout is exceeded, an instance of `Illuminate\\Http\\Client\\ConnectionException` will be thrown."
msgstr "當達到給定的逾時秒數後，會擲回 `Illuminate\\Http\\Client\\ConnectionException` 實體。"

#: docs/10.x/http-client.md:block 69 (paragraph)
msgid "You may specify the maximum number of seconds to wait while trying to connect to a server using the `connectTimeout` method:"
msgstr "可以使用 `connectTimeout` 方法來指定嘗試連線到伺服器時要等待的最大秒數："

#: docs/10.x/http-client.md:block 70 (code)
msgid "$response = Http::connectTimeout(3)->get(/* ... */);\n"
msgstr "$response = Http::connectTimeout(3)->get(/* ... */);\n"

#: docs/10.x/http-client.md:block 72 (header)
msgid "Retries"
msgstr "重試"

#: docs/10.x/http-client.md:block 73 (paragraph)
msgid "If you would like the HTTP client to automatically retry the request if a client or server error occurs, you may use the `retry` method. The `retry` method accepts the maximum number of times the request should be attempted and the number of milliseconds that Laravel should wait in between attempts:"
msgstr "若想讓 HTTP 用戶端在發生用戶端錯誤或伺服器端錯誤時自動重試，可以使用 `retry` 方法。`retry` 方法接受該 Request 要重試的最大次數，以及每次重試間要等待多少毫秒："

#: docs/10.x/http-client.md:block 74 (code)
msgid "$response = Http::retry(3, 100)->post(/* ... */);\n"
msgstr "$response = Http::retry(3, 100)->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 75 (paragraph)
msgid "If needed, you may pass a third argument to the `retry` method. The third argument should be a callable that determines if the retries should actually be attempted. For example, you may wish to only retry the request if the initial request encounters an `ConnectionException`:"
msgstr "若有需要，可以傳入第三個引數給 `retry` 方法。第三個引數應為一個 Callable，用來判斷是否要重試。舉例來說，我們可以判斷只在 Request 遇到 `ConnectionException` 時才重試："

#: docs/10.x/http-client.md:block 76 (code)
msgid "use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n\n"
"$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);\n"
msgstr "use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n\n"
"$response = Http::retry(3, 100, function (Exception $exception, PendingRequest $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 77 (paragraph)
msgid "If a request attempt fails, you may wish to make a change to the request before a new attempt is made. You can achieve this by modifying the request argument provided to the callable you provided to the `retry` method. For example, you might want to retry the request with a new authorization token if the first attempt returned an authentication error:"
msgstr "若 Request 查詢失敗，我們可能會想在進行新嘗試前對 Request 做點修改。若要在重新嘗試前對 Request 做修改，我們只需要將提供 `retry` 方法的 Request 引數更改為 Callable 即可。舉例來說，在第一次嘗試回傳身份驗證錯誤時，我們可能會想以新的 Authorization Token 來重試該 Request："

#: docs/10.x/http-client.md:block 78 (code)
msgid "use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n\n"
"$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n\n"
"    $request->withToken($this->getNewToken());\n\n"
"    return true;\n"
"})->post(/* ... */);\n"
msgstr "use Exception;\n"
"use Illuminate\\Http\\Client\\PendingRequest;\n\n"
"$response = Http::withToken($this->getToken())->retry(2, 0, function (Exception $exception, PendingRequest $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n\n"
"    $request->withToken($this->getNewToken());\n\n"
"    return true;\n"
"})->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 79 (paragraph)
msgid "If all of the requests fail, an instance of `Illuminate\\Http\\Client\\RequestException` will be thrown. If you would like to disable this behavior, you may provide a `throw` argument with a value of `false`. When disabled, the last response received by the client will be returned after all retries have been attempted:"
msgstr "若 Request 執行失敗，會擲回一個 `Illuminate\\Http\\Client\\RequestException` 實體。若想禁用這個行為，可傳入 `false` 給 `throw` 引數。當禁用擲回 Exception 時，會回傳所有重試中用戶端收到的最後一個 Response："

#: docs/10.x/http-client.md:block 80 (code)
msgid "$response = Http::retry(3, 100, throw: false)->post(/* ... */);\n"
msgstr "$response = Http::retry(3, 100, throw: false)->post(/* ... */);\n"

#: docs/10.x/http-client.md:block 81 (quote)
msgid "**Warning** If all of the requests fail because of a connection issue, a `Illuminate\\Http\\Client\\ConnectionException` will still be thrown even when the `throw` argument is set to `false`."
msgstr "**Warning** 若所有的 Request 都因為連線問題而失敗，即使 `throw` 引數設為 `false`，還是會擲回 `Illuminate\\Http\\Client\\ConnectionException`。"

#: docs/10.x/http-client.md:block 83 (header)
msgid "Error Handling"
msgstr "錯誤處理"

#: docs/10.x/http-client.md:block 84 (paragraph)
msgid "Unlike Guzzle's default behavior, Laravel's HTTP client wrapper does not throw exceptions on client or server errors (`400` and `500` level responses from servers). You may determine if one of these errors was returned using the `successful`, `clientError`, or `serverError` methods:"
msgstr "與 Guzzle 預設的行為不同，Laravel 的 HTTP 用戶端在遇到用戶端錯誤或伺服器端錯誤時 (即，伺服器回傳 `4XX` 與 `5XX` 等級的錯誤)，不會擲回 Exception。我們可以使用 `successful`、`clientError`、`serverError` 等方法來判斷是否遇到這類錯誤："

#: docs/10.x/http-client.md:block 85 (code)
msgid "// Determine if the status code is >= 200 and < 300...\n"
"$response->successful();\n\n"
"// Determine if the status code is >= 400...\n"
"$response->failed();\n\n"
"// Determine if the response has a 400 level status code...\n"
"$response->clientError();\n\n"
"// Determine if the response has a 500 level status code...\n"
"$response->serverError();\n\n"
"// Immediately execute the given callback if there was a client or server error...\n"
"$response->onError(callable $callback);\n"
msgstr "// 判斷狀態碼是否 >= 200 且 < 300...\n"
"$response->successful();\n\n"
"// 判斷狀態碼是否 >= 400...\n"
"$response->failed();\n\n"
"// 判斷 Response 是否為 4XX 等級的狀態碼...\n"
"$response->clientError();\n\n"
"// 判斷 Response 是否為 5XX 等級的狀態碼...\n"
"$response->serverError();\n\n"
"// 若發生用戶端或伺服器段錯誤，馬上執行給定的回呼...\n"
"$response->onError(callable $callback);\n"

#: docs/10.x/http-client.md:block 87 (header)
msgid "Throwing Exceptions"
msgstr "擲回 Exception"

#: docs/10.x/http-client.md:block 88 (paragraph)
msgid "If you have a response instance and would like to throw an instance of `Illuminate\\Http\\Client\\RequestException` if the response status code indicates a client or server error, you may use the `throw` or `throwIf` methods:"
msgstr "假設有個 Response 實體，而我們想在該 Response 的狀態碼為伺服器端或用戶端錯誤時擲回 `Illuminate\\Http\\Client\\RequestException`，則可以使用 `throw` 或 `throwIf` 方法："

#: docs/10.x/http-client.md:block 89 (code)
msgid "use Illuminate\\Http\\Client\\Response;\n\n"
"$response = Http::post(/* ... */);\n\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n\n"
"// Throw an exception if an error occurred and the given closure resolves to true...\n"
"$response->throwIf(fn (Response $response) => true);\n\n"
"// Throw an exception if an error occurred and the given condition is false...\n"
"$response->throwUnless($condition);\n\n"
"// Throw an exception if an error occurred and the given closure resolves to false...\n"
"$response->throwUnless(fn (Response $response) => false);\n\n"
"// Throw an exception if the response has a specific status code...\n"
"$response->throwIfStatus(403);\n\n"
"// Throw an exception unless the response has a specific status code...\n"
"$response->throwUnlessStatus(200);\n\n"
"return $response['user']['id'];\n"
msgstr "use Illuminate\\Http\\Client\\Response;\n\n"
"$response = Http::post(/* ... */);\n\n"
"// 當發生 Client 端或 Server 端錯誤時擲回 Exception...\n"
"$response->throw();\n\n"
"// 當發生錯誤且給定條件為 true 時擲回 Exception...\n"
"$response->throwIf($condition);\n\n"
"// 當發生錯誤且給定閉包解析為 true 時擲回 Exception...\n"
"$response->throwIf(fn (Response $response) => true);\n\n"
"// 當發生錯誤且給定條件為 false 時擲回 Exception...\n"
"$response->throwUnless($condition);\n\n"
"// 當發生錯誤且給定閉包解析為 false 時擲回 Exception...\n"
"$response->throwUnless(fn (Response $response) => false);\n\n"
"// 當 Response 會特定狀態碼時擲回 Exception...\n"
"$response->throwIfStatus(403);\n\n"
"// 除非 Response 為特定狀態碼，否則擲回 Exception...\n"
"$response->throwUnlessStatus(200);\n\n"
"return $response['user']['id'];\n"

#: docs/10.x/http-client.md:block 90 (paragraph)
msgid "The `Illuminate\\Http\\Client\\RequestException` instance has a public `$response` property which will allow you to inspect the returned response."
msgstr "`Illuminate\\Http\\Client\\RequestException` 實體有個 `$response` 公用屬性，我們可以使用該屬性來取得回傳的 Response。"

#: docs/10.x/http-client.md:block 91 (paragraph)
msgid "The `throw` method returns the response instance if no error occurred, allowing you to chain other operations onto the `throw` method:"
msgstr "如果沒有發生錯誤，`throw` 方法會回傳 Response 實體，能讓我們在 `throw` 方法後繼續串上其他操作："

#: docs/10.x/http-client.md:block 92 (code)
msgid "return Http::post(/* ... */)->throw()->json();\n"
msgstr "return Http::post(/* ... */)->throw()->json();\n"

#: docs/10.x/http-client.md:block 93 (paragraph)
msgid "If you would like to perform some additional logic before the exception is thrown, you may pass a closure to the `throw` method. The exception will be thrown automatically after the closure is invoked, so you do not need to re-throw the exception from within the closure:"
msgstr "若想在 Exception 被擲回前加上其他額外的邏輯，可傳入一個閉包給 `throw` 方法。叫用閉包後，就會自動擲回 Exception，因此我們不需要在閉包內重新擲回 Exception："

#: docs/10.x/http-client.md:block 94 (code)
msgid "use Illuminate\\Http\\Client\\Response;\n"
"use Illuminate\\Http\\Client\\RequestException;\n\n"
"return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) {\n"
"    // ...\n"
"})->json();\n"
msgstr "use Illuminate\\Http\\Client\\Response;\n"
"use Illuminate\\Http\\Client\\RequestException;\n\n"
"return Http::post(/* ... */)->throw(function (Response $response, RequestException $e) {\n"
"    // ...\n"
"})->json();\n"

#: docs/10.x/http-client.md:block 96 (header)
msgid "Guzzle Middleware"
msgstr "Guzzle Middleware"

#: docs/10.x/http-client.md:block 97 (paragraph)
msgid "Since Laravel's HTTP client is powered by Guzzle, you may take advantage of [Guzzle Middleware](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html) to manipulate the outgoing request or inspect the incoming response. To manipulate the outgoing request, register a Guzzle middleware via the `withMiddleware` method in combination with Guzzle's `mapRequest` middleware factory:"
msgstr "由於 Laravel 的 HTTP 用戶端使用 Guzzle，因此我們也可以使用 [Guzzle 的 Middleware 功能](https://docs.guzzlephp.org/en/stable/handlers-and-middleware.html)來對修改連外 Request，或是檢查連入的 Response。若要修改連外的 Request，可使用 `withMiddleware` 方法來註冊 Guzzle Middleware，並搭配使用 Guzzle 的 `mapRequest` Middleware Factory："

#: docs/10.x/http-client.md:block 98 (code)
msgid "use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\RequestInterface;\n\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapRequest(function (RequestInterface $request) {\n"
"        $request = $request->withHeader('X-Example', 'Value');\n"
"        \n"
"        return $request;\n"
"    })\n"
")->get('http://example.com');\n"
msgstr "use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\RequestInterface;\n\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapRequest(function (RequestInterface $request) {\n"
"        $request = $request->withHeader('X-Example', 'Value');\n"
"        \n"
"        return $request;\n"
"    })\n"
")->get('http://example.com');\n"

#: docs/10.x/http-client.md:block 99 (paragraph)
msgid "Likewise, you can inspect the incoming HTTP response by registering a middleware via the `withMiddleware` method in combination with Guzzle's `mapResponse` middleware factory:"
msgstr "類似地，我們也可以將 `withMiddleware` 方法與 Guzzle 的 `mapResponse` Middleware Factory 搭配使用來註冊用於檢查連入 HTTP Request 的 Middleware："

#: docs/10.x/http-client.md:block 100 (code)
msgid "use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\ResponseInterface;\n\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapResponse(function (ResponseInterface $response) {\n"
"        $header = $response->getHeader('X-Example');\n\n"
"        // ...\n"
"        \n"
"        return $response;\n"
"    })\n"
")->get('http://example.com');\n"
msgstr "use GuzzleHttp\\Middleware;\n"
"use Illuminate\\Support\\Facades\\Http;\n"
"use Psr\\Http\\Message\\ResponseInterface;\n\n"
"$response = Http::withMiddleware(\n"
"    Middleware::mapResponse(function (ResponseInterface $response) {\n"
"        $header = $response->getHeader('X-Example');\n\n"
"        // ...\n"
"        \n"
"        return $response;\n"
"    })\n"
")->get('http://example.com');\n"

#: docs/10.x/http-client.md:block 102 (header)
msgid "Guzzle Options"
msgstr "Guzzle 選項"

#: docs/10.x/http-client.md:block 103 (paragraph)
msgid "You may specify additional [Guzzle request options](http://docs.guzzlephp.org/en/stable/request-options.html) using the `withOptions` method. The `withOptions` method accepts an array of key / value pairs:"
msgstr "我們可以使用 `withOptions` 方法來指定額外的 [Guzzle Request 選項](http://docs.guzzlephp.org/en/stable/request-options.html)。`withOptions` 方法接受一組索引鍵 / 值配對的陣列："

#: docs/10.x/http-client.md:block 104 (code)
msgid "$response = Http::withOptions([\n"
"    'debug' => true,\n"
"])->get('http://example.com/users');\n"
msgstr "$response = Http::withOptions([\n"
"    'debug' => true,\n"
"])->get('http://example.com/users');\n"

#: docs/10.x/http-client.md:block 106 (header)
msgid "Concurrent Requests"
msgstr "同時進行的 Request"

#: docs/10.x/http-client.md:block 107 (paragraph)
msgid "Sometimes, you may wish to make multiple HTTP requests concurrently. In other words, you want several requests to be dispatched at the same time instead of issuing the requests sequentially. This can lead to substantial performance improvements when interacting with slow HTTP APIs."
msgstr "有時候，我們可能會想同時進行多個 HTTP Request。換句話說，不是依序執行 Request，而是同時分派多個 Request。同時執行多個 Request 的話，在處理速度慢的 HTTP API 時就可以大幅提升效能。"

#: docs/10.x/http-client.md:block 108 (paragraph)
msgid "Thankfully, you may accomplish this using the `pool` method. The `pool` method accepts a closure which receives an `Illuminate\\Http\\Client\\Pool` instance, allowing you to easily add requests to the request pool for dispatching:"
msgstr "所幸，我們只要使用 `pool` 方法就能達成。`pool` 方法接受一個閉包，該閉包會收到 `Illuminate\\Http\\Client\\Pool` 實體，能讓我們輕鬆地將 Request 加到 ^[Request Pool](請求集區) 以作分派："

#: docs/10.x/http-client.md:block 109 (code)
msgid "use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->get('http://localhost/first'),\n"
"    $pool->get('http://localhost/second'),\n"
"    $pool->get('http://localhost/third'),\n"
"]);\n\n"
"return $responses[0]->ok() &&\n"
"       $responses[1]->ok() &&\n"
"       $responses[2]->ok();\n"
msgstr "use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->get('http://localhost/first'),\n"
"    $pool->get('http://localhost/second'),\n"
"    $pool->get('http://localhost/third'),\n"
"]);\n\n"
"return $responses[0]->ok() &&\n"
"       $responses[1]->ok() &&\n"
"       $responses[2]->ok();\n"

#: docs/10.x/http-client.md:block 110 (paragraph)
msgid "As you can see, each response instance can be accessed based on the order it was added to the pool. If you wish, you can name the requests using the `as` method, which allows you to access the corresponding responses by name:"
msgstr "就像這樣，我們可以依據加入 Pool 的順序來存取每個 Response 實體。若有需要的話，也可以使用 `as` 方法來為 Request 命名，好讓我們能使用名稱來存取對應的 Response："

#: docs/10.x/http-client.md:block 111 (code)
msgid "use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->as('first')->get('http://localhost/first'),\n"
"    $pool->as('second')->get('http://localhost/second'),\n"
"    $pool->as('third')->get('http://localhost/third'),\n"
"]);\n\n"
"return $responses['first']->ok();\n"
msgstr "use Illuminate\\Http\\Client\\Pool;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"$responses = Http::pool(fn (Pool $pool) => [\n"
"    $pool->as('first')->get('http://localhost/first'),\n"
"    $pool->as('second')->get('http://localhost/second'),\n"
"    $pool->as('third')->get('http://localhost/third'),\n"
"]);\n\n"
"return $responses['first']->ok();\n"

#: docs/10.x/http-client.md:block 113 (header)
msgid "Macros"
msgstr "Macro"

#: docs/10.x/http-client.md:block 114 (paragraph)
msgid "The Laravel HTTP client allows you to define \"macros\", which can serve as a fluent, expressive mechanism to configure common request paths and headers when interacting with services throughout your application. To get started, you may define the macro within the `boot` method of your application's `App\\Providers\\AppServiceProvider` class:"
msgstr "Laravel HTTP 用戶端支援定義「^[Macro](巨集)」。通過 Macro，我們就能通過一些流暢且語義化的機制來在專案中為一些服務設定常用的 Request 路徑與標頭。若要開始使用 Macro，我們可以在專案的 `App\\Providers\\AppServiceProvider` 內 `boot` 方法中定義 Macro："

#: docs/10.x/http-client.md:block 115 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}\n"

#: docs/10.x/http-client.md:block 116 (paragraph)
msgid "Once your macro has been configured, you may invoke it from anywhere in your application to create a pending request with the specified configuration:"
msgstr "設定好 Macro 後，就可以在任何地方叫用這個 Macro，以使用指定的設定來建立 Request："

#: docs/10.x/http-client.md:block 117 (code)
msgid "$response = Http::github()->get('/');\n"
msgstr "$response = Http::github()->get('/');\n"

#: docs/10.x/http-client.md:block 119 (header)
msgid "Testing"
msgstr "測試"

#: docs/10.x/http-client.md:block 120 (paragraph)
msgid "Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's HTTP client is no exception. The `Http` facade's `fake` method allows you to instruct the HTTP client to return stubbed / dummy responses when requests are made."
msgstr "許多 Laravel 的服務都提供了能讓我們輕鬆撰寫測試的功能，而 Laravel 的 HTTP 用戶端也不例外。`Http` Facade 的 `fake` 方法能讓我們指定 HTTP 用戶端在建立 Request 後回傳一組虛擬的 Response。"

#: docs/10.x/http-client.md:block 122 (header)
msgid "Faking Responses"
msgstr "^[模擬](Fake) Response"

#: docs/10.x/http-client.md:block 123 (paragraph)
msgid "For example, to instruct the HTTP client to return empty, `200` status code responses for every request, you may call the `fake` method with no arguments:"
msgstr "舉例來說，若要讓 HTTP 用戶端為每個 Request 回傳 `200` 狀態碼的空 Response，可呼叫 `fake` 方法，然後不傳入任何引數："

#: docs/10.x/http-client.md:block 124 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"$response = Http::post(/* ... */);\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"$response = Http::post(/* ... */);\n"

#: docs/10.x/http-client.md:block 126 (header)
msgid "Faking Specific URLs"
msgstr "模擬執行 URL"

#: docs/10.x/http-client.md:block 127 (paragraph)
msgid "Alternatively, you may pass an array to the `fake` method. The array's keys should represent URL patterns that you wish to fake and their associated responses. The `*` character may be used as a wildcard character. Any requests made to URLs that have not been faked will actually be executed. You may use the `Http` facade's `response` method to construct stub / fake responses for these endpoints:"
msgstr "或者，我們也可以傳入一組陣列給 `fake` 方法。該陣列的索引鍵代表要模擬的 URL，對應的值則為 Response。可使用 `*` 字元來當作萬用字元。當 Request 的 URL 不在模擬列表內時，就會被實際執行。可以使用 `Http` Facade 的 `response` 方法來為這些^[Endpoint](端點)建立虛擬的 Response："

#: docs/10.x/http-client.md:block 128 (code)
msgid "Http::fake([\n"
"    // Stub a JSON response for GitHub endpoints...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),\n\n"
"    // Stub a string response for Google endpoints...\n"
"    'google.com/*' => Http::response('Hello World', 200, $headers),\n"
"]);\n"
msgstr "Http::fake([\n"
"    // 為 GitHub Endpoint 模擬一個 JSON Response...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, $headers),\n\n"
"    // 為 Google Endpoint 模擬一個字串的 Response...\n"
"    'google.com/*' => Http::response('Hello World', 200, $headers),\n"
"]);\n"

#: docs/10.x/http-client.md:block 129 (paragraph)
msgid "If you would like to specify a fallback URL pattern that will stub all unmatched URLs, you may use a single `*` character:"
msgstr "若想為所有不符合的 URL 建立一個遞補用 URL 規則，只要使用單一 `*` 字元即可："

#: docs/10.x/http-client.md:block 130 (code)
msgid "Http::fake([\n"
"    // Stub a JSON response for GitHub endpoints...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),\n\n"
"    // Stub a string response for all other endpoints...\n"
"    '*' => Http::response('Hello World', 200, ['Headers']),\n"
"]);\n"
msgstr "Http::fake([\n"
"    // 為 GitHub Endpoint 模擬一個 JSON Response...\n"
"    'github.com/*' => Http::response(['foo' => 'bar'], 200, ['Headers']),\n\n"
"    // 為所有其他的 Endpoint 模擬一個字串的 Response...\n"
"    '*' => Http::response('Hello World', 200, ['Headers']),\n"
"]);\n"

#: docs/10.x/http-client.md:block 132 (header)
msgid "Faking Response Sequences"
msgstr "模擬 Response 序列"

#: docs/10.x/http-client.md:block 133 (paragraph)
msgid "Sometimes you may need to specify that a single URL should return a series of fake responses in a specific order. You may accomplish this using the `Http::sequence` method to build the responses:"
msgstr "有時候我們需要讓單一 URL 以固定的順序回傳一系列模擬的 Response。我們可以使用 `Http::sequence`  方法來建立 Request："

#: docs/10.x/http-client.md:block 134 (code)
msgid "Http::fake([\n"
"    // Stub a series of responses for GitHub endpoints...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->pushStatus(404),\n"
"]);\n"
msgstr "Http::fake([\n"
"    // 為 GitHub Endpoint 模擬一系列的 Response...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->pushStatus(404),\n"
"]);\n"

#: docs/10.x/http-client.md:block 135 (paragraph)
msgid "When all the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception. If you would like to specify a default response that should be returned when a sequence is empty, you may use the `whenEmpty` method:"
msgstr "用完 Response 序列內的所有 Response 後，若之後又建立新的 Request，就會導致 Response 序列擲回 Exception。若想指定當序列為空時要回傳的預設 Response，可使用 `whenEmpty` 方法："

#: docs/10.x/http-client.md:block 136 (code)
msgid "Http::fake([\n"
"    // Stub a series of responses for GitHub endpoints...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->whenEmpty(Http::response()),\n"
"]);\n"
msgstr "Http::fake([\n"
"    // 為 GitHub Endpoint 模擬一系列的 Response...\n"
"    'github.com/*' => Http::sequence()\n"
"                            ->push('Hello World', 200)\n"
"                            ->push(['foo' => 'bar'], 200)\n"
"                            ->whenEmpty(Http::response()),\n"
"]);\n"

#: docs/10.x/http-client.md:block 137 (paragraph)
msgid "If you would like to fake a sequence of responses but do not need to specify a specific URL pattern that should be faked, you may use the `Http::fakeSequence` method:"
msgstr "若想模擬一系列的 Response，但又不想指定要模擬的特定 URL 格式，可使用 `Http::fakeSequence`  方法："

#: docs/10.x/http-client.md:block 138 (code)
msgid "Http::fakeSequence()\n"
"        ->push('Hello World', 200)\n"
"        ->whenEmpty(Http::response());\n"
msgstr "Http::fakeSequence()\n"
"        ->push('Hello World', 200)\n"
"        ->whenEmpty(Http::response());\n"

#: docs/10.x/http-client.md:block 140 (header)
msgid "Fake Callback"
msgstr "模擬回呼"

#: docs/10.x/http-client.md:block 141 (paragraph)
msgid "If you require more complicated logic to determine what responses to return for certain endpoints, you may pass a closure to the `fake` method. This closure will receive an instance of `Illuminate\\Http\\Client\\Request` and should return a response instance. Within your closure, you may perform whatever logic is necessary to determine what type of response to return:"
msgstr "若某些 Endpoint 需要使用比較複雜的邏輯來判斷要回傳什麼 Response 的話，可傳入一個閉包給 `fake` 方法。該閉包會收到一組 `Illuminate\\Http\\Client\\Request` 的實體，而該閉包必須回傳 Response 實體。在這個閉包內，我們就可以任意加上邏輯來判斷要回傳什麼類型的 Response："

#: docs/10.x/http-client.md:block 142 (code)
msgid "use Illuminate\\Http\\Client\\Request;\n\n"
"Http::fake(function (Request $request) {\n"
"    return Http::response('Hello World', 200);\n"
"});\n"
msgstr "use Illuminate\\Http\\Client\\Request;\n\n"
"Http::fake(function (Request $request) {\n"
"    return Http::response('Hello World', 200);\n"
"});\n"

#: docs/10.x/http-client.md:block 144 (header)
msgid "Preventing Stray Requests"
msgstr "避免漏掉的 Request"

#: docs/10.x/http-client.md:block 145 (paragraph)
msgid "If you would like to ensure that all requests sent via the HTTP client have been faked throughout your individual test or complete test suite, you can call the `preventStrayRequests` method. After calling this method, any requests that do not have a corresponding fake response will throw an exception rather than making the actual HTTP request:"
msgstr "若要確保在個別測試或整個測試套件中，所有使用 HTTP 用戶端的 Request 都有被 Fake 到，則可以使用 `preventStrayRequests` 方法。呼叫該方法後，若有任何找不到對應 Fake Response 的 Request，就不會產生實際的 HTTP Request，而會擲回 Exception："

#: docs/10.x/http-client.md:block 146 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::preventStrayRequests();\n\n"
"Http::fake([\n"
"    'github.com/*' => Http::response('ok'),\n"
"]);\n\n"
"// An \"ok\" response is returned...\n"
"Http::get('https://github.com/laravel/framework');\n\n"
"// An exception is thrown...\n"
"Http::get('https://laravel.com');\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::preventStrayRequests();\n\n"
"Http::fake([\n"
"    'github.com/*' => Http::response('ok'),\n"
"]);\n\n"
"// 回傳「ok」Response...\n"
"Http::get('https://github.com/laravel/framework');\n\n"
"// 擲回 Exception...\n"
"Http::get('https://laravel.com');\n"

#: docs/10.x/http-client.md:block 148 (header)
msgid "Inspecting Requests"
msgstr "檢查 Request"

#: docs/10.x/http-client.md:block 149 (paragraph)
msgid "When faking responses, you may occasionally wish to inspect the requests the client receives in order to make sure your application is sending the correct data or headers. You may accomplish this by calling the `Http::assertSent` method after calling `Http::fake`."
msgstr "在模擬 Response 時，有時候我們會需要檢查用戶端收到的 Request，以確保程式有傳送正確的資料。可以在呼叫 `Http::fake` 之前先呼叫 `Http::assertSent` 方法來檢查。"

#: docs/10.x/http-client.md:block 150 (paragraph)
msgid "The `assertSent` method accepts a closure which will receive an `Illuminate\\Http\\Client\\Request` instance and should return a boolean value indicating if the request matches your expectations. In order for the test to pass, at least one request must have been issued matching the given expectations:"
msgstr "`assertSent` 方法接受一組閉包，該閉包會收到 `Illuminate\\Http\\Client\\Request` 的實體，而該閉包應回傳用來表示 Request 是否符合預期的布林值。若要讓測試通過，提供的 Request 中就必須至少有一個是符合給定預期條件的："

#: docs/10.x/http-client.md:block 151 (code)
msgid "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n\n"
"Http::assertSent(function (Request $request) {\n"
"    return $request->hasHeader('X-First', 'foo') &&\n"
"           $request->url() == 'http://example.com/users' &&\n"
"           $request['name'] == 'Taylor' &&\n"
"           $request['role'] == 'Developer';\n"
"});\n"
msgstr "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"Http::withHeaders([\n"
"    'X-First' => 'foo',\n"
"])->post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n\n"
"Http::assertSent(function (Request $request) {\n"
"    return $request->hasHeader('X-First', 'foo') &&\n"
"           $request->url() == 'http://example.com/users' &&\n"
"           $request['name'] == 'Taylor' &&\n"
"           $request['role'] == 'Developer';\n"
"});\n"

#: docs/10.x/http-client.md:block 152 (paragraph)
msgid "If needed, you may assert that a specific request was not sent using the `assertNotSent` method:"
msgstr "若有需要，可以使用 `assertNotSent` 方法來判斷特定 Request 是否未被送出："

#: docs/10.x/http-client.md:block 153 (code)
msgid "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"Http::post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n\n"
"Http::assertNotSent(function (Request $request) {\n"
"    return $request->url() === 'http://example.com/posts';\n"
"});\n"
msgstr "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"Http::post('http://example.com/users', [\n"
"    'name' => 'Taylor',\n"
"    'role' => 'Developer',\n"
"]);\n\n"
"Http::assertNotSent(function (Request $request) {\n"
"    return $request->url() === 'http://example.com/posts';\n"
"});\n"

#: docs/10.x/http-client.md:block 154 (paragraph)
msgid "You may use the `assertSentCount` method to assert how many requests were \"sent\" during the test:"
msgstr "可以使用 `assertSentCount` 方法來判斷在測試時「送出」了多少個 Request："

#: docs/10.x/http-client.md:block 155 (code)
msgid "Http::fake();\n\n"
"Http::assertSentCount(5);\n"
msgstr "Http::fake();\n\n"
"Http::assertSentCount(5);\n"

#: docs/10.x/http-client.md:block 156 (paragraph)
msgid "Or, you may use the `assertNothingSent` method to assert that no requests were sent during the test:"
msgstr "或者，也可以使用 `assertNothingSent` 方法來判斷在測試時是否未送出任何 Request："

#: docs/10.x/http-client.md:block 157 (code)
msgid "Http::fake();\n\n"
"Http::assertNothingSent();\n"
msgstr "Http::fake();\n\n"
"Http::assertNothingSent();\n"

#: docs/10.x/http-client.md:block 159 (header)
msgid "Recording Requests / Responses"
msgstr "記錄 Request 或 Response"

#: docs/10.x/http-client.md:block 160 (paragraph)
msgid "You may use the `recorded` method to gather all requests and their corresponding responses. The `recorded` method returns a collection of arrays that contains instances of `Illuminate\\Http\\Client\\Request` and `Illuminate\\Http\\Client\\Response`:"
msgstr "可以使用 `recorded` 方法來取得所有的 Request 與其對應的 Response。`recorded` 方法會回傳一組陣列的 Collection，其內容為 `Illuminate\\Http\\Client\\Request` 與 `Illuminate\\Http\\Client\\Response` 的實體："

#: docs/10.x/http-client.md:block 161 (code)
msgid "Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n\n"
"$recorded = Http::recorded();\n\n"
"[$request, $response] = $recorded[0];\n"
msgstr "Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n\n"
"$recorded = Http::recorded();\n\n"
"[$request, $response] = $recorded[0];\n"

#: docs/10.x/http-client.md:block 162 (paragraph)
msgid "Additionally, the `recorded` method accepts a closure which will receive an instance of `Illuminate\\Http\\Client\\Request` and `Illuminate\\Http\\Client\\Response` and may be used to filter request / response pairs based on your expectations:"
msgstr "此外，也可傳入閉包給 `recorded` 方法，該閉包會收到 `Illuminate\\Http\\Client\\Request` 與 `Illuminate\\Http\\Client\\Response` 的實體。可以傳入閉包來依據需求過濾 Request／Response 配對："

#: docs/10.x/http-client.md:block 163 (code)
msgid "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Http\\Client\\Response;\n\n"
"Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n\n"
"$recorded = Http::recorded(function (Request $request, Response $response) {\n"
"    return $request->url() !== 'https://laravel.com' &&\n"
"           $response->successful();\n"
"});\n"
msgstr "use Illuminate\\Http\\Client\\Request;\n"
"use Illuminate\\Http\\Client\\Response;\n\n"
"Http::fake([\n"
"    'https://laravel.com' => Http::response(status: 500),\n"
"    'https://nova.laravel.com/' => Http::response(),\n"
"]);\n\n"
"Http::get('https://laravel.com');\n"
"Http::get('https://nova.laravel.com/');\n\n"
"$recorded = Http::recorded(function (Request $request, Response $response) {\n"
"    return $request->url() !== 'https://laravel.com' &&\n"
"           $response->successful();\n"
"});\n"

#: docs/10.x/http-client.md:block 165 (header)
msgid "Events"
msgstr "事件"

#: docs/10.x/http-client.md:block 166 (paragraph)
msgid "Laravel fires three events during the process of sending HTTP requests. The `RequestSending` event is fired prior to a request being sent, while the `ResponseReceived` event is fired after a response is received for a given request. The `ConnectionFailed` event is fired if no response is received for a given request."
msgstr "在傳送 HTTP Request 的過程中，Laravel 會觸發三個事件。在送出 Request 前會觸發 `RequestSending` 事件，而給定 Request 收到 Response 後會觸發 `ResponseReceived` 事件。若給定的 Request 未收到 Response，會觸發 `ConnectionFailed` 事件。"

#: docs/10.x/http-client.md:block 167 (paragraph)
msgid "The `RequestSending` and `ConnectionFailed` events both contain a public `$request` property that you may use to inspect the `Illuminate\\Http\\Client\\Request` instance. Likewise, the `ResponseReceived` event contains a `$request` property as well as a `$response` property which may be used to inspect the `Illuminate\\Http\\Client\\Response` instance. You may register event listeners for this event in your `App\\Providers\\EventServiceProvider` service provider:"
msgstr "`RequestSending` 與 `ConnectionFailed` 事件都有一個 `$request` 共用屬性，可以通過這個屬性來取得 `Illuminate\\Http\\Client\\Request` 實體。而 `ResponseReceived` 事件中也有一個 `$request` 公開屬性，以及一個可用來取得  `Illuminate\\Http\\Client\\Response` 實體的 `$response` 公開屬性。可以在 `App\\Providers\\EventServiceProvider` Service Provider 中為這些 Event 註冊 Listener："

#: docs/10.x/http-client.md:block 168 (code)
msgid "/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    'Illuminate\\Http\\Client\\Events\\RequestSending' => [\n"
"        'App\\Listeners\\LogRequestSending',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ResponseReceived' => [\n"
"        'App\\Listeners\\LogResponseReceived',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ConnectionFailed' => [\n"
"        'App\\Listeners\\LogConnectionFailed',\n"
"    ],\n"
"];\n"
msgstr "/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    'Illuminate\\Http\\Client\\Events\\RequestSending' => [\n"
"        'App\\Listeners\\LogRequestSending',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ResponseReceived' => [\n"
"        'App\\Listeners\\LogResponseReceived',\n"
"    ],\n"
"    'Illuminate\\Http\\Client\\Events\\ConnectionFailed' => [\n"
"        'App\\Listeners\\LogConnectionFailed',\n"
"    ],\n"
"];\n"

#: docs/8.x/http-client.md:block 13 (code)
msgid "$response->body() : string;\n"
"$response->json($key = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->ok() : bool;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->serverError() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"
msgstr "$response->body() : string;\n"
"$response->json($key = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->ok() : bool;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->serverError() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"

#: docs/8.x/http-client.md:block 53 (code)
msgid "// Basic authentication...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);\n\n"
"// Digest authentication...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);\n"
msgstr "// Basic 身份認證...\n"
"$response = Http::withBasicAuth('taylor@laravel.com', 'secret')->post(...);\n\n"
"// Digest 身份認證...\n"
"$response = Http::withDigestAuth('taylor@laravel.com', 'secret')->post(...);\n"

#: docs/8.x/http-client.md:block 57 (code)
msgid "$response = Http::withToken('token')->post(...);\n"
msgstr "$response = Http::withToken('token')->post(...);\n"

#: docs/8.x/http-client.md:block 61 (code)
msgid "$response = Http::timeout(3)->get(...);\n"
msgstr "$response = Http::timeout(3)->get(...);\n"

#: docs/8.x/http-client.md:block 65 (paragraph)
msgid "If you would like HTTP client to automatically retry the request if a client or server error occurs, you may use the `retry` method. The `retry` method accepts the maximum number of times the request should be attempted and the number of milliseconds that Laravel should wait in between attempts:"
msgstr "若想讓 HTTP 用戶端在發生用戶端錯誤或伺服器端錯誤時自動重試，可以使用 `retry` 方法。`retry` 方法接受該 Request 要重試的最大次數，以及每次重試間要等待多少毫秒："

#: docs/8.x/http-client.md:block 66 (code)
msgid "$response = Http::retry(3, 100)->post(...);\n"
msgstr "$response = Http::retry(3, 100)->post(...);\n"

#: docs/8.x/http-client.md:block 68 (code)
msgid "$response = Http::retry(3, 100, function ($exception) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(...);\n"
msgstr "$response = Http::retry(3, 100, function ($exception) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(...);\n"

#: docs/8.x/http-client.md:block 69 (paragraph)
msgid "If all of the requests fail, an instance of `Illuminate\\Http\\Client\\RequestException` will be thrown."
msgstr "若所有的 Request 都執行失敗，會擲回 `Illuminate\\Http\\Client\\RequestException` 實體。"

#: docs/8.x/http-client.md:block 77 (code)
msgid "$response = Http::post(...);\n\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n\n"
"return $response['user']['id'];\n"
msgstr "$response = Http::post(...);\n\n"
"// 若發生用戶端或伺服器端錯誤，擲回 Exception...\n"
"$response->throw();\n\n"
"// 若發生錯誤且給定條件為 True，擲回 Exception...\n"
"$response->throwIf($condition);\n\n"
"return $response['user']['id'];\n"

#: docs/8.x/http-client.md:block 80 (code)
msgid "return Http::post(...)->throw()->json();\n"
msgstr "return Http::post(...)->throw()->json();\n"

#: docs/8.x/http-client.md:block 82 (code)
msgid "return Http::post(...)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();\n"
msgstr "return Http::post(...)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();\n"

#: docs/8.x/http-client.md:block 97 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Http::macro('github', function () {\n"
"        return Http::withHeaders([\n"
"            'X-Example' => 'example',\n"
"        ])->baseUrl('https://github.com');\n"
"    });\n"
"}\n"

#: docs/8.x/http-client.md:block 102 (paragraph)
msgid "Many Laravel services provide functionality to help you easily and expressively write tests, and Laravel's HTTP wrapper is no exception. The `Http` facade's `fake` method allows you to instruct the HTTP client to return stubbed / dummy responses when requests are made."
msgstr "許多 Laravel 的服務都提供了能讓我們輕鬆撰寫測試的功能，而 Laravel 的 HTTP 包裝也不例外。`Http` Facade 的 `fake` 方法能讓我們指定 HTTP 用戶端在建立 Request 後回傳一組虛擬的 Response。"

#: docs/8.x/http-client.md:block 106 (code)
msgid "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"$response = Http::post(...);\n"
msgstr "use Illuminate\\Support\\Facades\\Http;\n\n"
"Http::fake();\n\n"
"$response = Http::post(...);\n"

#: docs/8.x/http-client.md:block 107 (quote)
msgid "{note} When faking requests, HTTP client middleware are not executed. You should define expectations for faked responses as if these middleware have run correctly."
msgstr "{note} 在建立模擬 Request 時，不會執行 HTTP 用戶端 Middleware。在為模擬 Request 定義 Expectation 時，請定義為這些 Middleware 都已正確執行的情況。"

#: docs/8.x/http-client.md:block 118 (paragraph)
msgid "When all of the responses in a response sequence have been consumed, any further requests will cause the response sequence to throw an exception. If you would like to specify a default response that should be returned when a sequence is empty, you may use the `whenEmpty` method:"
msgstr "用完 Response 序列內的所有 Response 後，接下來再建立 Request 就會導致 Response 系列擲回一個 Exception。若想指定當序列為空時要回傳的預設 Response，可使用 `whenEmpty` 方法："

#: docs/8.x/http-client.md:block 125 (code)
msgid "Http::fake(function ($request) {\n"
"    return Http::response('Hello World', 200);\n"
"});\n"
msgstr "Http::fake(function ($request) {\n"
"    return Http::response('Hello World', 200);\n"
"});\n"

#: docs/9.x/http-client.md:block 76 (code)
msgid "$response = Http::retry(3, 100, function ($exception, $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);\n"
msgstr "$response = Http::retry(3, 100, function ($exception, $request) {\n"
"    return $exception instanceof ConnectionException;\n"
"})->post(/* ... */);\n"

#: docs/9.x/http-client.md:block 78 (code)
msgid "$response = Http::withToken($this->getToken())->retry(2, 0, function ($exception, $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n\n"
"    $request->withToken($this->getNewToken());\n\n"
"    return true;\n"
"})->post(/* ... */);\n"
msgstr "$response = Http::withToken($this->getToken())->retry(2, 0, function ($exception, $request) {\n"
"    if (! $exception instanceof RequestException || $exception->response->status() !== 401) {\n"
"        return false;\n"
"    }\n\n"
"    $request->withToken($this->getNewToken());\n\n"
"    return true;\n"
"})->post(/* ... */);\n"

#: docs/9.x/http-client.md:block 89 (code)
msgid "$response = Http::post(/* ... */);\n\n"
"// Throw an exception if a client or server error occurred...\n"
"$response->throw();\n\n"
"// Throw an exception if an error occurred and the given condition is true...\n"
"$response->throwIf($condition);\n\n"
"// Throw an exception if an error occurred and the given closure resolves to true...\n"
"$response->throwIf(fn ($response) => true);\n\n"
"// Throw an exception if an error occurred and the given condition is false...\n"
"$response->throwUnless($condition);\n\n"
"// Throw an exception if an error occurred and the given closure resolves to false...\n"
"$response->throwUnless(fn ($response) => false);\n\n"
"// Throw an exception if the response has a specific status code...\n"
"$response->throwIfStatus(403);\n\n"
"// Throw an exception unless the response has a specific status code...\n"
"$response->throwUnlessStatus(200);\n\n"
"return $response['user']['id'];\n"
msgstr "$response = Http::post(/* ... */);\n\n"
"// 當發生 Client 端或 Server 端錯誤時擲回 Exception...\n"
"$response->throw();\n\n"
"// 當發生錯誤且給定條件為 true 時擲回 Exception...\n"
"$response->throwIf($condition);\n\n"
"// 當發生錯誤且給定閉包解析為 true 時擲回 Exception...\n"
"$response->throwIf(fn ($response) => true);\n\n"
"// 當發生錯誤且給定條件為 false 時擲回 Exception...\n"
"$response->throwUnless($condition);\n\n"
"// 當發生錯誤且給定閉包解析為 false 時擲回 Exception...\n"
"$response->throwUnless(fn ($response) => false);\n\n"
"// 當 Response 會特定狀態碼時擲回 Exception...\n"
"$response->throwIfStatus(403);\n\n"
"// 除非 Response 為特定狀態碼，否則擲回 Exception...\n"
"$response->throwUnlessStatus(200);\n\n"
"return $response['user']['id'];\n"

#: docs/9.x/http-client.md:block 94 (code)
msgid "return Http::post(/* ... */)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();\n"
msgstr "return Http::post(/* ... */)->throw(function ($response, $e) {\n"
"    //\n"
"})->json();\n"

#: docs/master/http-client.md:block 13 (code)
msgid "$response->body() : string;\n"
"$response->json($key = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->ok() : bool;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->notFound() : bool;\n"
"$response->serverError() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"
msgstr "$response->body() : string;\n"
"$response->json($key = null) : array|mixed;\n"
"$response->object() : object;\n"
"$response->collect($key = null) : Illuminate\\Support\\Collection;\n"
"$response->status() : int;\n"
"$response->ok() : bool;\n"
"$response->successful() : bool;\n"
"$response->redirect(): bool;\n"
"$response->failed() : bool;\n"
"$response->notFound() : bool;\n"
"$response->serverError() : bool;\n"
"$response->clientError() : bool;\n"
"$response->header($header) : string;\n"
"$response->headers() : array;\n"

