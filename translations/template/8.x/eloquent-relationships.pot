# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Taylor Otwell
# This file is distributed under the same license as the Laravel Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: Laravel Documentation VERSION\n"
"POT-Creation-Date: 2021-09-13 05:07+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: docs/8.x/eloquent-relationships.md:1
#, no-wrap
msgid "Eloquent: Relationships"
msgstr ""

#. type: Bullet: '- '
#: docs/8.x/eloquent-relationships.md:41
msgid "[Introduction](#introduction)"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:41
#, no-wrap
msgid ""
"- [Defining Relationships](#defining-relationships)\n"
"    - [One To One](#one-to-one)\n"
"    - [One To Many](#one-to-many)\n"
"    - [One To Many (Inverse) / Belongs To](#one-to-many-inverse)\n"
"    - [Has One Of Many](#has-one-of-many)\n"
"    - [Has One Through](#has-one-through)\n"
"    - [Has Many Through](#has-many-through)\n"
"- [Many To Many Relationships](#many-to-many)\n"
"    - [Retrieving Intermediate Table "
"Columns](#retrieving-intermediate-table-columns)\n"
"    - [Filtering Queries Via Intermediate Table "
"Columns](#filtering-queries-via-intermediate-table-columns)\n"
"    - [Defining Custom Intermediate Table "
"Models](#defining-custom-intermediate-table-models)\n"
"- [Polymorphic Relationships](#polymorphic-relationships)\n"
"    - [One To One](#one-to-one-polymorphic-relations)\n"
"    - [One To Many](#one-to-many-polymorphic-relations)\n"
"    - [One Of Many](#one-of-many-polymorphic-relations)\n"
"    - [Many To Many](#many-to-many-polymorphic-relations)\n"
"    - [Custom Polymorphic Types](#custom-polymorphic-types)\n"
"- [Dynamic Relationships](#dynamic-relationships)\n"
"- [Querying Relations](#querying-relations)\n"
"    - [Relationship Methods Vs. Dynamic "
"Properties](#relationship-methods-vs-dynamic-properties)\n"
"    - [Querying Relationship Existence](#querying-relationship-existence)\n"
"    - [Querying Relationship Absence](#querying-relationship-absence)\n"
"    - [Querying Morph To Relationships](#querying-morph-to-relationships)\n"
"- [Aggregating Related Models](#aggregating-related-models)\n"
"    - [Counting Related Models](#counting-related-models)\n"
"    - [Other Aggregate Functions](#other-aggregate-functions)\n"
"    - [Counting Related Models On Morph To "
"Relationships](#counting-related-models-on-morph-to-relationships)\n"
"- [Eager Loading](#eager-loading)\n"
"    - [Constraining Eager Loads](#constraining-eager-loads)\n"
"    - [Lazy Eager Loading](#lazy-eager-loading)\n"
"    - [Preventing Lazy Loading](#preventing-lazy-loading)\n"
"- [Inserting & Updating Related "
"Models](#inserting-and-updating-related-models)\n"
"    - [The `save` Method](#the-save-method)\n"
"    - [The `create` Method](#the-create-method)\n"
"    - [Belongs To Relationships](#updating-belongs-to-relationships)\n"
"    - [Many To Many Relationships](#updating-many-to-many-relationships)\n"
"- [Touching Parent Timestamps](#touching-parent-timestamps)\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:43
#, no-wrap
msgid "<a name=\"introduction\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:43
#, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:46
msgid ""
"Database tables are often related to one another. For example, a blog post "
"may have many comments or an order could be related to the user who placed "
"it. Eloquent makes managing and working with these relationships easy, and "
"supports a variety of common relationships:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:57
#, no-wrap
msgid ""
"<div class=\"content-list\" markdown=\"1\">\n"
"- [One To One](#one-to-one)\n"
"- [One To Many](#one-to-many)\n"
"- [Many To Many](#many-to-many)\n"
"- [Has One Through](#has-one-through)\n"
"- [Has Many Through](#has-many-through)\n"
"- [One To One (Polymorphic)](#one-to-one-polymorphic-relations)\n"
"- [One To Many (Polymorphic)](#one-to-many-polymorphic-relations)\n"
"- [Many To Many (Polymorphic)](#many-to-many-polymorphic-relations)\n"
"</div>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:59
#, no-wrap
msgid "<a name=\"defining-relationships\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:59
#, no-wrap
msgid "Defining Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:62
msgid ""
"Eloquent relationships are defined as methods on your Eloquent model "
"classes. Since relationships also serve as powerful [query "
"builders](/docs/{{version}}/queries), defining relationships as methods "
"provides powerful method chaining and querying capabilities. For example, we "
"may chain additional query constraints on this `posts` relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:64 docs/8.x/eloquent-relationships.md:1113
#, no-wrap
msgid "    $user->posts()->where('active', 1)->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:66
msgid ""
"But, before diving too deep into using relationships, let's learn how to "
"define each type of relationship supported by Eloquent."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:68
#, no-wrap
msgid "<a name=\"one-to-one\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:68
#, no-wrap
msgid "One To One"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:71
msgid ""
"A one-to-one relationship is a very basic type of database relationship. For "
"example, a `User` model might be associated with one `Phone` model. To "
"define this relationship, we will place a `phone` method on the `User` "
"model. The `phone` method should call the `hasOne` method and return its "
"result. The `hasOne` method is available to your model via the model's "
"`Illuminate\\Database\\Eloquent\\Model` base class:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:73 docs/8.x/eloquent-relationships.md:107 docs/8.x/eloquent-relationships.md:151 docs/8.x/eloquent-relationships.md:197 docs/8.x/eloquent-relationships.md:369 docs/8.x/eloquent-relationships.md:432 docs/8.x/eloquent-relationships.md:502 docs/8.x/eloquent-relationships.md:546 docs/8.x/eloquent-relationships.md:646 docs/8.x/eloquent-relationships.md:665 docs/8.x/eloquent-relationships.md:724 docs/8.x/eloquent-relationships.md:826 docs/8.x/eloquent-relationships.md:965 docs/8.x/eloquent-relationships.md:989 docs/8.x/eloquent-relationships.md:1090 docs/8.x/eloquent-relationships.md:1432 docs/8.x/eloquent-relationships.md:1496 docs/8.x/eloquent-relationships.md:1540 docs/8.x/eloquent-relationships.md:1650 docs/8.x/eloquent-relationships.md:1885
#, no-wrap
msgid "    <?php\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:75 docs/8.x/eloquent-relationships.md:109 docs/8.x/eloquent-relationships.md:153 docs/8.x/eloquent-relationships.md:199 docs/8.x/eloquent-relationships.md:371 docs/8.x/eloquent-relationships.md:434 docs/8.x/eloquent-relationships.md:504 docs/8.x/eloquent-relationships.md:548 docs/8.x/eloquent-relationships.md:648 docs/8.x/eloquent-relationships.md:667 docs/8.x/eloquent-relationships.md:726 docs/8.x/eloquent-relationships.md:828 docs/8.x/eloquent-relationships.md:967 docs/8.x/eloquent-relationships.md:991 docs/8.x/eloquent-relationships.md:1092 docs/8.x/eloquent-relationships.md:1434 docs/8.x/eloquent-relationships.md:1542 docs/8.x/eloquent-relationships.md:1887
#, no-wrap
msgid "    namespace App\\Models;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:77 docs/8.x/eloquent-relationships.md:111 docs/8.x/eloquent-relationships.md:155 docs/8.x/eloquent-relationships.md:201 docs/8.x/eloquent-relationships.md:373 docs/8.x/eloquent-relationships.md:436 docs/8.x/eloquent-relationships.md:506 docs/8.x/eloquent-relationships.md:550 docs/8.x/eloquent-relationships.md:650 docs/8.x/eloquent-relationships.md:728 docs/8.x/eloquent-relationships.md:830 docs/8.x/eloquent-relationships.md:969 docs/8.x/eloquent-relationships.md:993 docs/8.x/eloquent-relationships.md:1094 docs/8.x/eloquent-relationships.md:1436 docs/8.x/eloquent-relationships.md:1498 docs/8.x/eloquent-relationships.md:1544 docs/8.x/eloquent-relationships.md:1652 docs/8.x/eloquent-relationships.md:1889
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Model;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:88
#, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the phone associated with the user.\n"
"         */\n"
"        public function phone()\n"
"        {\n"
"            return $this->hasOne(Phone::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:90
msgid ""
"The first argument passed to the `hasOne` method is the name of the related "
"model class. Once the relationship is defined, we may retrieve the related "
"record using Eloquent's dynamic properties. Dynamic properties allow you to "
"access relationship methods as if they were properties defined on the model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:92
#, no-wrap
msgid "    $phone = User::find(1)->phone;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:94
msgid ""
"Eloquent determines the foreign key of the relationship based on the parent "
"model name. In this case, the `Phone` model is automatically assumed to have "
"a `user_id` foreign key. If you wish to override this convention, you may "
"pass a second argument to the `hasOne` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:96
#, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:98
msgid ""
"Additionally, Eloquent assumes that the foreign key should have a value "
"matching the primary key column of the parent. In other words, Eloquent will "
"look for the value of the user's `id` column in the `user_id` column of the "
"`Phone` record. If you would like the relationship to use a primary key "
"value other than `id` or your model's `$primaryKey` property, you may pass a "
"third argument to the `hasOne` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:100
#, no-wrap
msgid "    return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:102
#, no-wrap
msgid "<a name=\"one-to-one-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:102 docs/8.x/eloquent-relationships.md:541 docs/8.x/eloquent-relationships.md:982
#, no-wrap
msgid "Defining The Inverse Of The Relationship"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:105
msgid ""
"So, we can access the `Phone` model from our `User` model. Next, let's "
"define a relationship on the `Phone` model that will let us access the user "
"that owns the phone. We can define the inverse of a `hasOne` relationship "
"using the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:122
#, no-wrap
msgid ""
"    class Phone extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user that owns the phone.\n"
"         */\n"
"        public function user()\n"
"        {\n"
"            return $this->belongsTo(User::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:124
msgid ""
"When invoking the `user` method, Eloquent will attempt to find a `User` "
"model that has an `id` which matches the `user_id` column on the `Phone` "
"model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:126
msgid ""
"Eloquent determines the foreign key name by examining the name of the "
"relationship method and suffixing the method name with `_id`. So, in this "
"case, Eloquent assumes that the `Phone` model has a `user_id` "
"column. However, if the foreign key on the `Phone` model is not `user_id`, "
"you may pass a custom key name as the second argument to the `belongsTo` "
"method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:134
#, no-wrap
msgid ""
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:136
msgid ""
"If the parent model does not use `id` as its primary key, or you wish to "
"find the associated model using a different column, you may pass a third "
"argument to the `belongsTo` method specifying the parent table's custom key:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:144
#, no-wrap
msgid ""
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:146
#, no-wrap
msgid "<a name=\"one-to-many\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:146
#, no-wrap
msgid "One To Many"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:149
msgid ""
"A one-to-many relationship is used to define relationships where a single "
"model is the parent to one or more child models. For example, a blog post "
"may have an infinite number of comments. Like all other Eloquent "
"relationships, one-to-many relationships are defined by defining a method on "
"your Eloquent model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:166
#, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the comments for the blog post.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->hasMany(Comment::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:168
msgid ""
"Remember, Eloquent will automatically determine the proper foreign key "
"column for the `Comment` model. By convention, Eloquent will take the "
"\"snake case\" name of the parent model and suffix it with `_id`. So, in "
"this example, Eloquent will assume the foreign key column on the `Comment` "
"model is `post_id`."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:170
msgid ""
"Once the relationship method has been defined, we can access the "
"[collection](/docs/{{version}}/eloquent-collections) of related comments by "
"accessing the `comments` property. Remember, since Eloquent provides "
"\"dynamic relationship properties\", we can access relationship methods as "
"if they were defined as properties on the model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:172 docs/8.x/eloquent-relationships.md:768 docs/8.x/eloquent-relationships.md:870 docs/8.x/eloquent-relationships.md:1019 docs/8.x/eloquent-relationships.md:1174 docs/8.x/eloquent-relationships.md:1210 docs/8.x/eloquent-relationships.md:1225 docs/8.x/eloquent-relationships.md:1306 docs/8.x/eloquent-relationships.md:1368 docs/8.x/eloquent-relationships.md:1764
#, no-wrap
msgid "    use App\\Models\\Post;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:174
#, no-wrap
msgid "    $comments = Post::find(1)->comments;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:178
#, no-wrap
msgid ""
"    foreach ($comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:180
msgid ""
"Since all relationships also serve as query builders, you may add further "
"constraints to the relationship query by calling the `comments` method and "
"continuing to chain conditions onto the query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:184
#, no-wrap
msgid ""
"    $comment = Post::find(1)->comments()\n"
"                        ->where('title', 'foo')\n"
"                        ->first();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:186
msgid ""
"Like the `hasOne` method, you may also override the foreign and local keys "
"by passing additional arguments to the `hasMany` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:188
#, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:190
#, no-wrap
msgid "    return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:192
#, no-wrap
msgid "<a name=\"one-to-many-inverse\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:192
#, no-wrap
msgid "One To Many (Inverse) / Belongs To"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:195
msgid ""
"Now that we can access all of a post's comments, let's define a relationship "
"to allow a comment to access its parent post. To define the inverse of a "
"`hasMany` relationship, define a relationship method on the child model "
"which calls the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:212
#, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post that owns the comment.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:214
msgid ""
"Once the relationship has been defined, we can retrieve a comment's parent "
"post by accessing the `post` \"dynamic relationship property\":"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:216 docs/8.x/eloquent-relationships.md:880
#, no-wrap
msgid "    use App\\Models\\Comment;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:218 docs/8.x/eloquent-relationships.md:882
#, no-wrap
msgid "    $comment = Comment::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:220
#, no-wrap
msgid "    return $comment->post->title;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:222
msgid ""
"In the example above, Eloquent will attempt to find a `Post` model that has "
"an `id` which matches the `post_id` column on the `Comment` model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:224
msgid ""
"Eloquent determines the default foreign key name by examining the name of "
"the relationship method and suffixing the method name with a `_` followed by "
"the name of the parent model's primary key column. So, in this example, "
"Eloquent will assume the `Post` model's foreign key on the `comments` table "
"is `post_id`."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:226
msgid ""
"However, if the foreign key for your relationship does not follow these "
"conventions, you may pass a custom foreign key name as the second argument "
"to the `belongsTo` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:234
#, no-wrap
msgid ""
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:236
msgid ""
"If your parent model does not use `id` as its primary key, or you wish to "
"find the associated model using a different column, you may pass a third "
"argument to the `belongsTo` method specifying your parent table's custom "
"key:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:244
#, no-wrap
msgid ""
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:246
#, no-wrap
msgid "<a name=\"default-models\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:246
#, no-wrap
msgid "Default Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:249
msgid ""
"The `belongsTo`, `hasOne`, `hasOneThrough`, and `morphOne` relationships "
"allow you to define a default model that will be returned if the given "
"relationship is `null`. This pattern is often referred to as the [Null "
"Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern) and can "
"help remove conditional checks in your code. In the following example, the "
"`user` relation will return an empty `App\\Models\\User` model if no user is "
"attached to the `Post` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:257
#, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault();\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:259
msgid ""
"To populate the default model with attributes, you may pass an array or "
"closure to the `withDefault` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:269
#, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault([\n"
"            'name' => 'Guest Author',\n"
"        ]);\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:279
#, no-wrap
msgid ""
"    /**\n"
"     * Get the author of the post.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class)->withDefault(function ($user, "
"$post) {\n"
"            $user->name = 'Guest Author';\n"
"        });\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:281
#, no-wrap
msgid "<a name=\"has-one-of-many\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:281
#, no-wrap
msgid "Has One Of Many"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:284
msgid ""
"Sometimes a model may have many related models, yet you want to easily "
"retrieve the \"latest\" or \"oldest\" related model of the relationship. For "
"example, a `User` model may be related to many `Order` models, but you want "
"to define a convenient way to interact with the most recent order the user "
"has placed. You may accomplish this using the `hasOne` relationship type "
"combined with the `ofMany` methods:"
msgstr ""

#. type: Code fence info string
#: docs/8.x/eloquent-relationships.md:285 docs/8.x/eloquent-relationships.md:297 docs/8.x/eloquent-relationships.md:311 docs/8.x/eloquent-relationships.md:330 docs/8.x/eloquent-relationships.md:892 docs/8.x/eloquent-relationships.md:904 docs/8.x/eloquent-relationships.md:918 docs/8.x/eloquent-relationships.md:1683 docs/8.x/eloquent-relationships.md:1701
#, no-wrap
msgid "php"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:285
#, no-wrap
msgid ""
"/**\n"
" * Get the user's most recent order.\n"
" */\n"
"public function latestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->latestOfMany();\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:296 docs/8.x/eloquent-relationships.md:903
msgid ""
"Likewise, you may define a method to retrieve the \"oldest\", or first, "
"related model of a relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:297
#, no-wrap
msgid ""
"/**\n"
" * Get the user's oldest order.\n"
" */\n"
"public function oldestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->oldestOfMany();\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:308 docs/8.x/eloquent-relationships.md:915
msgid ""
"By default, the `latestOfMany` and `oldestOfMany` methods will retrieve the "
"latest or oldest related model based on the model's primary key, which must "
"be sortable. However, sometimes you may wish to retrieve a single model from "
"a larger relationship using a different sorting criteria."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:310
msgid ""
"For example, using the `ofMany` method, you may retrieve the user's most "
"expensive order. The `ofMany` method accepts the sortable column as its "
"first argument and which aggregate function (`min` or `max`) to apply when "
"querying for the related model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:311
#, no-wrap
msgid ""
"/**\n"
" * Get the user's largest order.\n"
" */\n"
"public function largestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->ofMany('price', 'max');\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:322
#, no-wrap
msgid ""
"> {note} Because PostgreSQL does not support executing the `MAX` function "
"against UUID columns, it is not currently possible to use one-of-many "
"relationships in combination with PostgreSQL UUID columns.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:324
#, no-wrap
msgid "<a name=\"advanced-has-one-of-many-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:324
#, no-wrap
msgid "Advanced Has One Of Many Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:327
msgid ""
"It is possible to construct more advanced \"has one of many\" "
"relationships. For example, A `Product` model may have many associated "
"`Price` models that are retained in the system even after new pricing is "
"published. In addition, new pricing data for the product may be able to be "
"published in advance to take effect at a future date via a `published_at` "
"column."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:329
msgid ""
"So, in summary, we need to retrieve the latest published pricing where the "
"published date is not in the future. In addition, if two prices have the "
"same published date, we will prefer the price with the greatest ID. To "
"accomplish this, we must pass an array to the `ofMany` method that contains "
"the sortable columns which determine the latest price. In addition, a "
"closure will be provided as the second argument to the `ofMany` method. This "
"closure will be responsible for adding additional publish date constraints "
"to the relationship query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:330
#, no-wrap
msgid ""
"/**\n"
" * Get the current pricing for the product.\n"
" */\n"
"public function currentPricing()\n"
"{\n"
"    return $this->hasOne(Price::class)->ofMany([\n"
"        'published_at' => 'max',\n"
"        'id' => 'max',\n"
"    ], function ($query) {\n"
"        $query->where('published_at', '<', now());\n"
"    });\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:346
#, no-wrap
msgid "<a name=\"has-one-through\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:346
#, no-wrap
msgid "Has One Through"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:349
msgid ""
"The \"has-one-through\" relationship defines a one-to-one relationship with "
"another model. However, this relationship indicates that the declaring model "
"can be matched with one instance of another model by proceeding _through_ a "
"third model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:351
msgid ""
"For example, in a vehicle repair shop application, each `Mechanic` model may "
"be associated with one `Car` model, and each `Car` model may be associated "
"with one `Owner` model. While the mechanic and the owner have no direct "
"relationship within the database, the mechanic can access the owner "
"_through_ the `Car` model. Let's look at the tables necessary to define this "
"relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:355
#, no-wrap
msgid ""
"    mechanics\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:360
#, no-wrap
msgid ""
"    cars\n"
"        id - integer\n"
"        model - string\n"
"        mechanic_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:365
#, no-wrap
msgid ""
"    owners\n"
"        id - integer\n"
"        name - string\n"
"        car_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:367
msgid ""
"Now that we have examined the table structure for the relationship, let's "
"define the relationship on the `Mechanic` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:384
#, no-wrap
msgid ""
"    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(Owner::class, Car::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:386
msgid ""
"The first argument passed to the `hasOneThrough` method is the name of the "
"final model we wish to access, while the second argument is the name of the "
"intermediate model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:388
#, no-wrap
msgid "<a name=\"has-one-through-key-conventions\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:388 docs/8.x/eloquent-relationships.md:453 docs/8.x/eloquent-relationships.md:784
#, no-wrap
msgid "Key Conventions"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:391
msgid ""
"Typical Eloquent foreign key conventions will be used when performing the "
"relationship's queries. If you would like to customize the keys of the "
"relationship, you may pass them as the third and fourth arguments to the "
"`hasOneThrough` method. The third argument is the name of the foreign key on "
"the intermediate model. The fourth argument is the name of the foreign key "
"on the final model. The fifth argument is the local key, while the sixth "
"argument is the local key of the intermediate model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:409
#, no-wrap
msgid ""
"    class Mechanic extends Model\n"
"    {\n"
"        /**\n"
"         * Get the car's owner.\n"
"         */\n"
"        public function carOwner()\n"
"        {\n"
"            return $this->hasOneThrough(\n"
"                Owner::class,\n"
"                Car::class,\n"
"                'mechanic_id', // Foreign key on the cars table...\n"
"                'car_id', // Foreign key on the owners table...\n"
"                'id', // Local key on the mechanics table...\n"
"                'id' // Local key on the cars table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:411
#, no-wrap
msgid "<a name=\"has-many-through\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:411
#, no-wrap
msgid "Has Many Through"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:414
msgid ""
"The \"has-many-through\" relationship provides a convenient way to access "
"distant relations via an intermediate relation. For example, let's assume we "
"are building a deployment platform like [Laravel "
"Vapor](https://vapor.laravel.com). A `Project` model might access many "
"`Deployment` models through an intermediate `Environment` model. Using this "
"example, you could easily gather all deployments for a given project. Let's "
"look at the tables required to define this relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:418
#, no-wrap
msgid ""
"    projects\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:423
#, no-wrap
msgid ""
"    environments\n"
"        id - integer\n"
"        project_id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:428
#, no-wrap
msgid ""
"    deployments\n"
"        id - integer\n"
"        environment_id - integer\n"
"        commit_hash - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:430
msgid ""
"Now that we have examined the table structure for the relationship, let's "
"define the relationship on the `Project` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:447
#, no-wrap
msgid ""
"    class Project extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the deployments for the project.\n"
"         */\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(Deployment::class, "
"Environment::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:449
msgid ""
"The first argument passed to the `hasManyThrough` method is the name of the "
"final model we wish to access, while the second argument is the name of the "
"intermediate model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:451
#, no-wrap
msgid ""
"Though the `Deployment` model's table does not contain a `project_id` "
"column, the `hasManyThrough` relation provides access to a project's "
"deployments via `$project->deployments`. To retrieve these models, Eloquent "
"inspects the `project_id` column on the intermediate `Environment` model's "
"table. After finding the relevant environment IDs, they are used to query "
"the `Deployment` model's table.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:453
#, no-wrap
msgid "<a name=\"has-many-through-key-conventions\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:456
msgid ""
"Typical Eloquent foreign key conventions will be used when performing the "
"relationship's queries. If you would like to customize the keys of the "
"relationship, you may pass them as the third and fourth arguments to the "
"`hasManyThrough` method. The third argument is the name of the foreign key "
"on the intermediate model. The fourth argument is the name of the foreign "
"key on the final model. The fifth argument is the local key, while the sixth "
"argument is the local key of the intermediate model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:471
#, no-wrap
msgid ""
"    class Project extends Model\n"
"    {\n"
"        public function deployments()\n"
"        {\n"
"            return $this->hasManyThrough(\n"
"                Deployment::class,\n"
"                Environment::class,\n"
"                'project_id', // Foreign key on the environments table...\n"
"                'environment_id', // Foreign key on the deployments "
"table...\n"
"                'id', // Local key on the projects table...\n"
"                'id' // Local key on the environments table...\n"
"            );\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:473
#, no-wrap
msgid "<a name=\"many-to-many\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:473 docs/8.x/eloquent-relationships.md:1804
#, no-wrap
msgid "Many To Many Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:476
msgid ""
"Many-to-many relations are slightly more complicated than `hasOne` and "
"`hasMany` relationships. An example of a many-to-many relationship is a user "
"that has many roles and those roles are also shared by other users in the "
"application. For example, a user may be assigned the role of \"Author\" and "
"\"Editor\"; however, those roles may also be assigned to other users as "
"well. So, a user has many roles and a role has many users."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:478
#, no-wrap
msgid "<a name=\"many-to-many-table-structure\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:478 docs/8.x/eloquent-relationships.md:698 docs/8.x/eloquent-relationships.md:800 docs/8.x/eloquent-relationships.md:934
#, no-wrap
msgid "Table Structure"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:481
msgid ""
"To define this relationship, three database tables are needed: `users`, "
"`roles`, and `role_user`. The `role_user` table is derived from the "
"alphabetical order of the related model names and contains `user_id` and "
"`role_id` columns. This table is used as an intermediate table linking the "
"users and roles."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:483
msgid ""
"Remember, since a role can belong to many users, we cannot simply place a "
"`user_id` column on the `roles` table. This would mean that a role could "
"only belong to a single user. In order to provide support for roles being "
"assigned to multiple users, the `role_user` table is needed. We can "
"summarize the relationship's table structure like so:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:487 docs/8.x/eloquent-relationships.md:709
#, no-wrap
msgid ""
"    users\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:491
#, no-wrap
msgid ""
"    roles\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:495
#, no-wrap
msgid ""
"    role_user\n"
"        user_id - integer\n"
"        role_id - integer\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:497
#, no-wrap
msgid "<a name=\"many-to-many-model-structure\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:497 docs/8.x/eloquent-relationships.md:719 docs/8.x/eloquent-relationships.md:821 docs/8.x/eloquent-relationships.md:958
#, no-wrap
msgid "Model Structure"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:500
msgid ""
"Many-to-many relationships are defined by writing a method that returns the "
"result of the `belongsToMany` method. The `belongsToMany` method is provided "
"by the `Illuminate\\Database\\Eloquent\\Model` base class that is used by "
"all of your application's Eloquent models. For example, let's define a "
"`roles` method on our `User` model. The first argument passed to this method "
"is the name of the related model class:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:517
#, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * The roles that belong to the user.\n"
"         */\n"
"        public function roles()\n"
"        {\n"
"            return $this->belongsToMany(Role::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:519
msgid ""
"Once the relationship is defined, you may access the user's roles using the "
"`roles` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:521 docs/8.x/eloquent-relationships.md:570 docs/8.x/eloquent-relationships.md:1109 docs/8.x/eloquent-relationships.md:1159 docs/8.x/eloquent-relationships.md:1585 docs/8.x/eloquent-relationships.md:1812
#, no-wrap
msgid "    use App\\Models\\User;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:523 docs/8.x/eloquent-relationships.md:572 docs/8.x/eloquent-relationships.md:1111 docs/8.x/eloquent-relationships.md:1161 docs/8.x/eloquent-relationships.md:1814 docs/8.x/eloquent-relationships.md:1832 docs/8.x/eloquent-relationships.md:1872
#, no-wrap
msgid "    $user = User::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:527
#, no-wrap
msgid ""
"    foreach ($user->roles as $role) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:529
msgid ""
"Since all relationships also serve as query builders, you may add further "
"constraints to the relationship query by calling the `roles` method and "
"continuing to chain conditions onto the query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:531
#, no-wrap
msgid "    $roles = User::find(1)->roles()->orderBy('name')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:533
msgid ""
"To determine the table name of the relationship's intermediate table, "
"Eloquent will join the two related model names in alphabetical "
"order. However, you are free to override this convention. You may do so by "
"passing a second argument to the `belongsToMany` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:535
#, no-wrap
msgid "    return $this->belongsToMany(Role::class, 'role_user');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:537
msgid ""
"In addition to customizing the name of the intermediate table, you may also "
"customize the column names of the keys on the table by passing additional "
"arguments to the `belongsToMany` method. The third argument is the foreign "
"key name of the model on which you are defining the relationship, while the "
"fourth argument is the foreign key name of the model that you are joining "
"to:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:539
#, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class, 'role_user', 'user_id', "
"'role_id');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:541
#, no-wrap
msgid "<a name=\"many-to-many-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:544
msgid ""
"To define the \"inverse\" of a many-to-many relationship, you should define "
"a method on the related model which also returns the result of the "
"`belongsToMany` method. To complete our user / role example, let's define "
"the `users` method on the `Role` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:561
#, no-wrap
msgid ""
"    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return $this->belongsToMany(User::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:563
msgid ""
"As you can see, the relationship is defined exactly the same as its `User` "
"model counterpart with the exception of referencing the `App\\Models\\User` "
"model. Since we're reusing the `belongsToMany` method, all of the usual "
"table and key customization options are available when defining the "
"\"inverse\" of many-to-many relationships."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:565
#, no-wrap
msgid "<a name=\"retrieving-intermediate-table-columns\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:565
#, no-wrap
msgid "Retrieving Intermediate Table Columns"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:568
msgid ""
"As you have already learned, working with many-to-many relations requires "
"the presence of an intermediate table. Eloquent provides some very helpful "
"ways of interacting with this table. For example, let's assume our `User` "
"model has many `Role` models that it is related to. After accessing this "
"relationship, we may access the intermediate table using the `pivot` "
"attribute on the models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:576
#, no-wrap
msgid ""
"    foreach ($user->roles as $role) {\n"
"        echo $role->pivot->created_at;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:578
msgid ""
"Notice that each `Role` model we retrieve is automatically assigned a "
"`pivot` attribute. This attribute contains a model representing the "
"intermediate table."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:580
msgid ""
"By default, only the model keys will be present on the `pivot` model. If "
"your intermediate table contains extra attributes, you must specify them "
"when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:582
#, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)->withPivot('active', "
"'created_by');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:584
msgid ""
"If you would like your intermediate table to have `created_at` and "
"`updated_at` timestamps that are automatically maintained by Eloquent, call "
"the `withTimestamps` method when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:586
#, no-wrap
msgid "    return $this->belongsToMany(Role::class)->withTimestamps();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:588
#, no-wrap
msgid ""
"> {note} Intermediate tables that utilize Eloquent's automatically "
"maintained timestamps are required to have both `created_at` and "
"`updated_at` timestamp columns.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:590
#, no-wrap
msgid "<a name=\"customizing-the-pivot-attribute-name\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:590
#, no-wrap
msgid "Customizing The `pivot` Attribute Name"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:593
msgid ""
"As noted previously, attributes from the intermediate table may be accessed "
"on models via the `pivot` attribute. However, you are free to customize the "
"name of this attribute to better reflect its purpose within your "
"application."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:595
msgid ""
"For example, if your application contains users that may subscribe to "
"podcasts, you likely have a many-to-many relationship between users and "
"podcasts. If this is the case, you may wish to rename your intermediate "
"table attribute to `subscription` instead of `pivot`. This can be done using "
"the `as` method when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:599
#, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscription')\n"
"                    ->withTimestamps();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:601
msgid ""
"Once the custom intermediate table attribute has been specified, you may "
"access the intermediate table data using the customized name:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:603
#, no-wrap
msgid "    $users = User::with('podcasts')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:607
#, no-wrap
msgid ""
"    foreach ($users->flatMap->podcasts as $podcast) {\n"
"        echo $podcast->subscription->created_at;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:609
#, no-wrap
msgid "<a name=\"filtering-queries-via-intermediate-table-columns\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:609
#, no-wrap
msgid "Filtering Queries Via Intermediate Table Columns"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:612
msgid ""
"You can also filter the results returned by `belongsToMany` relationship "
"queries using the `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, "
"`wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, and "
"`wherePivotNotNull` methods when defining the relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:615
#, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivot('approved', 1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:618
#, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotIn('priority', [1, 2]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:621
#, no-wrap
msgid ""
"    return $this->belongsToMany(Role::class)\n"
"                    ->wherePivotNotIn('priority', [1, 2]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:625
#, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotBetween('created_at', ['2020-01-01 "
"00:00:00', '2020-12-31 00:00:00']);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:629
#, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotBetween('created_at', ['2020-01-01 "
"00:00:00', '2020-12-31 00:00:00']);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:633
#, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNull('expired_at');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:637
#, no-wrap
msgid ""
"    return $this->belongsToMany(Podcast::class)\n"
"                    ->as('subscriptions')\n"
"                    ->wherePivotNotNull('expired_at');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:639
#, no-wrap
msgid "<a name=\"defining-custom-intermediate-table-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:639
#, no-wrap
msgid "Defining Custom Intermediate Table Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:642
msgid ""
"If you would like to define a custom model to represent the intermediate "
"table of your many-to-many relationship, you may call the `using` method "
"when defining the relationship. Custom pivot models give you the opportunity "
"to define additional methods on the pivot model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:644
msgid ""
"Custom many-to-many pivot models should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\Pivot` class while custom "
"polymorphic many-to-many pivot models should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` class. For example, "
"we may define a `Role` model which uses a custom `RoleUser` pivot model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:661
#, no-wrap
msgid ""
"    class Role extends Model\n"
"    {\n"
"        /**\n"
"         * The users that belong to the role.\n"
"         */\n"
"        public function users()\n"
"        {\n"
"            return "
"$this->belongsToMany(User::class)->using(RoleUser::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:663
msgid ""
"When defining the `RoleUser` model, you should extend the "
"`Illuminate\\Database\\Eloquent\\Relations\\Pivot` class:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:669
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:674
#, no-wrap
msgid ""
"    class RoleUser extends Pivot\n"
"    {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:676
#, no-wrap
msgid ""
"> {note} Pivot models may not use the `SoftDeletes` trait. If you need to "
"soft delete pivot records consider converting your pivot model to an actual "
"Eloquent model.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:678
#, no-wrap
msgid "<a name=\"custom-pivot-models-and-incrementing-ids\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:678
#, no-wrap
msgid "Custom Pivot Models And Incrementing IDs"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:681
msgid ""
"If you have defined a many-to-many relationship that uses a custom pivot "
"model, and that pivot model has an auto-incrementing primary key, you should "
"ensure your custom pivot model class defines an `incrementing` property that "
"is set to `true`."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:688
#, no-wrap
msgid ""
"    /**\n"
"     * Indicates if the IDs are auto-incrementing.\n"
"     *\n"
"     * @var bool\n"
"     */\n"
"    public $incrementing = true;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:690
#, no-wrap
msgid "<a name=\"polymorphic-relationships\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:690
#, no-wrap
msgid "Polymorphic Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:693
msgid ""
"A polymorphic relationship allows the child model to belong to more than one "
"type of model using a single association. For example, imagine you are "
"building an application that allows users to share blog posts and videos. In "
"such an application, a `Comment` model might belong to both the `Post` and "
"`Video` models."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:695
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:695
#, no-wrap
msgid "One To One (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:698
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:701
msgid ""
"A one-to-one polymorphic relation is similar to a typical one-to-one "
"relation; however, the child model can belong to more than one type of model "
"using a single association. For example, a blog `Post` and a `User` may "
"share a polymorphic relation to an `Image` model. Using a one-to-one "
"polymorphic relation allows you to have a single table of unique images that "
"may be associated with posts and users. First, let's examine the table "
"structure:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:705 docs/8.x/eloquent-relationships.md:941
#, no-wrap
msgid ""
"    posts\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:715
#, no-wrap
msgid ""
"    images\n"
"        id - integer\n"
"        url - string\n"
"        imageable_id - integer\n"
"        imageable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:717
msgid ""
"Note the `imageable_id` and `imageable_type` columns on the `images` "
"table. The `imageable_id` column will contain the ID value of the post or "
"user, while the `imageable_type` column will contain the class name of the "
"parent model. The `imageable_type` column is used by Eloquent to determine "
"which \"type\" of parent model to return when accessing the `imageable` "
"relation. In this case, the column would contain either `App\\Models\\Post` "
"or `App\\Models\\User`."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:719
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:722 docs/8.x/eloquent-relationships.md:824
msgid "Next, let's examine the model definitions needed to build this relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:739
#, no-wrap
msgid ""
"    class Image extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent imageable model (user or post).\n"
"         */\n"
"        public function imageable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:750
#, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get the post's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:761
#, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get the user's image.\n"
"         */\n"
"        public function image()\n"
"        {\n"
"            return $this->morphOne(Image::class, 'imageable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:763
#, no-wrap
msgid "<a name=\"one-to-one-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:763 docs/8.x/eloquent-relationships.md:865 docs/8.x/eloquent-relationships.md:1014
#, no-wrap
msgid "Retrieving The Relationship"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:766
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your models. For example, to retrieve the image for a "
"post, we can access the `image` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:770 docs/8.x/eloquent-relationships.md:872 docs/8.x/eloquent-relationships.md:1021 docs/8.x/eloquent-relationships.md:1723 docs/8.x/eloquent-relationships.md:1731 docs/8.x/eloquent-relationships.md:1752 docs/8.x/eloquent-relationships.md:1766 docs/8.x/eloquent-relationships.md:1774
#, no-wrap
msgid "    $post = Post::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:772
#, no-wrap
msgid "    $image = $post->image;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:774
msgid ""
"You may retrieve the parent of the polymorphic model by accessing the name "
"of the method that performs the call to `morphTo`. In this case, that is the "
"`imageable` method on the `Image` model. So, we will access that method as a "
"dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:776
#, no-wrap
msgid "    use App\\Models\\Image;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:778
#, no-wrap
msgid "    $image = Image::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:780
#, no-wrap
msgid "    $imageable = $image->imageable;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:782
msgid ""
"The `imageable` relation on the `Image` model will return either a `Post` or "
"`User` instance, depending on which type of model owns the image."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:784
#, no-wrap
msgid "<a name=\"morph-one-to-one-key-conventions\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:787
msgid ""
"If necessary, you may specify the name of the \"id\" and \"type\" columns "
"utilized by your polymorphic child model. If you do so, ensure that you "
"always pass the name of the relationship as the first argument to the "
"`morphTo` method. Typically, this value should match the method name, so you "
"may use PHP's `__FUNCTION__` constant:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:795
#, no-wrap
msgid ""
"    /**\n"
"     * Get the model that the image belongs to.\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo(__FUNCTION__, 'imageable_type', "
"'imageable_id');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:797
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:797
#, no-wrap
msgid "One To Many (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:800
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:803
msgid ""
"A one-to-many polymorphic relation is similar to a typical one-to-many "
"relation; however, the child model can belong to more than one type of model "
"using a single association. For example, imagine users of your application "
"can \"comment\" on posts and videos. Using polymorphic relationships, you "
"may use a single `comments` table to contain comments for both posts and "
"videos. First, let's examine the table structure required to build this "
"relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:808
#, no-wrap
msgid ""
"    posts\n"
"        id - integer\n"
"        title - string\n"
"        body - text\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:813
#, no-wrap
msgid ""
"    videos\n"
"        id - integer\n"
"        title - string\n"
"        url - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:819
#, no-wrap
msgid ""
"    comments\n"
"        id - integer\n"
"        body - text\n"
"        commentable_id - integer\n"
"        commentable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:821
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:841
#, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent commentable model (post or video).\n"
"         */\n"
"        public function commentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:852
#, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the post's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:863
#, no-wrap
msgid ""
"    class Video extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the video's comments.\n"
"         */\n"
"        public function comments()\n"
"        {\n"
"            return $this->morphMany(Comment::class, 'commentable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:865
#, no-wrap
msgid "<a name=\"one-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:868
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your model's dynamic relationship properties. For example, "
"to access all of the comments for a post, we can use the `comments` dynamic "
"property:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:876
#, no-wrap
msgid ""
"    foreach ($post->comments as $comment) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:878
msgid ""
"You may also retrieve the parent of a polymorphic child model by accessing "
"the name of the method that performs the call to `morphTo`. In this case, "
"that is the `commentable` method on the `Comment` model. So, we will access "
"that method as a dynamic relationship property in order to access the "
"comment's parent model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:884
#, no-wrap
msgid "    $commentable = $comment->commentable;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:886
msgid ""
"The `commentable` relation on the `Comment` model will return either a "
"`Post` or `Video` instance, depending on which type of model is the "
"comment's parent."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:888
#, no-wrap
msgid "<a name=\"one-of-many-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:888
#, no-wrap
msgid "One Of Many (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:891
msgid ""
"Sometimes a model may have many related models, yet you want to easily "
"retrieve the \"latest\" or \"oldest\" related model of the relationship. For "
"example, a `User` model may be related to many `Image` models, but you want "
"to define a convenient way to interact with the most recent image the user "
"has uploaded. You may accomplish this using the `morphOne` relationship type "
"combined with the `ofMany` methods:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:892
#, no-wrap
msgid ""
"/**\n"
" * Get the user's most recent image.\n"
" */\n"
"public function latestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:904
#, no-wrap
msgid ""
"/**\n"
" * Get the user's oldest image.\n"
" */\n"
"public function oldestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:917
msgid ""
"For example, using the `ofMany` method, you may retrieve the user's most "
"\"liked\" image. The `ofMany` method accepts the sortable column as its "
"first argument and which aggregate function (`min` or `max`) to apply when "
"querying for the related model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:918
#, no-wrap
msgid ""
"/**\n"
" * Get the user's most popular image.\n"
" */\n"
"public function bestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', "
"'max');\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:929
#, no-wrap
msgid ""
"> {tip} It is possible to construct more advanced \"one of many\" "
"relationships. For more information, please consult the [has one of many "
"documentation](#advanced-has-one-of-many-relationships).\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:931
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-relations\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:931
#, no-wrap
msgid "Many To Many (Polymorphic)"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:934
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-table-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:937
msgid ""
"Many-to-many polymorphic relations are slightly more complicated than "
"\"morph one\" and \"morph many\" relationships. For example, a `Post` model "
"and `Video` model could share a polymorphic relation to a `Tag` model. Using "
"a many-to-many polymorphic relation in this situation would allow your "
"application to have a single table of unique tags that may be associated "
"with posts or videos. First, let's examine the table structure required to "
"build this relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:945
#, no-wrap
msgid ""
"    videos\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:949
#, no-wrap
msgid ""
"    tags\n"
"        id - integer\n"
"        name - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:954
#, no-wrap
msgid ""
"    taggables\n"
"        tag_id - integer\n"
"        taggable_id - integer\n"
"        taggable_type - string\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:956
#, no-wrap
msgid ""
"> {tip} Before diving into polymorphic many-to-many relationships, you may "
"benefit from reading the documentation on typical [many-to-many "
"relationships](#many-to-many).\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:958
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-model-structure\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:961
msgid ""
"Next, we're ready to define the relationships on the models. The `Post` and "
"`Video` models will both contain a `tags` method that calls the "
"`morphToMany` method provided by the base Eloquent model class."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:963
msgid ""
"The `morphToMany` method accepts the name of the related model as well as "
"the \"relationship name\". Based on the name we assigned to our intermediate "
"table name and the keys it contains, we will refer to the relationship as "
"\"taggable\":"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:980
#, no-wrap
msgid ""
"    class Post extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the tags for the post.\n"
"         */\n"
"        public function tags()\n"
"        {\n"
"            return $this->morphToMany(Tag::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:982
#, no-wrap
msgid ""
"<a "
"name=\"many-to-many-polymorphic-defining-the-inverse-of-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:985
msgid ""
"Next, on the `Tag` model, you should define a method for each of its "
"possible parent models. So, in this example, we will define a `posts` method "
"and a `videos` method. Both of these methods should return the result of the "
"`morphedByMany` method."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:987
msgid ""
"The `morphedByMany` method accepts the name of the related model as well as "
"the \"relationship name\". Based on the name we assigned to our intermediate "
"table name and the keys it contains, we will refer to the relationship as "
"\"taggable\":"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1003
#, no-wrap
msgid ""
"    class Tag extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts that are assigned this tag.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->morphedByMany(Post::class, 'taggable');\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1012
#, no-wrap
msgid ""
"        /**\n"
"         * Get all of the videos that are assigned this tag.\n"
"         */\n"
"        public function videos()\n"
"        {\n"
"            return $this->morphedByMany(Video::class, 'taggable');\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1014
#, no-wrap
msgid "<a name=\"many-to-many-polymorphic-retrieving-the-relationship\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1017
msgid ""
"Once your database table and models are defined, you may access the "
"relationships via your models. For example, to access all of the tags for a "
"post, you may use the `tags` dynamic relationship property:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1025
#, no-wrap
msgid ""
"    foreach ($post->tags as $tag) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1027
msgid ""
"You may retrieve the parent of a polymorphic relation from the polymorphic "
"child model by accessing the name of the method that performs the call to "
"`morphedByMany`. In this case, that is the `posts` or `videos` methods on "
"the `Tag` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1029
#, no-wrap
msgid "    use App\\Models\\Tag;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1031
#, no-wrap
msgid "    $tag = Tag::find(1);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1035
#, no-wrap
msgid ""
"    foreach ($tag->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1039
#, no-wrap
msgid ""
"    foreach ($tag->videos as $video) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1041
#, no-wrap
msgid "<a name=\"custom-polymorphic-types\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1041
#, no-wrap
msgid "Custom Polymorphic Types"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1044
msgid ""
"By default, Laravel will use the fully qualified class name to store the "
"\"type\" of the related model. For instance, given the one-to-many "
"relationship example above where a `Comment` model may belong to a `Post` or "
"a `Video` model, the default `commentable_type` would be either "
"`App\\Models\\Post` or `App\\Models\\Video`, respectively. However, you may "
"wish to decouple these values from your application's internal structure."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1046
msgid ""
"For example, instead of using the model names as the \"type\", we may use "
"simple strings such as `post` and `video`. By doing so, the polymorphic "
"\"type\" column values in our database will remain valid even if the models "
"are renamed:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1048 docs/8.x/eloquent-relationships.md:1059
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1053
#, no-wrap
msgid ""
"    Relation::enforceMorphMap([\n"
"        'post' => 'App\\Models\\Post',\n"
"        'video' => 'App\\Models\\Video',\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1055
msgid ""
"You may call the `enforceMorphMap` method in the `boot` method of your "
"`App\\Providers\\AppServiceProvider` class or create a separate service "
"provider if you wish."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1057
msgid ""
"You may determine the morph alias of a given model at runtime using the "
"model's `getMorphClass` method. Conversely, you may determine the "
"fully-qualified class name associated with a morph alias using the "
"`Relation::getMorphedModel` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1061
#, no-wrap
msgid "    $alias = $post->getMorphClass();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1063
#, no-wrap
msgid "    $class = Relation::getMorphedModel($alias);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1065
#, no-wrap
msgid ""
"> {note} When adding a \"morph map\" to your existing application, every "
"morphable `*_type` column value in your database that still contains a "
"fully-qualified class will need to be converted to its \"map\" name.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1067
#, no-wrap
msgid "<a name=\"dynamic-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1067
#, no-wrap
msgid "Dynamic Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1070
msgid ""
"You may use the `resolveRelationUsing` method to define relations between "
"Eloquent models at runtime. While not typically recommended for normal "
"application development, this may occasionally be useful when developing "
"Laravel packages."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1072
msgid ""
"The `resolveRelationUsing` method accepts the desired relationship name as "
"its first argument. The second argument passed to the method should be a "
"closure that accepts the model instance and returns a valid Eloquent "
"relationship definition. Typically, you should configure dynamic "
"relationships within the boot method of a [service "
"provider](/docs/{{version}}/providers):"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1075
#, no-wrap
msgid ""
"    use App\\Models\\Order;\n"
"    use App\\Models\\Customer;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1079
#, no-wrap
msgid ""
"    Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"        return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"    });\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1081
#, no-wrap
msgid ""
"> {note} When defining dynamic relationships, always provide explicit key "
"name arguments to the Eloquent relationship methods.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1083
#, no-wrap
msgid "<a name=\"querying-relations\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:1083
#, no-wrap
msgid "Querying Relations"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1086
msgid ""
"Since all Eloquent relationships are defined via methods, you may call those "
"methods to obtain an instance of the relationship without actually executing "
"a query to load the related models. In addition, all types of Eloquent "
"relationships also serve as [query builders](/docs/{{version}}/queries), "
"allowing you to continue to chain constraints onto the relationship query "
"before finally executing the SQL query against your database."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1088
msgid ""
"For example, imagine a blog application in which a `User` model has many "
"associated `Post` models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1105
#, no-wrap
msgid ""
"    class User extends Model\n"
"    {\n"
"        /**\n"
"         * Get all of the posts for the user.\n"
"         */\n"
"        public function posts()\n"
"        {\n"
"            return $this->hasMany(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1107
msgid ""
"You may query the `posts` relationship and add additional constraints to the "
"relationship like so:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1115
msgid ""
"You are able to use any of the Laravel [query "
"builder's](/docs/{{version}}/queries) methods on the relationship, so be "
"sure to explore the query builder documentation to learn about all of the "
"methods that are available to you."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1117
#, no-wrap
msgid "<a name=\"chaining-orwhere-clauses-after-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1117
#, no-wrap
msgid "Chaining `orWhere` Clauses After Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1120
msgid ""
"As demonstrated in the example above, you are free to add additional "
"constraints to relationships when querying them. However, use caution when "
"chaining `orWhere` clauses onto a relationship, as the `orWhere` clauses "
"will be logically grouped at the same level as the relationship constraint:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1125
#, no-wrap
msgid ""
"    $user->posts()\n"
"            ->where('active', 1)\n"
"            ->orWhere('votes', '>=', 100)\n"
"            ->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1127
msgid ""
"The example above will generate the following SQL. As you can see, the `or` "
"clause instructs the query to return _any_ user with greater than 100 "
"votes. The query is no longer constrained to a specific user:"
msgstr ""

#. type: Code fence info string
#: docs/8.x/eloquent-relationships.md:1128 docs/8.x/eloquent-relationships.md:1147 docs/8.x/eloquent-relationships.md:1470
#, no-wrap
msgid "sql"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1128
#, no-wrap
msgid ""
"select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1135
msgid ""
"In most situations, you should use [logical "
"groups](/docs/{{version}}/queries#logical-grouping) to group the conditional "
"checks between parentheses:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1137 docs/8.x/eloquent-relationships.md:1191 docs/8.x/eloquent-relationships.md:1231 docs/8.x/eloquent-relationships.md:1239 docs/8.x/eloquent-relationships.md:1275 docs/8.x/eloquent-relationships.md:1292 docs/8.x/eloquent-relationships.md:1316 docs/8.x/eloquent-relationships.md:1327
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1144
#, no-wrap
msgid ""
"    $user->posts()\n"
"            ->where(function (Builder $query) {\n"
"                return $query->where('active', 1)\n"
"                             ->orWhere('votes', '>=', 100);\n"
"            })\n"
"            ->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1146
msgid ""
"The example above will produce the following SQL. Note that the logical "
"grouping has properly grouped the constraints and the query remains "
"constrained to a specific user:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1147
#, no-wrap
msgid ""
"select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1154
#, no-wrap
msgid "<a name=\"relationship-methods-vs-dynamic-properties\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1154
#, no-wrap
msgid "Relationship Methods Vs. Dynamic Properties"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1157
msgid ""
"If you do not need to add additional constraints to an Eloquent relationship "
"query, you may access the relationship as if it were a property. For "
"example, continuing to use our `User` and `Post` example models, we may "
"access all of a user's posts like so:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1165
#, no-wrap
msgid ""
"    foreach ($user->posts as $post) {\n"
"        //\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1167
msgid ""
"Dynamic relationship properties perform \"lazy loading\", meaning they will "
"only load their relationship data when you actually access them. Because of "
"this, developers often use [eager loading](#eager-loading) to pre-load "
"relationships they know will be accessed after loading the model. Eager "
"loading provides a significant reduction in SQL queries that must be "
"executed to load a model's relations."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1169
#, no-wrap
msgid "<a name=\"querying-relationship-existence\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1169
#, no-wrap
msgid "Querying Relationship Existence"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1172
msgid ""
"When retrieving model records, you may wish to limit your results based on "
"the existence of a relationship. For example, imagine you want to retrieve "
"all blog posts that have at least one comment. To do so, you may pass the "
"name of the relationship to the `has` and `orHas` methods:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1177
#, no-wrap
msgid ""
"    // Retrieve all posts that have at least one comment...\n"
"    $posts = Post::has('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1179
msgid ""
"You may also specify an operator and count value to further customize the "
"query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1182
#, no-wrap
msgid ""
"    // Retrieve all posts that have three or more comments...\n"
"    $posts = Post::has('comments', '>=', 3)->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1184
msgid ""
"Nested `has` statements may be constructed using \"dot\" notation. For "
"example, you may retrieve all posts that have at least one comment that has "
"at least one image:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1187
#, no-wrap
msgid ""
"    // Retrieve posts that have at least one comment with images...\n"
"    $posts = Post::has('comments.images')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1189
msgid ""
"If you need even more power, you may use the `whereHas` and `orWhereHas` "
"methods to define additional query constraints on your `has` queries, such "
"as inspecting the content of a comment:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1196
#, no-wrap
msgid ""
"    // Retrieve posts with at least one comment containing words like "
"code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1201
#, no-wrap
msgid ""
"    // Retrieve posts with at least ten comments containing words like "
"code%...\n"
"    $posts = Post::whereHas('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }, '>=', 10)->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1203
#, no-wrap
msgid ""
"> {note} Eloquent does not currently support querying for relationship "
"existence across databases. The relationships must exist within the same "
"database.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1205
#, no-wrap
msgid "<a name=\"inline-relationship-existence-queries\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1205
#, no-wrap
msgid "Inline Relationship Existence Queries"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1208
msgid ""
"If you would like to query for a relationship's existence with a single, "
"simple where condition attached to the relationship query, you may find it "
"more convenient to use the `whereRelation` and `whereMorphRelation` "
"methods. For example, we may query for all posts that have unapproved "
"comments:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1212
#, no-wrap
msgid "    $posts = Post::whereRelation('comments', 'is_approved', false)->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1214
msgid ""
"Of course, like calls to the query builder's `where` method, you may also "
"specify an operator:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1218
#, no-wrap
msgid ""
"    $posts = Post::whereRelation(\n"
"        'comments', 'created_at', '>=', now()->subHour()\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1220
#, no-wrap
msgid "<a name=\"querying-relationship-absence\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1220
#, no-wrap
msgid "Querying Relationship Absence"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1223
msgid ""
"When retrieving model records, you may wish to limit your results based on "
"the absence of a relationship. For example, imagine you want to retrieve all "
"blog posts that **don't** have any comments. To do so, you may pass the name "
"of the relationship to the `doesntHave` and `orDoesntHave` methods:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1227
#, no-wrap
msgid "    $posts = Post::doesntHave('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1229
msgid ""
"If you need even more power, you may use the `whereDoesntHave` and "
"`orWhereDoesntHave` methods to add additional query constraints to your "
"`doesntHave` queries, such as inspecting the content of a comment:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1235
#, no-wrap
msgid ""
"    $posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1237
msgid ""
"You may use \"dot\" notation to execute a query against a nested "
"relationship. For example, the following query will retrieve all posts that "
"do not have comments; however, posts that have comments from authors that "
"are not banned will be included in the results:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1243
#, no-wrap
msgid ""
"    $posts = Post::whereDoesntHave('comments.author', function (Builder "
"$query) {\n"
"        $query->where('banned', 0);\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1245
#, no-wrap
msgid "<a name=\"querying-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1245
#, no-wrap
msgid "Querying Morph To Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1248
msgid ""
"To query the existence of \"morph to\" relationships, you may use the "
"`whereHasMorph` and `whereDoesntHaveMorph` methods. These methods accept the "
"name of the relationship as their first argument. Next, the methods accept "
"the names of the related models that you wish to include in the "
"query. Finally, you may provide a closure which customizes the relationship "
"query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1253
#, no-wrap
msgid ""
"    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
"    use App\\Models\\Video;\n"
"    use Illuminate\\Database\\Eloquent\\Builder;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1262
#, no-wrap
msgid ""
"    // Retrieve comments associated to posts or videos with a title like "
"code%...\n"
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1271
#, no-wrap
msgid ""
"    // Retrieve comments associated to posts with a title not like "
"code%...\n"
"    $comments = Comment::whereDoesntHaveMorph(\n"
"        'commentable',\n"
"        Post::class,\n"
"        function (Builder $query) {\n"
"            $query->where('title', 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1273
msgid ""
"You may occasionally need to add query constraints based on the \"type\" of "
"the related polymorphic model. The closure passed to the `whereHasMorph` "
"method may receive a `$type` value as its second argument. This argument "
"allows you to inspect the \"type\" of the query that is being built:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1281
#, no-wrap
msgid ""
"    $comments = Comment::whereHasMorph(\n"
"        'commentable',\n"
"        [Post::class, Video::class],\n"
"        function (Builder $query, $type) {\n"
"            $column = $type === Post::class ? 'content' : 'title';\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1285
#, no-wrap
msgid ""
"            $query->where($column, 'like', 'code%');\n"
"        }\n"
"    )->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1287
#, no-wrap
msgid "<a name=\"querying-all-morph-to-related-models\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1287
#, no-wrap
msgid "Querying All Related Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1290
msgid ""
"Instead of passing an array of possible polymorphic models, you may provide "
"`*` as a wildcard value. This will instruct Laravel to retrieve all of the "
"possible polymorphic types from the database. Laravel will execute an "
"additional query in order to perform this operation:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1296
#, no-wrap
msgid ""
"    $comments = Comment::whereHasMorph('commentable', '*', function (Builder "
"$query) {\n"
"        $query->where('title', 'like', 'foo%');\n"
"    })->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1298
#, no-wrap
msgid "<a name=\"aggregating-related-models\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:1298
#, no-wrap
msgid "Aggregating Related Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1301
#, no-wrap
msgid "<a name=\"counting-related-models\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1301
#, no-wrap
msgid "Counting Related Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1304
msgid ""
"Sometimes you may want to count the number of related models for a given "
"relationship without actually loading the models. To accomplish this, you "
"may use the `withCount` method. The `withCount` method will place a "
"`{relation}_count` attribute on the resulting models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1308
#, no-wrap
msgid "    $posts = Post::withCount('comments')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1312
#, no-wrap
msgid ""
"    foreach ($posts as $post) {\n"
"        echo $post->comments_count;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1314
msgid ""
"By passing an array to the `withCount` method, you may add the \"counts\" "
"for multiple relations as well as add additional constraints to the queries:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1320
#, no-wrap
msgid ""
"    $posts = Post::withCount(['votes', 'comments' => function (Builder "
"$query) {\n"
"        $query->where('content', 'like', 'code%');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1323
#, no-wrap
msgid ""
"    echo $posts[0]->votes_count;\n"
"    echo $posts[0]->comments_count;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1325
msgid ""
"You may also alias the relationship count result, allowing multiple counts "
"on the same relationship:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1334
#, no-wrap
msgid ""
"    $posts = Post::withCount([\n"
"        'comments',\n"
"        'comments as pending_comments_count' => function (Builder $query) "
"{\n"
"            $query->where('approved', false);\n"
"        },\n"
"    ])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1337
#, no-wrap
msgid ""
"    echo $posts[0]->comments_count;\n"
"    echo $posts[0]->pending_comments_count;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1339
#, no-wrap
msgid "<a name=\"deferred-count-loading\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1339 docs/8.x/eloquent-relationships.md:1415
#, no-wrap
msgid "Deferred Count Loading"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1342
msgid ""
"Using the `loadCount` method, you may load a relationship count after the "
"parent model has already been retrieved:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1344
#, no-wrap
msgid "    $book = Book::first();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1346
#, no-wrap
msgid "    $book->loadCount('genres');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1348
msgid ""
"If you need to set additional query constraints on the count query, you may "
"pass an array keyed by the relationships you wish to count. The array values "
"should be closures which receive the query builder instance:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1352
#, no-wrap
msgid ""
"    $book->loadCount(['reviews' => function ($query) {\n"
"        $query->where('rating', 5);\n"
"    }])\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1354
#, no-wrap
msgid "<a name=\"relationship-counting-and-custom-select-statements\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1354
#, no-wrap
msgid "Relationship Counting & Custom Select Statements"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1357
msgid ""
"If you're combining `withCount` with a `select` statement, ensure that you "
"call `withCount` after the `select` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1361
#, no-wrap
msgid ""
"    $posts = Post::select(['title', 'body'])\n"
"                    ->withCount('comments')\n"
"                    ->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1363
#, no-wrap
msgid "<a name=\"other-aggregate-functions\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1363
#, no-wrap
msgid "Other Aggregate Functions"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1366
msgid ""
"In addition to the `withCount` method, Eloquent provides `withMin`, "
"`withMax`, `withAvg`, `withSum`, and `withExists` methods. These methods "
"will place a `{relation}_{function}_{column}` attribute on your resulting "
"models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1370
#, no-wrap
msgid "    $posts = Post::withSum('comments', 'votes')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1374
#, no-wrap
msgid ""
"    foreach ($posts as $post) {\n"
"        echo $post->comments_sum_votes;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1376
msgid ""
"If you wish to access the result of the aggregate function using another "
"name, you may specify your own alias:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1378
#, no-wrap
msgid "    $posts = Post::withSum('comments as total_comments', 'votes')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1382
#, no-wrap
msgid ""
"    foreach ($posts as $post) {\n"
"        echo $post->total_comments;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1384
msgid ""
"Like the `loadCount` method, deferred versions of these methods are also "
"available. These additional aggregate operations may be performed on "
"Eloquent models that have already been retrieved:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1386
#, no-wrap
msgid "    $post = Post::first();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1388
#, no-wrap
msgid "    $post->loadSum('comments', 'votes');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1390
msgid ""
"If you're combining these aggregate methods with a `select` statement, "
"ensure that you call the aggregate methods after the `select` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1394
#, no-wrap
msgid ""
"    $posts = Post::select(['title', 'body'])\n"
"                    ->withExists('comments')\n"
"                    ->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1396
#, no-wrap
msgid "<a name=\"counting-related-models-on-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1396
#, no-wrap
msgid "Counting Related Models On Morph To Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1399
msgid ""
"If you would like to eager load a \"morph to\" relationship, as well as "
"related model counts for the various entities that may be returned by that "
"relationship, you may utilize the `with` method in combination with the "
"`morphTo` relationship's `morphWithCount` method."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1401
msgid ""
"In this example, let's assume that `Photo` and `Post` models may create "
"`ActivityFeed` models. We will assume the `ActivityFeed` model defines a "
"\"morph to\" relationship named `parentable` that allows us to retrieve the "
"parent `Photo` or `Post` model for a given `ActivityFeed` "
"instance. Additionally, let's assume that `Photo` models \"have many\" `Tag` "
"models and `Post` models \"have many\" `Comment` models."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1403
msgid ""
"Now, let's imagine we want to retrieve `ActivityFeed` instances and eager "
"load the `parentable` parent models for each `ActivityFeed` instance. In "
"addition, we want to retrieve the number of tags that are associated with "
"each parent photo and the number of comments that are associated with each "
"parent post:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1405 docs/8.x/eloquent-relationships.md:1515
#, no-wrap
msgid "    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1413
#, no-wrap
msgid ""
"    $activities = ActivityFeed::with([\n"
"        'parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWithCount([\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['comments'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1415
#, no-wrap
msgid "<a name=\"morph-to-deferred-count-loading\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1418
msgid ""
"Let's assume we have already retrieved a set of `ActivityFeed` models and "
"now we would like to load the nested relationship counts for the various "
"`parentable` models associated with the activity feeds. You may use the "
"`loadMorphCount` method to accomplish this:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1420
#, no-wrap
msgid "    $activities = ActivityFeed::with('parentable')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1425
#, no-wrap
msgid ""
"    $activities->loadMorphCount('parentable', [\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['comments'],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1427
#, no-wrap
msgid "<a name=\"eager-loading\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:1427
#, no-wrap
msgid "Eager Loading"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1430
msgid ""
"When accessing Eloquent relationships as properties, the related models are "
"\"lazy loaded\". This means the relationship data is not actually loaded "
"until you first access the property. However, Eloquent can \"eager load\" "
"relationships at the time you query the parent model. Eager loading "
"alleviates the \"N + 1\" query problem. To illustrate the N + 1 query "
"problem, consider a `Book` model that \"belongs to\" to an `Author` model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1447
#, no-wrap
msgid ""
"    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1449
msgid "Now, let's retrieve all books and their authors:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1451 docs/8.x/eloquent-relationships.md:1625
#, no-wrap
msgid "    use App\\Models\\Book;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1453 docs/8.x/eloquent-relationships.md:1627
#, no-wrap
msgid "    $books = Book::all();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1457 docs/8.x/eloquent-relationships.md:1467
#, no-wrap
msgid ""
"    foreach ($books as $book) {\n"
"        echo $book->author->name;\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1459
msgid ""
"This loop will execute one query to retrieve all of the books within the "
"database table, then another query for each book in order to retrieve the "
"book's author. So, if we have 25 books, the code above would run 26 queries: "
"one for the original book, and 25 additional queries to retrieve the author "
"of each book."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1461
msgid ""
"Thankfully, we can use eager loading to reduce this operation to just two "
"queries. When building a query, you may specify which relationships should "
"be eager loaded using the `with` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1463
#, no-wrap
msgid "    $books = Book::with('author')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1469
msgid ""
"For this operation, only two queries will be executed - one query to "
"retrieve all of the books and one query to retrieve all of the authors for "
"all of the books:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1470
#, no-wrap
msgid ""
"select * from books\n"
"\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1477
#, no-wrap
msgid "<a name=\"eager-loading-multiple-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1477
#, no-wrap
msgid "Eager Loading Multiple Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1480
msgid ""
"Sometimes you may need to eager load several different relationships. To do "
"so, just pass an array of relationships to the `with` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1482
#, no-wrap
msgid "    $books = Book::with(['author', 'publisher'])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1484
#, no-wrap
msgid "<a name=\"nested-eager-loading\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1484
#, no-wrap
msgid "Nested Eager Loading"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1487
msgid ""
"To eager load a relationship's relationships, you may use \"dot\" "
"syntax. For example, let's eager load all of the book's authors and all of "
"the author's personal contacts:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1489
#, no-wrap
msgid "    $books = Book::with('author.contacts')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1491
#, no-wrap
msgid "<a name=\"nested-eager-loading-morphto-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1491
#, no-wrap
msgid "Nested Eager Loading `morphTo` Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1494
msgid ""
"If you would like to eager load a `morphTo` relationship, as well as nested "
"relationships on the various entities that may be returned by that "
"relationship, you may use the `with` method in combination with the "
"`morphTo` relationship's `morphWith` method. To help illustrate this method, "
"let's consider the following model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1509 docs/8.x/eloquent-relationships.md:1663
#, no-wrap
msgid ""
"    class ActivityFeed extends Model\n"
"    {\n"
"        /**\n"
"         * Get the parent of the activity feed record.\n"
"         */\n"
"        public function parentable()\n"
"        {\n"
"            return $this->morphTo();\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1511 docs/8.x/eloquent-relationships.md:1665
msgid ""
"In this example, let's assume `Event`, `Photo`, and `Post` models may create "
"`ActivityFeed` models. Additionally, let's assume that `Event` models belong "
"to a `Calendar` model, `Photo` models are associated with `Tag` models, and "
"`Post` models belong to an `Author` model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1513 docs/8.x/eloquent-relationships.md:1667
msgid ""
"Using these model definitions and relationships, we may retrieve "
"`ActivityFeed` model instances and eager load all `parentable` models and "
"their respective nested relationships:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1524
#, no-wrap
msgid ""
"    $activities = ActivityFeed::query()\n"
"        ->with(['parentable' => function (MorphTo $morphTo) {\n"
"            $morphTo->morphWith([\n"
"                Event::class => ['calendar'],\n"
"                Photo::class => ['tags'],\n"
"                Post::class => ['author'],\n"
"            ]);\n"
"        }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1526
#, no-wrap
msgid "<a name=\"eager-loading-specific-columns\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1526
#, no-wrap
msgid "Eager Loading Specific Columns"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1529
msgid ""
"You may not always need every column from the relationships you are "
"retrieving. For this reason, Eloquent allows you to specify which columns of "
"the relationship you would like to retrieve:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1531
#, no-wrap
msgid "    $books = Book::with('author:id,name,book_id')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1533
#, no-wrap
msgid ""
"> {note} When using this feature, you should always include the `id` column "
"and any relevant foreign key columns in the list of columns you wish to "
"retrieve.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1535
#, no-wrap
msgid "<a name=\"eager-loading-by-default\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1535
#, no-wrap
msgid "Eager Loading By Default"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1538
msgid ""
"Sometimes you might want to always load some relationships when retrieving a "
"model. To accomplish this, you may define a `$with` property on the model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1553
#, no-wrap
msgid ""
"    class Book extends Model\n"
"    {\n"
"        /**\n"
"         * The relationships that should always be loaded.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $with = ['author'];\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1561
#, no-wrap
msgid ""
"        /**\n"
"         * Get the author that wrote the book.\n"
"         */\n"
"        public function author()\n"
"        {\n"
"            return $this->belongsTo(Author::class);\n"
"        }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1570
#, no-wrap
msgid ""
"        /**\n"
"         * Get the genre of the book.\n"
"         */\n"
"        public function genre()\n"
"        {\n"
"            return $this->belongsTo(Genre::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1572
msgid ""
"If you would like to remove an item from the `$with` property for a single "
"query, you may use the `without` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1574
#, no-wrap
msgid "    $books = Book::without('author')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1576
msgid ""
"If you would like to override all items within the `$with` property for a "
"single query, you may use the `withOnly` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1578
#, no-wrap
msgid "    $books = Book::withOnly('genre')->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1580
#, no-wrap
msgid "<a name=\"constraining-eager-loads\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1580
#, no-wrap
msgid "Constraining Eager Loads"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1583
msgid ""
"Sometimes you may wish to eager load a relationship but also specify "
"additional query conditions for the eager loading query. You can accomplish "
"this by passing an array of relationships to the `with` method where the "
"array key is a relationship name and the array value is a closure that adds "
"additional constraints to the eager loading query:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1589
#, no-wrap
msgid ""
"    $users = User::with(['posts' => function ($query) {\n"
"        $query->where('title', 'like', '%code%');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1591
msgid ""
"In this example, Eloquent will only eager load posts where the post's "
"`title` column contains the word `code`. You may call other [query "
"builder](/docs/{{version}}/queries) methods to further customize the eager "
"loading operation:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1595
#, no-wrap
msgid ""
"    $users = User::with(['posts' => function ($query) {\n"
"        $query->orderBy('created_at', 'desc');\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1597
#, no-wrap
msgid ""
"> {note} The `limit` and `take` query builder methods may not be used when "
"constraining eager loads.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1599
#, no-wrap
msgid "<a name=\"constraining-eager-loading-of-morph-to-relationships\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1599
#, no-wrap
msgid "Constraining Eager Loading Of `morphTo` Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1602
msgid ""
"If you are eager loading a `morphTo` relationship, Eloquent will run "
"multiple queries to fetch each type of related model. You may add additional "
"constraints to each of these queries using the `MorphTo` relation's "
"`constrain` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1605
#, no-wrap
msgid ""
"    use Illuminate\\Database\\Eloquent\\Builder;\n"
"    use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1616
#, no-wrap
msgid ""
"    $comments = Comment::with(['commentable' => function (MorphTo $morphTo) "
"{\n"
"        $morphTo->constrain([\n"
"            Post::class => function (Builder $query) {\n"
"                $query->whereNull('hidden_at');\n"
"            },\n"
"            Video::class => function (Builder $query) {\n"
"                $query->where('type', 'educational');\n"
"            },\n"
"        ]);\n"
"    }])->get();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1618
msgid ""
"In this example, Eloquent will only eager load posts that have not been "
"hidden and videos have a `type` value of \"educational\"."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1620
#, no-wrap
msgid "<a name=\"lazy-eager-loading\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1620
#, no-wrap
msgid "Lazy Eager Loading"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1623
msgid ""
"Sometimes you may need to eager load a relationship after the parent model "
"has already been retrieved. For example, this may be useful if you need to "
"dynamically decide whether to load related models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1631
#, no-wrap
msgid ""
"    if ($someCondition) {\n"
"        $books->load('author', 'publisher');\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1633
msgid ""
"If you need to set additional query constraints on the eager loading query, "
"you may pass an array keyed by the relationships you wish to load. The array "
"values should be closure instances which receive the query instance:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1637
#, no-wrap
msgid ""
"    $author->load(['books' => function ($query) {\n"
"        $query->orderBy('published_date', 'asc');\n"
"    }]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1639
msgid ""
"To load a relationship only when it has not already been loaded, use the "
"`loadMissing` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1641
#, no-wrap
msgid "    $book->loadMissing('author');\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1643
#, no-wrap
msgid "<a name=\"nested-lazy-eager-loading-morphto\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1643
#, no-wrap
msgid "Nested Lazy Eager Loading & `morphTo`"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1646
msgid ""
"If you would like to eager load a `morphTo` relationship, as well as nested "
"relationships on the various entities that may be returned by that "
"relationship, you may use the `loadMorph` method."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1648
msgid ""
"This method accepts the name of the `morphTo` relationship as its first "
"argument, and an array of model / relationship pairs as its second "
"argument. To help illustrate this method, let's consider the following "
"model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1675
#, no-wrap
msgid ""
"    $activities = ActivityFeed::with('parentable')\n"
"        ->get()\n"
"        ->loadMorph('parentable', [\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1677
#, no-wrap
msgid "<a name=\"preventing-lazy-loading\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1677
#, no-wrap
msgid "Preventing Lazy Loading"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1680
msgid ""
"As previously discussed, eager loading relationships can often provide "
"significant performance benefits to your application. Therefore, if you "
"would like, you may instruct Laravel to always prevent the lazy loading of "
"relationships. To accomplish this, you may invoke the `preventLazyLoading` "
"method offered by the base Eloquent model class. Typically, you should call "
"this method within the `boot` method of your application's "
"`AppServiceProvider` class."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1682
msgid ""
"The `preventLazyLoading` method accepts an optional boolean argument that "
"indicates if lazy loading should be prevented. For example, you may wish to "
"only disable lazy loading in non-production environments so that your "
"production environment will continue to function normally even if a lazy "
"loaded relationship is accidentally present in production code:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1683
#, no-wrap
msgid ""
"use Illuminate\\Database\\Eloquent\\Model;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Model::preventLazyLoading(! $this->app->isProduction());\n"
"}\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1698
msgid ""
"After preventing lazy loading, Eloquent will throw a "
"`Illuminate\\Database\\LazyLoadingViolationException` exception when your "
"application attempts to lazy load any Eloquent relationship."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1700
msgid ""
"You may customize the behavior of lazy loading violations using the "
"`handleLazyLoadingViolationsUsing` method. For example, using this method, "
"you may instruct lazy loading violations to only be logged instead of "
"interrupting the application's execution with exceptions:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1701
#, no-wrap
msgid ""
"Model::handleLazyLoadingViolationUsing(function ($model, $relation) {\n"
"    $class = get_class($model);\n"
"\n"
"    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\n"
"});\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1710
#, no-wrap
msgid "<a name=\"inserting-and-updating-related-models\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:1710
#, no-wrap
msgid "Inserting & Updating Related Models"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1713
#, no-wrap
msgid "<a name=\"the-save-method\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1713
#, no-wrap
msgid "The `save` Method"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1716
msgid ""
"Eloquent provides convenient methods for adding new models to "
"relationships. For example, perhaps you need to add a new comment to a "
"post. Instead of manually setting the `post_id` attribute on the `Comment` "
"model you may insert the comment using the relationship's `save` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1719
#, no-wrap
msgid ""
"    use App\\Models\\Comment;\n"
"    use App\\Models\\Post;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1721
#, no-wrap
msgid "    $comment = new Comment(['message' => 'A new comment.']);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1725 docs/8.x/eloquent-relationships.md:1740
#, no-wrap
msgid "    $post->comments()->save($comment);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1727
msgid ""
"Note that we did not access the `comments` relationship as a dynamic "
"property. Instead, we called the `comments` method to obtain an instance of "
"the relationship. The `save` method will automatically add the appropriate "
"`post_id` value to the new `Comment` model."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1729
msgid ""
"If you need to save multiple related models, you may use the `saveMany` "
"method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1736
#, no-wrap
msgid ""
"    $post->comments()->saveMany([\n"
"        new Comment(['message' => 'A new comment.']),\n"
"        new Comment(['message' => 'Another new comment.']),\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1738
msgid ""
"The `save` and `saveMany` methods will persist the given model instances, "
"but will not add the newly persisted models to any in-memory relationships "
"that are already loaded onto the parent model. If you plan on accessing the "
"relationship after using the `save` or `saveMany` methods, you may wish to "
"use the `refresh` method to reload the model and its relationships:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1742
#, no-wrap
msgid "    $post->refresh();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1745
#, no-wrap
msgid ""
"    // All comments, including the newly saved comment...\n"
"    $post->comments;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1747
#, no-wrap
msgid "<a name=\"the-push-method\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1747
#, no-wrap
msgid "Recursively Saving Models & Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1750
msgid ""
"If you would like to `save` your model and all of its associated "
"relationships, you may use the `push` method. In this example, the `Post` "
"model will be saved as well as its comments and the comment's authors:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1755
#, no-wrap
msgid ""
"    $post->comments[0]->message = 'Message';\n"
"    $post->comments[0]->author->name = 'Author Name';\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1757
#, no-wrap
msgid "    $post->push();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1759
#, no-wrap
msgid "<a name=\"the-create-method\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1759
#, no-wrap
msgid "The `create` Method"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1762
msgid ""
"In addition to the `save` and `saveMany` methods, you may also use the "
"`create` method, which accepts an array of attributes, creates a model, and "
"inserts it into the database. The difference between `save` and `create` is "
"that `save` accepts a full Eloquent model instance while `create` accepts a "
"plain PHP `array`. The newly created model will be returned by the `create` "
"method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1770
#, no-wrap
msgid ""
"    $comment = $post->comments()->create([\n"
"        'message' => 'A new comment.',\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1772
msgid "You may use the `createMany` method to create multiple related models:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1779
#, no-wrap
msgid ""
"    $post->comments()->createMany([\n"
"        ['message' => 'A new comment.'],\n"
"        ['message' => 'Another new comment.'],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1781
msgid ""
"You may also use the `findOrNew`, `firstOrNew`, `firstOrCreate`, and "
"`updateOrCreate` methods to [create and update models on "
"relationships](/docs/{{version}}/eloquent#upserts)."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1783
#, no-wrap
msgid ""
"> {tip} Before using the `create` method, be sure to review the [mass "
"assignment](/docs/{{version}}/eloquent#mass-assignment) documentation.\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1785
#, no-wrap
msgid "<a name=\"updating-belongs-to-relationships\"></a>\n"
msgstr ""

#. type: Title ###
#: docs/8.x/eloquent-relationships.md:1785
#, no-wrap
msgid "Belongs To Relationships"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1788
msgid ""
"If you would like to assign a child model to a new parent model, you may use "
"the `associate` method. In this example, the `User` model defines a "
"`belongsTo` relationship to the `Account` model. This `associate` method "
"will set the foreign key on the child model:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1790
#, no-wrap
msgid "    use App\\Models\\Account;\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1792
#, no-wrap
msgid "    $account = Account::find(10);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1794
#, no-wrap
msgid "    $user->account()->associate($account);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1796 docs/8.x/eloquent-relationships.md:1802
#, no-wrap
msgid "    $user->save();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1798
msgid ""
"To remove a parent model from a child model, you may use the `dissociate` "
"method. This method will set the relationship's foreign key to `null`:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1800
#, no-wrap
msgid "    $user->account()->dissociate();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1804
#, no-wrap
msgid "<a name=\"updating-many-to-many-relationships\"></a>\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1807
#, no-wrap
msgid "<a name=\"attaching-detaching\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1807
#, no-wrap
msgid "Attaching / Detaching"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1810
msgid ""
"Eloquent also provides methods to make working with many-to-many "
"relationships more convenient. For example, let's imagine a user can have "
"many roles and a role can have many users. You may use the `attach` method "
"to attach a role to a user by inserting a record in the relationship's "
"intermediate table:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1816
#, no-wrap
msgid "    $user->roles()->attach($roleId);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1818
msgid ""
"When attaching a relationship to a model, you may also pass an array of "
"additional data to be inserted into the intermediate table:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1820
#, no-wrap
msgid "    $user->roles()->attach($roleId, ['expires' => $expires]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1822
msgid ""
"Sometimes it may be necessary to remove a role from a user. To remove a "
"many-to-many relationship record, use the `detach` method. The `detach` "
"method will delete the appropriate record out of the intermediate table; "
"however, both models will remain in the database:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1825
#, no-wrap
msgid ""
"    // Detach a single role from the user...\n"
"    $user->roles()->detach($roleId);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1828
#, no-wrap
msgid ""
"    // Detach all roles from the user...\n"
"    $user->roles()->detach();\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1830
msgid "For convenience, `attach` and `detach` also accept arrays of IDs as input:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1834
#, no-wrap
msgid "    $user->roles()->detach([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1839
#, no-wrap
msgid ""
"    $user->roles()->attach([\n"
"        1 => ['expires' => $expires],\n"
"        2 => ['expires' => $expires],\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1841
#, no-wrap
msgid "<a name=\"syncing-associations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1841
#, no-wrap
msgid "Syncing Associations"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1844
msgid ""
"You may also use the `sync` method to construct many-to-many "
"associations. The `sync` method accepts an array of IDs to place on the "
"intermediate table. Any IDs that are not in the given array will be removed "
"from the intermediate table. So, after this operation is complete, only the "
"IDs in the given array will exist in the intermediate table:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1846
#, no-wrap
msgid "    $user->roles()->sync([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1848
msgid "You may also pass additional intermediate table values with the IDs:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1850
#, no-wrap
msgid "    $user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1852
msgid ""
"If you would like to insert the same intermediate table values with each of "
"the synced model IDs, you may use the `syncWithPivotValues` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1854
#, no-wrap
msgid "    $user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1856
msgid ""
"If you do not want to detach existing IDs that are missing from the given "
"array, you may use the `syncWithoutDetaching` method:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1858
#, no-wrap
msgid "    $user->roles()->syncWithoutDetaching([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1860
#, no-wrap
msgid "<a name=\"toggling-associations\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1860
#, no-wrap
msgid "Toggling Associations"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1863
msgid ""
"The many-to-many relationship also provides a `toggle` method which "
"\"toggles\" the attachment status of the given related model IDs. If the "
"given ID is currently attached, it will be detached. Likewise, if it is "
"currently detached, it will be attached:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1865
#, no-wrap
msgid "    $user->roles()->toggle([1, 2, 3]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1867
#, no-wrap
msgid "<a name=\"updating-a-record-on-the-intermediate-table\"></a>\n"
msgstr ""

#. type: Title ####
#: docs/8.x/eloquent-relationships.md:1867
#, no-wrap
msgid "Updating A Record On The Intermediate Table"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1870
msgid ""
"If you need to update an existing row in your relationship's intermediate "
"table, you may use the `updateExistingPivot` method. This method accepts the "
"intermediate record foreign key and an array of attributes to update:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1876
#, no-wrap
msgid ""
"    $user->roles()->updateExistingPivot($roleId, [\n"
"        'active' => false,\n"
"    ]);\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1878
#, no-wrap
msgid "<a name=\"touching-parent-timestamps\"></a>\n"
msgstr ""

#. type: Title ##
#: docs/8.x/eloquent-relationships.md:1878
#, no-wrap
msgid "Touching Parent Timestamps"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1881
msgid ""
"When a model defines a `belongsTo` or `belongsToMany` relationship to "
"another model, such as a `Comment` which belongs to a `Post`, it is "
"sometimes helpful to update the parent's timestamp when the child model is "
"updated."
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1883
msgid ""
"For example, when a `Comment` model is updated, you may want to "
"automatically \"touch\" the `updated_at` timestamp of the owning `Post` so "
"that it is set to the current date and time. To accomplish this, you may add "
"a `touches` property to your child model containing the names of the "
"relationships that should have their `updated_at` timestamps updated when "
"the child model is updated:"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1898
#, no-wrap
msgid ""
"    class Comment extends Model\n"
"    {\n"
"        /**\n"
"         * All of the relationships to be touched.\n"
"         *\n"
"         * @var array\n"
"         */\n"
"        protected $touches = ['post'];\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1907
#, no-wrap
msgid ""
"        /**\n"
"         * Get the post that the comment belongs to.\n"
"         */\n"
"        public function post()\n"
"        {\n"
"            return $this->belongsTo(Post::class);\n"
"        }\n"
"    }\n"
msgstr ""

#. type: Plain text
#: docs/8.x/eloquent-relationships.md:1908
#, no-wrap
msgid ""
"> {note} Parent model timestamps will only be updated if the child model is "
"updated using Eloquent's `save` method.\n"
msgstr ""
