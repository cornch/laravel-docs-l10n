msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/eloquent-relationships.pot\n"
"X-Crowdin-File-ID: 55\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2022-04-18 09:23\n"

#: docs/8.x/eloquent-relationships.md:block 1 (header)
msgid "Eloquent: Relationships"
msgstr "Eloquent：關聯"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Defining Relationships](#defining-relationships)"
msgstr "[定義關聯](#defining-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One To One](#one-to-one)"
msgstr "[一對一](#one-to-one)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One To Many](#one-to-many)"
msgstr "[一對多](#one-to-many)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One To Many (Inverse) / Belongs To](#one-to-many-inverse)"
msgstr "[一對多 (反向) / BelongsTo](#one-to-many-inverse)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Has One Of Many](#has-one-of-many)"
msgstr "[一對多中之一](#has-one-of-many)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Has One Through](#has-one-through)"
msgstr "[間接一對一](#has-one-through)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Has Many Through](#has-many-through)"
msgstr "[間接一對多](#has-many-through)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Many To Many Relationships](#many-to-many)"
msgstr "[多對多關聯](#many-to-many)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Retrieving Intermediate Table Columns](#retrieving-intermediate-table-columns)"
msgstr "[取得中介資料表欄位](#retrieving-intermediate-table-columns)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Filtering Queries Via Intermediate Table Columns](#filtering-queries-via-intermediate-table-columns)"
msgstr "[使用中介資料表欄位來過濾查詢](#filtering-queries-via-intermediate-table-columns)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Defining Custom Intermediate Table Models](#defining-custom-intermediate-table-models)"
msgstr "[定義自訂的中介資料表 Model](#defining-custom-intermediate-table-models)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Polymorphic Relationships](#polymorphic-relationships)"
msgstr "[多型關聯](#polymorphic-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One To One](#one-to-one-polymorphic-relations)"
msgstr "[一對一](#one-to-one-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One To Many](#one-to-many-polymorphic-relations)"
msgstr "[一對多](#one-to-many-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[One Of Many](#one-of-many-polymorphic-relations)"
msgstr "[多中之一](#one-of-many-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Many To Many](#many-to-many-polymorphic-relations)"
msgstr "[多對多](#many-to-many-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Custom Polymorphic Types](#custom-polymorphic-types)"
msgstr "[自訂多型類型](#custom-polymorphic-types)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Dynamic Relationships](#dynamic-relationships)"
msgstr "[動態關聯](#dynamic-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Querying Relations](#querying-relations)"
msgstr "[查詢關聯](#querying-relations)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Relationship Methods Vs. Dynamic Properties](#relationship-methods-vs-dynamic-properties)"
msgstr "[關聯方法 Vs. 動態屬性](#relationship-methods-vs-dynamic-properties)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Querying Relationship Existence](#querying-relationship-existence)"
msgstr "[查詢關聯存在](#querying-relationship-existence)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Querying Relationship Absence](#querying-relationship-absence)"
msgstr "[查詢關聯不存在](#querying-relationship-absence)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Querying Morph To Relationships](#querying-morph-to-relationships)"
msgstr "[查詢 MorphTo 關聯](#querying-morph-to-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Aggregating Related Models](#aggregating-related-models)"
msgstr "[彙總關聯的 Model](#aggregating-related-models)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Counting Related Models](#counting-related-models)"
msgstr "[關聯 Model 計數](#counting-related-models)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Other Aggregate Functions](#other-aggregate-functions)"
msgstr "[其他彙總函式](#other-aggregate-functions)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Counting Related Models On Morph To Relationships](#counting-related-models-on-morph-to-relationships)"
msgstr "[在 MorphTo 關聯上對關聯的 Model 計數](#counting-related-models-on-morph-to-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Eager Loading](#eager-loading)"
msgstr "[積極式載入 (Eager Loading)](#eager-loading)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Constraining Eager Loads](#constraining-eager-loads)"
msgstr "[帶有條件的積極式載入](#constraining-eager-loads)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Lazy Eager Loading](#lazy-eager-loading)"
msgstr "[消極的積極式載入 (Lazy Eager Loading)](#lazy-eager-loading)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Preventing Lazy Loading](#preventing-lazy-loading)"
msgstr "[預防消極載入 (Lazy Loading)](#preventing-lazy-loading)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Inserting & Updating Related Models](#inserting-and-updating-related-models)"
msgstr "[插入或更新管理的 Model](#inserting-and-updating-related-models)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[The `save` Method](#the-save-method)"
msgstr "[`save` 方法](#the-save-method)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[The `create` Method](#the-create-method)"
msgstr "[`create` 方法](#the-create-method)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Belongs To Relationships](#updating-belongs-to-relationships)"
msgstr "[BelongsTo 關聯](#updating-belongs-to-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Many To Many Relationships](#updating-many-to-many-relationships)"
msgstr "[多對多關聯](#updating-many-to-many-relationships)"

#: docs/8.x/eloquent-relationships.md:block 2 (unordered list)
msgid "[Touching Parent Timestamps](#touching-parent-timestamps)"
msgstr "[更新上層 Model 的時戳](#touching-parent-timestamps)"

#: docs/8.x/eloquent-relationships.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/8.x/eloquent-relationships.md:block 5 (paragraph)
msgid "Database tables are often related to one another. For example, a blog post may have many comments or an order could be related to the user who placed it. Eloquent makes managing and working with these relationships easy, and supports a variety of common relationships:"
msgstr "資料庫中的資料表通常會互相彼此關聯。舉例來說，部落格文章可能會有許多的留言，而訂單則可能會關聯到建立訂單的使用者。在 Eloquent 中，要管理並處理這些關聯非常簡單，並支援多種常見的關聯："

#: docs/8.x/eloquent-relationships.md:block 7 (unordered list)
msgid "[Many To Many](#many-to-many)"
msgstr "[多對多](#many-to-many)"

#: docs/8.x/eloquent-relationships.md:block 7 (unordered list)
msgid "[One To One (Polymorphic)](#one-to-one-polymorphic-relations)"
msgstr "[一對一 (多型)](#one-to-one-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 7 (unordered list)
msgid "[One To Many (Polymorphic)](#one-to-many-polymorphic-relations)"
msgstr "[一對多 (多型)](#one-to-many-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 7 (unordered list)
msgid "[Many To Many (Polymorphic)](#many-to-many-polymorphic-relations)"
msgstr "[多對多 (多型)](#many-to-many-polymorphic-relations)"

#: docs/8.x/eloquent-relationships.md:block 10 (header)
msgid "Defining Relationships"
msgstr "定義關聯"

#: docs/8.x/eloquent-relationships.md:block 11 (paragraph)
msgid "Eloquent relationships are defined as methods on your Eloquent model classes. Since relationships also serve as powerful [query builders](/docs/{{version}}/queries), defining relationships as methods provides powerful method chaining and querying capabilities. For example, we may chain additional query constraints on this `posts` relationship:"
msgstr "Eloquent 關聯是作為方法定義在 Eloquent Model 類別中。由於關聯也可當作強大的 [Query Builder](/docs/{{version}}/queries) 使用，因此將關聯定義為方法也能讓方法得以串連使用並進行查詢。舉例來說，我們可以在這個 `posts` 關聯中串上額外的查詢條件："

#: docs/8.x/eloquent-relationships.md:block 12 (code)
msgid "$user->posts()->where('active', 1)->get();\n"
msgstr "$user->posts()->where('active', 1)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 13 (paragraph)
msgid "But, before diving too deep into using relationships, let's learn how to define each type of relationship supported by Eloquent."
msgstr "不過，在更深入瞭解如何使用關聯以前，我們先來了解一下如何定義 Eloquent 所支援的各種關聯型別吧！"

#: docs/8.x/eloquent-relationships.md:block 15 (header)
msgid "One To One"
msgstr "一對一"

#: docs/8.x/eloquent-relationships.md:block 16 (paragraph)
msgid "A one-to-one relationship is a very basic type of database relationship. For example, a `User` model might be associated with one `Phone` model. To define this relationship, we will place a `phone` method on the `User` model. The `phone` method should call the `hasOne` method and return its result. The `hasOne` method is available to your model via the model's `Illuminate\\Database\\Eloquent\\Model` base class:"
msgstr "一對一關聯是一種非常基本的資料庫關聯。舉例來說，一個 `User` Model 可能與一個 `Phone` Model 有關。要定義這個關聯，我們先在 `User` Model 中定義一個 `phone` 方法。`phone` 方法應呼叫 `hasOne` 方法並回傳其結果。`hasOne` 方法是通過 Model 的 `Illuminate\\Database\\Eloquent\\Model` 基礎類別提供的："

#: docs/8.x/eloquent-relationships.md:block 17 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get the phone associated with the user.\n"
"     */\n"
"    public function phone()\n"
"    {\n"
"        return $this->hasOne(Phone::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get the phone associated with the user.\n"
"     */\n"
"    public function phone()\n"
"    {\n"
"        return $this->hasOne(Phone::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 18 (paragraph)
msgid "The first argument passed to the `hasOne` method is the name of the related model class. Once the relationship is defined, we may retrieve the related record using Eloquent's dynamic properties. Dynamic properties allow you to access relationship methods as if they were properties defined on the model:"
msgstr "傳給 `hasOne` 方法的第一個引述是關聯 Model 類別的名稱。定義好關聯後，我們就可以通過 Eloquent 的動態屬性來存取這個關聯的紀錄。動態屬性能讓我們像在存取定義在 Model 上的屬性一樣來存取關聯方法："

#: docs/8.x/eloquent-relationships.md:block 19 (code)
msgid "$phone = User::find(1)->phone;\n"
msgstr "$phone = User::find(1)->phone;\n"

#: docs/8.x/eloquent-relationships.md:block 20 (paragraph)
msgid "Eloquent determines the foreign key of the relationship based on the parent model name. In this case, the `Phone` model is automatically assumed to have a `user_id` foreign key. If you wish to override this convention, you may pass a second argument to the `hasOne` method:"
msgstr "Eloquent 會通過上層 Model 的名稱來判斷關聯的外部索引鍵 (Foreign Key)。在這個例子中，Eloquent 會自動假設 `Phone` Model 中有個 `user_id` 外部索引鍵。若要複寫這個慣例用法的話，可以傳入第二個引數給 `hasOne` 方法："

#: docs/8.x/eloquent-relationships.md:block 21 (code)
msgid "return $this->hasOne(Phone::class, 'foreign_key');\n"
msgstr "return $this->hasOne(Phone::class, 'foreign_key');\n"

#: docs/8.x/eloquent-relationships.md:block 22 (paragraph)
msgid "Additionally, Eloquent assumes that the foreign key should have a value matching the primary key column of the parent. In other words, Eloquent will look for the value of the user's `id` column in the `user_id` column of the `Phone` record. If you would like the relationship to use a primary key value other than `id` or your model's `$primaryKey` property, you may pass a third argument to the `hasOne` method:"
msgstr "此外，Eloquent 還會假設這個外部索引鍵應該要有個與上層資料的主索引鍵欄位相同的值。換句話說，Eloquent 會在 `Phone` 紀錄的 `user_id` 欄位中找到與該使用者 `id` 欄位值相同的資料。若想在關聯中使用 `id` 或 Model 的 `$primaryKey` 屬性意外的其他主索引鍵值的話，可傳入第三個引數給 `hasOne` 方法："

#: docs/8.x/eloquent-relationships.md:block 23 (code)
msgid "return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"
msgstr "return $this->hasOne(Phone::class, 'foreign_key', 'local_key');\n"

#: docs/8.x/eloquent-relationships.md:block 25 (header)
msgid "Defining The Inverse Of The Relationship"
msgstr "定義反向的關聯"

#: docs/8.x/eloquent-relationships.md:block 26 (paragraph)
msgid "So, we can access the `Phone` model from our `User` model. Next, let's define a relationship on the `Phone` model that will let us access the user that owns the phone. We can define the inverse of a `hasOne` relationship using the `belongsTo` method:"
msgstr "好了，我們現在可以在 `User` Model 中存取 `Phone` Model 了。接著，我們來在 `Phone` Model 上定義關聯，好讓我們能在存取擁有這隻電話的使用者。我們可以使用 `belongsTo` 方法來定義反向的 `hasOne` 關聯："

#: docs/8.x/eloquent-relationships.md:block 27 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Phone extends Model\n"
"{\n"
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Phone extends Model\n"
"{\n"
"    /**\n"
"     * Get the user that owns the phone.\n"
"     */\n"
"    public function user()\n"
"    {\n"
"        return $this->belongsTo(User::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 28 (paragraph)
msgid "When invoking the `user` method, Eloquent will attempt to find a `User` model that has an `id` which matches the `user_id` column on the `Phone` model."
msgstr "當叫用 `user` 方法時，Eloquent 會嘗試尋找一筆 `id` 符合 `Phone` Model 中 `user_id` 欄位的 `User` Model。"

#: docs/8.x/eloquent-relationships.md:block 29 (paragraph)
msgid "Eloquent determines the foreign key name by examining the name of the relationship method and suffixing the method name with `_id`. So, in this case, Eloquent assumes that the `Phone` model has a `user_id` column. However, if the foreign key on the `Phone` model is not `user_id`, you may pass a custom key name as the second argument to the `belongsTo` method:"
msgstr "Eloquent 會檢查關聯方法的名稱，並在這個方法的名稱後加上 `_id` 來自動判斷外部索引鍵名稱。因此，在這個例子中，Eloquent 會假設 `Phone` Model 有個 `user_id` 欄位。不過，若 `Phone` Model 的外部索引鍵不是 `user_id`，則可以傳遞一個自訂索引鍵名稱給 `belongsTo`，作為第二個引數："

#: docs/8.x/eloquent-relationships.md:block 30 (code)
msgid "/**\n"
" * Get the user that owns the phone.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class, 'foreign_key');\n"
"}\n"
msgstr "/**\n"
" * Get the user that owns the phone.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class, 'foreign_key');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 31 (paragraph)
msgid "If the parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying the parent table's custom key:"
msgstr "若上層 Model 不使用 `id` 作為其主索引鍵，或是想要使用不同的欄位來尋找關聯的 Model，則可以傳遞第三個引數給 `belongsTo` 方法來指定上層資料表的自訂索引鍵："

#: docs/8.x/eloquent-relationships.md:block 32 (code)
msgid "/**\n"
" * Get the user that owns the phone.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"}\n"
msgstr "/**\n"
" * Get the user that owns the phone.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class, 'foreign_key', 'owner_key');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 34 (header)
msgid "One To Many"
msgstr "一對多"

#: docs/8.x/eloquent-relationships.md:block 35 (paragraph)
msgid "A one-to-many relationship is used to define relationships where a single model is the parent to one or more child models. For example, a blog post may have an infinite number of comments. Like all other Eloquent relationships, one-to-many relationships are defined by defining a method on your Eloquent model:"
msgstr "一對多關聯可用來定義某個有一個或多個子 Model 的單一 Model。舉例來說，部落格文章可能有無限數量筆留言。與其他 Eloquent 關聯一樣，一對多關聯可通過在 Eloquent Model 中定義方法來定義："

#: docs/8.x/eloquent-relationships.md:block 36 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get the comments for the blog post.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->hasMany(Comment::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get the comments for the blog post.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->hasMany(Comment::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 37 (paragraph)
msgid "Remember, Eloquent will automatically determine the proper foreign key column for the `Comment` model. By convention, Eloquent will take the \"snake case\" name of the parent model and suffix it with `_id`. So, in this example, Eloquent will assume the foreign key column on the `Comment` model is `post_id`."
msgstr "請記得，Eloquent 會自動為 `Comment` Model 判斷適當的外部索引鍵欄位。依照慣例，Eloquent 會去上層 Model 的「蛇形命名法 (snake_case)」名稱，並在其後加上 `_id`。因此，在這個例子中，Eloquent 會假設 `Comment` Model 上的外部索引鍵欄位為 `post_id`。"

#: docs/8.x/eloquent-relationships.md:block 38 (paragraph)
msgid "Once the relationship method has been defined, we can access the [collection](/docs/{{version}}/eloquent-collections) of related comments by accessing the `comments` property. Remember, since Eloquent provides \"dynamic relationship properties\", we can access relationship methods as if they were defined as properties on the model:"
msgstr "定義好關聯方法後，我們就可以通過 `comments` 屬性來存取關聯留言的 [Collection](/docs/{{version}}/eloquent-collections)。請記得，由於 Eloquent 提供了「動態關聯屬性」，因此我們可以像我們是在 Model 上定義屬性一樣地存取關聯方法："

#: docs/8.x/eloquent-relationships.md:block 39 (code)
msgid "use App\\Models\\Post;\n\n"
"$comments = Post::find(1)->comments;\n\n"
"foreach ($comments as $comment) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\Post;\n\n"
"$comments = Post::find(1)->comments;\n\n"
"foreach ($comments as $comment) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 40 (paragraph)
msgid "Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `comments` method and continuing to chain conditions onto the query:"
msgstr "由於所有的關聯也同時是 Query Builder，因此我們也能通過呼叫 `comments` 方法並繼續在查詢上串上條件來進一步給關聯加上查詢條件："

#: docs/8.x/eloquent-relationships.md:block 41 (code)
msgid "$comment = Post::find(1)->comments()\n"
"                    ->where('title', 'foo')\n"
"                    ->first();\n"
msgstr "$comment = Post::find(1)->comments()\n"
"                    ->where('title', 'foo')\n"
"                    ->first();\n"

#: docs/8.x/eloquent-relationships.md:block 42 (paragraph)
msgid "Like the `hasOne` method, you may also override the foreign and local keys by passing additional arguments to the `hasMany` method:"
msgstr "就像 `hasOne` 方法，我們也可以通過傳遞額外的參數給 `hasMany` 來複寫外部與內部的索引鍵："

#: docs/8.x/eloquent-relationships.md:block 43 (code)
msgid "return $this->hasMany(Comment::class, 'foreign_key');\n\n"
"return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"
msgstr "return $this->hasMany(Comment::class, 'foreign_key');\n\n"
"return $this->hasMany(Comment::class, 'foreign_key', 'local_key');\n"

#: docs/8.x/eloquent-relationships.md:block 45 (header)
msgid "One To Many (Inverse) / Belongs To"
msgstr "一對多 (反向) / 隸屬於 (Belongs To)"

#: docs/8.x/eloquent-relationships.md:block 46 (paragraph)
msgid "Now that we can access all of a post's comments, let's define a relationship to allow a comment to access its parent post. To define the inverse of a `hasMany` relationship, define a relationship method on the child model which calls the `belongsTo` method:"
msgstr "現在，我們已經可以存取一篇文章的所有留言了。讓我們來定義一個關聯，以從留言去的其上層的文章。要定義 `hasMany` 關聯的相反，我們可以在子 Model 中定義一個呼叫了 `belongsTo` 方法的關聯方法："

#: docs/8.x/eloquent-relationships.md:block 47 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * Get the post that owns the comment.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 48 (paragraph)
msgid "Once the relationship has been defined, we can retrieve a comment's parent post by accessing the `post` \"dynamic relationship property\":"
msgstr "定義好關聯後，我們就可以通過存取 `post`「動態關聯屬性」來取得留言的上層文章："

#: docs/8.x/eloquent-relationships.md:block 49 (code)
msgid "use App\\Models\\Comment;\n\n"
"$comment = Comment::find(1);\n\n"
"return $comment->post->title;\n"
msgstr "use App\\Models\\Comment;\n\n"
"$comment = Comment::find(1);\n\n"
"return $comment->post->title;\n"

#: docs/8.x/eloquent-relationships.md:block 50 (paragraph)
msgid "In the example above, Eloquent will attempt to find a `Post` model that has an `id` which matches the `post_id` column on the `Comment` model."
msgstr "在上述例子中，Eloquent 會嘗試找到 `id` 符合 `Comments` Model 中 `post_id` 欄位的 `Post` Model。"

#: docs/8.x/eloquent-relationships.md:block 51 (paragraph)
msgid "Eloquent determines the default foreign key name by examining the name of the relationship method and suffixing the method name with a `_` followed by the name of the parent model's primary key column. So, in this example, Eloquent will assume the `Post` model's foreign key on the `comments` table is `post_id`."
msgstr "Eloquent 會檢查關聯方法的名稱，並在該名稱後加上 `_`，然後再加上上層 Model 的主索引鍵欄位名稱作為預設的外部索引鍵名稱。因此，在這個例子中，Eloquent 會假設 `Post` Model 在 `comments` 資料表中的外部索引鍵為 `post_id`。"

#: docs/8.x/eloquent-relationships.md:block 52 (paragraph)
msgid "However, if the foreign key for your relationship does not follow these conventions, you may pass a custom foreign key name as the second argument to the `belongsTo` method:"
msgstr "不過，若沒有依照這種慣例來命名關聯的外部索引鍵，則可以將自訂的外部索引鍵傳遞給 `belongsTo` 方法作為第二個引數："

#: docs/8.x/eloquent-relationships.md:block 53 (code)
msgid "/**\n"
" * Get the post that owns the comment.\n"
" */\n"
"public function post()\n"
"{\n"
"    return $this->belongsTo(Post::class, 'foreign_key');\n"
"}\n"
msgstr "/**\n"
" * Get the post that owns the comment.\n"
" */\n"
"public function post()\n"
"{\n"
"    return $this->belongsTo(Post::class, 'foreign_key');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 54 (paragraph)
msgid "If your parent model does not use `id` as its primary key, or you wish to find the associated model using a different column, you may pass a third argument to the `belongsTo` method specifying your parent table's custom key:"
msgstr "若上層 Model 不使用 `id` 作為其主索引鍵，或是想要使用不同的欄位來尋找關聯的 Model，則可以傳遞第三個引數給 `belongsTo` 方法來指定上層資料表的自訂索引鍵："

#: docs/8.x/eloquent-relationships.md:block 55 (code)
msgid "/**\n"
" * Get the post that owns the comment.\n"
" */\n"
"public function post()\n"
"{\n"
"    return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"}\n"
msgstr "/**\n"
" * Get the post that owns the comment.\n"
" */\n"
"public function post()\n"
"{\n"
"    return $this->belongsTo(Post::class, 'foreign_key', 'owner_key');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 57 (header)
msgid "Default Models"
msgstr "預設 Model"

#: docs/8.x/eloquent-relationships.md:block 58 (paragraph)
msgid "The `belongsTo`, `hasOne`, `hasOneThrough`, and `morphOne` relationships allow you to define a default model that will be returned if the given relationship is `null`. This pattern is often referred to as the [Null Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern) and can help remove conditional checks in your code. In the following example, the `user` relation will return an empty `App\\Models\\User` model if no user is attached to the `Post` model:"
msgstr "`belongsTo`, `hasOne`, `hasOneThrough`, 以及 `morphOne` 關聯可定義一個預設 Model，當給定的關聯為 `null` 時會回傳該預設 Model。這種模式通常稱為 [Null Object pattern](https://en.wikipedia.org/wiki/Null_Object_pattern)，並能讓你在程式碼中減少條件檢查的次數。在下列範例中，`user` 關聯會在沒有使用者附加在 `Post` Model 時回傳一個空的 `App\\Models\\User` Model："

#: docs/8.x/eloquent-relationships.md:block 59 (code)
msgid "/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault();\n"
"}\n"
msgstr "/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault();\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 60 (paragraph)
msgid "To populate the default model with attributes, you may pass an array or closure to the `withDefault` method:"
msgstr "若要為預設的 Model 設定屬性，則可以傳入陣列或閉包給 `withDefault` 方法："

#: docs/8.x/eloquent-relationships.md:block 61 (code)
msgid "/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault([\n"
"        'name' => 'Guest Author',\n"
"    ]);\n"
"}\n\n"
"/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault(function ($user, $post) {\n"
"        $user->name = 'Guest Author';\n"
"    });\n"
"}\n"
msgstr "/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault([\n"
"        'name' => 'Guest Author',\n"
"    ]);\n"
"}\n\n"
"/**\n"
" * Get the author of the post.\n"
" */\n"
"public function user()\n"
"{\n"
"    return $this->belongsTo(User::class)->withDefault(function ($user, $post) {\n"
"        $user->name = 'Guest Author';\n"
"    });\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 63 (header)
msgid "Querying Belongs To Relationships"
msgstr "查詢 Belongs To 關聯"

#: docs/8.x/eloquent-relationships.md:block 64 (paragraph)
msgid "When querying for the children of a \"belongs to\" relationship, you may manually build the `where` clause to retrieve the corresponding Eloquent models:"
msgstr "在查詢「Belongs To」關聯的子項目時，可以手動建立用於取得相應 Eloquent Model 的 `where` 子句："

#: docs/8.x/eloquent-relationships.md:block 65 (code)
msgid "use App\\Models\\Post;\n\n"
"$posts = Post::where('user_id', $user->id)->get();\n"
msgstr "use App\\Models\\Post;\n\n"
"$posts = Post::where('user_id', $user->id)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 66 (paragraph)
msgid "However, you may find it more convenient to use the `whereBelongsTo` method, which will automatically determine the proper relationship and foreign key for the given model:"
msgstr "不過，使用 `whereBelongsTo` 方法可能會比較方便。該方法會為給定的 Model 自動判斷適當的關聯與外部索引鍵："

#: docs/8.x/eloquent-relationships.md:block 67 (code)
msgid "$posts = Post::whereBelongsTo($user)->get();\n"
msgstr "$posts = Post::whereBelongsTo($user)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 68 (paragraph)
msgid "By default, Laravel will determine the relationship associated with the given model based on the class name of the model; however, you may specify the relationship name manually by providing it as the second argument to the `whereBelongsTo` method:"
msgstr "預設情況下，Larave 會依據 Model 的類別名稱來判斷與給定 Model 有關的關聯。不過，我們也可以通過傳入第二個引數給 `whereBelongsTo` 方法來手動指定關聯的名稱："

#: docs/8.x/eloquent-relationships.md:block 69 (code)
msgid "$posts = Post::whereBelongsTo($user, 'author')->get();\n"
msgstr "$posts = Post::whereBelongsTo($user, 'author')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 71 (header)
msgid "Has One Of Many"
msgstr "一對多中之一"

#: docs/8.x/eloquent-relationships.md:block 72 (paragraph)
msgid "Sometimes a model may have many related models, yet you want to easily retrieve the \"latest\" or \"oldest\" related model of the relationship. For example, a `User` model may be related to many `Order` models, but you want to define a convenient way to interact with the most recent order the user has placed. You may accomplish this using the `hasOne` relationship type combined with the `ofMany` methods:"
msgstr "有時候，某個 Model 可能有多個關聯 Model，而我們可能會想取多個關聯 Model 中「最新」或「最舊」的關聯 Model。舉例來說，`User` Model (使用者) 可能會關聯到多個 `Order` Model (訂單)，而我們可能會想定義一種方便的方法來存取使用者最新的訂單。我們可以通過將 `hasOne` 關聯類型與 `ofMany` 方法搭配使用來達成："

#: docs/8.x/eloquent-relationships.md:block 73 (code)
msgid "/**\n"
" * Get the user's most recent order.\n"
" */\n"
"public function latestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->latestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's most recent order.\n"
" */\n"
"public function latestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->latestOfMany();\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 74 (paragraph)
msgid "Likewise, you may define a method to retrieve the \"oldest\", or first, related model of a relationship:"
msgstr "同樣的，我們也可以定義一個方法來取得一個關聯中「最舊」或第一個關聯的 Model："

#: docs/8.x/eloquent-relationships.md:block 75 (code)
msgid "/**\n"
" * Get the user's oldest order.\n"
" */\n"
"public function oldestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->oldestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's oldest order.\n"
" */\n"
"public function oldestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->oldestOfMany();\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 76 (paragraph)
msgid "By default, the `latestOfMany` and `oldestOfMany` methods will retrieve the latest or oldest related model based on the model's primary key, which must be sortable. However, sometimes you may wish to retrieve a single model from a larger relationship using a different sorting criteria."
msgstr "預設情況下，`latestOfMany` 與 `oldestOfMany` 方法會依照該 Model 的主索引鍵來取得最新或最舊的 Model，而該索引鍵必須要是可以排序的。不過，有時候我們可能會想從一個更大的關聯中通過另一種方法來取得單一 Model："

#: docs/8.x/eloquent-relationships.md:block 77 (paragraph)
msgid "For example, using the `ofMany` method, you may retrieve the user's most expensive order. The `ofMany` method accepts the sortable column as its first argument and which aggregate function (`min` or `max`) to apply when querying for the related model:"
msgstr "舉例來說，我們可以使用 `ofMany` 方法來去的使用者下過金額最高的訂單。`ofMany` 方法的第一個引數為可排序的欄位，接著則是要套用哪個匯總函式 (`min` 或 `max` 等) 在關聯的 Model 上："

#: docs/8.x/eloquent-relationships.md:block 78 (code)
msgid "/**\n"
" * Get the user's largest order.\n"
" */\n"
"public function largestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->ofMany('price', 'max');\n"
"}\n"
msgstr "/**\n"
" * Get the user's largest order.\n"
" */\n"
"public function largestOrder()\n"
"{\n"
"    return $this->hasOne(Order::class)->ofMany('price', 'max');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 79 (quote)
msgid "{note} Because PostgreSQL does not support executing the `MAX` function against UUID columns, it is not currently possible to use one-of-many relationships in combination with PostgreSQL UUID columns."
msgstr "{note} 由於 PostgreSQL 不支援在 UUID 欄位上執行 `MAX` 函式，因此目前一對多關聯無法搭配 PostgreSQL 的 UUID 欄位使用。"

#: docs/8.x/eloquent-relationships.md:block 81 (header)
msgid "Advanced Has One Of Many Relationships"
msgstr "進階的一對多中之一關聯"

#: docs/8.x/eloquent-relationships.md:block 82 (paragraph)
msgid "It is possible to construct more advanced \"has one of many\" relationships. For example, A `Product` model may have many associated `Price` models that are retained in the system even after new pricing is published. In addition, new pricing data for the product may be able to be published in advance to take effect at a future date via a `published_at` column."
msgstr "我們還可以進一步地做出進階的「一對多中之一」關聯。舉例來說，`Product` Model 可能會有許多相應的 `Price` Model，這些 `Price` Model 會在每次更新商品價格後保留在系統內。此外，我們也可以進一步地通過 `published_at` 欄位來讓某個商品價格在未來的時間點生效。"

#: docs/8.x/eloquent-relationships.md:block 83 (paragraph)
msgid "So, in summary, we need to retrieve the latest published pricing where the published date is not in the future. In addition, if two prices have the same published date, we will prefer the price with the greatest ID. To accomplish this, we must pass an array to the `ofMany` method that contains the sortable columns which determine the latest price. In addition, a closure will be provided as the second argument to the `ofMany` method. This closure will be responsible for adding additional publish date constraints to the relationship query:"
msgstr "因此，總結一下，我們會需要取得最新且已發布的價格，且發佈時間不可是未來。此外，若有兩個價格的發佈時間相同，則我們取 ID 最大的那個價格。為此，我們必須傳入一個陣列給 `ofMany` 方法，該陣列序包用來判斷最新價格的可排序欄位。此外，我們會提供一個閉包給 `ofMany` 方法作為第二個引述。這個閉包會負責為關聯查詢加上額外的發佈時間條件："

#: docs/8.x/eloquent-relationships.md:block 84 (code)
msgid "/**\n"
" * Get the current pricing for the product.\n"
" */\n"
"public function currentPricing()\n"
"{\n"
"    return $this->hasOne(Price::class)->ofMany([\n"
"        'published_at' => 'max',\n"
"        'id' => 'max',\n"
"    ], function ($query) {\n"
"        $query->where('published_at', '<', now());\n"
"    });\n"
"}\n"
msgstr "/**\n"
" * Get the current pricing for the product.\n"
" */\n"
"public function currentPricing()\n"
"{\n"
"    return $this->hasOne(Price::class)->ofMany([\n"
"        'published_at' => 'max',\n"
"        'id' => 'max',\n"
"    ], function ($query) {\n"
"        $query->where('published_at', '<', now());\n"
"    });\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 86 (header)
msgid "Has One Through"
msgstr "間接一對一"

#: docs/8.x/eloquent-relationships.md:block 87 (paragraph)
msgid "The \"has-one-through\" relationship defines a one-to-one relationship with another model. However, this relationship indicates that the declaring model can be matched with one instance of another model by proceeding *through* a third model."
msgstr "「間接一對一 (has-one-through)」關聯定義了與另一個 Model 間的一對一關係。不過，使用這種關聯代表宣告關聯的 Model 可以 **通過** 一個 Model 來對應到另一個 Model 的實體。"

#: docs/8.x/eloquent-relationships.md:block 88 (paragraph)
msgid "For example, in a vehicle repair shop application, each `Mechanic` model may be associated with one `Car` model, and each `Car` model may be associated with one `Owner` model. While the mechanic and the owner have no direct relationship within the database, the mechanic can access the owner *through* the `Car` model. Let's look at the tables necessary to define this relationship:"
msgstr "舉例來說，在汽車維修網站中，每個 `Mechanic` Model (零件) 可以跟一個 `Car` Model 關聯。而每個 `Car` Model (汽車) 則可以關聯到一個 `Owner` Model (車主)。雖然零件與車主在資料庫中並沒有直接的關聯性，但我們可以 **通過** `Car` Model 來在零件上存取車主。來看看要定義這種關聯所需的資料表："

#: docs/8.x/eloquent-relationships.md:block 89 (code)
msgid "mechanics\n"
"    id - integer\n"
"    name - string\n\n"
"cars\n"
"    id - integer\n"
"    model - string\n"
"    mechanic_id - integer\n\n"
"owners\n"
"    id - integer\n"
"    name - string\n"
"    car_id - integer\n"
msgstr "mechanics\n"
"    id - integer\n"
"    name - string\n\n"
"cars\n"
"    id - integer\n"
"    model - string\n"
"    mechanic_id - integer\n\n"
"owners\n"
"    id - integer\n"
"    name - string\n"
"    car_id - integer\n"

#: docs/8.x/eloquent-relationships.md:block 90 (paragraph)
msgid "Now that we have examined the table structure for the relationship, let's define the relationship on the `Mechanic` model:"
msgstr "現在，我們已經瞭解了這種關聯性的資料表結構。讓我們來在 `Mechanic` Model 上定義關聯："

#: docs/8.x/eloquent-relationships.md:block 91 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Mechanic extends Model\n"
"{\n"
"    /**\n"
"     * Get the car's owner.\n"
"     */\n"
"    public function carOwner()\n"
"    {\n"
"        return $this->hasOneThrough(Owner::class, Car::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Mechanic extends Model\n"
"{\n"
"    /**\n"
"     * Get the car's owner.\n"
"     */\n"
"    public function carOwner()\n"
"    {\n"
"        return $this->hasOneThrough(Owner::class, Car::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 92 (paragraph)
msgid "The first argument passed to the `hasOneThrough` method is the name of the final model we wish to access, while the second argument is the name of the intermediate model."
msgstr "傳給 `hasOneThrough` 方法的第一個引述是最後我們想存取的 Model 名稱；第二個引數則是中介 Model 的名稱。"

#: docs/8.x/eloquent-relationships.md:block 94 (header)
msgid "Key Conventions"
msgstr "索引鍵慣例"

#: docs/8.x/eloquent-relationships.md:block 95 (paragraph)
msgid "Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the `hasOneThrough` method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:"
msgstr "在進行關聯查詢時，會使用到典型的 Eloquent 外部索引鍵慣例。若想自訂關聯使用的索引鍵，則可以將自訂索引鍵傳給 `hasOneThrough` 方法的第三個與第四個引數。第三個引數為中介 Model 上的外部索引鍵名稱。第四個引數則是最終 Model 的外部索引鍵名稱。第五個引數則為內部索引鍵，而第六個引述則是中介 Model 上的內部索引鍵："

#: docs/8.x/eloquent-relationships.md:block 96 (code)
msgid "class Mechanic extends Model\n"
"{\n"
"    /**\n"
"     * Get the car's owner.\n"
"     */\n"
"    public function carOwner()\n"
"    {\n"
"        return $this->hasOneThrough(\n"
"            Owner::class,\n"
"            Car::class,\n"
"            'mechanic_id', // Foreign key on the cars table...\n"
"            'car_id', // Foreign key on the owners table...\n"
"            'id', // Local key on the mechanics table...\n"
"            'id' // Local key on the cars table...\n"
"        );\n"
"    }\n"
"}\n"
msgstr "class Mechanic extends Model\n"
"{\n"
"    /**\n"
"     * Get the car's owner.\n"
"     */\n"
"    public function carOwner()\n"
"    {\n"
"        return $this->hasOneThrough(\n"
"            Owner::class,\n"
"            Car::class,\n"
"            'mechanic_id', // cars 表上的外部索引鍵...\n"
"            'car_id', // owners 表上的外部索引鍵...\n"
"            'id', // mechanics 表上的內部索引鍵...\n"
"            'id' // cars 表上的內部索引鍵...\n"
"        );\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 98 (header)
msgid "Has Many Through"
msgstr "間接一對多"

#: docs/8.x/eloquent-relationships.md:block 99 (paragraph)
msgid "The \"has-many-through\" relationship provides a convenient way to access distant relations via an intermediate relation. For example, let's assume we are building a deployment platform like [Laravel Vapor](https://vapor.laravel.com). A `Project` model might access many `Deployment` models through an intermediate `Environment` model. Using this example, you could easily gather all deployments for a given project. Let's look at the tables required to define this relationship:"
msgstr "「間接一對多 (has-many-through)」關聯提供了一個方便的方法來通過中介關聯存取另一個關聯。舉例來說，假設我們有一個像 [Laravel Vapor](https://vapor.laravel.com) 這樣的部署平台。`Project` Model (專案)可通過一個中介的 `Environment` Model (環境) 來存取多個 `Deployment` Model (部署)。依照這個例子，我們可以很輕鬆的取得特定專案的所有部署。來看看定義這個關聯性所需的資料表："

#: docs/8.x/eloquent-relationships.md:block 100 (code)
msgid "projects\n"
"    id - integer\n"
"    name - string\n\n"
"environments\n"
"    id - integer\n"
"    project_id - integer\n"
"    name - string\n\n"
"deployments\n"
"    id - integer\n"
"    environment_id - integer\n"
"    commit_hash - string\n"
msgstr "projects\n"
"    id - integer\n"
"    name - string\n\n"
"environments\n"
"    id - integer\n"
"    project_id - integer\n"
"    name - string\n\n"
"deployments\n"
"    id - integer\n"
"    environment_id - integer\n"
"    commit_hash - string\n"

#: docs/8.x/eloquent-relationships.md:block 101 (paragraph)
msgid "Now that we have examined the table structure for the relationship, let's define the relationship on the `Project` model:"
msgstr "現在，我們已經瞭解了這種關聯性的資料表結構。讓我們來在 `Project` Model 上定義關聯："

#: docs/8.x/eloquent-relationships.md:block 102 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Project extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the deployments for the project.\n"
"     */\n"
"    public function deployments()\n"
"    {\n"
"        return $this->hasManyThrough(Deployment::class, Environment::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Project extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the deployments for the project.\n"
"     */\n"
"    public function deployments()\n"
"    {\n"
"        return $this->hasManyThrough(Deployment::class, Environment::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 103 (paragraph)
msgid "The first argument passed to the `hasManyThrough` method is the name of the final model we wish to access, while the second argument is the name of the intermediate model."
msgstr "傳給 `hasManyThrough` 方法的第一個引述是最後我們想存取的 Model 名稱；第二個引數則是中介 Model 的名稱。"

#: docs/8.x/eloquent-relationships.md:block 104 (paragraph)
msgid "Though the `Deployment` model's table does not contain a `project_id` column, the `hasManyThrough` relation provides access to a project's deployments via `$project->deployments`. To retrieve these models, Eloquent inspects the `project_id` column on the intermediate `Environment` model's table. After finding the relevant environment IDs, they are used to query the `Deployment` model's table."
msgstr "雖然 `Deployment` Model 的資料表不包含 `project_id` 欄位，但 `hasManyThrough` 關聯可讓我們通過 `$project->deployments` 來存取專案的部署。為了取得這些 Model，Eloquent 會先在中介的 `Environment` Model 資料表上讀取 `project_id`。找到相關的環境 ID 後，再通過這些 ID 來查詢 `Deployment` Model 的資料表。"

#: docs/8.x/eloquent-relationships.md:block 107 (paragraph)
msgid "Typical Eloquent foreign key conventions will be used when performing the relationship's queries. If you would like to customize the keys of the relationship, you may pass them as the third and fourth arguments to the `hasManyThrough` method. The third argument is the name of the foreign key on the intermediate model. The fourth argument is the name of the foreign key on the final model. The fifth argument is the local key, while the sixth argument is the local key of the intermediate model:"
msgstr "在進行關聯查詢時，會使用到典型的 Eloquent 外部索引鍵慣例。若想自訂關聯使用的索引鍵，則可以將自訂索引鍵傳給 `hasManyThrough` 方法的第三個與第四個引數。第三個引數為中介 Model 上的外部索引鍵名稱。第四個引數則是最終 Model 的外部索引鍵名稱。第五個引數則為內部索引鍵，而第六個引述則是中介 Model 上的內部索引鍵："

#: docs/8.x/eloquent-relationships.md:block 108 (code)
msgid "class Project extends Model\n"
"{\n"
"    public function deployments()\n"
"    {\n"
"        return $this->hasManyThrough(\n"
"            Deployment::class,\n"
"            Environment::class,\n"
"            'project_id', // Foreign key on the environments table...\n"
"            'environment_id', // Foreign key on the deployments table...\n"
"            'id', // Local key on the projects table...\n"
"            'id' // Local key on the environments table...\n"
"        );\n"
"    }\n"
"}\n"
msgstr "class Project extends Model\n"
"{\n"
"    public function deployments()\n"
"    {\n"
"        return $this->hasManyThrough(\n"
"            Deployment::class,\n"
"            Environment::class,\n"
"            'project_id', // environments 表上的外部索引鍵...\n"
"            'environment_id', // deployments 表上的外部索引鍵...\n"
"            'id', // projects 表上的內部索引鍵...\n"
"            'id' // environments 表上的內部索引鍵...\n"
"        );\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 110 (header)
msgid "Many To Many Relationships"
msgstr "Many To Many 關聯"

#: docs/8.x/eloquent-relationships.md:block 111 (paragraph)
msgid "Many-to-many relations are slightly more complicated than `hasOne` and `hasMany` relationships. An example of a many-to-many relationship is a user that has many roles and those roles are also shared by other users in the application. For example, a user may be assigned the role of \"Author\" and \"Editor\"; however, those roles may also be assigned to other users as well. So, a user has many roles and a role has many users."
msgstr "比起 `hasOne` 或 `hasMany`，多對多關聯稍微複雜一點。一個多對多關聯的例子是：一位使用者可以有多個職位，而這些職位也會被網站中的其他使用者使用。舉例來說，某位使用者可能會被設定職位「作者」與「編輯」，但這些職位也可能會被指派給其他使用者。因此，一位使用者可以有多個職位，而一個職位則可以有多位使用者。"

#: docs/8.x/eloquent-relationships.md:block 113 (header)
msgid "Table Structure"
msgstr "資料表結構"

#: docs/8.x/eloquent-relationships.md:block 114 (paragraph)
msgid "To define this relationship, three database tables are needed: `users`, `roles`, and `role_user`. The `role_user` table is derived from the alphabetical order of the related model names and contains `user_id` and `role_id` columns. This table is used as an intermediate table linking the users and roles."
msgstr "要定義這種關聯，我們需要三張資料表：`users`, `roles`, 與 `role_user`。`role_user` 資料表的名稱是由關聯的 Model 名稱按照字母排序串接而來的，裡面包含了 `user_id` 與 `role_id` 欄位。這張資料表會用來作為關聯使用者與職位的中介資料表。"

#: docs/8.x/eloquent-relationships.md:block 115 (paragraph)
msgid "Remember, since a role can belong to many users, we cannot simply place a `user_id` column on the `roles` table. This would mean that a role could only belong to a single user. In order to provide support for roles being assigned to multiple users, the `role_user` table is needed. We can summarize the relationship's table structure like so:"
msgstr "請記得，由於一個職位可以同時關聯到多位使用者，因此我們沒辦法在 `roles` 資料表上設定 `user_id` 欄位。若這麼做的話，一個職位就只能有一位使用者。為了要讓職位能被設定給多位使用者，我們會需要 `role_user` 資料表。我們可以總結一下，資料表的結構會長這樣："

#: docs/8.x/eloquent-relationships.md:block 116 (code)
msgid "users\n"
"    id - integer\n"
"    name - string\n\n"
"roles\n"
"    id - integer\n"
"    name - string\n\n"
"role_user\n"
"    user_id - integer\n"
"    role_id - integer\n"
msgstr "users\n"
"    id - integer\n"
"    name - string\n\n"
"roles\n"
"    id - integer\n"
"    name - string\n\n"
"role_user\n"
"    user_id - integer\n"
"    role_id - integer\n"

#: docs/8.x/eloquent-relationships.md:block 118 (header)
msgid "Model Structure"
msgstr "Model 架構"

#: docs/8.x/eloquent-relationships.md:block 119 (paragraph)
msgid "Many-to-many relationships are defined by writing a method that returns the result of the `belongsToMany` method. The `belongsToMany` method is provided by the `Illuminate\\Database\\Eloquent\\Model` base class that is used by all of your application's Eloquent models. For example, let's define a `roles` method on our `User` model. The first argument passed to this method is the name of the related model class:"
msgstr "我們可以通過撰寫一個回傳 `belongsToMany` 方法執行結果的方法來定義多對多關聯。`belongsToMany` 方法是由 `Illuminate\\Database\\Eloquent\\Model` 基礎類別提供的，你的專案中所有的 Eloquent Model 都使用了這個類別。舉例來說，讓我們來在 `User` Model 上定義一個 `roles` 方法。傳入這個方法的第一個引述是關聯 Model 類別的名稱："

#: docs/8.x/eloquent-relationships.md:block 120 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * The roles that belong to the user.\n"
"     */\n"
"    public function roles()\n"
"    {\n"
"        return $this->belongsToMany(Role::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * The roles that belong to the user.\n"
"     */\n"
"    public function roles()\n"
"    {\n"
"        return $this->belongsToMany(Role::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 121 (paragraph)
msgid "Once the relationship is defined, you may access the user's roles using the `roles` dynamic relationship property:"
msgstr "定義好關聯後，就可以使用 `roles` 動態關聯屬性來存取該使用者的角色："

#: docs/8.x/eloquent-relationships.md:block 122 (code)
msgid "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->roles as $role) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->roles as $role) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 123 (paragraph)
msgid "Since all relationships also serve as query builders, you may add further constraints to the relationship query by calling the `roles` method and continuing to chain conditions onto the query:"
msgstr "由於所有的關聯也同時是 Query Builder，因此我們也能通過呼叫 `roles` 方法並繼續在查詢上串上條件來進一步給關聯加上查詢條件："

#: docs/8.x/eloquent-relationships.md:block 124 (code)
msgid "$roles = User::find(1)->roles()->orderBy('name')->get();\n"
msgstr "$roles = User::find(1)->roles()->orderBy('name')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 125 (paragraph)
msgid "To determine the table name of the relationship's intermediate table, Eloquent will join the two related model names in alphabetical order. However, you are free to override this convention. You may do so by passing a second argument to the `belongsToMany` method:"
msgstr "為了判斷該關聯的中介資料表表名，Eloquent 會將兩個關聯 Model 的名稱按照字母排序串接在一起。不過，這個慣例是可以隨意複寫的，只需要傳入第二個引數給 `belongsToMany` 方法即可："

#: docs/8.x/eloquent-relationships.md:block 126 (code)
msgid "return $this->belongsToMany(Role::class, 'role_user');\n"
msgstr "return $this->belongsToMany(Role::class, 'role_user');\n"

#: docs/8.x/eloquent-relationships.md:block 127 (paragraph)
msgid "In addition to customizing the name of the intermediate table, you may also customize the column names of the keys on the table by passing additional arguments to the `belongsToMany` method. The third argument is the foreign key name of the model on which you are defining the relationship, while the fourth argument is the foreign key name of the model that you are joining to:"
msgstr "除了自訂中介表的表名外，也可以傳入額外的引數給 `belongsToMany` 來自訂中介表上的欄位名稱。第三個引數目前定義關聯的 Model 的外部索引鍵，而第四個引述則是要連結的 Model 的外部索引鍵："

#: docs/8.x/eloquent-relationships.md:block 128 (code)
msgid "return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\n"
msgstr "return $this->belongsToMany(Role::class, 'role_user', 'user_id', 'role_id');\n"

#: docs/8.x/eloquent-relationships.md:block 131 (paragraph)
msgid "To define the \"inverse\" of a many-to-many relationship, you should define a method on the related model which also returns the result of the `belongsToMany` method. To complete our user / role example, let's define the `users` method on the `Role` model:"
msgstr "若要定義 many-to-many 的「相反」關聯，應先在關聯的 Model 上定義一個同樣回傳 `belongsToMany` 方法結果的方法。接著我們的使用者與角色的例子，我們來在 `Role` Model 上定義 `users` 方法："

#: docs/8.x/eloquent-relationships.md:block 132 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Role extends Model\n"
"{\n"
"    /**\n"
"     * The users that belong to the role.\n"
"     */\n"
"    public function users()\n"
"    {\n"
"        return $this->belongsToMany(User::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Role extends Model\n"
"{\n"
"    /**\n"
"     * The users that belong to the role.\n"
"     */\n"
"    public function users()\n"
"    {\n"
"        return $this->belongsToMany(User::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 133 (paragraph)
msgid "As you can see, the relationship is defined exactly the same as its `User` model counterpart with the exception of referencing the `App\\Models\\User` model. Since we're reusing the `belongsToMany` method, all of the usual table and key customization options are available when defining the \"inverse\" of many-to-many relationships."
msgstr "如你所見，除了這邊是參照 `App\\Models\\User` 外，關聯定義跟 `User` Model 中對應的部分完全一樣。由於我們使用的還是 `belongsToMany` 方法，因此，在定義「反向」的 many-to-many 關聯時，一樣可以使用一般的資料表與索引鍵自訂選項。"

#: docs/8.x/eloquent-relationships.md:block 135 (header)
msgid "Retrieving Intermediate Table Columns"
msgstr "取得中介資料表欄位"

#: docs/8.x/eloquent-relationships.md:block 136 (paragraph)
msgid "As you have already learned, working with many-to-many relations requires the presence of an intermediate table. Eloquent provides some very helpful ways of interacting with this table. For example, let's assume our `User` model has many `Role` models that it is related to. After accessing this relationship, we may access the intermediate table using the `pivot` attribute on the models:"
msgstr "讀者可能已經瞭解到，處理 Many-to-Many 關聯時必須要有一張中介資料表。Eloquent 提供了一些非常適用的方法來與中介資料表互動。舉例來說，假設 `User` Model 有許多關聯的 `Role` Model。存取這個關聯後，我們可以使用 Model 上的 `pivot` 屬性來存取中介資料表："

#: docs/8.x/eloquent-relationships.md:block 137 (code)
msgid "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->roles as $role) {\n"
"    echo $role->pivot->created_at;\n"
"}\n"
msgstr "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->roles as $role) {\n"
"    echo $role->pivot->created_at;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 138 (paragraph)
msgid "Notice that each `Role` model we retrieve is automatically assigned a `pivot` attribute. This attribute contains a model representing the intermediate table."
msgstr "可以注意到，我們取得的每個 `Role` 資料表都會自動獲得一個 `pivot` 屬性。這個屬性包含了一個代表中介資料表的 Model。"

#: docs/8.x/eloquent-relationships.md:block 139 (paragraph)
msgid "By default, only the model keys will be present on the `pivot` model. If your intermediate table contains extra attributes, you must specify them when defining the relationship:"
msgstr "預設情況下，只有 Model 的索引鍵會出現在 `Pivot` Model 上。若中介資料表包含了其他額外的屬性，則需要在定義關聯時指定這些屬性："

#: docs/8.x/eloquent-relationships.md:block 140 (code)
msgid "return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\n"
msgstr "return $this->belongsToMany(Role::class)->withPivot('active', 'created_by');\n"

#: docs/8.x/eloquent-relationships.md:block 141 (paragraph)
msgid "If you would like your intermediate table to have `created_at` and `updated_at` timestamps that are automatically maintained by Eloquent, call the `withTimestamps` method when defining the relationship:"
msgstr "若想讓中介資料表擁有 Eloquent 能自動維護的 `created_at` 與 `updated_at` 時戳，可在定義關聯的時候呼叫 `withTimestamps` 方法："

#: docs/8.x/eloquent-relationships.md:block 142 (code)
msgid "return $this->belongsToMany(Role::class)->withTimestamps();\n"
msgstr "return $this->belongsToMany(Role::class)->withTimestamps();\n"

#: docs/8.x/eloquent-relationships.md:block 143 (quote)
msgid "{note} Intermediate tables that utilize Eloquent's automatically maintained timestamps are required to have both `created_at` and `updated_at` timestamp columns."
msgstr "{note} 使用 Eloquent 自動維護時戳的中介資料表會需要擁有 `created_at` 與 `updated_at` 兩個時戳欄位。"

#: docs/8.x/eloquent-relationships.md:block 145 (header)
msgid "Customizing The `pivot` Attribute Name"
msgstr "自訂 `pivot` 屬性名稱"

#: docs/8.x/eloquent-relationships.md:block 146 (paragraph)
msgid "As noted previously, attributes from the intermediate table may be accessed on models via the `pivot` attribute. However, you are free to customize the name of this attribute to better reflect its purpose within your application."
msgstr "剛才也有提過，我們可以使用 `pivot` 屬性來存取中介資料表的屬性。不過，我們可以自訂這個屬性的名稱以讓其跟貼合在專案中的用途。"

#: docs/8.x/eloquent-relationships.md:block 147 (paragraph)
msgid "For example, if your application contains users that may subscribe to podcasts, you likely have a many-to-many relationship between users and podcasts. If this is the case, you may wish to rename your intermediate table attribute to `subscription` instead of `pivot`. This can be done using the `as` method when defining the relationship:"
msgstr "舉例來說，我們的專案中可能會包含能讓使用者訂閱 Podcast 的功能，我們可能會想在使用者與 Podcast 間使用 Many-to-Many 關聯。在這個例子中，我們可能會想將中介資料表屬性的名稱從 `pivot` 改成 `subscription`。可以在定義關聯時使用 `as` 方法來完成："

#: docs/8.x/eloquent-relationships.md:block 148 (code)
msgid "return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscription')\n"
"                ->withTimestamps();\n"
msgstr "return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscription')\n"
"                ->withTimestamps();\n"

#: docs/8.x/eloquent-relationships.md:block 149 (paragraph)
msgid "Once the custom intermediate table attribute has been specified, you may access the intermediate table data using the customized name:"
msgstr "指定好自訂的中介資料表屬性後，就可以使用自訂的名稱來存取中介資料表資料："

#: docs/8.x/eloquent-relationships.md:block 150 (code)
msgid "$users = User::with('podcasts')->get();\n\n"
"foreach ($users->flatMap->podcasts as $podcast) {\n"
"    echo $podcast->subscription->created_at;\n"
"}\n"
msgstr "$users = User::with('podcasts')->get();\n\n"
"foreach ($users->flatMap->podcasts as $podcast) {\n"
"    echo $podcast->subscription->created_at;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 152 (header)
msgid "Filtering Queries Via Intermediate Table Columns"
msgstr "通過中介資料表欄位來過濾查詢"

#: docs/8.x/eloquent-relationships.md:block 153 (paragraph)
msgid "You can also filter the results returned by `belongsToMany` relationship queries using the `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, `wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, and `wherePivotNotNull` methods when defining the relationship:"
msgstr "也可以在定義關聯時使用 `wherePivot`, `wherePivotIn`, `wherePivotNotIn`, `wherePivotBetween`, `wherePivotNotBetween`, `wherePivotNull`, 與 `wherePivotNotNull` 方法來過濾 `belongsToMany` 關聯查詢的回傳結果："

#: docs/8.x/eloquent-relationships.md:block 154 (code)
msgid "return $this->belongsToMany(Role::class)\n"
"                ->wherePivot('approved', 1);\n\n"
"return $this->belongsToMany(Role::class)\n"
"                ->wherePivotIn('priority', [1, 2]);\n\n"
"return $this->belongsToMany(Role::class)\n"
"                ->wherePivotNotIn('priority', [1, 2]);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNull('expired_at');\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNotNull('expired_at');\n"
msgstr "return $this->belongsToMany(Role::class)\n"
"                ->wherePivot('approved', 1);\n\n"
"return $this->belongsToMany(Role::class)\n"
"                ->wherePivotIn('priority', [1, 2]);\n\n"
"return $this->belongsToMany(Role::class)\n"
"                ->wherePivotNotIn('priority', [1, 2]);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNotBetween('created_at', ['2020-01-01 00:00:00', '2020-12-31 00:00:00']);\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNull('expired_at');\n\n"
"return $this->belongsToMany(Podcast::class)\n"
"                ->as('subscriptions')\n"
"                ->wherePivotNotNull('expired_at');\n"

#: docs/8.x/eloquent-relationships.md:block 156 (header)
msgid "Defining Custom Intermediate Table Models"
msgstr "定義自訂的中介表 Model"

#: docs/8.x/eloquent-relationships.md:block 157 (paragraph)
msgid "If you would like to define a custom model to represent the intermediate table of your many-to-many relationship, you may call the `using` method when defining the relationship. Custom pivot models give you the opportunity to define additional methods on the pivot model."
msgstr "若想定義一個代表多對多關聯之中介資料表的自訂 Model，則可以在定義關聯時呼叫 `using` 方法。自訂樞紐 Model (Pivot Model) 能讓我們有機會在樞紐 Model 上定義一些額外的方法。"

#: docs/8.x/eloquent-relationships.md:block 158 (paragraph)
msgid "Custom many-to-many pivot models should extend the `Illuminate\\Database\\Eloquent\\Relations\\Pivot` class while custom polymorphic many-to-many pivot models should extend the `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot` class. For example, we may define a `Role` model which uses a custom `RoleUser` pivot model:"
msgstr "要自訂多對多樞紐 Model，則應繼承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 類別。多型多對多的樞紐 Model 則應繼承 `Illuminate\\Database\\Eloquent\\Relations\\MorphPivot`。舉例來說，我們可以定義一個使用了 `RoleUser` 樞紐 Model 的` Role` Model："

#: docs/8.x/eloquent-relationships.md:block 159 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Role extends Model\n"
"{\n"
"    /**\n"
"     * The users that belong to the role.\n"
"     */\n"
"    public function users()\n"
"    {\n"
"        return $this->belongsToMany(User::class)->using(RoleUser::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Role extends Model\n"
"{\n"
"    /**\n"
"     * The users that belong to the role.\n"
"     */\n"
"    public function users()\n"
"    {\n"
"        return $this->belongsToMany(User::class)->using(RoleUser::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 160 (paragraph)
msgid "When defining the `RoleUser` model, you should extend the `Illuminate\\Database\\Eloquent\\Relations\\Pivot` class:"
msgstr "定義 `RoleUser` Model 時，應繼承 `Illuminate\\Database\\Eloquent\\Relations\\Pivot` 類別："

#: docs/8.x/eloquent-relationships.md:block 161 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n\n"
"class RoleUser extends Pivot\n"
"{\n"
"    //\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Relations\\Pivot;\n\n"
"class RoleUser extends Pivot\n"
"{\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 162 (quote)
msgid "{note} Pivot models may not use the `SoftDeletes` trait. If you need to soft delete pivot records consider converting your pivot model to an actual Eloquent model."
msgstr "{note} 樞紐 Model 不能使用 `SoftDeletes` Trait。若有需要對樞紐紀錄作軟刪除，請考慮將樞紐 Model 改寫成真正的 Eloquent Model。"

#: docs/8.x/eloquent-relationships.md:block 164 (header)
msgid "Custom Pivot Models And Incrementing IDs"
msgstr "自訂樞紐 Model 並遞增 ID"

#: docs/8.x/eloquent-relationships.md:block 165 (paragraph)
msgid "If you have defined a many-to-many relationship that uses a custom pivot model, and that pivot model has an auto-incrementing primary key, you should ensure your custom pivot model class defines an `incrementing` property that is set to `true`."
msgstr "若有定義了使用自訂樞紐 Model 的多對多關聯，且該樞紐 Model 由自動遞增的主索引鍵 (Auto-Incrementing Primary Key)，則應確保這個自訂樞紐 Model 類別由定義一個設為 `true` 的 `incrementing` 屬性。"

#: docs/8.x/eloquent-relationships.md:block 166 (code)
msgid "/**\n"
" * Indicates if the IDs are auto-incrementing.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $incrementing = true;\n"
msgstr "/**\n"
" * Indicates if the IDs are auto-incrementing.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $incrementing = true;\n"

#: docs/8.x/eloquent-relationships.md:block 168 (header)
msgid "Polymorphic Relationships"
msgstr "Polymorphic (多型) 關聯"

#: docs/8.x/eloquent-relationships.md:block 169 (paragraph)
msgid "A polymorphic relationship allows the child model to belong to more than one type of model using a single association. For example, imagine you are building an application that allows users to share blog posts and videos. In such an application, a `Comment` model might belong to both the `Post` and `Video` models."
msgstr "使用多型關聯，就能讓子 Model 通過單一關聯來隸屬於多種 Model。舉例來說，假設我們正在製作一個能讓使用者分享部落格貼文與影片的網站。在這種例子中，`Comment` (留言) Model 有可能隸屬於 `Post` (貼文) Model，也可能隸屬於 `Video` (影片) Model。"

#: docs/8.x/eloquent-relationships.md:block 171 (header)
msgid "One To One (Polymorphic)"
msgstr "一對一 (多型)"

#: docs/8.x/eloquent-relationships.md:block 174 (paragraph)
msgid "A one-to-one polymorphic relation is similar to a typical one-to-one relation; however, the child model can belong to more than one type of model using a single association. For example, a blog `Post` and a `User` may share a polymorphic relation to an `Image` model. Using a one-to-one polymorphic relation allows you to have a single table of unique images that may be associated with posts and users. First, let's examine the table structure:"
msgstr "多型的一對一關聯於一般的一對一關聯類似。不過，在這種關聯中的子 Model 可以使用一種關聯來表示出對超過一種 Model 的從屬關係。舉例來說，部落格的 `Post` (貼文) 與 `User` (使用者) 可能會共享一個多型關聯的 `Image` (圖片) Model。使用多型的一對一關聯，就能讓我們製作一張用來儲存不重複圖片的資料表，並將該資料表關聯到貼文跟使用者上。首先，我們來看看下列資料表架構："

#: docs/8.x/eloquent-relationships.md:block 175 (code)
msgid "posts\n"
"    id - integer\n"
"    name - string\n\n"
"users\n"
"    id - integer\n"
"    name - string\n\n"
"images\n"
"    id - integer\n"
"    url - string\n"
"    imageable_id - integer\n"
"    imageable_type - string\n"
msgstr "posts\n"
"    id - integer\n"
"    name - string\n\n"
"users\n"
"    id - integer\n"
"    name - string\n\n"
"images\n"
"    id - integer\n"
"    url - string\n"
"    imageable_id - integer\n"
"    imageable_type - string\n"

#: docs/8.x/eloquent-relationships.md:block 176 (paragraph)
msgid "Note the `imageable_id` and `imageable_type` columns on the `images` table. The `imageable_id` column will contain the ID value of the post or user, while the `imageable_type` column will contain the class name of the parent model. The `imageable_type` column is used by Eloquent to determine which \"type\" of parent model to return when accessing the `imageable` relation. In this case, the column would contain either `App\\Models\\Post` or `App\\Models\\User`."
msgstr "可以注意到 `images` 資料表上的 `imageable_id` 與 `imageable_type` 欄位。`imageable_id` 欄位用來包含貼文或使用者的 ID 值，而 `imageable_type` 欄位則用來包含上層 Model 的類別名稱。`imageable_type` 是用來給 Eloquent 判斷上層 Model 的「型別 (Type)」，以在存取 `imageable` 關聯時能回傳該上層 Model。在這種情況下，這個欄位的內容會是 `App\\Models\\Post` 或 `App\\Models\\User`。"

#: docs/8.x/eloquent-relationships.md:block 179 (paragraph)
msgid "Next, let's examine the model definitions needed to build this relationship:"
msgstr "接著，讓我們來看看要製作這種關聯所需要的 Model 定義："

#: docs/8.x/eloquent-relationships.md:block 180 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Image extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent imageable model (user or post).\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get the post's image.\n"
"     */\n"
"    public function image()\n"
"    {\n"
"        return $this->morphOne(Image::class, 'imageable');\n"
"    }\n"
"}\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get the user's image.\n"
"     */\n"
"    public function image()\n"
"    {\n"
"        return $this->morphOne(Image::class, 'imageable');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Image extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent imageable model (user or post).\n"
"     */\n"
"    public function imageable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get the post's image.\n"
"     */\n"
"    public function image()\n"
"    {\n"
"        return $this->morphOne(Image::class, 'imageable');\n"
"    }\n"
"}\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get the user's image.\n"
"     */\n"
"    public function image()\n"
"    {\n"
"        return $this->morphOne(Image::class, 'imageable');\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 182 (header)
msgid "Retrieving The Relationship"
msgstr "取得關聯"

#: docs/8.x/eloquent-relationships.md:block 183 (paragraph)
msgid "Once your database table and models are defined, you may access the relationships via your models. For example, to retrieve the image for a post, we can access the `image` dynamic relationship property:"
msgstr "定義好資料庫資料表與 Model 後，就可以通過這些 Model 來存取關聯。舉例來說，若要取得一則貼文的圖片，我們可以存取 `image` 動態關聯屬性："

#: docs/8.x/eloquent-relationships.md:block 184 (code)
msgid "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"$image = $post->image;\n"
msgstr "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"$image = $post->image;\n"

#: docs/8.x/eloquent-relationships.md:block 185 (paragraph)
msgid "You may retrieve the parent of the polymorphic model by accessing the name of the method that performs the call to `morphTo`. In this case, that is the `imageable` method on the `Image` model. So, we will access that method as a dynamic relationship property:"
msgstr "可以通過存取呼叫 `morphTo` 之方法的名稱來取得多型 Model 的上層 Model。在這個例子中，就是 `Image` Model 的 `imageable` 方法。因此，我們可以用動態關聯屬性來存取該方法："

#: docs/8.x/eloquent-relationships.md:block 186 (code)
msgid "use App\\Models\\Image;\n\n"
"$image = Image::find(1);\n\n"
"$imageable = $image->imageable;\n"
msgstr "use App\\Models\\Image;\n\n"
"$image = Image::find(1);\n\n"
"$imageable = $image->imageable;\n"

#: docs/8.x/eloquent-relationships.md:block 187 (paragraph)
msgid "The `imageable` relation on the `Image` model will return either a `Post` or `User` instance, depending on which type of model owns the image."
msgstr "依據擁有該圖片的 Model 類型，`Image` Model 上的 `imageable` 關聯會回傳 `Post` 或 `User` 實體。"

#: docs/8.x/eloquent-relationships.md:block 190 (paragraph)
msgid "If necessary, you may specify the name of the \"id\" and \"type\" columns utilized by your polymorphic child model. If you do so, ensure that you always pass the name of the relationship as the first argument to the `morphTo` method. Typically, this value should match the method name, so you may use PHP's `__FUNCTION__` constant:"
msgstr "若有需要，也可以指定多型子 Model 所使用的「id」與「type」欄位名稱。若要自訂這些欄位的名稱，請先確保有將關聯的名稱傳給 `morphTo` 方法的第一個引數。一般來說，這個值應該要與方法名稱相同，因此我們可以使用 PHP 的 `__FUNCTION__` 常數："

#: docs/8.x/eloquent-relationships.md:block 191 (code)
msgid "/**\n"
" * Get the model that the image belongs to.\n"
" */\n"
"public function imageable()\n"
"{\n"
"    return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\n"
"}\n"
msgstr "/**\n"
" * Get the model that the image belongs to.\n"
" */\n"
"public function imageable()\n"
"{\n"
"    return $this->morphTo(__FUNCTION__, 'imageable_type', 'imageable_id');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 193 (header)
msgid "One To Many (Polymorphic)"
msgstr "一對多 (多型)"

#: docs/8.x/eloquent-relationships.md:block 196 (paragraph)
msgid "A one-to-many polymorphic relation is similar to a typical one-to-many relation; however, the child model can belong to more than one type of model using a single association. For example, imagine users of your application can \"comment\" on posts and videos. Using polymorphic relationships, you may use a single `comments` table to contain comments for both posts and videos. First, let's examine the table structure required to build this relationship:"
msgstr "One-to-Many 的多型關聯與一般的 One-to-Many 關聯很類似。不過，在多型關聯中，可以使用單一關聯來讓子 Model 可以隸屬於多種類型的 Model。舉例來說，假設有個使用者可以在貼文與影片上「留言」的網站。若使用多型關聯，我們可以使用單一一個 `comments` 表來包含用於貼文與影片的留言。首先，來看看需要建立這種關聯的資料表結構："

#: docs/8.x/eloquent-relationships.md:block 197 (code)
msgid "posts\n"
"    id - integer\n"
"    title - string\n"
"    body - text\n\n"
"videos\n"
"    id - integer\n"
"    title - string\n"
"    url - string\n\n"
"comments\n"
"    id - integer\n"
"    body - text\n"
"    commentable_id - integer\n"
"    commentable_type - string\n"
msgstr "posts\n"
"    id - integer\n"
"    title - string\n"
"    body - text\n\n"
"videos\n"
"    id - integer\n"
"    title - string\n"
"    url - string\n\n"
"comments\n"
"    id - integer\n"
"    body - text\n"
"    commentable_id - integer\n"
"    commentable_type - string\n"

#: docs/8.x/eloquent-relationships.md:block 201 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent commentable model (post or video).\n"
"     */\n"
"    public function commentable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the post's comments.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->morphMany(Comment::class, 'commentable');\n"
"    }\n"
"}\n\n"
"class Video extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the video's comments.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->morphMany(Comment::class, 'commentable');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent commentable model (post or video).\n"
"     */\n"
"    public function commentable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the post's comments.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->morphMany(Comment::class, 'commentable');\n"
"    }\n"
"}\n\n"
"class Video extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the video's comments.\n"
"     */\n"
"    public function comments()\n"
"    {\n"
"        return $this->morphMany(Comment::class, 'commentable');\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 204 (paragraph)
msgid "Once your database table and models are defined, you may access the relationships via your model's dynamic relationship properties. For example, to access all of the comments for a post, we can use the `comments` dynamic property:"
msgstr "定義好資料表與 Model 後，就可以使用 Model 的動態關聯屬性來存取這個關聯。舉例來說，若要存取某個貼文的所有留言，我們可以使用 `comments` 動態屬性："

#: docs/8.x/eloquent-relationships.md:block 205 (code)
msgid "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"foreach ($post->comments as $comment) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"foreach ($post->comments as $comment) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 206 (paragraph)
msgid "You may also retrieve the parent of a polymorphic child model by accessing the name of the method that performs the call to `morphTo`. In this case, that is the `commentable` method on the `Comment` model. So, we will access that method as a dynamic relationship property in order to access the comment's parent model:"
msgstr "也可以通過存取呼叫 `morphTo` 之方法的名稱來取得多型子 Model 的上層 Model。在這個例子中，就是 `Comment` Model 的 `commentable` 方法。因此，我們可以用動態關聯屬性來存取該方法以取得留言的上層 Model："

#: docs/8.x/eloquent-relationships.md:block 207 (code)
msgid "use App\\Models\\Comment;\n\n"
"$comment = Comment::find(1);\n\n"
"$commentable = $comment->commentable;\n"
msgstr "use App\\Models\\Comment;\n\n"
"$comment = Comment::find(1);\n\n"
"$commentable = $comment->commentable;\n"

#: docs/8.x/eloquent-relationships.md:block 208 (paragraph)
msgid "The `commentable` relation on the `Comment` model will return either a `Post` or `Video` instance, depending on which type of model is the comment's parent."
msgstr "依照不同的留言上層 Model 類型，`Comment` Model 的 `commentable` 關聯回傳的不是 `Post` 實體就是 `Video` 實體。"

#: docs/8.x/eloquent-relationships.md:block 210 (header)
msgid "One Of Many (Polymorphic)"
msgstr "多中之一 (多型)"

#: docs/8.x/eloquent-relationships.md:block 211 (paragraph)
msgid "Sometimes a model may have many related models, yet you want to easily retrieve the \"latest\" or \"oldest\" related model of the relationship. For example, a `User` model may be related to many `Image` models, but you want to define a convenient way to interact with the most recent image the user has uploaded. You may accomplish this using the `morphOne` relationship type combined with the `ofMany` methods:"
msgstr "有時候，某個 Model 可能有多個關聯 Model，而我們可能會想取多個關聯 Model 中「最新」或「最舊」的關聯 Model。舉例來說，`User` Model (使用者) 可能會關聯到多個 `Image` Model (圖片)，而我們可能會想定義一種方便的方法來存取使用者最新的圖片。我們可以通過將 `morphOne` 關聯類型與 `ofMany` 方法搭配使用來達成："

#: docs/8.x/eloquent-relationships.md:block 212 (code)
msgid "/**\n"
" * Get the user's most recent image.\n"
" */\n"
"public function latestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's most recent image.\n"
" */\n"
"public function latestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->latestOfMany();\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 214 (code)
msgid "/**\n"
" * Get the user's oldest image.\n"
" */\n"
"public function oldestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\n"
"}\n"
msgstr "/**\n"
" * Get the user's oldest image.\n"
" */\n"
"public function oldestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->oldestOfMany();\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 216 (paragraph)
msgid "For example, using the `ofMany` method, you may retrieve the user's most \"liked\" image. The `ofMany` method accepts the sortable column as its first argument and which aggregate function (`min` or `max`) to apply when querying for the related model:"
msgstr "舉例來說，我們可以使用 `ofMany` 方法來去的使用者獲得最多「讚」的圖片。`ofMany` 方法的第一個引數為可排序的欄位，接著則是要套用哪個匯總函式 (`min` 或 `max` 等) 在關聯的 Model 上："

#: docs/8.x/eloquent-relationships.md:block 217 (code)
msgid "/**\n"
" * Get the user's most popular image.\n"
" */\n"
"public function bestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\n"
"}\n"
msgstr "/**\n"
" * Get the user's most popular image.\n"
" */\n"
"public function bestImage()\n"
"{\n"
"    return $this->morphOne(Image::class, 'imageable')->ofMany('likes', 'max');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 218 (quote)
msgid "{tip} It is possible to construct more advanced \"one of many\" relationships. For more information, please consult the [has one of many documentation](#advanced-has-one-of-many-relationships)."
msgstr "{tip} 還有辦法建立建立更進階的「One of Many」關聯。更多資訊請參考 [Has One of Many 說明文件](#advanced-has-one-of-many-relationships)。"

#: docs/8.x/eloquent-relationships.md:block 220 (header)
msgid "Many To Many (Polymorphic)"
msgstr "多對多 (多型)"

#: docs/8.x/eloquent-relationships.md:block 223 (paragraph)
msgid "Many-to-many polymorphic relations are slightly more complicated than \"morph one\" and \"morph many\" relationships. For example, a `Post` model and `Video` model could share a polymorphic relation to a `Tag` model. Using a many-to-many polymorphic relation in this situation would allow your application to have a single table of unique tags that may be associated with posts or videos. First, let's examine the table structure required to build this relationship:"
msgstr "多型的 Many-to-Many 關聯比「Morph One」或「Morph Many」都稍微複雜一點。舉例來說，`Post` Model 與 `Video` Model 可以共用一個多型關聯的 `Tag` Model。在這種情況下使用多型的 Many-to-Many 可以讓我們的專案中只需要一張資料表來儲存獨立的 Tag，就可以關聯給 Post 跟 Video。首先，來看看要建立這種關聯的資料表架構："

#: docs/8.x/eloquent-relationships.md:block 224 (code)
msgid "posts\n"
"    id - integer\n"
"    name - string\n\n"
"videos\n"
"    id - integer\n"
"    name - string\n\n"
"tags\n"
"    id - integer\n"
"    name - string\n\n"
"taggables\n"
"    tag_id - integer\n"
"    taggable_id - integer\n"
"    taggable_type - string\n"
msgstr "posts\n"
"    id - integer\n"
"    name - string\n\n"
"videos\n"
"    id - integer\n"
"    name - string\n\n"
"tags\n"
"    id - integer\n"
"    name - string\n\n"
"taggables\n"
"    tag_id - integer\n"
"    taggable_id - integer\n"
"    taggable_type - string\n"

#: docs/8.x/eloquent-relationships.md:block 225 (quote)
msgid "{tip} Before diving into polymorphic many-to-many relationships, you may benefit from reading the documentation on typical [many-to-many relationships](#many-to-many)."
msgstr "{tip} 在進一步深入瞭解多型的 Many-to-Many 關聯前，我們建議你先閱讀有關普通 [Many-to-Many 關聯](#many-to-many)的說明文件。"

#: docs/8.x/eloquent-relationships.md:block 228 (paragraph)
msgid "Next, we're ready to define the relationships on the models. The `Post` and `Video` models will both contain a `tags` method that calls the `morphToMany` method provided by the base Eloquent model class."
msgstr "接著，我們就可以開始在 Model 上定義關聯了。`Post` 與 `Video` Model 都包含了一個 `tags` 方法，該方法中會呼叫基礎 Eloquent Model 類別中的 `morphToMany` 方法。"

#: docs/8.x/eloquent-relationships.md:block 229 (paragraph)
msgid "The `morphToMany` method accepts the name of the related model as well as the \"relationship name\". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as \"taggable\":"
msgstr "`morphToMany` 方法接受關聯 Model 的名稱，以及「關聯名稱」。根據我們設定給中介表的名稱以及其中包含的索引鍵，我們可以將關聯推導為「taggable」："

#: docs/8.x/eloquent-relationships.md:block 230 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the tags for the post.\n"
"     */\n"
"    public function tags()\n"
"    {\n"
"        return $this->morphToMany(Tag::class, 'taggable');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Post extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the tags for the post.\n"
"     */\n"
"    public function tags()\n"
"    {\n"
"        return $this->morphToMany(Tag::class, 'taggable');\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 233 (paragraph)
msgid "Next, on the `Tag` model, you should define a method for each of its possible parent models. So, in this example, we will define a `posts` method and a `videos` method. Both of these methods should return the result of the `morphedByMany` method."
msgstr "接著，在 `Tag` Model 中，我們可以為 Tag 的各個可能的上層 Model 定義個別的方法。因此，在這個例子中，我們會定義一個 `posts` 方法與一個 `videos` 方法。這兩個方法都應回傳 `morphedByMany` 方法的結果。"

#: docs/8.x/eloquent-relationships.md:block 234 (paragraph)
msgid "The `morphedByMany` method accepts the name of the related model as well as the \"relationship name\". Based on the name we assigned to our intermediate table name and the keys it contains, we will refer to the relationship as \"taggable\":"
msgstr "`morphedByMany` 方法接受關聯 Model 的名稱，以及「關聯名稱」。根據我們設定給中介表的名稱以及其中包含的索引鍵，我們可以將關聯推導為「taggable」："

#: docs/8.x/eloquent-relationships.md:block 235 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Tag extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the posts that are assigned this tag.\n"
"     */\n"
"    public function posts()\n"
"    {\n"
"        return $this->morphedByMany(Post::class, 'taggable');\n"
"    }\n\n"
"    /**\n"
"     * Get all of the videos that are assigned this tag.\n"
"     */\n"
"    public function videos()\n"
"    {\n"
"        return $this->morphedByMany(Video::class, 'taggable');\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Tag extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the posts that are assigned this tag.\n"
"     */\n"
"    public function posts()\n"
"    {\n"
"        return $this->morphedByMany(Post::class, 'taggable');\n"
"    }\n\n"
"    /**\n"
"     * Get all of the videos that are assigned this tag.\n"
"     */\n"
"    public function videos()\n"
"    {\n"
"        return $this->morphedByMany(Video::class, 'taggable');\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 238 (paragraph)
msgid "Once your database table and models are defined, you may access the relationships via your models. For example, to access all of the tags for a post, you may use the `tags` dynamic relationship property:"
msgstr "定義好資料庫資料表與 Model 後，就可以通過這些 Model 來存取關聯。舉例來說，若要取得一則貼文的 Tag，我們可以使用 `tags` 動態關聯屬性："

#: docs/8.x/eloquent-relationships.md:block 239 (code)
msgid "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"foreach ($post->tags as $tag) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"foreach ($post->tags as $tag) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 240 (paragraph)
msgid "You may retrieve the parent of a polymorphic relation from the polymorphic child model by accessing the name of the method that performs the call to `morphedByMany`. In this case, that is the `posts` or `videos` methods on the `Tag` model:"
msgstr "可以在多型子 Model 中通過存取呼叫 `morphedByMany` 的方法名稱來存取多型關聯的上層 Model。在這個例子中，就是 `Tag` Model 上的 `posts` 與 `videos` 方法："

#: docs/8.x/eloquent-relationships.md:block 241 (code)
msgid "use App\\Models\\Tag;\n\n"
"$tag = Tag::find(1);\n\n"
"foreach ($tag->posts as $post) {\n"
"    //\n"
"}\n\n"
"foreach ($tag->videos as $video) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\Tag;\n\n"
"$tag = Tag::find(1);\n\n"
"foreach ($tag->posts as $post) {\n"
"    //\n"
"}\n\n"
"foreach ($tag->videos as $video) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 243 (header)
msgid "Custom Polymorphic Types"
msgstr "自訂多型型別"

#: docs/8.x/eloquent-relationships.md:block 244 (paragraph)
msgid "By default, Laravel will use the fully qualified class name to store the \"type\" of the related model. For instance, given the one-to-many relationship example above where a `Comment` model may belong to a `Post` or a `Video` model, the default `commentable_type` would be either `App\\Models\\Post` or `App\\Models\\Video`, respectively. However, you may wish to decouple these values from your application's internal structure."
msgstr "預設情況下，Laravel 會使用類別的完整格式名稱 (Fully Qualified Class Name) 來儲存關聯 Model 的「類型 (Type)」。具體而言，在上述的 One-to-Many 例子中，`Comment` Model 可以隸屬於 `Post` Model、也可以隸屬於 `Video` Model，因此預設的 `commentable_type` 就分別會是 `App\\Models\\Post` 或 `App\\Models\\Video`。不過，開發人員可能會想將這些值從專案的內部結構中解耦 (Decouple) 出來。"

#: docs/8.x/eloquent-relationships.md:block 245 (paragraph)
msgid "For example, instead of using the model names as the \"type\", we may use simple strings such as `post` and `video`. By doing so, the polymorphic \"type\" column values in our database will remain valid even if the models are renamed:"
msgstr "舉例來說，我們可以使用像 `post` 或 `video` 等簡單的字串作為「型別」，而不是使用 Model 名稱。這樣一來，即使我們修改了 Model 的名稱，資料庫中的多型「type」欄位值也會繼續有效："

#: docs/8.x/eloquent-relationships.md:block 246 (code)
msgid "use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\n"
"Relation::enforceMorphMap([\n"
"    'post' => 'App\\Models\\Post',\n"
"    'video' => 'App\\Models\\Video',\n"
"]);\n"
msgstr "use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\n"
"Relation::enforceMorphMap([\n"
"    'post' => 'App\\Models\\Post',\n"
"    'video' => 'App\\Models\\Video',\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 247 (paragraph)
msgid "You may call the `enforceMorphMap` method in the `boot` method of your `App\\Providers\\AppServiceProvider` class or create a separate service provider if you wish."
msgstr "可以在 `App\\Providers\\AppServiceProvider` 類別或依照需求自行的 Service Provider 中之 `boot` 方法內呼叫 `enforceMorphMap` 方法："

#: docs/8.x/eloquent-relationships.md:block 248 (paragraph)
msgid "You may determine the morph alias of a given model at runtime using the model's `getMorphClass` method. Conversely, you may determine the fully-qualified class name associated with a morph alias using the `Relation::getMorphedModel` method:"
msgstr "我們可以使用 Model 的 `getMorphClass` 方法來在執行階段判斷給定 Model 的 Morph 別名。相反的，我們可以使用 `Relation::getMorphedModel` 方法來取得 Morph 別名的完整格式類別名稱："

#: docs/8.x/eloquent-relationships.md:block 249 (code)
msgid "use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\n"
"$alias = $post->getMorphClass();\n\n"
"$class = Relation::getMorphedModel($alias);\n"
msgstr "use Illuminate\\Database\\Eloquent\\Relations\\Relation;\n\n"
"$alias = $post->getMorphClass();\n\n"
"$class = Relation::getMorphedModel($alias);\n"

#: docs/8.x/eloquent-relationships.md:block 250 (quote)
msgid "{note} When adding a \"morph map\" to your existing application, every morphable `*_type` column value in your database that still contains a fully-qualified class will need to be converted to its \"map\" name."
msgstr "{note} 在專案中使用「Morph Map」時，所有的 morphable `*_type` 欄位值還是會保持原本的完整各式類別名稱，需要再更改為其「映射 (Map)」的名稱。"

#: docs/8.x/eloquent-relationships.md:block 252 (header)
msgid "Dynamic Relationships"
msgstr "動態關聯"

#: docs/8.x/eloquent-relationships.md:block 253 (paragraph)
msgid "You may use the `resolveRelationUsing` method to define relations between Eloquent models at runtime. While not typically recommended for normal application development, this may occasionally be useful when developing Laravel packages."
msgstr "可以使用 `resolveRelationUsing` 方法來在執行階段定義 Eloquent Model 間的關聯。雖然對於一般的專案開發並不建議這麼做，但在開發 Laravel 套件的時候偶爾會很實用。"

#: docs/8.x/eloquent-relationships.md:block 254 (paragraph)
msgid "The `resolveRelationUsing` method accepts the desired relationship name as its first argument. The second argument passed to the method should be a closure that accepts the model instance and returns a valid Eloquent relationship definition. Typically, you should configure dynamic relationships within the boot method of a [service provider](/docs/{{version}}/providers):"
msgstr "`resolveRelationUsing` 方法接受自訂的關聯名稱作為其第一個引述。第二個傳入該方法的引數應為閉包，該閉包應接受一個 Model 實體並回傳一個有效的 Eloquent 關聯定義。一般來說，應在某個 [Service Provider](/docs/{{version}}/providers) 內的 boot 方法中定義動態關聯。"

#: docs/8.x/eloquent-relationships.md:block 255 (code)
msgid "use App\\Models\\Order;\n"
"use App\\Models\\Customer;\n\n"
"Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"    return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"});\n"
msgstr "use App\\Models\\Order;\n"
"use App\\Models\\Customer;\n\n"
"Order::resolveRelationUsing('customer', function ($orderModel) {\n"
"    return $orderModel->belongsTo(Customer::class, 'customer_id');\n"
"});\n"

#: docs/8.x/eloquent-relationships.md:block 256 (quote)
msgid "{note} When defining dynamic relationships, always provide explicit key name arguments to the Eloquent relationship methods."
msgstr "{note} 在定義動態關聯時，請總是提供顯式的索引鍵名稱給 Eloquent 關聯方法。"

#: docs/8.x/eloquent-relationships.md:block 258 (header)
msgid "Querying Relations"
msgstr "查詢關聯"

#: docs/8.x/eloquent-relationships.md:block 259 (paragraph)
msgid "Since all Eloquent relationships are defined via methods, you may call those methods to obtain an instance of the relationship without actually executing a query to load the related models. In addition, all types of Eloquent relationships also serve as [query builders](/docs/{{version}}/queries), allowing you to continue to chain constraints onto the relationship query before finally executing the SQL query against your database."
msgstr "由於所有的 Eloquent 關聯都是以方法來定義的，所以我們可以呼叫這些方法來取得關聯的實體，而不需執行查詢來載入關聯的 Model。此外，每種 Eloquent 關聯都可作為 [Query Builder](/docs/{{version}}/queries) 使用，因此我們也能在最終向資料庫執行 SQL 查詢前往關聯查詢串上一些查詢條件。"

#: docs/8.x/eloquent-relationships.md:block 260 (paragraph)
msgid "For example, imagine a blog application in which a `User` model has many associated `Post` models:"
msgstr "舉例來說，假設我們有一個部落格網站，其中 `User` Model 可以關聯到 `Post` Model："

#: docs/8.x/eloquent-relationships.md:block 261 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the posts for the user.\n"
"     */\n"
"    public function posts()\n"
"    {\n"
"        return $this->hasMany(Post::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class User extends Model\n"
"{\n"
"    /**\n"
"     * Get all of the posts for the user.\n"
"     */\n"
"    public function posts()\n"
"    {\n"
"        return $this->hasMany(Post::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 262 (paragraph)
msgid "You may query the `posts` relationship and add additional constraints to the relationship like so:"
msgstr "我們可以查詢 `posts` 關聯，並在關聯上像這樣加上額外的條件："

#: docs/8.x/eloquent-relationships.md:block 263 (code)
msgid "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"$user->posts()->where('active', 1)->get();\n"
msgstr "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"$user->posts()->where('active', 1)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 264 (paragraph)
msgid "You are able to use any of the Laravel [query builder's](/docs/{{version}}/queries) methods on the relationship, so be sure to explore the query builder documentation to learn about all of the methods that are available to you."
msgstr "在關聯上我們可以使用任何的 Laravel [Query Builder](/docs/{{version}}/queries) 方法，因此請確保有先閱讀過 Query Builder 的說明文件以瞭解有哪些方法可以使用。"

#: docs/8.x/eloquent-relationships.md:block 266 (header)
msgid "Chaining `orWhere` Clauses After Relationships"
msgstr "在關聯後方串上 `orWhere` 子句"

#: docs/8.x/eloquent-relationships.md:block 267 (paragraph)
msgid "As demonstrated in the example above, you are free to add additional constraints to relationships when querying them. However, use caution when chaining `orWhere` clauses onto a relationship, as the `orWhere` clauses will be logically grouped at the same level as the relationship constraint:"
msgstr "像上面的範例中一樣，在進行查詢的時候我們可以自由地往關聯新增查詢。不過，在將 `orWhere` 自居串上關聯時要注意，因為 `orWhere` 自居可能會被邏輯性地分組在與關聯條件相同的層級上："

#: docs/8.x/eloquent-relationships.md:block 268 (code)
msgid "$user->posts()\n"
"        ->where('active', 1)\n"
"        ->orWhere('votes', '>=', 100)\n"
"        ->get();\n"
msgstr "$user->posts()\n"
"        ->where('active', 1)\n"
"        ->orWhere('votes', '>=', 100)\n"
"        ->get();\n"

#: docs/8.x/eloquent-relationships.md:block 269 (paragraph)
msgid "The example above will generate the following SQL. As you can see, the `or` clause instructs the query to return *any* user with greater than 100 votes. The query is no longer constrained to a specific user:"
msgstr "上述的例子會產生下列的 SQL。如你所見，`or` 子句會讓查詢回傳 **所有** 大於 100 得票數的使用者。這個查詢不會被限制在任何特定使用者上："

#: docs/8.x/eloquent-relationships.md:block 270 (code)
msgid "select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"
msgstr "select *\n"
"from posts\n"
"where user_id = ? and active = 1 or votes >= 100\n"

#: docs/8.x/eloquent-relationships.md:block 271 (paragraph)
msgid "In most situations, you should use [logical groups](/docs/{{version}}/queries#logical-grouping) to group the conditional checks between parentheses:"
msgstr "在大多數的情況下，應該使用[邏輯群組](/docs/{{version}}/queries#logical-grouping)以將條件檢查放在括號中進行分組："

#: docs/8.x/eloquent-relationships.md:block 272 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$user->posts()\n"
"        ->where(function (Builder $query) {\n"
"            return $query->where('active', 1)\n"
"                         ->orWhere('votes', '>=', 100);\n"
"        })\n"
"        ->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$user->posts()\n"
"        ->where(function (Builder $query) {\n"
"            return $query->where('active', 1)\n"
"                         ->orWhere('votes', '>=', 100);\n"
"        })\n"
"        ->get();\n"

#: docs/8.x/eloquent-relationships.md:block 273 (paragraph)
msgid "The example above will produce the following SQL. Note that the logical grouping has properly grouped the constraints and the query remains constrained to a specific user:"
msgstr "上述的例子會產生下列 SQL。可以注意到，查詢條件已正確地進行邏輯分組，且查詢有保持限制在特定使用者上："

#: docs/8.x/eloquent-relationships.md:block 274 (code)
msgid "select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"
msgstr "select *\n"
"from posts\n"
"where user_id = ? and (active = 1 or votes >= 100)\n"

#: docs/8.x/eloquent-relationships.md:block 276 (header)
msgid "Relationship Methods Vs. Dynamic Properties"
msgstr "關聯方法 V.s. 動態屬性"

#: docs/8.x/eloquent-relationships.md:block 277 (paragraph)
msgid "If you do not need to add additional constraints to an Eloquent relationship query, you may access the relationship as if it were a property. For example, continuing to use our `User` and `Post` example models, we may access all of a user's posts like so:"
msgstr "若不想在 Eloquent 關聯查詢上新增任何額外的查詢條件，則可以直接將關聯作為屬性一樣存取。舉例來說，接續使用我們的 `User` 與 `Post` 範例 Model，我們可以像這樣存取 User 的所有 Post："

#: docs/8.x/eloquent-relationships.md:block 278 (code)
msgid "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->posts as $post) {\n"
"    //\n"
"}\n"
msgstr "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"foreach ($user->posts as $post) {\n"
"    //\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 279 (paragraph)
msgid "Dynamic relationship properties perform \"lazy loading\", meaning they will only load their relationship data when you actually access them. Because of this, developers often use [eager loading](#eager-loading) to pre-load relationships they know will be accessed after loading the model. Eager loading provides a significant reduction in SQL queries that must be executed to load a model's relations."
msgstr "動態屬性會被「延遲載入 (Lazy Loading)」，這表示，這些關聯資料只有在實際存取的時候才會被載入。也因此，開發人員常常會使用[積極式載入](#eager-loading)來預先載入稍後會被存取的關聯。使用預先載入，就可以顯著地降低許多在載入 Model 關聯時會被執行的 SQL 查詢。"

#: docs/8.x/eloquent-relationships.md:block 281 (header)
msgid "Querying Relationship Existence"
msgstr "查詢存在的關聯"

#: docs/8.x/eloquent-relationships.md:block 282 (paragraph)
msgid "When retrieving model records, you may wish to limit your results based on the existence of a relationship. For example, imagine you want to retrieve all blog posts that have at least one comment. To do so, you may pass the name of the relationship to the `has` and `orHas` methods:"
msgstr "在取得 Model 紀錄時，我們可能會想依據關聯是否存在來限制查詢結果。舉例來說，假設我們想取得所有至少有一篇留言的部落格貼文。為此，我們可以將關聯的名稱傳入 `has` 或 `orHas` 方法中："

#: docs/8.x/eloquent-relationships.md:block 283 (code)
msgid "use App\\Models\\Post;\n\n"
"// Retrieve all posts that have at least one comment...\n"
"$posts = Post::has('comments')->get();\n"
msgstr "use App\\Models\\Post;\n\n"
"// 取得所有至少有一篇留言的貼文...\n"
"$posts = Post::has('comments')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 284 (paragraph)
msgid "You may also specify an operator and count value to further customize the query:"
msgstr "我們也可以指定一個運算子與總數來進一步自訂查詢："

#: docs/8.x/eloquent-relationships.md:block 285 (code)
msgid "// Retrieve all posts that have three or more comments...\n"
"$posts = Post::has('comments', '>=', 3)->get();\n"
msgstr "// 取得所有至少有 3 篇留言的貼文...\n"
"$posts = Post::has('comments', '>=', 3)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 286 (paragraph)
msgid "Nested `has` statements may be constructed using \"dot\" notation. For example, you may retrieve all posts that have at least one comment that has at least one image:"
msgstr "可以使用「點 (.)」標記法來撰寫巢狀的 `has` 陳述式。舉例來說，我們可以取得所有至少有一篇含有圖片的留言的部落格貼文："

#: docs/8.x/eloquent-relationships.md:block 287 (code)
msgid "// Retrieve posts that have at least one comment with images...\n"
"$posts = Post::has('comments.images')->get();\n"
msgstr "// 取得有留言且這些留言至少有一張圖片的貼文...\n"
"$posts = Post::has('comments.images')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 288 (paragraph)
msgid "If you need even more power, you may use the `whereHas` and `orWhereHas` methods to define additional query constraints on your `has` queries, such as inspecting the content of a comment:"
msgstr "若需要更多功能，可以使用 `whereHas` 或 `orWhereHas` 方法來在 `has` 查詢上定義額外的查詢條件，如檢查留言的內容等："

#: docs/8.x/eloquent-relationships.md:block 289 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"// Retrieve posts with at least one comment containing words like code%...\n"
"$posts = Post::whereHas('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"})->get();\n\n"
"// Retrieve posts with at least ten comments containing words like code%...\n"
"$posts = Post::whereHas('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"}, '>=', 10)->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"// 取得至少有一篇留言內容包含文字 code% 的貼文...\n"
"$posts = Post::whereHas('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"})->get();\n\n"
"// 取得至少有 10 篇留言內容包含文字 code% 的貼文...\n"
"$posts = Post::whereHas('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"}, '>=', 10)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 290 (quote)
msgid "{note} Eloquent does not currently support querying for relationship existence across databases. The relationships must exist within the same database."
msgstr "{note} 由於 Eloquent 目前並不支援在多個資料庫間查詢關聯的存否，因此要查詢的關聯必須在同一個資料庫中。"

#: docs/8.x/eloquent-relationships.md:block 292 (header)
msgid "Inline Relationship Existence Queries"
msgstr "內嵌的存在關聯查詢"

#: docs/8.x/eloquent-relationships.md:block 293 (paragraph)
msgid "If you would like to query for a relationship's existence with a single, simple where condition attached to the relationship query, you may find it more convenient to use the `whereRelation` and `whereMorphRelation` methods. For example, we may query for all posts that have unapproved comments:"
msgstr "若想要使用附加在關聯查詢上的簡單且單一的 Where 條件來查詢關聯的存否，那麼用 `whereRelation` 與 `whereMorphRelation` 方法應該會很方便。舉例來說，我們可以查詢所有有未審核 (Unapproved) 留言的貼文："

#: docs/8.x/eloquent-relationships.md:block 294 (code)
msgid "use App\\Models\\Post;\n\n"
"$posts = Post::whereRelation('comments', 'is_approved', false)->get();\n"
msgstr "use App\\Models\\Post;\n\n"
"$posts = Post::whereRelation('comments', 'is_approved', false)->get();\n"

#: docs/8.x/eloquent-relationships.md:block 295 (paragraph)
msgid "Of course, like calls to the query builder's `where` method, you may also specify an operator:"
msgstr "當然，就像呼叫 Query Builder 的 `where` 方法一樣，我們也可以指定運算子："

#: docs/8.x/eloquent-relationships.md:block 296 (code)
msgid "$posts = Post::whereRelation(\n"
"    'comments', 'created_at', '>=', now()->subHour()\n"
")->get();\n"
msgstr "$posts = Post::whereRelation(\n"
"    'comments', 'created_at', '>=', now()->subHour()\n"
")->get();\n"

#: docs/8.x/eloquent-relationships.md:block 298 (header)
msgid "Querying Relationship Absence"
msgstr "查詢不存在的關聯"

#: docs/8.x/eloquent-relationships.md:block 299 (paragraph)
msgid "When retrieving model records, you may wish to limit your results based on the absence of a relationship. For example, imagine you want to retrieve all blog posts that **don't** have any comments. To do so, you may pass the name of the relationship to the `doesntHave` and `orDoesntHave` methods:"
msgstr "在取得 Model 紀錄時，我們可能會想依據關聯的是否不存在來限制查詢結果。舉例來說，假設我們想取得所有 **沒有** 留言的部落格貼文。為此，我們可以將關聯的名稱傳入 `doesntHave` 或 `orDoesntHave` 方法中："

#: docs/8.x/eloquent-relationships.md:block 300 (code)
msgid "use App\\Models\\Post;\n\n"
"$posts = Post::doesntHave('comments')->get();\n"
msgstr "use App\\Models\\Post;\n\n"
"$posts = Post::doesntHave('comments')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 301 (paragraph)
msgid "If you need even more power, you may use the `whereDoesntHave` and `orWhereDoesntHave` methods to add additional query constraints to your `doesntHave` queries, such as inspecting the content of a comment:"
msgstr "若需要更多功能，可以使用 `whereDoesntHave` 或 `orWhereDoesntHave` 方法來在 `doesntHave` 查詢上加上額外的查詢條件，如檢查留言的內容等："

#: docs/8.x/eloquent-relationships.md:block 302 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"})->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::whereDoesntHave('comments', function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"})->get();\n"

#: docs/8.x/eloquent-relationships.md:block 303 (paragraph)
msgid "You may use \"dot\" notation to execute a query against a nested relationship. For example, the following query will retrieve all posts that do not have comments; however, posts that have comments from authors that are not banned will be included in the results:"
msgstr "我們也可以使用「點 (.)」標記法來對巢狀關聯進行查詢。舉例來說，下列查詢會取得所有沒有留言的貼文。不過，具有未禁言作者發表留言的文章也會被包含在結果裡面："

#: docs/8.x/eloquent-relationships.md:block 304 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\n"
"    $query->where('banned', 0);\n"
"})->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::whereDoesntHave('comments.author', function (Builder $query) {\n"
"    $query->where('banned', 0);\n"
"})->get();\n"

#: docs/8.x/eloquent-relationships.md:block 306 (header)
msgid "Querying Morph To Relationships"
msgstr "查詢 Morph To 關聯"

#: docs/8.x/eloquent-relationships.md:block 307 (paragraph)
msgid "To query the existence of \"morph to\" relationships, you may use the `whereHasMorph` and `whereDoesntHaveMorph` methods. These methods accept the name of the relationship as their first argument. Next, the methods accept the names of the related models that you wish to include in the query. Finally, you may provide a closure which customizes the relationship query:"
msgstr "若要查詢「Morph To」關聯是否存在，可以使用 `whereHasMorph` 或 `whereDoesntHaveMorph` 方法。這些方法都接受關聯名稱作為其第一個引數。接著，這個方法還接受要被包含在查詢裡的關聯 Model 名稱。最後，我們還可以提供用來自訂關聯查詢的閉包："

#: docs/8.x/eloquent-relationships.md:block 308 (code)
msgid "use App\\Models\\Comment;\n"
"use App\\Models\\Post;\n"
"use App\\Models\\Video;\n"
"use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"// Retrieve comments associated to posts or videos with a title like code%...\n"
"$comments = Comment::whereHasMorph(\n"
"    'commentable',\n"
"    [Post::class, Video::class],\n"
"    function (Builder $query) {\n"
"        $query->where('title', 'like', 'code%');\n"
"    }\n"
")->get();\n\n"
"// Retrieve comments associated to posts with a title not like code%...\n"
"$comments = Comment::whereDoesntHaveMorph(\n"
"    'commentable',\n"
"    Post::class,\n"
"    function (Builder $query) {\n"
"        $query->where('title', 'like', 'code%');\n"
"    }\n"
")->get();\n"
msgstr "use App\\Models\\Comment;\n"
"use App\\Models\\Post;\n"
"use App\\Models\\Video;\n"
"use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"// 取得至少有一篇留言的貼文或影片，且貼文或影片的標題包含文字 code%...\n"
"$comments = Comment::whereHasMorph(\n"
"    'commentable',\n"
"    [Post::class, Video::class],\n"
"    function (Builder $query) {\n"
"        $query->where('title', 'like', 'code%');\n"
"    }\n"
")->get();\n\n"
"// 取得至少有一篇留言的貼文或影片，且貼文或影片的標題不包含文字 code%...\n"
"$comments = Comment::whereDoesntHaveMorph(\n"
"    'commentable',\n"
"    Post::class,\n"
"    function (Builder $query) {\n"
"        $query->where('title', 'like', 'code%');\n"
"    }\n"
")->get();\n"

#: docs/8.x/eloquent-relationships.md:block 309 (paragraph)
msgid "You may occasionally need to add query constraints based on the \"type\" of the related polymorphic model. The closure passed to the `whereHasMorph` method may receive a `$type` value as its second argument. This argument allows you to inspect the \"type\" of the query that is being built:"
msgstr "有時候，我們可能會想依據多型關聯 Model 的「類型」來新增查詢條件。傳給 `whereHasMorph` 方法的閉包可接受一個 `$type` 值作為其第二個引述。使用 `$type`引述，就可以檢查正在建立的查詢是什麼「類型」："

#: docs/8.x/eloquent-relationships.md:block 310 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$comments = Comment::whereHasMorph(\n"
"    'commentable',\n"
"    [Post::class, Video::class],\n"
"    function (Builder $query, $type) {\n"
"        $column = $type === Post::class ? 'content' : 'title';\n\n"
"        $query->where($column, 'like', 'code%');\n"
"    }\n"
")->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$comments = Comment::whereHasMorph(\n"
"    'commentable',\n"
"    [Post::class, Video::class],\n"
"    function (Builder $query, $type) {\n"
"        $column = $type === Post::class ? 'content' : 'title';\n\n"
"        $query->where($column, 'like', 'code%');\n"
"    }\n"
")->get();\n"

#: docs/8.x/eloquent-relationships.md:block 312 (header)
msgid "Querying All Related Models"
msgstr "查詢所有關聯的 Model"

#: docs/8.x/eloquent-relationships.md:block 313 (paragraph)
msgid "Instead of passing an array of possible polymorphic models, you may provide `*` as a wildcard value. This will instruct Laravel to retrieve all of the possible polymorphic types from the database. Laravel will execute an additional query in order to perform this operation:"
msgstr "我們可以提供 `*` 作為萬用字元，而不需以陣列列出所有可能的多型 Model。這樣以來 Laravel 就會從資料庫中取得所有可能的多型類型。Laravel 會執行一個額外的查詢來進行此行動："

#: docs/8.x/eloquent-relationships.md:block 314 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\n"
"    $query->where('title', 'like', 'foo%');\n"
"})->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$comments = Comment::whereHasMorph('commentable', '*', function (Builder $query) {\n"
"    $query->where('title', 'like', 'foo%');\n"
"})->get();\n"

#: docs/8.x/eloquent-relationships.md:block 316 (header)
msgid "Aggregating Related Models"
msgstr "彙總關聯的 Model"

#: docs/8.x/eloquent-relationships.md:block 318 (header)
msgid "Counting Related Models"
msgstr "計數關聯的 Model"

#: docs/8.x/eloquent-relationships.md:block 319 (paragraph)
msgid "Sometimes you may want to count the number of related models for a given relationship without actually loading the models. To accomplish this, you may use the `withCount` method. The `withCount` method will place a `{relation}_count` attribute on the resulting models:"
msgstr "有時候我們可能會想知道給定關聯中關聯 Model 的數量，但又不想真正載入這些 Model。為此，我們可以使用 `withCount` 方法。`withCount` 方法會在查詢結果的 Model 中加上一個 `{關聯}_count` 屬性："

#: docs/8.x/eloquent-relationships.md:block 320 (code)
msgid "use App\\Models\\Post;\n\n"
"$posts = Post::withCount('comments')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->comments_count;\n"
"}\n"
msgstr "use App\\Models\\Post;\n\n"
"$posts = Post::withCount('comments')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->comments_count;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 321 (paragraph)
msgid "By passing an array to the `withCount` method, you may add the \"counts\" for multiple relations as well as add additional constraints to the queries:"
msgstr "只要將陣列傳入 `withCount` 方法，就可以為多個關聯「計數」，或是在查詢上加上額外的查詢條件："

#: docs/8.x/eloquent-relationships.md:block 322 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"}])->get();\n\n"
"echo $posts[0]->votes_count;\n"
"echo $posts[0]->comments_count;\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::withCount(['votes', 'comments' => function (Builder $query) {\n"
"    $query->where('content', 'like', 'code%');\n"
"}])->get();\n\n"
"echo $posts[0]->votes_count;\n"
"echo $posts[0]->comments_count;\n"

#: docs/8.x/eloquent-relationships.md:block 323 (paragraph)
msgid "You may also alias the relationship count result, allowing multiple counts on the same relationship:"
msgstr "也可以為關聯總數結果加上別名，這樣就能對單一關聯計算多次數量："

#: docs/8.x/eloquent-relationships.md:block 324 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::withCount([\n"
"    'comments',\n"
"    'comments as pending_comments_count' => function (Builder $query) {\n"
"        $query->where('approved', false);\n"
"    },\n"
"])->get();\n\n"
"echo $posts[0]->comments_count;\n"
"echo $posts[0]->pending_comments_count;\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n\n"
"$posts = Post::withCount([\n"
"    'comments',\n"
"    'comments as pending_comments_count' => function (Builder $query) {\n"
"        $query->where('approved', false);\n"
"    },\n"
"])->get();\n\n"
"echo $posts[0]->comments_count;\n"
"echo $posts[0]->pending_comments_count;\n"

#: docs/8.x/eloquent-relationships.md:block 326 (header)
msgid "Deferred Count Loading"
msgstr "延後 (Deferred) 數量計算的載入"

#: docs/8.x/eloquent-relationships.md:block 327 (paragraph)
msgid "Using the `loadCount` method, you may load a relationship count after the parent model has already been retrieved:"
msgstr "使用 `loadCount` 方法，就可以在上層 Model 已經載入後再接著載入關聯的計數："

#: docs/8.x/eloquent-relationships.md:block 328 (code)
msgid "$book = Book::first();\n\n"
"$book->loadCount('genres');\n"
msgstr "$book = Book::first();\n\n"
"$book->loadCount('genres');\n"

#: docs/8.x/eloquent-relationships.md:block 329 (paragraph)
msgid "If you need to set additional query constraints on the count query, you may pass an array keyed by the relationships you wish to count. The array values should be closures which receive the query builder instance:"
msgstr "若想在計數查詢上設定額外的查詢條件，可以傳入一組陣列，其索引鍵應為要計數的關聯。陣列的值則為一個閉包，用來接收 Query Builder 實體："

#: docs/8.x/eloquent-relationships.md:block 330 (code)
msgid "$book->loadCount(['reviews' => function ($query) {\n"
"    $query->where('rating', 5);\n"
"}])\n"
msgstr "$book->loadCount(['reviews' => function ($query) {\n"
"    $query->where('rating', 5);\n"
"}])\n"

#: docs/8.x/eloquent-relationships.md:block 332 (header)
msgid "Relationship Counting & Custom Select Statements"
msgstr "關聯計數與自訂 Select 陳述式"

#: docs/8.x/eloquent-relationships.md:block 333 (paragraph)
msgid "If you're combining `withCount` with a `select` statement, ensure that you call `withCount` after the `select` method:"
msgstr "若想組合使用 `withCount` 與 `select` 陳述式，請在 `select` 方法後再呼叫 `withCount`："

#: docs/8.x/eloquent-relationships.md:block 334 (code)
msgid "$posts = Post::select(['title', 'body'])\n"
"                ->withCount('comments')\n"
"                ->get();\n"
msgstr "$posts = Post::select(['title', 'body'])\n"
"                ->withCount('comments')\n"
"                ->get();\n"

#: docs/8.x/eloquent-relationships.md:block 336 (header)
msgid "Other Aggregate Functions"
msgstr "其他彙總函式"

#: docs/8.x/eloquent-relationships.md:block 337 (paragraph)
msgid "In addition to the `withCount` method, Eloquent provides `withMin`, `withMax`, `withAvg`, `withSum`, and `withExists` methods. These methods will place a `{relation}_{function}_{column}` attribute on your resulting models:"
msgstr "除了 `withCount` 方法外，Eloquent 也提供了 `withMin`, `withMax`, `withAvg`, `withSum`, 與 `withExists` 等方法。這些方法會在查詢結果的 Model 上加上一個  `{關聯}_{函式}_{欄位}` 屬性："

#: docs/8.x/eloquent-relationships.md:block 338 (code)
msgid "use App\\Models\\Post;\n\n"
"$posts = Post::withSum('comments', 'votes')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->comments_sum_votes;\n"
"}\n"
msgstr "use App\\Models\\Post;\n\n"
"$posts = Post::withSum('comments', 'votes')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->comments_sum_votes;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 339 (paragraph)
msgid "If you wish to access the result of the aggregate function using another name, you may specify your own alias:"
msgstr "若想使用另一個名稱來存取彙總函式的結果，可自行指定別名："

#: docs/8.x/eloquent-relationships.md:block 340 (code)
msgid "$posts = Post::withSum('comments as total_comments', 'votes')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->total_comments;\n"
"}\n"
msgstr "$posts = Post::withSum('comments as total_comments', 'votes')->get();\n\n"
"foreach ($posts as $post) {\n"
"    echo $post->total_comments;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 341 (paragraph)
msgid "Like the `loadCount` method, deferred versions of these methods are also available. These additional aggregate operations may be performed on Eloquent models that have already been retrieved:"
msgstr "與 `loadCount` 方法類似，Eloquent 中也有這些方法的延遲 (Deferred) 版本。可以在已經取得的 Eloquent Model 上進行這些額外的彙總運算："

#: docs/8.x/eloquent-relationships.md:block 342 (code)
msgid "$post = Post::first();\n\n"
"$post->loadSum('comments', 'votes');\n"
msgstr "$post = Post::first();\n\n"
"$post->loadSum('comments', 'votes');\n"

#: docs/8.x/eloquent-relationships.md:block 343 (paragraph)
msgid "If you're combining these aggregate methods with a `select` statement, ensure that you call the aggregate methods after the `select` method:"
msgstr "若想組合使用這些彙總與 `select` 陳述式，請在 `select` 方法後再呼叫這些彙總函式："

#: docs/8.x/eloquent-relationships.md:block 344 (code)
msgid "$posts = Post::select(['title', 'body'])\n"
"                ->withExists('comments')\n"
"                ->get();\n"
msgstr "$posts = Post::select(['title', 'body'])\n"
"                ->withExists('comments')\n"
"                ->get();\n"

#: docs/8.x/eloquent-relationships.md:block 346 (header)
msgid "Counting Related Models On Morph To Relationships"
msgstr "在 Morph To 關聯上計算關聯 Model 的數量"

#: docs/8.x/eloquent-relationships.md:block 347 (paragraph)
msgid "If you would like to eager load a \"morph to\" relationship, as well as related model counts for the various entities that may be returned by that relationship, you may utilize the `with` method in combination with the `morphTo` relationship's `morphWithCount` method."
msgstr "若想積極式載入「Morph to」關聯、或是關聯 Model 計數等由關聯回傳的功能，可以使用 `morphTo` 關聯的 `morphWithCount` 方法，並搭配 `with` 方法使用。"

#: docs/8.x/eloquent-relationships.md:block 348 (paragraph)
msgid "In this example, let's assume that `Photo` and `Post` models may create `ActivityFeed` models. We will assume the `ActivityFeed` model defines a \"morph to\" relationship named `parentable` that allows us to retrieve the parent `Photo` or `Post` model for a given `ActivityFeed` instance. Additionally, let's assume that `Photo` models \"have many\" `Tag` models and `Post` models \"have many\" `Comment` models."
msgstr "在這個例子中，我們假設 `Photo` 與 `Post` Model 會建立 `ActivityFeed` Model。假設 `ActivityFeed` Model 定義一個名為  `parentable` 的「Morph to」關聯，可讓使用者在某一 `ActivityFeed` 實體上取得上層的 `Photo` 或 `Post` Model。此外，我們也假設 `Photo` Model「Have Many (有多個)」 `Tag` Model，而 `Post` Model「Have Many」`Comment` Model。"

#: docs/8.x/eloquent-relationships.md:block 349 (paragraph)
msgid "Now, let's imagine we want to retrieve `ActivityFeed` instances and eager load the `parentable` parent models for each `ActivityFeed` instance. In addition, we want to retrieve the number of tags that are associated with each parent photo and the number of comments that are associated with each parent post:"
msgstr "接著，來假設我們現在要去的 `ActivityFeed` 實體，並為取得的每個 `ActivityFeed` 實體積極式載入 `parentable` 上層 Model。此外，我們也想知道上層的每張圖片各有多少個 Tag、還有上層的每篇貼文各有多少則留言："

#: docs/8.x/eloquent-relationships.md:block 350 (code)
msgid "use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$activities = ActivityFeed::with([\n"
"    'parentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->morphWithCount([\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['comments'],\n"
"        ]);\n"
"    }])->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$activities = ActivityFeed::with([\n"
"    'parentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->morphWithCount([\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['comments'],\n"
"        ]);\n"
"    }])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 353 (paragraph)
msgid "Let's assume we have already retrieved a set of `ActivityFeed` models and now we would like to load the nested relationship counts for the various `parentable` models associated with the activity feeds. You may use the `loadMorphCount` method to accomplish this:"
msgstr "假設我們已經取得 `ActivityFeed` Model (活動摘要)，接著，我們想要載入與活動摘要關聯的各種 `parentable` Model 的巢狀關聯數量。我們可以使用 `loadMorphCount` 方法來完成："

#: docs/8.x/eloquent-relationships.md:block 354 (code)
msgid "$activities = ActivityFeed::with('parentable')->get();\n\n"
"$activities->loadMorphCount('parentable', [\n"
"    Photo::class => ['tags'],\n"
"    Post::class => ['comments'],\n"
"]);\n"
msgstr "$activities = ActivityFeed::with('parentable')->get();\n\n"
"$activities->loadMorphCount('parentable', [\n"
"    Photo::class => ['tags'],\n"
"    Post::class => ['comments'],\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 356 (header)
msgid "Eager Loading"
msgstr "積極式載入"

#: docs/8.x/eloquent-relationships.md:block 357 (paragraph)
msgid "When accessing Eloquent relationships as properties, the related models are \"lazy loaded\". This means the relationship data is not actually loaded until you first access the property. However, Eloquent can \"eager load\" relationships at the time you query the parent model. Eager loading alleviates the \"N + 1\" query problem. To illustrate the N + 1 query problem, consider a `Book` model that \"belongs to\" to an `Author` model:"
msgstr "以屬性方式存取 Eloquent 關聯時，關聯的 Model 會被「消極式載入 (Lazy Load)」。這表示，直到首次存取該屬性前，關聯資料都不會被載入。不過，Eloquent 也可以在查詢上層 Model 時就「積極式載入 (Eager Load)」關聯。積極式載入可以減少「N + 1」問題。為了示範什麼是 N + 1 問題，我們先假設有個「隸屬於 (Belongs to)」`Author` Model 的 `Book` Model："

#: docs/8.x/eloquent-relationships.md:block 358 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Book extends Model\n"
"{\n"
"    /**\n"
"     * Get the author that wrote the book.\n"
"     */\n"
"    public function author()\n"
"    {\n"
"        return $this->belongsTo(Author::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Book extends Model\n"
"{\n"
"    /**\n"
"     * Get the author that wrote the book.\n"
"     */\n"
"    public function author()\n"
"    {\n"
"        return $this->belongsTo(Author::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 359 (paragraph)
msgid "Now, let's retrieve all books and their authors:"
msgstr "現在，我們來取得所有書籍與其作者："

#: docs/8.x/eloquent-relationships.md:block 360 (code)
msgid "use App\\Models\\Book;\n\n"
"$books = Book::all();\n\n"
"foreach ($books as $book) {\n"
"    echo $book->author->name;\n"
"}\n"
msgstr "use App\\Models\\Book;\n\n"
"$books = Book::all();\n\n"
"foreach ($books as $book) {\n"
"    echo $book->author->name;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 361 (paragraph)
msgid "This loop will execute one query to retrieve all of the books within the database table, then another query for each book in order to retrieve the book's author. So, if we have 25 books, the code above would run 26 queries: one for the original book, and 25 additional queries to retrieve the author of each book."
msgstr "這個迴圈會執行一個查詢來取得資料表中所有的書籍，然後每本書都會再執行一個查詢來取得書籍的作者。因此，若我們有 25 本書，上述程式碼就會執行 26 筆資料庫查詢：1 個查詢來取得書籍，另外 25 個額外的查詢來取得每本書的作者。"

#: docs/8.x/eloquent-relationships.md:block 362 (paragraph)
msgid "Thankfully, we can use eager loading to reduce this operation to just two queries. When building a query, you may specify which relationships should be eager loaded using the `with` method:"
msgstr "幸好，我們可以使用積極式載入來把這一連串行動降低為只需要 2 個查詢。在建立查詢時，可以使用 `with` 方法來指定哪個關聯要被積極式載入："

#: docs/8.x/eloquent-relationships.md:block 363 (code)
msgid "$books = Book::with('author')->get();\n\n"
"foreach ($books as $book) {\n"
"    echo $book->author->name;\n"
"}\n"
msgstr "$books = Book::with('author')->get();\n\n"
"foreach ($books as $book) {\n"
"    echo $book->author->name;\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 364 (paragraph)
msgid "For this operation, only two queries will be executed - one query to retrieve all of the books and one query to retrieve all of the authors for all of the books:"
msgstr "這樣一來，就只會執行 2 個查詢 —— 一個查詢去的所有的書籍，另一個查詢則取得所有書籍的作者。"

#: docs/8.x/eloquent-relationships.md:block 365 (code)
msgid "select * from books\n\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"
msgstr "select * from books\n\n"
"select * from authors where id in (1, 2, 3, 4, 5, ...)\n"

#: docs/8.x/eloquent-relationships.md:block 367 (header)
msgid "Eager Loading Multiple Relationships"
msgstr "積極式載入多個關聯"

#: docs/8.x/eloquent-relationships.md:block 368 (paragraph)
msgid "Sometimes you may need to eager load several different relationships. To do so, just pass an array of relationships to the `with` method:"
msgstr "有時候，我們可能需要積極式載入多個不同的關聯。要載入多個不同的關聯，只需要傳入一組包含關聯的陣列給 `with` 方法即可："

#: docs/8.x/eloquent-relationships.md:block 369 (code)
msgid "$books = Book::with(['author', 'publisher'])->get();\n"
msgstr "$books = Book::with(['author', 'publisher'])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 371 (header)
msgid "Nested Eager Loading"
msgstr "巢狀積極式載入"

#: docs/8.x/eloquent-relationships.md:block 372 (paragraph)
msgid "To eager load a relationship's relationships, you may use \"dot\" syntax. For example, let's eager load all of the book's authors and all of the author's personal contacts:"
msgstr "若要積極載入關聯的關聯，可以使用「點 (.)」標記法。舉例來說，讓我們來積極載入所有書籍的作者，以及所有作者的聯絡方式 (Contact)："

#: docs/8.x/eloquent-relationships.md:block 373 (code)
msgid "$books = Book::with('author.contacts')->get();\n"
msgstr "$books = Book::with('author.contacts')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 375 (header)
msgid "Nested Eager Loading `morphTo` Relationships"
msgstr "積極載入巢狀的 `morphTo` 關聯"

#: docs/8.x/eloquent-relationships.md:block 376 (paragraph)
msgid "If you would like to eager load a `morphTo` relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the `with` method in combination with the `morphTo` relationship's `morphWith` method. To help illustrate this method, let's consider the following model:"
msgstr "若想積極載入 `morphTo` 關聯、或是巢狀的關聯等由 morphTo 關聯回傳的功能，可以使用 `morphTo` 關聯的 `morphWith` 方法，並搭配 `with` 方法使用。為了讓我們更瞭解這個功能，我們先來看看下列 Model："

#: docs/8.x/eloquent-relationships.md:block 377 (code)
msgid "<?php\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class ActivityFeed extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent of the activity feed record.\n"
"     */\n"
"    public function parentable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class ActivityFeed extends Model\n"
"{\n"
"    /**\n"
"     * Get the parent of the activity feed record.\n"
"     */\n"
"    public function parentable()\n"
"    {\n"
"        return $this->morphTo();\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 378 (paragraph)
msgid "In this example, let's assume `Event`, `Photo`, and `Post` models may create `ActivityFeed` models. Additionally, let's assume that `Event` models belong to a `Calendar` model, `Photo` models are associated with `Tag` models, and `Post` models belong to an `Author` model."
msgstr "在這個例子中，先假設 `Event`, `Photo`, 與 `Post` 會建立 `ActivityFeed` Model。另外，也來假設 `Event` Model 隸屬於 `Calendar` Model，而 `Photo` Model 則與 `Tag` Model 相關聯，然後 `Post` Model 隸屬於 `Author` Model。"

#: docs/8.x/eloquent-relationships.md:block 379 (paragraph)
msgid "Using these model definitions and relationships, we may retrieve `ActivityFeed` model instances and eager load all `parentable` models and their respective nested relationships:"
msgstr "有了這些 Model 定義與關聯，我們就可以取得 `ActivityFeed` Model 實體，然後積極載入所有 `parentable` Model 與這些 `parentable` Model 的巢狀關聯："

#: docs/8.x/eloquent-relationships.md:block 380 (code)
msgid "use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$activities = ActivityFeed::query()\n"
"    ->with(['parentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->morphWith([\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"
"    }])->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$activities = ActivityFeed::query()\n"
"    ->with(['parentable' => function (MorphTo $morphTo) {\n"
"        $morphTo->morphWith([\n"
"            Event::class => ['calendar'],\n"
"            Photo::class => ['tags'],\n"
"            Post::class => ['author'],\n"
"        ]);\n"
"    }])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 382 (header)
msgid "Eager Loading Specific Columns"
msgstr "積極載入特定欄位"

#: docs/8.x/eloquent-relationships.md:block 383 (paragraph)
msgid "You may not always need every column from the relationships you are retrieving. For this reason, Eloquent allows you to specify which columns of the relationship you would like to retrieve:"
msgstr "有時候，我們可能並不像取得關聯的所有欄位。為此，Eloquent 能讓我們指定要取得關聯的哪些欄位："

#: docs/8.x/eloquent-relationships.md:block 384 (code)
msgid "$books = Book::with('author:id,name,book_id')->get();\n"
msgstr "$books = Book::with('author:id,name,book_id')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 385 (quote)
msgid "{note} When using this feature, you should always include the `id` column and any relevant foreign key columns in the list of columns you wish to retrieve."
msgstr "{note} 使用這個功能時，請務必在欄位列表中包含 `id` 欄位以及其他相關的外部索引鍵欄位。"

#: docs/8.x/eloquent-relationships.md:block 387 (header)
msgid "Eager Loading By Default"
msgstr "預設積極載入"

#: docs/8.x/eloquent-relationships.md:block 388 (paragraph)
msgid "Sometimes you might want to always load some relationships when retrieving a model. To accomplish this, you may define a `$with` property on the model:"
msgstr "對於某些 Model，我們可能會希望這個 Model 總是能載入一些關聯。為此，我們可以在這種 Model 上定義一個 `$with` 屬性："

#: docs/8.x/eloquent-relationships.md:block 389 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Book extends Model\n"
"{\n"
"    /**\n"
"     * The relationships that should always be loaded.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $with = ['author'];\n\n"
"    /**\n"
"     * Get the author that wrote the book.\n"
"     */\n"
"    public function author()\n"
"    {\n"
"        return $this->belongsTo(Author::class);\n"
"    }\n\n"
"    /**\n"
"     * Get the genre of the book.\n"
"     */\n"
"    public function genre()\n"
"    {\n"
"        return $this->belongsTo(Genre::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Book extends Model\n"
"{\n"
"    /**\n"
"     * The relationships that should always be loaded.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $with = ['author'];\n\n"
"    /**\n"
"     * Get the author that wrote the book.\n"
"     */\n"
"    public function author()\n"
"    {\n"
"        return $this->belongsTo(Author::class);\n"
"    }\n\n"
"    /**\n"
"     * Get the genre of the book.\n"
"     */\n"
"    public function genre()\n"
"    {\n"
"        return $this->belongsTo(Genre::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 390 (paragraph)
msgid "If you would like to remove an item from the `$with` property for a single query, you may use the `without` method:"
msgstr "若想為單一查詢移除 `$with` 屬性中的某個項目，可以使用 `without` 方法："

#: docs/8.x/eloquent-relationships.md:block 391 (code)
msgid "$books = Book::without('author')->get();\n"
msgstr "$books = Book::without('author')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 392 (paragraph)
msgid "If you would like to override all items within the `$with` property for a single query, you may use the `withOnly` method:"
msgstr "若想為單一查詢複寫 `$with` 屬性中的所有項目，可以使用 `withOnly` 方法："

#: docs/8.x/eloquent-relationships.md:block 393 (code)
msgid "$books = Book::withOnly('genre')->get();\n"
msgstr "$books = Book::withOnly('genre')->get();\n"

#: docs/8.x/eloquent-relationships.md:block 395 (header)
msgid "Constraining Eager Loads"
msgstr "包含查詢條件的積極載入"

#: docs/8.x/eloquent-relationships.md:block 396 (paragraph)
msgid "Sometimes you may wish to eager load a relationship but also specify additional query conditions for the eager loading query. You can accomplish this by passing an array of relationships to the `with` method where the array key is a relationship name and the array value is a closure that adds additional constraints to the eager loading query:"
msgstr "在積極載入關聯時，我們有時候可能會希望能給積極載入查詢指定額外的查詢條件。可以通過傳入一組包含關聯的陣列給 `with` 方法來達成。這個陣列的索引鍵應為關聯的名稱，而陣列值則為要給積極載入查詢加上額外查詢條件的閉包："

#: docs/8.x/eloquent-relationships.md:block 397 (code)
msgid "use App\\Models\\User;\n\n"
"$users = User::with(['posts' => function ($query) {\n"
"    $query->where('title', 'like', '%code%');\n"
"}])->get();\n"
msgstr "use App\\Models\\User;\n\n"
"$users = User::with(['posts' => function ($query) {\n"
"    $query->where('title', 'like', '%code%');\n"
"}])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 398 (paragraph)
msgid "In this example, Eloquent will only eager load posts where the post's `title` column contains the word `code`. You may call other [query builder](/docs/{{version}}/queries) methods to further customize the eager loading operation:"
msgstr "在這個例子中，Eloquent 只會積極載入 `title` 欄位含有關鍵字 `code` 的文章。你還可以呼叫其他的 [Query Builder](/docs/{{version}}/queries) 方法來進一步自訂積極式載入："

#: docs/8.x/eloquent-relationships.md:block 399 (code)
msgid "$users = User::with(['posts' => function ($query) {\n"
"    $query->orderBy('created_at', 'desc');\n"
"}])->get();\n"
msgstr "$users = User::with(['posts' => function ($query) {\n"
"    $query->orderBy('created_at', 'desc');\n"
"}])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 400 (quote)
msgid "{note} The `limit` and `take` query builder methods may not be used when constraining eager loads."
msgstr "{note} 積極式載入不能使用 `limit` 與 `take` Query Builder 方法來作條件限制。"

#: docs/8.x/eloquent-relationships.md:block 402 (header)
msgid "Constraining Eager Loading Of `morphTo` Relationships"
msgstr "包含查詢條件的 `morphTo` 關聯積極載入"

#: docs/8.x/eloquent-relationships.md:block 403 (paragraph)
msgid "If you are eager loading a `morphTo` relationship, Eloquent will run multiple queries to fetch each type of related model. You may add additional constraints to each of these queries using the `MorphTo` relation's `constrain` method:"
msgstr "在積極載入 `morphTo` 關聯時，Eloquent 會為關聯 Model 的每個類型都執行多筆查詢。我們可以使用 `MorphTo` 關聯的 `constrain` 方法來對這些查詢分別加上額外的查詢條件："

#: docs/8.x/eloquent-relationships.md:block 404 (code)
msgid "use Illuminate\\Database\\Eloquent\\Builder;\n"
"use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\n"
"    $morphTo->constrain([\n"
"        Post::class => function (Builder $query) {\n"
"            $query->whereNull('hidden_at');\n"
"        },\n"
"        Video::class => function (Builder $query) {\n"
"            $query->where('type', 'educational');\n"
"        },\n"
"    ]);\n"
"}])->get();\n"
msgstr "use Illuminate\\Database\\Eloquent\\Builder;\n"
"use Illuminate\\Database\\Eloquent\\Relations\\MorphTo;\n\n"
"$comments = Comment::with(['commentable' => function (MorphTo $morphTo) {\n"
"    $morphTo->constrain([\n"
"        Post::class => function (Builder $query) {\n"
"            $query->whereNull('hidden_at');\n"
"        },\n"
"        Video::class => function (Builder $query) {\n"
"            $query->where('type', 'educational');\n"
"        },\n"
"    ]);\n"
"}])->get();\n"

#: docs/8.x/eloquent-relationships.md:block 405 (paragraph)
msgid "In this example, Eloquent will only eager load posts that have not been hidden and videos have a `type` value of \"educational\"."
msgstr "在這個範例中，Eloquent 只會積極載入非隱藏的貼文，以及 `type` 值不是「educational」的影片。"

#: docs/8.x/eloquent-relationships.md:block 407 (header)
msgid "Lazy Eager Loading"
msgstr "消極的積極式載入"

#: docs/8.x/eloquent-relationships.md:block 408 (paragraph)
msgid "Sometimes you may need to eager load a relationship after the parent model has already been retrieved. For example, this may be useful if you need to dynamically decide whether to load related models:"
msgstr "有時候，我們可能需要在已取得上層 Model 後才積極載入某個關聯。舉例來說，當想動態決定是否要載入關聯 Model 時，這種功能特別適合："

#: docs/8.x/eloquent-relationships.md:block 409 (code)
msgid "use App\\Models\\Book;\n\n"
"$books = Book::all();\n\n"
"if ($someCondition) {\n"
"    $books->load('author', 'publisher');\n"
"}\n"
msgstr "use App\\Models\\Book;\n\n"
"$books = Book::all();\n\n"
"if ($someCondition) {\n"
"    $books->load('author', 'publisher');\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 410 (paragraph)
msgid "If you need to set additional query constraints on the eager loading query, you may pass an array keyed by the relationships you wish to load. The array values should be closure instances which receive the query instance:"
msgstr "若想在積極載入查詢上設定額外的查詢條件，可以傳入一組陣列，其索引鍵應為要載入的關聯。陣列的值則為一個閉包，用來接收 Query Builder 實體："

#: docs/8.x/eloquent-relationships.md:block 411 (code)
msgid "$author->load(['books' => function ($query) {\n"
"    $query->orderBy('published_date', 'asc');\n"
"}]);\n"
msgstr "$author->load(['books' => function ($query) {\n"
"    $query->orderBy('published_date', 'asc');\n"
"}]);\n"

#: docs/8.x/eloquent-relationships.md:block 412 (paragraph)
msgid "To load a relationship only when it has not already been loaded, use the `loadMissing` method:"
msgstr "若想只在某個關聯未被載入時才載入該關聯，可使用 `loadMissing` 方法："

#: docs/8.x/eloquent-relationships.md:block 413 (code)
msgid "$book->loadMissing('author');\n"
msgstr "$book->loadMissing('author');\n"

#: docs/8.x/eloquent-relationships.md:block 415 (header)
msgid "Nested Lazy Eager Loading & `morphTo`"
msgstr "巢狀之消極的積極載入與 `morphTo`"

#: docs/8.x/eloquent-relationships.md:block 416 (paragraph)
msgid "If you would like to eager load a `morphTo` relationship, as well as nested relationships on the various entities that may be returned by that relationship, you may use the `loadMorph` method."
msgstr "若想積極式載入 `morphTo` 關聯、或是關聯 Model 的巢狀關聯等由 morphTo 關聯所回傳的功能，可以使用 `loadMorph` 方法："

#: docs/8.x/eloquent-relationships.md:block 417 (paragraph)
msgid "This method accepts the name of the `morphTo` relationship as its first argument, and an array of model / relationship pairs as its second argument. To help illustrate this method, let's consider the following model:"
msgstr "這個方法的第一個引數是 `morphTo` 關聯的名稱，第二個引數則是一組包含 Model / 關聯配對的陣列。為了說明這個功能，先來看看下列 Model："

#: docs/8.x/eloquent-relationships.md:block 421 (code)
msgid "$activities = ActivityFeed::with('parentable')\n"
"    ->get()\n"
"    ->loadMorph('parentable', [\n"
"        Event::class => ['calendar'],\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['author'],\n"
"    ]);\n"
msgstr "$activities = ActivityFeed::with('parentable')\n"
"    ->get()\n"
"    ->loadMorph('parentable', [\n"
"        Event::class => ['calendar'],\n"
"        Photo::class => ['tags'],\n"
"        Post::class => ['author'],\n"
"    ]);\n"

#: docs/8.x/eloquent-relationships.md:block 423 (header)
msgid "Preventing Lazy Loading"
msgstr "預防消極載入"

#: docs/8.x/eloquent-relationships.md:block 424 (paragraph)
msgid "As previously discussed, eager loading relationships can often provide significant performance benefits to your application. Therefore, if you would like, you may instruct Laravel to always prevent the lazy loading of relationships. To accomplish this, you may invoke the `preventLazyLoading` method offered by the base Eloquent model class. Typically, you should call this method within the `boot` method of your application's `AppServiceProvider` class."
msgstr "前面也說明過，對你的專案來說，積極載入關聯通常可以顯著提升效能。因此，我們可能會希望讓 Laravel 總是避免消極式載入關聯。為此，我們可以呼叫基礎 Eloquent Model 上的 `preventLazyLoading` 方法。一般來說，應該在你的專案中 `AppServiceProvider` 類別的 `boot` 方法內呼叫這個方法。"

#: docs/8.x/eloquent-relationships.md:block 425 (paragraph)
msgid "The `preventLazyLoading` method accepts an optional boolean argument that indicates if lazy loading should be prevented. For example, you may wish to only disable lazy loading in non-production environments so that your production environment will continue to function normally even if a lazy loaded relationship is accidentally present in production code:"
msgstr "`preventLazyLoading` 方法接受一個可選的布林引數，用來判斷是否應防止消極式載入。舉例來說，我們肯跟會希望只在非正式環境下才進用消極式載入，這樣一來，就算正式環境上的程式碼內不小心有個消極式載入的關聯，正式環境也可以正常運作："

#: docs/8.x/eloquent-relationships.md:block 426 (code)
msgid "use Illuminate\\Database\\Eloquent\\Model;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Model::preventLazyLoading(! $this->app->isProduction());\n"
"}\n"
msgstr "use Illuminate\\Database\\Eloquent\\Model;\n\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Model::preventLazyLoading(! $this->app->isProduction());\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 427 (paragraph)
msgid "After preventing lazy loading, Eloquent will throw a `Illuminate\\Database\\LazyLoadingViolationException` exception when your application attempts to lazy load any Eloquent relationship."
msgstr "阻止消極式載入後，當程式嘗試要消極載入任何 Eloquent 關聯時，Eloquent 會擲回一個 `Illuminate\\Database\\LazyLoadingViolationException` 例外。"

#: docs/8.x/eloquent-relationships.md:block 428 (paragraph)
msgid "You may customize the behavior of lazy loading violations using the `handleLazyLoadingViolationsUsing` method. For example, using this method, you may instruct lazy loading violations to only be logged instead of interrupting the application's execution with exceptions:"
msgstr "可以使用 `handleLazyLoadingViolationsUsing` 方法來自訂當發生消極載入時要如何處置。舉例來說，我們可以使用這個方法來讓 Laravel 在遇到消極載入的時候紀錄到日誌，而不是使用例外在終止程式的執行："

#: docs/8.x/eloquent-relationships.md:block 429 (code)
msgid "Model::handleLazyLoadingViolationUsing(function ($model, $relation) {\n"
"    $class = get_class($model);\n\n"
"    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\n"
"});\n"
msgstr "Model::handleLazyLoadingViolationUsing(function ($model, $relation) {\n"
"    $class = get_class($model);\n\n"
"    info(\"Attempted to lazy load [{$relation}] on model [{$class}].\");\n"
"});\n"

#: docs/8.x/eloquent-relationships.md:block 431 (header)
msgid "Inserting & Updating Related Models"
msgstr "插入與更新關聯的 Model"

#: docs/8.x/eloquent-relationships.md:block 433 (header)
msgid "The `save` Method"
msgstr "`save` 方法"

#: docs/8.x/eloquent-relationships.md:block 434 (paragraph)
msgid "Eloquent provides convenient methods for adding new models to relationships. For example, perhaps you need to add a new comment to a post. Instead of manually setting the `post_id` attribute on the `Comment` model you may insert the comment using the relationship's `save` method:"
msgstr "Eloquent 提供了一些方便的方法來給關聯新增新 Model。舉例來說，我們可能會需要給貼文新增新留言。比起手動在 `Comment` Model 上設定 `post_id`，我們可以使用關聯的 `save` Model 來插入留言："

#: docs/8.x/eloquent-relationships.md:block 435 (code)
msgid "use App\\Models\\Comment;\n"
"use App\\Models\\Post;\n\n"
"$comment = new Comment(['message' => 'A new comment.']);\n\n"
"$post = Post::find(1);\n\n"
"$post->comments()->save($comment);\n"
msgstr "use App\\Models\\Comment;\n"
"use App\\Models\\Post;\n\n"
"$comment = new Comment(['message' => 'A new comment.']);\n\n"
"$post = Post::find(1);\n\n"
"$post->comments()->save($comment);\n"

#: docs/8.x/eloquent-relationships.md:block 436 (paragraph)
msgid "Note that we did not access the `comments` relationship as a dynamic property. Instead, we called the `comments` method to obtain an instance of the relationship. The `save` method will automatically add the appropriate `post_id` value to the new `Comment` model."
msgstr "請注意，我們不是以動態屬性的方式來存取 `comment` 關聯，而是呼叫 `comments` 方法來取得關聯的實體。`save` 方法會自動為新建立的 `Comment` Model 加上適當的 `post_id` 值。"

#: docs/8.x/eloquent-relationships.md:block 437 (paragraph)
msgid "If you need to save multiple related models, you may use the `saveMany` method:"
msgstr "若有需要保存多個關聯 Model，可以使用 `saveMany` 方法："

#: docs/8.x/eloquent-relationships.md:block 438 (code)
msgid "$post = Post::find(1);\n\n"
"$post->comments()->saveMany([\n"
"    new Comment(['message' => 'A new comment.']),\n"
"    new Comment(['message' => 'Another new comment.']),\n"
"]);\n"
msgstr "$post = Post::find(1);\n\n"
"$post->comments()->saveMany([\n"
"    new Comment(['message' => 'A new comment.']),\n"
"    new Comment(['message' => 'Another new comment.']),\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 439 (paragraph)
msgid "The `save` and `saveMany` methods will persist the given model instances, but will not add the newly persisted models to any in-memory relationships that are already loaded onto the parent model. If you plan on accessing the relationship after using the `save` or `saveMany` methods, you may wish to use the `refresh` method to reload the model and its relationships:"
msgstr "`save` 與 `saveMany` 會將 Model 實體保存起來。不過，保存好的 Model 並不會被加到上層 Model 中已經載入到記憶體的關聯。在使用 `save` 或 `saveMany` 方法後，若有打算要存取這些關聯，可使用 `refresh` 方法來重新載入 Model 與其關聯："

#: docs/8.x/eloquent-relationships.md:block 440 (code)
msgid "$post->comments()->save($comment);\n\n"
"$post->refresh();\n\n"
"// All comments, including the newly saved comment...\n"
"$post->comments;\n"
msgstr "$post->comments()->save($comment);\n\n"
"$post->refresh();\n\n"
"// 所有留言，包含新建立的留言...\n"
"$post->comments;\n"

#: docs/8.x/eloquent-relationships.md:block 442 (header)
msgid "Recursively Saving Models & Relationships"
msgstr "遞歸保存 Model 與關聯"

#: docs/8.x/eloquent-relationships.md:block 443 (paragraph)
msgid "If you would like to `save` your model and all of its associated relationships, you may use the `push` method. In this example, the `Post` model will be saved as well as its comments and the comment's authors:"
msgstr "若想讓 `save` 方法保存 Model 與其所有相關的關聯 Model，可以使用 `push` 方法。在這個例子中，`Post` Model、`Post` Model 的留言、留言的作者等都會一起被保存："

#: docs/8.x/eloquent-relationships.md:block 444 (code)
msgid "$post = Post::find(1);\n\n"
"$post->comments[0]->message = 'Message';\n"
"$post->comments[0]->author->name = 'Author Name';\n\n"
"$post->push();\n"
msgstr "$post = Post::find(1);\n\n"
"$post->comments[0]->message = 'Message';\n"
"$post->comments[0]->author->name = 'Author Name';\n\n"
"$post->push();\n"

#: docs/8.x/eloquent-relationships.md:block 446 (header)
msgid "The `create` Method"
msgstr "`create` 方法"

#: docs/8.x/eloquent-relationships.md:block 447 (paragraph)
msgid "In addition to the `save` and `saveMany` methods, you may also use the `create` method, which accepts an array of attributes, creates a model, and inserts it into the database. The difference between `save` and `create` is that `save` accepts a full Eloquent model instance while `create` accepts a plain PHP `array`. The newly created model will be returned by the `create` method:"
msgstr "除了 `save` 跟 `saveMany` 方法外，也可以使用 `create` 方法來建立 Model 並插入資料庫。`create` 方法接受一組包含屬性的陣列。`save` 與 `create` 間不同的地方在於：`save` 接收完整的 Eloquent Model 實體，而 `create` 接收的是純 PHP 的 `array`。`create` 方法會回傳新建立的 Model："

#: docs/8.x/eloquent-relationships.md:block 448 (code)
msgid "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"$comment = $post->comments()->create([\n"
"    'message' => 'A new comment.',\n"
"]);\n"
msgstr "use App\\Models\\Post;\n\n"
"$post = Post::find(1);\n\n"
"$comment = $post->comments()->create([\n"
"    'message' => 'A new comment.',\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 449 (paragraph)
msgid "You may use the `createMany` method to create multiple related models:"
msgstr "可以使用 `createMany` 方法來建立多個關聯的 Model："

#: docs/8.x/eloquent-relationships.md:block 450 (code)
msgid "$post = Post::find(1);\n\n"
"$post->comments()->createMany([\n"
"    ['message' => 'A new comment.'],\n"
"    ['message' => 'Another new comment.'],\n"
"]);\n"
msgstr "$post = Post::find(1);\n\n"
"$post->comments()->createMany([\n"
"    ['message' => 'A new comment.'],\n"
"    ['message' => 'Another new comment.'],\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 451 (paragraph)
msgid "You may also use the `findOrNew`, `firstOrNew`, `firstOrCreate`, and `updateOrCreate` methods to [create and update models on relationships](/docs/{{version}}/eloquent#upserts)."
msgstr "也可以使用 `findOrNew`, `firstOrNew`, `firstOrCreate`, 與 `updateOrCreate` 等方法來[在關聯上建立並更新 Model](/docs/{{version}}/eloquent#upserts)。"

#: docs/8.x/eloquent-relationships.md:block 452 (quote)
msgid "{tip} Before using the `create` method, be sure to review the [mass assignment](/docs/{{version}}/eloquent#mass-assignment) documentation."
msgstr "{tip} 在使用 `create` 方法前，請先閱讀[大量賦值](/docs/{{version}}/eloquent#mass-assignment)的說明文件。"

#: docs/8.x/eloquent-relationships.md:block 454 (header)
msgid "Belongs To Relationships"
msgstr "Belongs To 關聯"

#: docs/8.x/eloquent-relationships.md:block 455 (paragraph)
msgid "If you would like to assign a child model to a new parent model, you may use the `associate` method. In this example, the `User` model defines a `belongsTo` relationship to the `Account` model. This `associate` method will set the foreign key on the child model:"
msgstr "若想將子 Model 指派給新的上層 Model，可以使用 `associate` 方法。在這個例子中，`User` Model 定義了一個連到 `Account` Model 的 `belongsTo` 關聯。`associate` 方法會在子 Model 上設定外部索引鍵："

#: docs/8.x/eloquent-relationships.md:block 456 (code)
msgid "use App\\Models\\Account;\n\n"
"$account = Account::find(10);\n\n"
"$user->account()->associate($account);\n\n"
"$user->save();\n"
msgstr "use App\\Models\\Account;\n\n"
"$account = Account::find(10);\n\n"
"$user->account()->associate($account);\n\n"
"$user->save();\n"

#: docs/8.x/eloquent-relationships.md:block 457 (paragraph)
msgid "To remove a parent model from a child model, you may use the `dissociate` method. This method will set the relationship's foreign key to `null`:"
msgstr "若要從子 Model 上移除上層 Model，可以使用 `dissociate` 方法。這個方法會將關聯的外部索引鍵設為 `null`："

#: docs/8.x/eloquent-relationships.md:block 458 (code)
msgid "$user->account()->dissociate();\n\n"
"$user->save();\n"
msgstr "$user->account()->dissociate();\n\n"
"$user->save();\n"

#: docs/8.x/eloquent-relationships.md:block 462 (header)
msgid "Attaching / Detaching"
msgstr "附加 / 解除附加"

#: docs/8.x/eloquent-relationships.md:block 463 (paragraph)
msgid "Eloquent also provides methods to make working with many-to-many relationships more convenient. For example, let's imagine a user can have many roles and a role can have many users. You may use the `attach` method to attach a role to a user by inserting a record in the relationship's intermediate table:"
msgstr "Eloquent 還提供一些能讓處理多對多關聯更方便的方法。舉例來說，先假設一個使用者 (User) 可以有多個職位 (Role)，而一個職位可以有多個使用者。可以使用 `attach` 方法來將某個職位附加到使用者身上，`attach` 會在關聯的中介資料表上插入一筆紀錄來完成："

#: docs/8.x/eloquent-relationships.md:block 464 (code)
msgid "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"$user->roles()->attach($roleId);\n"
msgstr "use App\\Models\\User;\n\n"
"$user = User::find(1);\n\n"
"$user->roles()->attach($roleId);\n"

#: docs/8.x/eloquent-relationships.md:block 465 (paragraph)
msgid "When attaching a relationship to a model, you may also pass an array of additional data to be inserted into the intermediate table:"
msgstr "在把關聯附加到 Model 上時，可以傳入一組陣列，包含額外要被插入到中介資料表上的資料："

#: docs/8.x/eloquent-relationships.md:block 466 (code)
msgid "$user->roles()->attach($roleId, ['expires' => $expires]);\n"
msgstr "$user->roles()->attach($roleId, ['expires' => $expires]);\n"

#: docs/8.x/eloquent-relationships.md:block 467 (paragraph)
msgid "Sometimes it may be necessary to remove a role from a user. To remove a many-to-many relationship record, use the `detach` method. The `detach` method will delete the appropriate record out of the intermediate table; however, both models will remain in the database:"
msgstr "有時候，我們還會需要從使用者身上移除某個職位。若要移除 Many-to-Many 關聯的紀錄，請使用 `detach` 方法。`detach` 方法會從中介資料表上移除相應的紀錄。不過，使用者跟職位兩個 Model 都還會保留在資料庫中："

#: docs/8.x/eloquent-relationships.md:block 468 (code)
msgid "// Detach a single role from the user...\n"
"$user->roles()->detach($roleId);\n\n"
"// Detach all roles from the user...\n"
"$user->roles()->detach();\n"
msgstr "// 在使用者上取消附加單一職位...\n"
"$user->roles()->detach($roleId);\n\n"
"// 在使用者上取消附加所有職位...\n"
"$user->roles()->detach();\n"

#: docs/8.x/eloquent-relationships.md:block 469 (paragraph)
msgid "For convenience, `attach` and `detach` also accept arrays of IDs as input:"
msgstr "為了更方便使用，`attach` 與 `detach` 也能接受一組包含 ID 的陣列作為輸入："

#: docs/8.x/eloquent-relationships.md:block 470 (code)
msgid "$user = User::find(1);\n\n"
"$user->roles()->detach([1, 2, 3]);\n\n"
"$user->roles()->attach([\n"
"    1 => ['expires' => $expires],\n"
"    2 => ['expires' => $expires],\n"
"]);\n"
msgstr "$user = User::find(1);\n\n"
"$user->roles()->detach([1, 2, 3]);\n\n"
"$user->roles()->attach([\n"
"    1 => ['expires' => $expires],\n"
"    2 => ['expires' => $expires],\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 472 (header)
msgid "Syncing Associations"
msgstr "同步關聯"

#: docs/8.x/eloquent-relationships.md:block 473 (paragraph)
msgid "You may also use the `sync` method to construct many-to-many associations. The `sync` method accepts an array of IDs to place on the intermediate table. Any IDs that are not in the given array will be removed from the intermediate table. So, after this operation is complete, only the IDs in the given array will exist in the intermediate table:"
msgstr "可以使用 `sync` 方法來設定 Many-to-Many 關聯。`sync` 方法接受一組包含 ID 的陣列，用以插入中介資料表。中介資料表中若有不在此陣列中的 ID 則會被移除。因此，完成這個操作後，中介資料表中就只會有給定陣列中的 ID："

#: docs/8.x/eloquent-relationships.md:block 474 (code)
msgid "$user->roles()->sync([1, 2, 3]);\n"
msgstr "$user->roles()->sync([1, 2, 3]);\n"

#: docs/8.x/eloquent-relationships.md:block 475 (paragraph)
msgid "You may also pass additional intermediate table values with the IDs:"
msgstr "也可以使用 ID 來傳入額外的中介資料表值："

#: docs/8.x/eloquent-relationships.md:block 476 (code)
msgid "$user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"
msgstr "$user->roles()->sync([1 => ['expires' => true], 2, 3]);\n"

#: docs/8.x/eloquent-relationships.md:block 477 (paragraph)
msgid "If you would like to insert the same intermediate table values with each of the synced model IDs, you may use the `syncWithPivotValues` method:"
msgstr "如喔想為每個同步的 Model ID 都插入相同的中介資料表值，則可以使用 `syncWithPivotValue` 方法："

#: docs/8.x/eloquent-relationships.md:block 478 (code)
msgid "$user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\n"
msgstr "$user->roles()->syncWithPivotValues([1, 2, 3], ['active' => true]);\n"

#: docs/8.x/eloquent-relationships.md:block 479 (paragraph)
msgid "If you do not want to detach existing IDs that are missing from the given array, you may use the `syncWithoutDetaching` method:"
msgstr "若想從給定陣列中移除現有的 ID，則可以使用 `syncWithoutDetaching` 方法："

#: docs/8.x/eloquent-relationships.md:block 480 (code)
msgid "$user->roles()->syncWithoutDetaching([1, 2, 3]);\n"
msgstr "$user->roles()->syncWithoutDetaching([1, 2, 3]);\n"

#: docs/8.x/eloquent-relationships.md:block 482 (header)
msgid "Toggling Associations"
msgstr "切換關聯"

#: docs/8.x/eloquent-relationships.md:block 483 (paragraph)
msgid "The many-to-many relationship also provides a `toggle` method which \"toggles\" the attachment status of the given related model IDs. If the given ID is currently attached, it will be detached. Likewise, if it is currently detached, it will be attached:"
msgstr "Many-to-Many 關聯還提供了一個 `toggle` 方法，可以用來「切換 (Toggle)」給定關聯 Model ID 的附加狀態。若給定的 ID 目前是已附加的狀態，則該 ID 會被解除附加。反之，若目前未附加，則會被附加上去："

#: docs/8.x/eloquent-relationships.md:block 484 (code)
msgid "$user->roles()->toggle([1, 2, 3]);\n"
msgstr "$user->roles()->toggle([1, 2, 3]);\n"

#: docs/8.x/eloquent-relationships.md:block 486 (header)
msgid "Updating A Record On The Intermediate Table"
msgstr "更新中介資料表上的紀錄"

#: docs/8.x/eloquent-relationships.md:block 487 (paragraph)
msgid "If you need to update an existing row in your relationship's intermediate table, you may use the `updateExistingPivot` method. This method accepts the intermediate record foreign key and an array of attributes to update:"
msgstr "若想更新關聯的中介資料表上現有的紀錄，可以使用 `updateExistingPivot` 方法。這個方法接受中介資料表的外部索引鍵以及一組包含要更新屬性的陣列："

#: docs/8.x/eloquent-relationships.md:block 488 (code)
msgid "$user = User::find(1);\n\n"
"$user->roles()->updateExistingPivot($roleId, [\n"
"    'active' => false,\n"
"]);\n"
msgstr "$user = User::find(1);\n\n"
"$user->roles()->updateExistingPivot($roleId, [\n"
"    'active' => false,\n"
"]);\n"

#: docs/8.x/eloquent-relationships.md:block 490 (header)
msgid "Touching Parent Timestamps"
msgstr "更新上層的時戳"

#: docs/8.x/eloquent-relationships.md:block 491 (paragraph)
msgid "When a model defines a `belongsTo` or `belongsToMany` relationship to another model, such as a `Comment` which belongs to a `Post`, it is sometimes helpful to update the parent's timestamp when the child model is updated."
msgstr "若某 Model 有定義對另一個 Model 的 `belongsTo` 或 `belongsToMany` 關聯 —— 如 `Comment` Model 隸屬於 `Post` Model 等 —— 有時候，若能在子 Model 更新時也一併更新上層 Model 的時戳會很實用。"

#: docs/8.x/eloquent-relationships.md:block 492 (paragraph)
msgid "For example, when a `Comment` model is updated, you may want to automatically \"touch\" the `updated_at` timestamp of the owning `Post` so that it is set to the current date and time. To accomplish this, you may add a `touches` property to your child model containing the names of the relationships that should have their `updated_at` timestamps updated when the child model is updated:"
msgstr "舉例來說，當 `Comment` Model 更新後，我們可能會想自動「更新 (Touch)」擁有該 `Comment` 的 `Post` Model 上的 `updated_at` 時戳，將該時戳設為目前的日期與時間。為此，我們可以在子 Model 內新增一個 `touches` 屬性，其中包含關聯的名稱。當子 Model 更新後，這些關聯的 `updated_at` 時戳也會一起更新："

#: docs/8.x/eloquent-relationships.md:block 493 (code)
msgid "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * All of the relationships to be touched.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $touches = ['post'];\n\n"
"    /**\n"
"     * Get the post that the comment belongs to.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Models;\n\n"
"use Illuminate\\Database\\Eloquent\\Model;\n\n"
"class Comment extends Model\n"
"{\n"
"    /**\n"
"     * All of the relationships to be touched.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $touches = ['post'];\n\n"
"    /**\n"
"     * Get the post that the comment belongs to.\n"
"     */\n"
"    public function post()\n"
"    {\n"
"        return $this->belongsTo(Post::class);\n"
"    }\n"
"}\n"

#: docs/8.x/eloquent-relationships.md:block 494 (quote)
msgid "{note} Parent model timestamps will only be updated if the child model is updated using Eloquent's `save` method."
msgstr "{note} 只有在使用 Eloquent 的 `save` 方法來更新子 Model 時，才會更新上傳 Model 的時戳。"

#: docs/9.x/eloquent-relationships.md:block 68 (paragraph)
msgid "You may also provide a [collection](/docs/{{version}}/eloquent-collections) instance to the `whereBelongsTo` method. When doing so, Laravel will retrieve models that belong to any of the parent models within the collection:"
msgstr "我們也可以提供一個 [Collection](/docs/{{version}}/eloquent-collections) 實體給 `whereBelongsTo` 方法。這時，Laravel 會取得所有上層 Model 有包含在該 Collection 中的 Model："

#: docs/9.x/eloquent-relationships.md:block 69 (code)
msgid "$users = User::where('vip', true)->get();\n\n"
"$posts = Post::whereBelongsTo($users)->get();\n"
msgstr "$users = User::where('vip', true)->get();\n\n"
"$posts = Post::whereBelongsTo($users)->get();\n"

#: docs/9.x/eloquent-relationships.md:block 84 (paragraph)
msgid "It is possible to construct more advanced \"has one of many\" relationships. For example, a `Product` model may have many associated `Price` models that are retained in the system even after new pricing is published. In addition, new pricing data for the product may be able to be published in advance to take effect at a future date via a `published_at` column."
msgstr "我們還可以進一步地做出進階的「一對多中之一」關聯。舉例來說，`Product` Model 可能會有許多相應的 `Price` Model，這些 `Price` Model 會在每次更新商品價格後保留在系統內。此外，我們也可以進一步地通過 `published_at` 欄位來讓某個商品價格在未來的時間點生效。"

#: docs/9.x/eloquent-relationships.md:block 407 (paragraph)
msgid "In this example, Eloquent will only eager load posts that have not been hidden and videos that have a `type` value of \"educational\"."
msgstr "在這個範例中，Eloquent 只會積極載入非隱藏的貼文，以及 `type` 值不是「educational」的影片。"

