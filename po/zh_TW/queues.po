msgid ""
msgstr ""
"Content-Type: text/plain; charset=UTF-8\n"
"Language: zh_TW\n"
"Language-Team: Chinese Traditional\n"
"PO-Revision-Date: 2024-06-30 08:15\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"Project-Id-Version: laravel-docs\n"
"X-Crowdin-File: /main/templates/queues.pot\n"
"X-Crowdin-File-ID: 125\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"

# H1
#: ./docs/8.x/queues.md:1
#: ./docs/9.x/queues.md:1
#: ./docs/10.x/queues.md:1
#: ./docs/11.x/queues.md:1
#: ./docs/master/queues.md:1
msgid "Queues"
msgstr "佇列 - Queue"

# P
#: ./docs/8.x/queues.md:3
#: ./docs/9.x/queues.md:3
#: ./docs/10.x/queues.md:3
#: ./docs/11.x/queues.md:3
#: ./docs/master/queues.md:3
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

# P
#: ./docs/10.x/queues.md:4
#: ./docs/11.x/queues.md:4
#: ./docs/master/queues.md:4
msgid "[Connections vs. Queues](#connections-vs-queues)"
msgstr ""

# P
#: ./docs/8.x/queues.md:4
#: ./docs/9.x/queues.md:4
msgid "[Connections Vs. Queues](#connections-vs-queues)"
msgstr "[連線 Vs. 佇列](#connections-vs-queues)"

# P
#: ./docs/10.x/queues.md:5
#: ./docs/11.x/queues.md:5
#: ./docs/master/queues.md:5
msgid "[Driver Notes and Prerequisites](#driver-prerequisites)"
msgstr ""

# P
#: ./docs/8.x/queues.md:5
#: ./docs/9.x/queues.md:5
msgid "[Driver Notes & Prerequisites](#driver-prerequisites)"
msgstr "[Driver 注意事項與前置需求](#driver-prerequisites)"

# P
#: ./docs/8.x/queues.md:6
#: ./docs/9.x/queues.md:6
#: ./docs/10.x/queues.md:6
#: ./docs/11.x/queues.md:6
#: ./docs/master/queues.md:6
msgid "[Creating Jobs](#creating-jobs)"
msgstr "[建立 Job](#creating-jobs)"

# P
#: ./docs/8.x/queues.md:7
#: ./docs/9.x/queues.md:7
#: ./docs/10.x/queues.md:7
#: ./docs/11.x/queues.md:7
#: ./docs/master/queues.md:7
msgid "[Generating Job Classes](#generating-job-classes)"
msgstr "[產生 Job 類別](#generating-job-classes)"

# P
#: ./docs/8.x/queues.md:8
#: ./docs/9.x/queues.md:8
#: ./docs/10.x/queues.md:8
#: ./docs/11.x/queues.md:8
#: ./docs/master/queues.md:8
msgid "[Class Structure](#class-structure)"
msgstr "[類別架構](#class-structure)"

# P
#: ./docs/8.x/queues.md:9
#: ./docs/9.x/queues.md:9
#: ./docs/10.x/queues.md:9
#: ./docs/11.x/queues.md:9
#: ./docs/master/queues.md:9
msgid "[Unique Jobs](#unique-jobs)"
msgstr "[不重複 Job](#unique-jobs)"

# P
#: ./docs/10.x/queues.md:10
#: ./docs/11.x/queues.md:10
#: ./docs/master/queues.md:10
msgid "[Encrypted Jobs](#encrypted-jobs)"
msgstr "[加密的 Job](#encrypted-jobs)"

# P
#: ./docs/8.x/queues.md:10
#: ./docs/9.x/queues.md:10
#: ./docs/10.x/queues.md:11
#: ./docs/11.x/queues.md:11
#: ./docs/master/queues.md:11
msgid "[Job Middleware](#job-middleware)"
msgstr "[Job Middleware](#job-middleware)"

# P
#: ./docs/8.x/queues.md:11
#: ./docs/9.x/queues.md:11
#: ./docs/10.x/queues.md:12
#: ./docs/11.x/queues.md:12
#: ./docs/master/queues.md:12
msgid "[Rate Limiting](#rate-limiting)"
msgstr "[頻率限制](#rate-limiting)"

# P
#: ./docs/8.x/queues.md:12
#: ./docs/9.x/queues.md:12
#: ./docs/10.x/queues.md:13
#: ./docs/11.x/queues.md:13
#: ./docs/master/queues.md:13
msgid "[Preventing Job Overlaps](#preventing-job-overlaps)"
msgstr "[避免 Job 重疊](#preventing-job-overlaps)"

# P
#: ./docs/8.x/queues.md:13
#: ./docs/9.x/queues.md:13
#: ./docs/10.x/queues.md:14
#: ./docs/11.x/queues.md:14
#: ./docs/master/queues.md:14
msgid "[Throttling Exceptions](#throttling-exceptions)"
msgstr "[頻率限制的 Exception](#throttling-exceptions)"

# P
#: ./docs/8.x/queues.md:14
#: ./docs/9.x/queues.md:14
#: ./docs/10.x/queues.md:15
#: ./docs/11.x/queues.md:16
#: ./docs/master/queues.md:15
msgid "[Dispatching Jobs](#dispatching-jobs)"
msgstr "[分派 Job](#dispatching-jobs)"

# P
#: ./docs/11.x/queues.md:15
msgid "[Skipping Jobs](#skipping-jobs)"
msgstr ""

# P
#: ./docs/8.x/queues.md:15
#: ./docs/9.x/queues.md:15
#: ./docs/10.x/queues.md:16
#: ./docs/11.x/queues.md:17
#: ./docs/master/queues.md:16
msgid "[Delayed Dispatching](#delayed-dispatching)"
msgstr "[延遲分派](#delayed-dispatching)"

# P
#: ./docs/8.x/queues.md:16
#: ./docs/9.x/queues.md:16
#: ./docs/10.x/queues.md:17
#: ./docs/11.x/queues.md:18
#: ./docs/master/queues.md:17
msgid "[Synchronous Dispatching](#synchronous-dispatching)"
msgstr "[同步分派](#synchronous-dispatching)"

# P
#: ./docs/8.x/queues.md:17
#: ./docs/9.x/queues.md:17
#: ./docs/10.x/queues.md:18
#: ./docs/11.x/queues.md:19
#: ./docs/master/queues.md:18
msgid "[Jobs & Database Transactions](#jobs-and-database-transactions)"
msgstr "[Job 與資料庫 Transaction](#jobs-and-database-transactions)"

# P
#: ./docs/8.x/queues.md:18
#: ./docs/9.x/queues.md:18
#: ./docs/10.x/queues.md:19
#: ./docs/11.x/queues.md:20
#: ./docs/master/queues.md:19
msgid "[Job Chaining](#job-chaining)"
msgstr "[串聯 Job](#job-chaining)"

# P
#: ./docs/8.x/queues.md:19
#: ./docs/9.x/queues.md:19
msgid "[Customizing The Queue & Connection](#customizing-the-queue-and-connection)"
msgstr "[自訂佇列與連線](#customizing-the-queue-and-connection)"

# P
#: ./docs/10.x/queues.md:20
#: ./docs/11.x/queues.md:21
#: ./docs/master/queues.md:20
msgid "[Customizing The Queue and Connection](#customizing-the-queue-and-connection)"
msgstr ""

# P
#: ./docs/8.x/queues.md:20
#: ./docs/9.x/queues.md:20
#: ./docs/10.x/queues.md:21
#: ./docs/11.x/queues.md:22
#: ./docs/master/queues.md:21
msgid "[Specifying Max Job Attempts / Timeout Values](#max-job-attempts-and-timeout)"
msgstr "[指定 Job 最大嘗試次數與逾時](#max-job-attempts-and-timeout)"

# P
#: ./docs/8.x/queues.md:21
#: ./docs/9.x/queues.md:21
#: ./docs/10.x/queues.md:22
#: ./docs/11.x/queues.md:23
#: ./docs/master/queues.md:22
msgid "[Error Handling](#error-handling)"
msgstr "[錯誤處理](#error-handling)"

# P
#: ./docs/8.x/queues.md:22
#: ./docs/9.x/queues.md:22
#: ./docs/10.x/queues.md:23
#: ./docs/11.x/queues.md:24
#: ./docs/master/queues.md:23
msgid "[Job Batching](#job-batching)"
msgstr "[批次 Job](#job-batching)"

# P
#: ./docs/8.x/queues.md:23
#: ./docs/9.x/queues.md:23
#: ./docs/10.x/queues.md:24
#: ./docs/11.x/queues.md:25
#: ./docs/master/queues.md:24
msgid "[Defining Batchable Jobs](#defining-batchable-jobs)"
msgstr "[定義批次 Job](#defining-batchable-jobs)"

# P
#: ./docs/8.x/queues.md:24
#: ./docs/9.x/queues.md:24
#: ./docs/10.x/queues.md:25
#: ./docs/11.x/queues.md:26
#: ./docs/master/queues.md:25
msgid "[Dispatching Batches](#dispatching-batches)"
msgstr "[分派批次](#dispatching-batches)"

# P
#: ./docs/8.x/queues.md:25
#: ./docs/9.x/queues.md:25
msgid "[Adding Jobs To Batches](#adding-jobs-to-batches)"
msgstr "[將 Job 加入批次中](#adding-jobs-to-batches)"

# P
#: ./docs/10.x/queues.md:26
#: ./docs/11.x/queues.md:27
#: ./docs/master/queues.md:26
msgid "[Chains and Batches](#chains-and-batches)"
msgstr ""

# P
#: ./docs/8.x/queues.md:26
#: ./docs/9.x/queues.md:26
#: ./docs/10.x/queues.md:28
#: ./docs/11.x/queues.md:29
#: ./docs/master/queues.md:28
msgid "[Inspecting Batches](#inspecting-batches)"
msgstr "[檢查批次](#inspecting-batches)"

# P
#: ./docs/10.x/queues.md:27
#: ./docs/11.x/queues.md:28
#: ./docs/master/queues.md:27
msgid "[Adding Jobs to Batches](#adding-jobs-to-batches)"
msgstr ""

# P
#: ./docs/8.x/queues.md:27
#: ./docs/9.x/queues.md:27
#: ./docs/10.x/queues.md:29
#: ./docs/11.x/queues.md:30
#: ./docs/master/queues.md:29
msgid "[Cancelling Batches](#cancelling-batches)"
msgstr "[取消批次](#cancelling-batches)"

# P
#: ./docs/8.x/queues.md:28
#: ./docs/9.x/queues.md:28
#: ./docs/10.x/queues.md:30
#: ./docs/11.x/queues.md:31
#: ./docs/master/queues.md:30
msgid "[Batch Failures](#batch-failures)"
msgstr "[批次執行失敗](#batch-failures)"

# P
#: ./docs/8.x/queues.md:29
#: ./docs/9.x/queues.md:29
#: ./docs/10.x/queues.md:31
#: ./docs/11.x/queues.md:32
#: ./docs/master/queues.md:31
msgid "[Pruning Batches](#pruning-batches)"
msgstr "[修剪批次](#pruning-batches)"

# P
#: ./docs/8.x/queues.md:30
#: ./docs/9.x/queues.md:30
#: ./docs/10.x/queues.md:33
#: ./docs/11.x/queues.md:34
#: ./docs/master/queues.md:33
msgid "[Queueing Closures](#queueing-closures)"
msgstr "[將閉包放入佇列](#queueing-closures)"

# P
#: ./docs/8.x/queues.md:31
#: ./docs/9.x/queues.md:31
msgid "[Running The Queue Worker](#running-the-queue-worker)"
msgstr "[執行 Queue Worker](#running-the-queue-worker)"

# P
#: ./docs/10.x/queues.md:32
#: ./docs/11.x/queues.md:33
#: ./docs/master/queues.md:32
msgid "[Storing Batches in DynamoDB](#storing-batches-in-dynamodb)"
msgstr ""

# P
#: ./docs/8.x/queues.md:32
#: ./docs/9.x/queues.md:32
#: ./docs/10.x/queues.md:35
#: ./docs/11.x/queues.md:36
#: ./docs/master/queues.md:35
msgid "[The `queue:work` Command](#the-queue-work-command)"
msgstr "[`queue:work` 指令](#the-queue-work-command)"

# P
#: ./docs/8.x/queues.md:33
#: ./docs/9.x/queues.md:33
#: ./docs/10.x/queues.md:36
#: ./docs/11.x/queues.md:37
#: ./docs/master/queues.md:36
msgid "[Queue Priorities](#queue-priorities)"
msgstr "[佇列的優先度](#queue-priorities)"

# P
#: ./docs/10.x/queues.md:34
#: ./docs/11.x/queues.md:35
#: ./docs/master/queues.md:34
msgid "[Running the Queue Worker](#running-the-queue-worker)"
msgstr ""

# P
#: ./docs/8.x/queues.md:34
#: ./docs/9.x/queues.md:34
msgid "[Queue Workers & Deployment](#queue-workers-and-deployment)"
msgstr "[Queue Worker 與部署](#queue-workers-and-deployment)"

# P
#: ./docs/8.x/queues.md:35
#: ./docs/9.x/queues.md:35
msgid "[Job Expirations & Timeouts](#job-expirations-and-timeouts)"
msgstr "[Job 的實效性與逾時](#job-expirations-and-timeouts)"

# P
#: ./docs/8.x/queues.md:36
#: ./docs/9.x/queues.md:36
#: ./docs/10.x/queues.md:39
#: ./docs/11.x/queues.md:40
#: ./docs/master/queues.md:39
msgid "[Supervisor Configuration](#supervisor-configuration)"
msgstr "[Supervisor 設定](#supervisor-configuration)"

# P
#: ./docs/10.x/queues.md:37
#: ./docs/11.x/queues.md:38
#: ./docs/master/queues.md:37
msgid "[Queue Workers and Deployment](#queue-workers-and-deployment)"
msgstr ""

# P
#: ./docs/8.x/queues.md:37
#: ./docs/9.x/queues.md:37
#: ./docs/10.x/queues.md:40
#: ./docs/11.x/queues.md:41
#: ./docs/master/queues.md:40
msgid "[Dealing With Failed Jobs](#dealing-with-failed-jobs)"
msgstr "[處理失敗的 Job](#dealing-with-failed-jobs)"

# P
#: ./docs/10.x/queues.md:38
#: ./docs/11.x/queues.md:39
#: ./docs/master/queues.md:38
msgid "[Job Expirations and Timeouts](#job-expirations-and-timeouts)"
msgstr ""

# P
#: ./docs/8.x/queues.md:38
#: ./docs/9.x/queues.md:38
#: ./docs/10.x/queues.md:41
#: ./docs/11.x/queues.md:42
#: ./docs/master/queues.md:41
msgid "[Cleaning Up After Failed Jobs](#cleaning-up-after-failed-jobs)"
msgstr "[在 Job 失敗後進行清理](#cleaning-up-after-failed-jobs)"

# P
#: ./docs/8.x/queues.md:39
#: ./docs/9.x/queues.md:39
#: ./docs/10.x/queues.md:42
#: ./docs/11.x/queues.md:43
#: ./docs/master/queues.md:42
msgid "[Retrying Failed Jobs](#retrying-failed-jobs)"
msgstr "[重試失敗的 Job](#retrying-failed-jobs)"

# P
#: ./docs/8.x/queues.md:40
#: ./docs/9.x/queues.md:40
#: ./docs/10.x/queues.md:43
#: ./docs/11.x/queues.md:44
#: ./docs/master/queues.md:43
msgid "[Ignoring Missing Models](#ignoring-missing-models)"
msgstr "[忽略不存在的 Model](#ignoring-missing-models)"

# P
#: ./docs/8.x/queues.md:41
#: ./docs/9.x/queues.md:41
#: ./docs/10.x/queues.md:44
#: ./docs/11.x/queues.md:45
#: ./docs/master/queues.md:44
msgid "[Pruning Failed Jobs](#pruning-failed-jobs)"
msgstr "[修剪失敗的 Job](#pruning-failed-jobs)"

# P
#: ./docs/8.x/queues.md:42
#: ./docs/9.x/queues.md:42
msgid "[Storing Failed Jobs In DynamoDB](#storing-failed-jobs-in-dynamodb)"
msgstr "[在 DynamoDB 中保存失敗的 Job](#storing-failed-jobs-in-dynamodb)"

# P
#: ./docs/8.x/queues.md:43
#: ./docs/9.x/queues.md:43
#: ./docs/10.x/queues.md:46
#: ./docs/11.x/queues.md:47
#: ./docs/master/queues.md:46
msgid "[Disabling Failed Job Storage](#disabling-failed-job-storage)"
msgstr "[禁用失敗 Job 的保存](#disabling-failed-job-storage)"

# P
#: ./docs/8.x/queues.md:44
#: ./docs/9.x/queues.md:44
#: ./docs/10.x/queues.md:47
#: ./docs/11.x/queues.md:48
#: ./docs/master/queues.md:47
msgid "[Failed Job Events](#failed-job-events)"
msgstr "[失敗 Job 事件](#failed-job-events)"

# P
#: ./docs/10.x/queues.md:45
#: ./docs/11.x/queues.md:46
#: ./docs/master/queues.md:45
msgid "[Storing Failed Jobs in DynamoDB](#storing-failed-jobs-in-dynamodb)"
msgstr ""

# P
#: ./docs/8.x/queues.md:45
#: ./docs/9.x/queues.md:45
#: ./docs/10.x/queues.md:48
#: ./docs/11.x/queues.md:49
#: ./docs/master/queues.md:48
msgid "[Clearing Jobs From Queues](#clearing-jobs-from-queues)"
msgstr "[在佇列中清除 Job](#clearing-jobs-from-queues)"

# P
#: ./docs/8.x/queues.md:46
#: ./docs/9.x/queues.md:46
#: ./docs/10.x/queues.md:49
#: ./docs/11.x/queues.md:50
#: ./docs/master/queues.md:49
msgid "[Monitoring Your Queues](#monitoring-your-queues)"
msgstr "[監控佇列](#monitoring-your-queues)"

# P
#: ./docs/8.x/queues.md:47
#: ./docs/9.x/queues.md:47
#: ./docs/10.x/queues.md:54
#: ./docs/11.x/queues.md:56
#: ./docs/master/queues.md:55
msgid "[Job Events](#job-events)"
msgstr "[Job 事件](#job-events)"

# P
#: ./docs/8.x/queues.md:49
#: ./docs/9.x/queues.md:49
#: ./docs/10.x/queues.md:56
#: ./docs/11.x/queues.md:58
#: ./docs/master/queues.md:57
#~ msgid "<a name=\"introduction\"></a>"
#~ msgstr ""

# P
#: ./docs/10.x/queues.md:50
#: ./docs/11.x/queues.md:51
#: ./docs/master/queues.md:50
msgid "[Testing](#testing)"
msgstr "[測試](#testing)"

# H2
#: ./docs/8.x/queues.md:50
#: ./docs/9.x/queues.md:50
#: ./docs/10.x/queues.md:57
#: ./docs/11.x/queues.md:59
#: ./docs/master/queues.md:58
msgid "Introduction"
msgstr "簡介"

# P
#: ./docs/10.x/queues.md:51
#: ./docs/11.x/queues.md:52
#: ./docs/master/queues.md:51
msgid "[Faking a Subset of Jobs](#faking-a-subset-of-jobs)"
msgstr ""

# P
#: ./docs/10.x/queues.md:52
#: ./docs/11.x/queues.md:53
#: ./docs/master/queues.md:52
msgid "[Testing Job Chains](#testing-job-chains)"
msgstr "[測試串連的 Job](#testing-job-chains)"

# P
#: ./docs/8.x/queues.md:52
#: ./docs/9.x/queues.md:52
#: ./docs/10.x/queues.md:59
#: ./docs/11.x/queues.md:61
#: ./docs/master/queues.md:60
msgid "While building your web application, you may have some tasks, such as parsing and storing an uploaded CSV file, that take too long to perform during a typical web request. Thankfully, Laravel allows you to easily create queued jobs that may be processed in the background. By moving time intensive tasks to a queue, your application can respond to web requests with blazing speed and provide a better user experience to your customers."
msgstr "在製作 Web App 時，有些任務若在 Web Request 中進行會花費太多時間，如解析 CSV 檔並上傳。所幸，在 Laravel 中，要建立在背景執行的佇列任務非常輕鬆。只要將需要花費時間的任務移到佇列中執行，就能加速網站對 Request 的回應速度，並提供更好的使用者經驗給客戶。"

# P
#: ./docs/10.x/queues.md:53
#: ./docs/11.x/queues.md:54
#: ./docs/master/queues.md:53
msgid "[Testing Job Batches](#testing-job-batches)"
msgstr "[測試批次的 Job](#testing-job-batches)"

# P
#: ./docs/8.x/queues.md:54
#: ./docs/9.x/queues.md:54
#: ./docs/10.x/queues.md:61
#: ./docs/11.x/queues.md:63
#: ./docs/master/queues.md:62
msgid "Laravel queues provide a unified queueing API across a variety of different queue backends, such as [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), or even a relational database."
msgstr "Laravel 的佇列為各種不同的佇列後端都提供了統一的 API。這些後端包括 [Amazon SQS](https://aws.amazon.com/sqs/)、[Redis](https://redis.io)、甚至是關聯式資料庫。"

# P
#: ./docs/11.x/queues.md:55
#: ./docs/master/queues.md:54
msgid "[Testing Job / Queue Interactions](#testing-job-queue-interactions)"
msgstr ""

# P
#: ./docs/8.x/queues.md:56
#: ./docs/9.x/queues.md:56
#: ./docs/10.x/queues.md:63
#: ./docs/11.x/queues.md:65
#: ./docs/master/queues.md:64
msgid "Laravel's queue configuration options are stored in your application's `config/queue.php` configuration file. In this file, you will find connection configurations for each of the queue drivers that are included with the framework, including the database, [Amazon SQS](https://aws.amazon.com/sqs/), [Redis](https://redis.io), and [Beanstalkd](https://beanstalkd.github.io/) drivers, as well as a synchronous driver that will execute jobs immediately (for use during local development). A `null` queue driver is also included which discards queued jobs."
msgstr "Laravel 的佇列設定選項保存在專案的 `config/queue.php` 設定檔中。在這個檔案內，可以看到供各個 Laravel 內建佇列 Driver 使用的連線設定，包含資料庫、[Amazon SQS](https://aws.amazon.com/sqs/)、[Redis](https://redis.io)、[Beanstalkd](https://beanstalkd.github.io/) 等 Driver，還包括一個會即時執行任務的同步佇列 (用於本機開發)。還包含一個 `null` 佇列，用於忽略佇列任務。"

# P
#: ./docs/8.x/queues.md:58
#: ./docs/9.x/queues.md:59
#: ./docs/10.x/queues.md:66
#: ./docs/11.x/queues.md:68
#: ./docs/master/queues.md:67
msgid "Laravel now offers Horizon, a beautiful dashboard and configuration system for your Redis powered queues. Check out the full [Horizon documentation](/docs/{{version}}/horizon) for more information."
msgstr "Laravel 現在還提供 Horizon。Horizon 是為 Redis 佇列提供的一個一個漂亮面板。更多資訊請參考完整的 [Horizon 說明文件](/docs/{{version}}/horizon)。"

# P
#: ./docs/8.x/queues.md:60
#: ./docs/9.x/queues.md:61
#: ./docs/10.x/queues.md:68
#: ./docs/11.x/queues.md:70
#: ./docs/master/queues.md:69
#~ msgid "<a name=\"connections-vs-queues\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:61
#: ./docs/9.x/queues.md:62
msgid "Connections Vs. Queues"
msgstr "連線 Vs. 佇列"

# P
#: ./docs/8.x/queues.md:63
#: ./docs/9.x/queues.md:64
#: ./docs/10.x/queues.md:71
#: ./docs/11.x/queues.md:73
#: ./docs/master/queues.md:72
msgid "Before getting started with Laravel queues, it is important to understand the distinction between \"connections\" and \"queues\". In your `config/queue.php` configuration file, there is a `connections` configuration array. This option defines the connections to backend queue services such as Amazon SQS, Beanstalk, or Redis. However, any given queue connection may have multiple \"queues\" which may be thought of as different stacks or piles of queued jobs."
msgstr "在開始使用 Laravel 佇列前，我們需要先瞭解「^[連線](Connection)」與「^[佇列](Queue)」的差別。在 `config/queue.php` 設定檔中有個 `connections` 設定陣列。該選項用於定義連到後端佇列服務的連線，後端佇列服務就是像 Amazon SQS、Beanstalk、Redis 等。不過，一個佇列連線可以有多個「佇列」，我們可以將這些不同的佇列想成是幾個不同堆疊的佇列任務。"

# P
#: ./docs/8.x/queues.md:65
#: ./docs/9.x/queues.md:66
#: ./docs/10.x/queues.md:73
#: ./docs/11.x/queues.md:75
#: ./docs/master/queues.md:74
msgid "Note that each connection configuration example in the `queue` configuration file contains a `queue` attribute. This is the default queue that jobs will be dispatched to when they are sent to a given connection. In other words, if you dispatch a job without explicitly defining which queue it should be dispatched to, the job will be placed on the queue that is defined in the `queue` attribute of the connection configuration:"
msgstr "可以注意到範例 `queue` 設定檔中的各個範例連線設定中都包含了一個 `queue` 屬性。這個 `queue` 屬性指定的，就是當我們將任務傳給這個連線時預設會被分派的佇列。換句話說，若我們在分派任務時沒有顯式定義要分派到哪個佇列上，這個任務就會被分派到連線設定中 `queue` 屬性所定義的佇列上："

# CODE
#: ./docs/8.x/queues.md:67
#: ./docs/9.x/queues.md:68
#: ./docs/10.x/queues.md:75
#: ./docs/11.x/queues.md:77
#: ./docs/master/queues.md:76
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"\n"
"// This job is sent to the default connection's default queue...\n"
"ProcessPodcast::dispatch();\n"
"\n"
"// This job is sent to the default connection's \"emails\" queue...\n"
"ProcessPodcast::dispatch()->onQueue('emails');"
msgstr ""

# H3
#: ./docs/10.x/queues.md:69
#: ./docs/11.x/queues.md:71
#: ./docs/master/queues.md:70
msgid "Connections vs. Queues"
msgstr ""

# P
#: ./docs/8.x/queues.md:75
#: ./docs/9.x/queues.md:76
#: ./docs/10.x/queues.md:83
#: ./docs/11.x/queues.md:85
#: ./docs/master/queues.md:84
msgid "Some applications may not need to ever push jobs onto multiple queues, instead preferring to have one simple queue. However, pushing jobs to multiple queues can be especially useful for applications that wish to prioritize or segment how jobs are processed, since the Laravel queue worker allows you to specify which queues it should process by priority. For example, if you push jobs to a `high` queue, you may run a worker that gives them higher processing priority:"
msgstr "有的程式沒有要將任務推送到不同佇列的需求，這些程式只需要有單一佇列就好了。不過，因為 Laravel 的 Queue Worker 可調整各個 Queue 的優先處理等級，因此如果想要調整不同任務的優先處理順序，把任務推送到不同佇列就很有用。就來來說，我們如果把任務推送到 `high` 佇列，我們就可以執行一個 Worker 來讓這個佇列以更高優先級處理："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:77
#: ./docs/9.x/queues.md:78
#: ./docs/10.x/queues.md:85
#: ./docs/11.x/queues.md:87
#: ./docs/master/queues.md:86
msgid "php artisan queue:work --queue=high,default"
msgstr ""

# P
#: ./docs/8.x/queues.md:79
#: ./docs/9.x/queues.md:82
#: ./docs/10.x/queues.md:89
#: ./docs/11.x/queues.md:91
#: ./docs/master/queues.md:90
#~ msgid "<a name=\"driver-prerequisites\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:80
#: ./docs/9.x/queues.md:83
msgid "Driver Notes & Prerequisites"
msgstr "Driver 注意事項與前置需求"

# P
#: ./docs/8.x/queues.md:82
#: ./docs/9.x/queues.md:85
#: ./docs/10.x/queues.md:92
#: ./docs/11.x/queues.md:94
#: ./docs/master/queues.md:93
#~ msgid "<a name=\"database\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:83
#: ./docs/9.x/queues.md:86
#: ./docs/10.x/queues.md:93
#: ./docs/11.x/queues.md:95
#: ./docs/master/queues.md:94
msgid "Database"
msgstr "Database"

# P
#: ./docs/8.x/queues.md:85
#: ./docs/9.x/queues.md:88
#: ./docs/10.x/queues.md:95
msgid "In order to use the `database` queue driver, you will need a database table to hold the jobs. To generate a migration that creates this table, run the `queue:table` Artisan command. Once the migration has been created, you may migrate your database using the `migrate` command:"
msgstr "若要使用 `database` 佇列 Driver，我們需要先有一個用來存放任務的資料庫資料表。若要產生一個用於建立這個資料表的 Migration，請執行 `queue:table` Artisan 指令。建立好 Migration 後，就可以使用 `migrate` 指令來 Migrate 資料庫："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:87
#: ./docs/9.x/queues.md:90
#: ./docs/10.x/queues.md:97
msgid ""
"php artisan queue:table\n"
"\n"
"php artisan migrate"
msgstr ""

# H3
#: ./docs/10.x/queues.md:90
#: ./docs/11.x/queues.md:92
#: ./docs/master/queues.md:91
msgid "Driver Notes and Prerequisites"
msgstr ""

# P
#: ./docs/8.x/queues.md:91
#: ./docs/9.x/queues.md:96
#: ./docs/10.x/queues.md:103
msgid "Finally, don't forget to instruct your application to use the `database` driver by updating the `QUEUE_CONNECTION` variable in your application's `.env` file:"
msgstr "最後，別忘了更新專案 `.env` 檔中的 `QUEUE_CONNECTION` 變數來讓專案使用 `database` Driver："

# CODE
#: ./docs/8.x/queues.md:93
#: ./docs/9.x/queues.md:98
#: ./docs/10.x/queues.md:105
msgid "QUEUE_CONNECTION=database"
msgstr ""

# P
#: ./docs/8.x/queues.md:95
#: ./docs/9.x/queues.md:100
#: ./docs/10.x/queues.md:107
#: ./docs/11.x/queues.md:105
#: ./docs/master/queues.md:104
#~ msgid "<a name=\"redis\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:96
#: ./docs/9.x/queues.md:101
#: ./docs/10.x/queues.md:108
#: ./docs/11.x/queues.md:106
#: ./docs/master/queues.md:105
msgid "Redis"
msgstr "Redis"

# P
#: ./docs/11.x/queues.md:97
#: ./docs/master/queues.md:96
msgid "In order to use the `database` queue driver, you will need a database table to hold the jobs. Typically, this is included in Laravel's default `0001_01_01_000002_create_jobs_table.php` [database migration](/docs/{{version}}/migrations); however, if your application does not contain this migration, you may use the `make:queue-table` Artisan command to create it:"
msgstr ""

# P
#: ./docs/8.x/queues.md:98
#: ./docs/9.x/queues.md:103
#: ./docs/10.x/queues.md:110
#: ./docs/11.x/queues.md:108
#: ./docs/master/queues.md:107
msgid "In order to use the `redis` queue driver, you should configure a Redis database connection in your `config/database.php` configuration file."
msgstr "若要使用 `redis` 佇列 Driver，請在 `config/database.php` 設定檔中設定 Redis 資料庫連線。"

# CODE: shell
#: ./docs/11.x/queues.md:99
#: ./docs/master/queues.md:98
msgid ""
"php artisan make:queue-table\n"
"\n"
"php artisan migrate"
msgstr ""

# P
#: ./docs/8.x/queues.md:100
#: ./docs/9.x/queues.md:105
#: ./docs/10.x/queues.md:115
#: ./docs/11.x/queues.md:113
#: ./docs/master/queues.md:112
msgid "**Redis Cluster**"
msgstr "**Redis Cluster**"

# P
#: ./docs/8.x/queues.md:102
msgid "If your Redis queue connection uses a Redis Cluster, your queue names must contain a [key hash tag](https://redis.io/topics/cluster-spec#keys-hash-tags). This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:"
msgstr "若 Redis 佇列要使用 Redis Cluster，則設定的佇列名稱必須包含一個 [Key Hash Tag](https://redis.io/topics/cluster-spec#keys-hash-tags)。必須加上 Key Hash Tag，這樣才能確保給定佇列中所有的 Redis 索引鍵都有被放在相同的 Hash Slot 中："

# CODE
#: ./docs/8.x/queues.md:104
#: ./docs/9.x/queues.md:109
#: ./docs/10.x/queues.md:119
msgid ""
"'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => '{default}',\n"
"    'retry_after' => 90,\n"
"],"
msgstr ""

# P
#: ./docs/9.x/queues.md:107
#: ./docs/10.x/queues.md:117
#: ./docs/11.x/queues.md:115
#: ./docs/master/queues.md:114
msgid "If your Redis queue connection uses a Redis Cluster, your queue names must contain a [key hash tag](https://redis.io/docs/reference/cluster-spec/#hash-tags). This is required in order to ensure all of the Redis keys for a given queue are placed into the same hash slot:"
msgstr "若 Redis 佇列要使用 Redis Cluster，則設定的佇列名稱必須包含一個 [Key Hash Tag](https://redis.io/docs/reference/cluster-spec/#hash-tags)。必須加上 Key Hash Tag，這樣才能確保給定佇列中所有的 Redis 索引鍵都有被放在相同的 Hash Slot 中："

# P
#: ./docs/8.x/queues.md:111
#: ./docs/9.x/queues.md:116
#: ./docs/10.x/queues.md:126
#: ./docs/11.x/queues.md:126
#: ./docs/master/queues.md:125
msgid "**Blocking**"
msgstr "**Blocking**"

# P
#: ./docs/10.x/queues.md:113
#: ./docs/11.x/queues.md:111
#: ./docs/master/queues.md:110
msgid "The `serializer` and `compression` Redis options are not supported by the `redis` queue driver."
msgstr "`redis` Queue Driver 不支援 `serializer` 與 `compression` Redis 選項。"

# P
#: ./docs/8.x/queues.md:113
#: ./docs/9.x/queues.md:118
#: ./docs/10.x/queues.md:128
#: ./docs/11.x/queues.md:128
#: ./docs/master/queues.md:127
msgid "When using the Redis queue, you may use the `block_for` configuration option to specify how long the driver should wait for a job to become available before iterating through the worker loop and re-polling the Redis database."
msgstr "在使用 Redis 佇列時，可使用 `block_for` 設定選項來指定 Redis Driver 在迭代 Worker 迴圈並重新讀取 Redis 資料庫來等新 Job 進來時要等待多久。"

# P
#: ./docs/8.x/queues.md:115
#: ./docs/9.x/queues.md:120
#: ./docs/10.x/queues.md:130
#: ./docs/11.x/queues.md:130
#: ./docs/master/queues.md:129
msgid "Adjusting this value based on your queue load can be more efficient than continually polling the Redis database for new jobs. For instance, you may set the value to `5` to indicate that the driver should block for five seconds while waiting for a job to become available:"
msgstr "可依據佇列的負載來調整這個值，以避免不斷讀取 Redis 資料庫來尋找新任務，會比較有效率。舉例來說，我們可以將其設為 `5`，表示 Redis Driver 在等待新任務出現時應先等待 5 秒再查詢 Redis 資料庫："

# CODE
#: ./docs/11.x/queues.md:117
#: ./docs/master/queues.md:116
msgid ""
"'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),\n"
"    'queue' => env('REDIS_QUEUE', '{default}'),\n"
"    'retry_after' => env('REDIS_QUEUE_RETRY_AFTER', 90),\n"
"    'block_for' => null,\n"
"    'after_commit' => false,\n"
"],"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:117
#: ./docs/9.x/queues.md:122
#: ./docs/10.x/queues.md:132
msgid ""
"'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => 'default',\n"
"    'queue' => 'default',\n"
"    'retry_after' => 90,\n"
"    'block_for' => 5,\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:125
#: ./docs/9.x/queues.md:131
#: ./docs/10.x/queues.md:141
#: ./docs/11.x/queues.md:142
#: ./docs/master/queues.md:141
msgid "Setting `block_for` to `0` will cause queue workers to block indefinitely until a job is available. This will also prevent signals such as `SIGTERM` from being handled until the next job has been processed."
msgstr "將 `block_for` 設為 `0` 會導致 Queue Worker 在新 Job 出現前一直 Block。也會導致在處理下一個 Job 前都無法處理如 `SIGTERM` 等訊號 (Signal)。"

# P
#: ./docs/8.x/queues.md:127
#: ./docs/9.x/queues.md:133
#: ./docs/10.x/queues.md:143
#: ./docs/11.x/queues.md:144
#: ./docs/master/queues.md:143
#~ msgid "<a name=\"other-driver-prerequisites\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:128
#: ./docs/9.x/queues.md:134
#: ./docs/10.x/queues.md:144
#: ./docs/11.x/queues.md:145
#: ./docs/master/queues.md:144
msgid "Other Driver Prerequisites"
msgstr "其他 Driver 的前置要求"

# P
#: ./docs/8.x/queues.md:130
#: ./docs/9.x/queues.md:136
#: ./docs/10.x/queues.md:146
#: ./docs/11.x/queues.md:147
#: ./docs/master/queues.md:146
msgid "The following dependencies are needed for the listed queue drivers. These dependencies may be installed via the Composer package manager:"
msgstr "下列 Queue Driver 還需要一些相依性套件。可以使用 Composer 套件管理員來安裝這些相依性套件："

# CODE
#: ./docs/11.x/queues.md:132
#: ./docs/master/queues.md:131
msgid ""
"'redis' => [\n"
"    'driver' => 'redis',\n"
"    'connection' => env('REDIS_QUEUE_CONNECTION', 'default'),\n"
"    'queue' => env('REDIS_QUEUE', 'default'),\n"
"    'retry_after' => env('REDIS_QUEUE_RETRY_AFTER', 90),\n"
"    'block_for' => 5,\n"
"    'after_commit' => false,\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:134
#: ./docs/9.x/queues.md:140
#: ./docs/10.x/queues.md:150
#: ./docs/11.x/queues.md:151
#: ./docs/master/queues.md:150
msgid "Amazon SQS: `aws/aws-sdk-php ~3.0`"
msgstr "Amazon SQS: `aws/aws-sdk-php ~3.0`"

# P
#: ./docs/8.x/queues.md:135
#: ./docs/9.x/queues.md:141
#: ./docs/10.x/queues.md:151
msgid "Beanstalkd: `pda/pheanstalk ~4.0`"
msgstr "Beanstalkd: `pda/pheanstalk ~4.0`"

# P
#: ./docs/8.x/queues.md:136
#: ./docs/9.x/queues.md:142
#: ./docs/10.x/queues.md:152
msgid "Redis: `predis/predis ~1.0` or phpredis PHP extension"
msgstr "Redis: `predis/predis ~1.0` 或 phpredis PHP 擴充套件"

# P
#: ./docs/8.x/queues.md:140
#: ./docs/9.x/queues.md:146
#: ./docs/10.x/queues.md:156
#: ./docs/11.x/queues.md:158
#: ./docs/master/queues.md:156
#~ msgid "<a name=\"creating-jobs\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:141
#: ./docs/9.x/queues.md:147
#: ./docs/10.x/queues.md:157
#: ./docs/11.x/queues.md:159
#: ./docs/master/queues.md:157
msgid "Creating Jobs"
msgstr "建立 Job"

# P
#: ./docs/8.x/queues.md:143
#: ./docs/9.x/queues.md:149
#: ./docs/10.x/queues.md:159
#: ./docs/11.x/queues.md:161
#: ./docs/master/queues.md:159
#~ msgid "<a name=\"generating-job-classes\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:144
#: ./docs/9.x/queues.md:150
#: ./docs/10.x/queues.md:160
#: ./docs/11.x/queues.md:162
#: ./docs/master/queues.md:160
msgid "Generating Job Classes"
msgstr "產生 Job 類別"

# P
#: ./docs/8.x/queues.md:146
#: ./docs/9.x/queues.md:152
#: ./docs/10.x/queues.md:162
#: ./docs/11.x/queues.md:164
#: ./docs/master/queues.md:162
msgid "By default, all of the queueable jobs for your application are stored in the `app/Jobs` directory. If the `app/Jobs` directory doesn't exist, it will be created when you run the `make:job` Artisan command:"
msgstr "預設情況下，專案中所有可放入佇列的任務都存放在 `app/Jobs` 目錄內。若 `app/Jobs` 目錄不存在，則執行 `make:jobs` Artisan 指令時會建立該目錄："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:148
#: ./docs/9.x/queues.md:154
#: ./docs/10.x/queues.md:164
#: ./docs/11.x/queues.md:166
#: ./docs/master/queues.md:164
msgid "php artisan make:job ProcessPodcast"
msgstr ""

# P
#: ./docs/8.x/queues.md:150
#: ./docs/9.x/queues.md:158
#: ./docs/10.x/queues.md:168
#: ./docs/11.x/queues.md:170
#: ./docs/master/queues.md:168
msgid "The generated class will implement the `Illuminate\\Contracts\\Queue\\ShouldQueue` interface, indicating to Laravel that the job should be pushed onto the queue to run asynchronously."
msgstr "產生的類別會實作 `Illuminate\\Contracts\\Queue\\ShouldQueue` 介面，這樣 Laravel 就知道該 Job 要被推入佇列並以非同步方式執行。"

# P
#: ./docs/11.x/queues.md:152
#: ./docs/master/queues.md:151
msgid "Beanstalkd: `pda/pheanstalk ~5.0`"
msgstr ""

# P
#: ./docs/8.x/queues.md:152
#: ./docs/9.x/queues.md:161
#: ./docs/10.x/queues.md:171
#: ./docs/11.x/queues.md:173
#: ./docs/master/queues.md:171
msgid "Job stubs may be customized using [stub publishing](/docs/{{version}}/artisan#stub-customization)."
msgstr "可以[安裝 Stub](/docs/{{version}}/artisan#stub-customization) 來自訂 Job 的 Stub。"

# P
#: ./docs/11.x/queues.md:153
#: ./docs/master/queues.md:152
msgid "Redis: `predis/predis ~2.0` or phpredis PHP extension"
msgstr ""

# P
#: ./docs/11.x/queues.md:154
msgid "[MongoDB](https://www.mongodb.com/docs/drivers/php/laravel-mongodb/current/queues/): `mongodb/laravel-mongodb`"
msgstr ""

# P
#: ./docs/8.x/queues.md:154
#: ./docs/9.x/queues.md:163
#: ./docs/10.x/queues.md:173
#: ./docs/11.x/queues.md:175
#: ./docs/master/queues.md:173
#~ msgid "<a name=\"class-structure\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:155
#: ./docs/9.x/queues.md:164
#: ./docs/10.x/queues.md:174
#: ./docs/11.x/queues.md:176
#: ./docs/master/queues.md:174
msgid "Class Structure"
msgstr "類別架構"

# P
#: ./docs/8.x/queues.md:157
#: ./docs/9.x/queues.md:166
#: ./docs/10.x/queues.md:176
#: ./docs/11.x/queues.md:178
#: ./docs/master/queues.md:176
msgid "Job classes are very simple, normally containing only a `handle` method that is invoked when the job is processed by the queue. To get started, let's take a look at an example job class. In this example, we'll pretend we manage a podcast publishing service and need to process the uploaded podcast files before they are published:"
msgstr "Job 類別非常簡單，通常只包含了一個 `handle` 方法，會在佇列處理 Job 時叫用。要開始使用 Job，我們先來看一個範例 Job 類別。在這個範例中，我們先假裝時我們在管理一個 Podcast 上架服務，我們需要在上架前處理上傳的 Podcast 檔案："

# CODE
#: ./docs/8.x/queues.md:159
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Models\\Podcast\n"
"     */\n"
"    protected $podcast;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:168
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Models\\Podcast\n"
"     */\n"
"    public $podcast;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:178
#: ./docs/master/queues.md:178
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct(\n"
"        public Podcast $podcast,\n"
"    ) {}\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(AudioProcessor $processor): void\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:180
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Queue\\Queueable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Queueable;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct(\n"
"        public Podcast $podcast,\n"
"    ) {}\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(AudioProcessor $processor): void\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:205
#: ./docs/9.x/queues.md:214
#: ./docs/10.x/queues.md:210
#: ./docs/master/queues.md:210
msgid "In this example, note that we were able to pass an [Eloquent model](/docs/{{version}}/eloquent) directly into the queued job's constructor. Because of the `SerializesModels` trait that the job is using, Eloquent models and their loaded relationships will be gracefully serialized and unserialized when the job is processing."
msgstr "在這個範例中，可以看到我們直接將 [Eloquent Model] 傳入佇列任務的 ^[Constructor](建構函式) 中。由於該任務有使用 `SerializesModels` Trait，所以 Eloquent Model 與已載入的關聯 Model 都會被序列化處理，並在處理任務時反序列化。"

# P
#: ./docs/8.x/queues.md:207
#: ./docs/9.x/queues.md:216
#: ./docs/10.x/queues.md:212
#: ./docs/11.x/queues.md:211
#: ./docs/master/queues.md:212
msgid "If your queued job accepts an Eloquent model in its constructor, only the identifier for the model will be serialized onto the queue. When the job is actually handled, the queue system will automatically re-retrieve the full model instance and its loaded relationships from the database. This approach to model serialization allows for much smaller job payloads to be sent to your queue driver."
msgstr "若佇列任務的 Constructor 中接受 Eloquent Model，則只有 Model 的^[識別元](Identifier)會被序列化進佇列中。實際要處理任務時，佇列系統會自動從資料庫中重新取得完整的 Model 實體以及已載入的關聯。通過這種序列化 Model 的做法，我們就能縮小傳入佇列 Driver 的任務^[承載](Payload)。"

# P
#: ./docs/11.x/queues.md:209
msgid "In this example, note that we were able to pass an [Eloquent model](/docs/{{version}}/eloquent) directly into the queued job's constructor. Because of the `Queueable` trait that the job is using, Eloquent models and their loaded relationships will be gracefully serialized and unserialized when the job is processing."
msgstr ""

# P
#: ./docs/8.x/queues.md:209
#: ./docs/9.x/queues.md:218
#: ./docs/10.x/queues.md:214
#: ./docs/11.x/queues.md:213
#: ./docs/master/queues.md:214
#~ msgid "<a name=\"handle-method-dependency-injection\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:210
#: ./docs/9.x/queues.md:219
#: ./docs/10.x/queues.md:215
#: ./docs/11.x/queues.md:214
#: ./docs/master/queues.md:215
msgid "`handle` Method Dependency Injection"
msgstr "`handle` 方法的相依性插入"

# P
#: ./docs/8.x/queues.md:212
#: ./docs/9.x/queues.md:221
#: ./docs/10.x/queues.md:217
#: ./docs/11.x/queues.md:216
#: ./docs/master/queues.md:217
msgid "The `handle` method is invoked when the job is processed by the queue. Note that we are able to type-hint dependencies on the `handle` method of the job. The Laravel [service container](/docs/{{version}}/container) automatically injects these dependencies."
msgstr "佇列在處理任務時會叫用該任務的 `handle` 方法。請注意，我們可以在任務的 `handle` 方法上^[型別提示](Type-Hint)任何相依性項目。Laravel [Service Container](/docs/{{version}}/container) 會自動插入這些相依性。"

# P
#: ./docs/8.x/queues.md:214
#: ./docs/9.x/queues.md:223
#: ./docs/10.x/queues.md:219
#: ./docs/11.x/queues.md:218
#: ./docs/master/queues.md:219
msgid "If you would like to take total control over how the container injects dependencies into the `handle` method, you may use the container's `bindMethod` method. The `bindMethod` method accepts a callback which receives the job and the container. Within the callback, you are free to invoke the `handle` method however you wish. Typically, you should call this method from the `boot` method of your `App\\Providers\\AppServiceProvider` [service provider](/docs/{{version}}/providers):"
msgstr "若想完整控制 Container 要如何插入這些相依性到 `handle` 方法，可使用 Container 的 `bindMethod` 方法。`bindMethod` 方法接收一個回呼，該回呼則接收該任務與 Container。我們可以在這個回呼中自行叫用 `handle` 方法。一般來說，我們應該從 `App\\Providers\\AppServiceProvider` [Service Provider](/docs/{{version}}/providers) 的 `boot` 方法中叫用這個方法："

# CODE
#: ./docs/8.x/queues.md:216
#: ./docs/9.x/queues.md:225
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Services\\AudioProcessor;\n"
"\n"
"$this->app->bindMethod([ProcessPodcast::class, 'handle'], function ($job, $app) {\n"
"    return $job->handle($app->make(AudioProcessor::class));\n"
"});"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:221
#: ./docs/11.x/queues.md:220
#: ./docs/master/queues.md:221
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Contracts\\Foundation\\Application;\n"
"\n"
"$this->app->bindMethod([ProcessPodcast::class, 'handle'], function (ProcessPodcast $job, Application $app) {\n"
"    return $job->handle($app->make(AudioProcessor::class));\n"
"});"
msgstr ""

# P
#: ./docs/8.x/queues.md:223
#: ./docs/9.x/queues.md:233
#: ./docs/10.x/queues.md:230
#: ./docs/11.x/queues.md:229
#: ./docs/master/queues.md:230
msgid "Binary data, such as raw image contents, should be passed through the `base64_encode` function before being passed to a queued job. Otherwise, the job may not properly serialize to JSON when being placed on the queue."
msgstr "二進位資料，如圖片等，應在傳入佇列任務前先使用 `base64_encode` 函式進行編碼。若未進行編碼，則這些資料在放入佇列時可能無法正確被序列化為 JSON。"

# P
#: ./docs/8.x/queues.md:225
#: ./docs/9.x/queues.md:235
#: ./docs/10.x/queues.md:232
#: ./docs/11.x/queues.md:231
#: ./docs/master/queues.md:232
#~ msgid "<a name=\"handling-relationships\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:226
#: ./docs/9.x/queues.md:236
#: ./docs/10.x/queues.md:233
#: ./docs/11.x/queues.md:232
#: ./docs/master/queues.md:233
msgid "Queued Relationships"
msgstr "佇列中的關聯"

# P
#: ./docs/8.x/queues.md:228
#: ./docs/9.x/queues.md:238
msgid "Because loaded relationships also get serialized, the serialized job string can sometimes become quite large. To prevent relations from being serialized, you can call the `withoutRelations` method on the model when setting a property value. This method will return an instance of the model without its loaded relationships:"
msgstr "由於 Model 上已載入的關聯也會被序列化，因此序列化的任務字串有時候會變得很大。若要防止關聯被序列化，可在設定屬性值時在 Model 上呼叫 `withoutRelations` 方法。該方法會回傳該 Model 不含已載入關聯的實體："

# CODE
#: ./docs/8.x/queues.md:230
#: ./docs/9.x/queues.md:240
msgid ""
"/**\n"
" * Create a new job instance.\n"
" *\n"
" * @param  \\App\\Models\\Podcast  $podcast\n"
" * @return void\n"
" */\n"
"public function __construct(Podcast $podcast)\n"
"{\n"
"    $this->podcast = $podcast->withoutRelations();\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:235
#: ./docs/11.x/queues.md:234
#: ./docs/master/queues.md:235
msgid "Because all loaded Eloquent model relationships also get serialized when a job is queued, the serialized job string can sometimes become quite large. Furthermore, when a job is deserialized and model relationships are re-retrieved from the database, they will be retrieved in their entirety. Any previous relationship constraints that were applied before the model was serialized during the job queueing process will not be applied when the job is deserialized. Therefore, if you wish to work with a subset of a given relationship, you should re-constrain that relationship within your queued job."
msgstr "由於所有已載入的 Eloquent Model 關聯都會在 Job 被放入佇列時序列化，因此，序列化的 Job 字串有時候會比較大。此外，當任務被反序列化，然後 Model 關聯被從資料庫中重新取出時，這些關聯的資料會以完整的關聯取出。這表示，若在 Model 被任務佇列序列化前有對關聯套用任何查詢條件，在反序列化時，這些條件都不會被套用。因此，若只想處理給定關聯中的一部分，應在佇列任務中重新套用這些查詢條件。"

# P
#: ./docs/10.x/queues.md:237
#: ./docs/11.x/queues.md:236
#: ./docs/master/queues.md:237
msgid "Or, to prevent relations from being serialized, you can call the `withoutRelations` method on the model when setting a property value. This method will return an instance of the model without its loaded relationships:"
msgstr "或者，若要防止關聯被序列化，可在設定屬性值時在 Model 上呼叫 `withoutRelations` 方法。該方法會回傳該 Model 不含已載入關聯的實體："

# CODE
#: ./docs/11.x/queues.md:238
msgid ""
"/**\n"
" * Create a new job instance.\n"
" */\n"
"public function __construct(\n"
"    Podcast $podcast,\n"
") {\n"
"    $this->podcast = $podcast->withoutRelations();\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:239
#: ./docs/master/queues.md:239
msgid ""
"/**\n"
" * Create a new job instance.\n"
" */\n"
"public function __construct(Podcast $podcast)\n"
"{\n"
"    $this->podcast = $podcast->withoutRelations();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:241
#: ./docs/9.x/queues.md:251
msgid "Furthermore, when a job is deserialized and model relationships are re-retrieved from the database, they will be retrieved in their entirety. Any previous relationship constraints that were applied before the model was serialized during the job queueing process will not be applied when the job is deserialized. Therefore, if you wish to work with a subset of a given relationship, you should re-constrain that relationship within your queued job."
msgstr "此外，當任務被反序列化，然後 Model 關聯被從資料庫中重新取出時，這些關聯的資料會以完整的關聯取出。這表示，若在 Model 被任務佇列序列化前有對關聯套用任何查詢條件，在反序列化時，這些條件都不會被套用。因此，若只想處理給定關聯中的一部分，應在佇列任務中重新套用這些查詢條件。"

# P
#: ./docs/8.x/queues.md:243
#: ./docs/9.x/queues.md:253
#: ./docs/10.x/queues.md:262
#: ./docs/11.x/queues.md:261
#: ./docs/master/queues.md:262
#~ msgid "<a name=\"unique-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:244
#: ./docs/9.x/queues.md:254
#: ./docs/10.x/queues.md:263
#: ./docs/11.x/queues.md:262
#: ./docs/master/queues.md:263
msgid "Unique Jobs"
msgstr "不重複 Job"

# P
#: ./docs/8.x/queues.md:246
#: ./docs/9.x/queues.md:257
#: ./docs/10.x/queues.md:266
#: ./docs/11.x/queues.md:265
#: ./docs/master/queues.md:266
msgid "Unique jobs require a cache driver that supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support atomic locks. In addition, unique job constraints do not apply to jobs within batches."
msgstr "若要使用不重複任務，則需要使用支援 [Atomic Lock] 的快取 Driver。目前，`memcached`、`redis`、`dynamodb`、`database`、`file`、`array` 等快取 Driver 有支援 Atomic Lock。此外，不重複任務的^[條件限制](Constraint)不會被套用到批次任務中的人物上。"

# P
#: ./docs/10.x/queues.md:247
#: ./docs/11.x/queues.md:247
#: ./docs/master/queues.md:247
msgid "If you are using PHP constructor property promotion and would like to indicate that an Eloquent model should not have its relations serialized, you may use the `WithoutRelations` attribute:"
msgstr ""

# P
#: ./docs/8.x/queues.md:248
#: ./docs/9.x/queues.md:259
#: ./docs/10.x/queues.md:268
#: ./docs/11.x/queues.md:267
#: ./docs/master/queues.md:268
msgid "Sometimes, you may want to ensure that only one instance of a specific job is on the queue at any point in time. You may do so by implementing the `ShouldBeUnique` interface on your job class. This interface does not require you to define any additional methods on your class:"
msgstr "有時候，我們可能會想確保某個任務在佇列中一次只能有一個實體。我們可以在 Job 類別上實作 `ShouldBeUnique` 介面來確保一次只執行一個實體。要實作這個介面，我們需要在 Class 上定義幾個額外的方法："

# CODE
#: ./docs/10.x/queues.md:249
#: ./docs/master/queues.md:249
msgid ""
"use Illuminate\\Queue\\Attributes\\WithoutRelations;\n"
"\n"
"/**\n"
" * Create a new job instance.\n"
" */\n"
"public function __construct(\n"
"    #[WithoutRelations]\n"
"    public Podcast $podcast\n"
") {\n"
"}"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:249
msgid ""
"use Illuminate\\Queue\\Attributes\\WithoutRelations;\n"
"\n"
"/**\n"
" * Create a new job instance.\n"
" */\n"
"public function __construct(\n"
"    #[WithoutRelations]\n"
"    public Podcast $podcast,\n"
") {}"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:250
#: ./docs/9.x/queues.md:261
#: ./docs/10.x/queues.md:270
#: ./docs/11.x/queues.md:269
#: ./docs/master/queues.md:270
msgid ""
"<?php\n"
"\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    ...\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:260
#: ./docs/11.x/queues.md:259
#: ./docs/master/queues.md:260
msgid "If a job receives a collection or array of Eloquent models instead of a single model, the models within that collection will not have their relationships restored when the job is deserialized and executed. This is to prevent excessive resource usage on jobs that deal with large numbers of models."
msgstr ""

# P
#: ./docs/8.x/queues.md:260
#: ./docs/9.x/queues.md:271
#: ./docs/10.x/queues.md:280
#: ./docs/11.x/queues.md:279
#: ./docs/master/queues.md:280
msgid "In the example above, the `UpdateSearchIndex` job is unique. So, the job will not be dispatched if another instance of the job is already on the queue and has not finished processing."
msgstr "在上述範例中，`UpdateSearchIndex` Job 是^[不重複](Unique)的。所以，若佇列中已經有該 Job 的另一個實體且尚未執行完畢，就不會再次分派該 Job。"

# P
#: ./docs/8.x/queues.md:262
#: ./docs/9.x/queues.md:273
#: ./docs/10.x/queues.md:282
#: ./docs/11.x/queues.md:281
#: ./docs/master/queues.md:282
msgid "In certain cases, you may want to define a specific \"key\" that makes the job unique or you may want to specify a timeout beyond which the job no longer stays unique. To accomplish this, you may define `uniqueId` and `uniqueFor` properties or methods on your job class:"
msgstr "在某些情況下，我們可能會想指定要用來判斷 Job 是否重複的「索引鍵」，或是我們可能會想指定一個逾時時間，讓這個 Job 在執行超過該逾時後就不再判斷是否重複。為此，可在 Job 類別上定義 `uniqueId` 與 `uniqueFor` 屬性或方法："

# CODE
#: ./docs/8.x/queues.md:264
#: ./docs/9.x/queues.md:275
msgid ""
"<?php\n"
"\n"
"use App\\Models\\Product;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    /**\n"
"     * The product instance.\n"
"     *\n"
"     * @var \\App\\Product\n"
"     */\n"
"    public $product;\n"
"\n"
"    /**\n"
"     * The number of seconds after which the job's unique lock will be released.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $uniqueFor = 3600;\n"
"\n"
"    /**\n"
"     * The unique ID of the job.\n"
"     *\n"
"     * @return string\n"
"     */\n"
"    public function uniqueId()\n"
"    {\n"
"        return $this->product->id;\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:284
#: ./docs/11.x/queues.md:283
#: ./docs/master/queues.md:284
msgid ""
"<?php\n"
"\n"
"use App\\Models\\Product;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUnique;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    /**\n"
"     * The product instance.\n"
"     *\n"
"     * @var \\App\\Product\n"
"     */\n"
"    public $product;\n"
"\n"
"    /**\n"
"     * The number of seconds after which the job's unique lock will be released.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $uniqueFor = 3600;\n"
"\n"
"    /**\n"
"     * Get the unique ID for the job.\n"
"     */\n"
"    public function uniqueId(): string\n"
"    {\n"
"        return $this->product->id;\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:297
#: ./docs/9.x/queues.md:308
#: ./docs/10.x/queues.md:315
#: ./docs/11.x/queues.md:314
#: ./docs/master/queues.md:315
msgid "In the example above, the `UpdateSearchIndex` job is unique by a product ID. So, any new dispatches of the job with the same product ID will be ignored until the existing job has completed processing. In addition, if the existing job is not processed within one hour, the unique lock will be released and another job with the same unique key can be dispatched to the queue."
msgstr "在上述範例中，`UpdateSearchIndex` Job 使用 Product ID 來判斷是否重複。因此，若新分派的 Job 有相同的 Product ID，則直到現存 Job 執行完畢前，這個 Job 都會被忽略。此外，若現有的 Job 在一個小時內都未被處理，這個不重複鎖定會被解除，之後若有另一個具相同重複索引鍵的 Job 將可被分派進佇列中。"

# P
#: ./docs/8.x/queues.md:299
#: ./docs/9.x/queues.md:313
#: ./docs/10.x/queues.md:320
#: ./docs/11.x/queues.md:319
#: ./docs/master/queues.md:320
#~ msgid "<a name=\"keeping-jobs-unique-until-processing-begins\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:300
#: ./docs/9.x/queues.md:314
#: ./docs/10.x/queues.md:321
#: ./docs/11.x/queues.md:320
#: ./docs/master/queues.md:321
msgid "Keeping Jobs Unique Until Processing Begins"
msgstr "在開始處理 Job 後仍維持讓 Job 不重複"

# P
#: ./docs/8.x/queues.md:302
#: ./docs/9.x/queues.md:316
#: ./docs/10.x/queues.md:323
#: ./docs/11.x/queues.md:322
#: ./docs/master/queues.md:323
msgid "By default, unique jobs are \"unlocked\" after a job completes processing or fails all of its retry attempts. However, there may be situations where you would like your job to unlock immediately before it is processed. To accomplish this, your job should implement the `ShouldBeUniqueUntilProcessing` contract instead of the `ShouldBeUnique` contract:"
msgstr "預設情況下，不重複的 Job 會在執行完成或所有嘗試都失敗後「解除鎖定」。不過，有的情況下，我們可能會想在執行完成前就先解除鎖定 Job。為此，不要在該 Job 上實作 `ShouldBeUnique`，而是實作 `ShouldBeUniqueUntillProcessing` Contract："

# CODE
#: ./docs/8.x/queues.md:304
#: ./docs/9.x/queues.md:318
#: ./docs/10.x/queues.md:325
#: ./docs/11.x/queues.md:324
#: ./docs/master/queues.md:325
msgid ""
"<?php\n"
"\n"
"use App\\Models\\Product;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeUniqueUntilProcessing;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUniqueUntilProcessing\n"
"{\n"
"    // ...\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:311
#: ./docs/10.x/queues.md:318
#: ./docs/11.x/queues.md:317
#: ./docs/master/queues.md:318
msgid "If your application dispatches jobs from multiple web servers or containers, you should ensure that all of your servers are communicating with the same central cache server so that Laravel can accurately determine if a job is unique."
msgstr "若專案會在多個 Web Server 或 Container 上分派任務，則請確保所有的這些 Server 都使用相同的中央 Cache Server，好讓 Laravel 可精準判斷該 Job 是否不重複。"

# P
#: ./docs/8.x/queues.md:315
#: ./docs/9.x/queues.md:329
#: ./docs/10.x/queues.md:336
#: ./docs/11.x/queues.md:335
#: ./docs/master/queues.md:336
#~ msgid "<a name=\"unique-job-locks\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:316
#: ./docs/9.x/queues.md:330
#: ./docs/10.x/queues.md:337
#: ./docs/11.x/queues.md:336
#: ./docs/master/queues.md:337
msgid "Unique Job Locks"
msgstr "不重複 Job 的鎖定"

# P
#: ./docs/8.x/queues.md:318
#: ./docs/9.x/queues.md:332
#: ./docs/10.x/queues.md:339
#: ./docs/11.x/queues.md:338
#: ./docs/master/queues.md:339
msgid "Behind the scenes, when a `ShouldBeUnique` job is dispatched, Laravel attempts to acquire a [lock](/docs/{{version}}/cache#atomic-locks) with the `uniqueId` key. If the lock is not acquired, the job is not dispatched. This lock is released when the job completes processing or fails all of its retry attempts. By default, Laravel will use the default cache driver to obtain this lock. However, if you wish to use another driver for acquiring the lock, you may define a `uniqueVia` method that returns the cache driver that should be used:"
msgstr "當分派 `ShouldBeUnique` 時，Laravel 會在幕後使用 `uniqueId` 索引鍵來取得一個 [^[Lock](鎖定)](/docs/{{version}}/cache#atomic-locks)。若未能取得 Lock，就不會分派該 Job。當 Job 完成處理或所有嘗試都失敗後，就會解除該 Lock。預設情況下，Laravel 會使用預設的快取 Driver 來取得該 Lock。不過，若想使用其他 Driver 來取得 Lock，可定義一個 `uniqueVia` 方法，並在該方法中回傳要使用的快取 Driver："

# CODE
#: ./docs/8.x/queues.md:320
#: ./docs/9.x/queues.md:334
msgid ""
"use Illuminate\\Support\\Facades\\Cache;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    ...\n"
"\n"
"    /**\n"
"     * Get the cache driver for the unique job lock.\n"
"     *\n"
"     * @return \\Illuminate\\Contracts\\Cache\\Repository\n"
"     */\n"
"    public function uniqueVia()\n"
"    {\n"
"        return Cache::driver('redis');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:337
#: ./docs/9.x/queues.md:352
#: ./docs/10.x/queues.md:358
#: ./docs/11.x/queues.md:357
#: ./docs/master/queues.md:358
msgid "If you only need to limit the concurrent processing of a job, use the [`WithoutOverlapping`](/docs/{{version}}/queues#preventing-job-overlaps) job middleware instead."
msgstr "若想限制某個 Job 可^[同時](Concurrent)執行的數量，請使用 [`WithoutOverlapping`](/docs/{{version}}/queues#preventing-job-overlaps) Job Middleware 而不是使用 Unique Job。"

# P
#: ./docs/8.x/queues.md:339
#: ./docs/9.x/queues.md:354
#: ./docs/10.x/queues.md:375
#: ./docs/11.x/queues.md:374
#: ./docs/master/queues.md:375
#~ msgid "<a name=\"job-middleware\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:340
#: ./docs/9.x/queues.md:355
#: ./docs/10.x/queues.md:376
#: ./docs/11.x/queues.md:375
#: ./docs/master/queues.md:376
msgid "Job Middleware"
msgstr "Job Middleware"

# CODE
#: ./docs/10.x/queues.md:341
#: ./docs/11.x/queues.md:340
#: ./docs/master/queues.md:341
msgid ""
"use Illuminate\\Contracts\\Cache\\Repository;\n"
"use Illuminate\\Support\\Facades\\Cache;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeUnique\n"
"{\n"
"    ...\n"
"\n"
"    /**\n"
"     * Get the cache driver for the unique job lock.\n"
"     */\n"
"    public function uniqueVia(): Repository\n"
"    {\n"
"        return Cache::driver('redis');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:342
#: ./docs/9.x/queues.md:357
#: ./docs/10.x/queues.md:378
#: ./docs/11.x/queues.md:377
#: ./docs/master/queues.md:378
msgid "Job middleware allow you to wrap custom logic around the execution of queued jobs, reducing boilerplate in the jobs themselves. For example, consider the following `handle` method which leverages Laravel's Redis rate limiting features to allow only one job to process every five seconds:"
msgstr "使用 Job Middleware 就能讓我們將佇列 Job 包裝在一組自定邏輯內執行，讓我們能減少在各個 Job 內撰寫重複的程式碼。舉例來說，假設有下列這個 `handle` 方法，該方法會使用 Laravel 的 Redis 頻率限制功能，限制每 5 秒只能處理 1 個 Job："

# CODE
#: ./docs/8.x/queues.md:344
#: ./docs/9.x/queues.md:359
msgid ""
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {\n"
"        info('Lock obtained...');\n"
"\n"
"        // Handle job...\n"
"    }, function () {\n"
"        // Could not obtain lock...\n"
"\n"
"        return $this->release(5);\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:360
#: ./docs/11.x/queues.md:359
#: ./docs/master/queues.md:360
#~ msgid "<a name=\"encrypted-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/10.x/queues.md:361
#: ./docs/11.x/queues.md:360
#: ./docs/master/queues.md:361
msgid "Encrypted Jobs"
msgstr "加密的 Job"

# P
#: ./docs/10.x/queues.md:363
#: ./docs/11.x/queues.md:362
#: ./docs/master/queues.md:363
msgid "Laravel allows you to ensure the privacy and integrity of a job's data via [encryption](/docs/{{version}}/encryption). To get started, simply add the `ShouldBeEncrypted` interface to the job class. Once this interface has been added to the class, Laravel will automatically encrypt your job before pushing it onto a queue:"
msgstr ""

# P
#: ./docs/8.x/queues.md:364
#: ./docs/9.x/queues.md:379
#: ./docs/10.x/queues.md:398
#: ./docs/11.x/queues.md:397
#: ./docs/master/queues.md:398
msgid "While this code is valid, the implementation of the `handle` method becomes noisy since it is cluttered with Redis rate limiting logic. In addition, this rate limiting logic must be duplicated for any other jobs that we want to rate limit."
msgstr "雖然我們確實可以這樣寫，但這樣一來 `handle` 方法的實作就變得很亂，因為我們的程式碼跟 Redis 頻率限制的邏輯混在一起了。此外，這樣的頻率限制邏輯一定也會與其他我們想要作頻率限制的 Job 重複。"

# CODE
#: ./docs/10.x/queues.md:365
#: ./docs/11.x/queues.md:364
#: ./docs/master/queues.md:365
msgid ""
"<?php\n"
"\n"
"use Illuminate\\Contracts\\Queue\\ShouldBeEncrypted;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"\n"
"class UpdateSearchIndex implements ShouldQueue, ShouldBeEncrypted\n"
"{\n"
"    // ...\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:366
#: ./docs/9.x/queues.md:381
#: ./docs/10.x/queues.md:400
#: ./docs/11.x/queues.md:399
#: ./docs/master/queues.md:400
msgid "Instead of rate limiting in the handle method, we could define a job middleware that handles rate limiting. Laravel does not have a default location for job middleware, so you are welcome to place job middleware anywhere in your application. In this example, we will place the middleware in an `app/Jobs/Middleware` directory:"
msgstr "我們可以定義一個 Job Middleware 來處理頻率限制，而不用在 handle 方法內處理。Laravel 中沒有預設放置 Job Middleware 的地方，因此我們可以隨意在專案內放置這些 Job Middleware。舉例來說，我們可以把 Middleware 放在 `app/Jobs/Middleware` 目錄下："

# CODE
#: ./docs/8.x/queues.md:368
#: ./docs/9.x/queues.md:383
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs\\Middleware;\n"
"\n"
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"class RateLimited\n"
"{\n"
"    /**\n"
"     * Process the queued job.\n"
"     *\n"
"     * @param  mixed  $job\n"
"     * @param  callable  $next\n"
"     * @return mixed\n"
"     */\n"
"    public function handle($job, $next)\n"
"    {\n"
"        Redis::throttle('key')\n"
"                ->block(0)->allow(1)->every(5)\n"
"                ->then(function () use ($job, $next) {\n"
"                    // Lock obtained...\n"
"\n"
"                    $next($job);\n"
"                }, function () use ($job) {\n"
"                    // Could not obtain lock...\n"
"\n"
"                    $job->release(5);\n"
"                });\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:380
#: ./docs/11.x/queues.md:379
#: ./docs/master/queues.md:380
msgid ""
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    Redis::throttle('key')->block(0)->allow(1)->every(5)->then(function () {\n"
"        info('Lock obtained...');\n"
"\n"
"        // Handle job...\n"
"    }, function () {\n"
"        // Could not obtain lock...\n"
"\n"
"        return $this->release(5);\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:399
#: ./docs/9.x/queues.md:414
#: ./docs/10.x/queues.md:432
#: ./docs/11.x/queues.md:431
#: ./docs/master/queues.md:432
msgid "As you can see, like [route middleware](/docs/{{version}}/middleware), job middleware receive the job being processed and a callback that should be invoked to continue processing the job."
msgstr "就像這樣，跟 [Route Middleware](/docs/{{version}}/middleware) 很像，Job Middleware 會收到正在處理的 Job，以及要繼續執行 Job 時要叫用的回呼。"

# P
#: ./docs/8.x/queues.md:401
#: ./docs/9.x/queues.md:416
#: ./docs/10.x/queues.md:434
#: ./docs/11.x/queues.md:433
#: ./docs/master/queues.md:434
msgid "After creating job middleware, they may be attached to a job by returning them from the job's `middleware` method. This method does not exist on jobs scaffolded by the `make:job` Artisan command, so you will need to manually add it to your job class:"
msgstr "建立好 Job Middleware 後，我們就可以在 Job 的 `middleware` 方法內將這個 Middleware 附加上去了。`make:job` 產生的空 Job 不包含 `middleware` 方法，所以我們需要手動在 Job 類別中新增這個方法："

# CODE
#: ./docs/10.x/queues.md:402
#: ./docs/11.x/queues.md:401
#: ./docs/master/queues.md:402
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs\\Middleware;\n"
"\n"
"use Closure;\n"
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"class RateLimited\n"
"{\n"
"    /**\n"
"     * Process the queued job.\n"
"     *\n"
"     * @param  \\Closure(object): void  $next\n"
"     */\n"
"    public function handle(object $job, Closure $next): void\n"
"    {\n"
"        Redis::throttle('key')\n"
"                ->block(0)->allow(1)->every(5)\n"
"                ->then(function () use ($job, $next) {\n"
"                    // Lock obtained...\n"
"\n"
"                    $next($job);\n"
"                }, function () use ($job) {\n"
"                    // Could not obtain lock...\n"
"\n"
"                    $job->release(5);\n"
"                });\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:403
#: ./docs/9.x/queues.md:418
msgid ""
"use App\\Jobs\\Middleware\\RateLimited;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new RateLimited];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:415
#: ./docs/9.x/queues.md:431
#: ./docs/10.x/queues.md:449
#: ./docs/11.x/queues.md:448
#: ./docs/master/queues.md:449
msgid "Job middleware can also be assigned to queueable event listeners, mailables, and notifications."
msgstr "Job Middleware 也可以被指派給可放入佇列的 Event Listener、Mailable、Notification 等。"

# P
#: ./docs/8.x/queues.md:417
#: ./docs/9.x/queues.md:433
#: ./docs/10.x/queues.md:451
#: ./docs/11.x/queues.md:450
#: ./docs/master/queues.md:451
#~ msgid "<a name=\"rate-limiting\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:418
#: ./docs/9.x/queues.md:434
#: ./docs/10.x/queues.md:452
#: ./docs/11.x/queues.md:451
#: ./docs/master/queues.md:452
msgid "Rate Limiting"
msgstr "頻率限制"

# P
#: ./docs/8.x/queues.md:420
#: ./docs/9.x/queues.md:436
#: ./docs/10.x/queues.md:454
#: ./docs/11.x/queues.md:453
#: ./docs/master/queues.md:454
msgid "Although we just demonstrated how to write your own rate limiting job middleware, Laravel actually includes a rate limiting middleware that you may utilize to rate limit jobs. Like [route rate limiters](/docs/{{version}}/routing#defining-rate-limiters), job rate limiters are defined using the `RateLimiter` facade's `for` method."
msgstr "雖然我們已經示範了要如何自行撰寫頻率限制的 Job Middleware。不過，其實 Laravel 有內建用來為 Job 做頻率限制的 Middleware。就跟 [Route 的 Rate Limiter](/docs/{{version}}/routing#defining-rate-limiters) 一樣，可以使用 `RateLimiter` Facade 的 `for` 方法來定義 Job 的頻率限制。"

# P
#: ./docs/8.x/queues.md:422
#: ./docs/9.x/queues.md:438
#: ./docs/10.x/queues.md:456
#: ./docs/11.x/queues.md:455
#: ./docs/master/queues.md:456
msgid "For example, you may wish to allow users to backup their data once per hour while imposing no such limit on premium customers. To accomplish this, you may define a `RateLimiter` in the `boot` method of your `AppServiceProvider`:"
msgstr "舉例來說，我們可能會想讓使用者能備份資料，而一般的使用者限制為每小時可備份一次，VIP 使用者則不限次數。若要做這種頻率限制，可以在 `AppServiceProvider` 中的 `boot` 方法內定義一個 `RateLimiter`："

# CODE
#: ./docs/8.x/queues.md:424
#: ./docs/9.x/queues.md:440
msgid ""
"use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"use Illuminate\\Support\\Facades\\RateLimiter;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    RateLimiter::for('backups', function ($job) {\n"
"        return $job->user->vipCustomer()\n"
"                    ? Limit::none()\n"
"                    : Limit::perHour(1)->by($job->user->id);\n"
"    });\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:436
#: ./docs/11.x/queues.md:435
#: ./docs/master/queues.md:436
msgid ""
"use App\\Jobs\\Middleware\\RateLimited;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new RateLimited];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:441
#: ./docs/9.x/queues.md:457
#: ./docs/10.x/queues.md:473
#: ./docs/11.x/queues.md:472
#: ./docs/master/queues.md:473
msgid "In the example above, we defined an hourly rate limit; however, you may easily define a rate limit based on minutes using the `perMinute` method. In addition, you may pass any value you wish to the `by` method of the rate limit; however, this value is most often used to segment rate limits by customer:"
msgstr "在上述範例中，我們定義了一個每小時的頻率限制。除了以小時來定義頻率限制外，也可以使用 `perMinute` 方法來以分鐘定義頻率限制。此外，我們也可以傳入任意值給頻率限制的 `by` 方法。傳給 `by` 的值通常是用來區分不同使用者的："

# CODE
#: ./docs/8.x/queues.md:443
#: ./docs/9.x/queues.md:459
#: ./docs/10.x/queues.md:475
#: ./docs/11.x/queues.md:474
#: ./docs/master/queues.md:475
msgid "return Limit::perMinute(50)->by($job->user->id);"
msgstr ""

# P
#: ./docs/8.x/queues.md:445
#: ./docs/9.x/queues.md:461
msgid "Once you have defined your rate limit, you may attach the rate limiter to your backup job using the `Illuminate\\Queue\\Middleware\\RateLimited` middleware. Each time the job exceeds the rate limit, this middleware will release the job back to the queue with an appropriate delay based on the rate limit duration."
msgstr "定義好頻率限制後，我們就可以使用 `Illuminate\\Queue\\Middleware\\RateLimited` Middleware 來將這個 Rate Limiter 附加到備份 Job 上。每當這個 Job 超過頻率限制後，這個 Middleware 就會依照頻率限制的間隔，使用適當的延遲時間來將該 Job 放回到佇列中。"

# CODE
#: ./docs/8.x/queues.md:447
#: ./docs/9.x/queues.md:463
msgid ""
"use Illuminate\\Queue\\Middleware\\RateLimited;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new RateLimited('backups')];\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:458
#: ./docs/11.x/queues.md:457
#: ./docs/master/queues.md:458
msgid ""
"use Illuminate\\Cache\\RateLimiting\\Limit;\n"
"use Illuminate\\Support\\Facades\\RateLimiter;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    RateLimiter::for('backups', function (object $job) {\n"
"        return $job->user->vipCustomer()\n"
"                    ? Limit::none()\n"
"                    : Limit::perHour(1)->by($job->user->id);\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:459
#: ./docs/9.x/queues.md:475
#: ./docs/10.x/queues.md:491
#: ./docs/11.x/queues.md:490
#: ./docs/master/queues.md:491
msgid "Releasing a rate limited job back onto the queue will still increment the job's total number of `attempts`. You may wish to tune your `tries` and `maxExceptions` properties on your job class accordingly. Or, you may wish to use the [`retryUntil` method](#time-based-attempts) to define the amount of time until the job should no longer be attempted."
msgstr "將受頻率限制的 Job 放回佇列後，一樣會增加 Job 的 `attemps` 總數。若有需要可以在 Job 類別上適當地設定 `tries` 與 `maxExceptions` 屬性。或者，也可以使用 [`retryUntil` 方法](#time-based-attempts) 來定義不再重新嘗試 Job 的時間。"

# P
#: ./docs/8.x/queues.md:461
#: ./docs/9.x/queues.md:477
#: ./docs/10.x/queues.md:493
#: ./docs/11.x/queues.md:492
#: ./docs/master/queues.md:493
msgid "If you do not want a job to be retried when it is rate limited, you may use the `dontRelease` method:"
msgstr "若不想讓 Job 在遇到頻率限制後重新嘗試，可使用 `dontRelease` 方法："

# CODE
#: ./docs/8.x/queues.md:463
#: ./docs/9.x/queues.md:479
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new RateLimited('backups'))->dontRelease()];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:473
#: ./docs/9.x/queues.md:490
#: ./docs/10.x/queues.md:506
#: ./docs/11.x/queues.md:505
#: ./docs/master/queues.md:506
msgid "If you are using Redis, you may use the `Illuminate\\Queue\\Middleware\\RateLimitedWithRedis` middleware, which is fine-tuned for Redis and more efficient than the basic rate limiting middleware."
msgstr "若使用 Redis，可使用 `Illuminate\\Queue\\Middleware\\RateLimitedWithRedis` Middleware。這個 Middleware 有為 Redis 做最佳化，比起一般基礎的頻率限制 Middleware 來說會更有效率。"

# P
#: ./docs/8.x/queues.md:475
#: ./docs/9.x/queues.md:492
#: ./docs/10.x/queues.md:508
#: ./docs/11.x/queues.md:507
#: ./docs/master/queues.md:508
#~ msgid "<a name=\"preventing-job-overlaps\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:476
#: ./docs/9.x/queues.md:493
#: ./docs/10.x/queues.md:509
#: ./docs/11.x/queues.md:508
#: ./docs/master/queues.md:509
msgid "Preventing Job Overlaps"
msgstr "避免 Job 重疊"

# P
#: ./docs/10.x/queues.md:477
#: ./docs/11.x/queues.md:476
#: ./docs/master/queues.md:477
msgid "Once you have defined your rate limit, you may attach the rate limiter to your job using the `Illuminate\\Queue\\Middleware\\RateLimited` middleware. Each time the job exceeds the rate limit, this middleware will release the job back to the queue with an appropriate delay based on the rate limit duration."
msgstr "定義好頻率限制後，我們就可以使用 `Illuminate\\Queue\\Middleware\\RateLimited` Middleware 來將這個 Rate Limiter 附加到 Job 上。每當這個 Job 超過頻率限制後，這個 Middleware 就會依照頻率限制的間隔，使用適當的延遲時間來將該 Job 放回到佇列中。"

# P
#: ./docs/8.x/queues.md:478
#: ./docs/9.x/queues.md:495
#: ./docs/10.x/queues.md:511
#: ./docs/11.x/queues.md:510
#: ./docs/master/queues.md:511
msgid "Laravel includes an `Illuminate\\Queue\\Middleware\\WithoutOverlapping` middleware that allows you to prevent job overlaps based on an arbitrary key. This can be helpful when a queued job is modifying a resource that should only be modified by one job at a time."
msgstr "Laravel 隨附了一個 `Illuminate\\Queue\\Middleware\\WithoutOverlapping` Middleware，可讓我們依照任意索引鍵來避免 Job 重疊。使用這個 Middleware 就能避免同一個資源同時被多個佇列 Job 修改。"

# CODE
#: ./docs/10.x/queues.md:479
#: ./docs/11.x/queues.md:478
#: ./docs/master/queues.md:479
msgid ""
"use Illuminate\\Queue\\Middleware\\RateLimited;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new RateLimited('backups')];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:480
#: ./docs/9.x/queues.md:497
#: ./docs/10.x/queues.md:513
#: ./docs/11.x/queues.md:512
#: ./docs/master/queues.md:513
msgid "For example, let's imagine you have a queued job that updates a user's credit score and you want to prevent credit score update job overlaps for the same user ID. To accomplish this, you can return the `WithoutOverlapping` middleware from your job's `middleware` method:"
msgstr "舉例來說，假設我們有個佇列任務會負責更新使用者的信用分數，而我們想避免兩個更新相同 User ID 的信用分數 Job 重疊。為此，可在 Job 的 `middleware` 方法中回傳 `WithoutOverlapping` Middleware："

# CODE
#: ./docs/8.x/queues.md:482
#: ./docs/9.x/queues.md:499
msgid ""
"use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new WithoutOverlapping($this->user->id)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:494
msgid "Any overlapping jobs will be released back to the queue. You may also specify the number of seconds that must elapse before the released job will be attempted again:"
msgstr "每當有重疊的 Job，這些 Job 都會被重新放到佇列中。我們可以指定一個秒數，讓這些被重新放回佇列的 Job 在重新嘗試前必須等待多久："

# CODE
#: ./docs/10.x/queues.md:495
#: ./docs/11.x/queues.md:494
#: ./docs/master/queues.md:495
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new RateLimited('backups'))->dontRelease()];\n"
"}"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:496
#: ./docs/9.x/queues.md:513
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:506
#: ./docs/9.x/queues.md:523
#: ./docs/10.x/queues.md:539
#: ./docs/11.x/queues.md:538
#: ./docs/master/queues.md:539
msgid "If you wish to immediately delete any overlapping jobs so that they will not be retried, you may use the `dontRelease` method:"
msgstr "若想在 Job 重疊時馬上刪除這些重疊的 Job 來讓這些 Job 不被重試，請使用 `dontRelease` 方法："

# CODE
#: ./docs/8.x/queues.md:508
#: ./docs/9.x/queues.md:525
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->dontRelease()];\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:511
#: ./docs/10.x/queues.md:527
#: ./docs/11.x/queues.md:526
#: ./docs/master/queues.md:527
msgid "Any overlapping jobs of the same type will be released back to the queue. You may also specify the number of seconds that must elapse before the released job will be attempted again:"
msgstr "每當有重疊的 Job，這些 Job 都會被重新放到佇列中。可以指定這些被重新放回佇列的 Job 在重新嘗試前必須等待多久的秒數："

# CODE
#: ./docs/10.x/queues.md:515
#: ./docs/11.x/queues.md:514
#: ./docs/master/queues.md:515
msgid ""
"use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new WithoutOverlapping($this->user->id)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:518
#: ./docs/9.x/queues.md:535
#: ./docs/10.x/queues.md:551
#: ./docs/11.x/queues.md:550
#: ./docs/master/queues.md:551
msgid "The `WithoutOverlapping` middleware is powered by Laravel's atomic lock feature. Sometimes, your job may unexpectedly fail or timeout in such a way that the lock is not released. Therefore, you may explicitly define a lock expiration time using the `expireAfter` method. For example, the example below will instruct Laravel to release the `WithoutOverlapping` lock three minutes after the job has started processing:"
msgstr "`WithoutOverlapping` Middleware 使用 Laravel 的 Atomic Lock 功能提供。有時候，Job 可能會未預期地失敗或逾時，並可能未正確釋放 Lock。因此，我們可以使用 `expireAfter` 方法來顯式定義一個 Lock 的有效時間。舉例來說，下列範例會讓 Laravel 在 Job 開始處理的 3 分鐘後釋放 `WithoutOverlapping` Lock："

# CODE
#: ./docs/8.x/queues.md:520
#: ./docs/9.x/queues.md:537
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:529
#: ./docs/11.x/queues.md:528
#: ./docs/master/queues.md:529
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->releaseAfter(60)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:530
#: ./docs/9.x/queues.md:548
#: ./docs/10.x/queues.md:564
#: ./docs/11.x/queues.md:563
#: ./docs/master/queues.md:564
msgid "The `WithoutOverlapping` middleware requires a cache driver that supports [locks](/docs/{{version}}/cache#atomic-locks). Currently, the `memcached`, `redis`, `dynamodb`, `database`, `file`, and `array` cache drivers support atomic locks."
msgstr "若要使用 `WithoutOverlapping` Middleware，則需要使用支援 [Atomic Lock] 的快取 Driver。目前，`memcached`、`redis`、`dynamodb`、`database`、`file`、`array` 等快取 Driver 有支援 Atomic Lock。"

# P
#: ./docs/8.x/queues.md:532
#: ./docs/9.x/queues.md:585
#: ./docs/10.x/queues.md:601
#: ./docs/11.x/queues.md:598
#: ./docs/master/queues.md:601
#~ msgid "<a name=\"throttling-exceptions\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:533
#: ./docs/9.x/queues.md:586
#: ./docs/10.x/queues.md:602
#: ./docs/11.x/queues.md:599
#: ./docs/master/queues.md:602
msgid "Throttling Exceptions"
msgstr "頻率限制的 Exception"

# P
#: ./docs/8.x/queues.md:535
#: ./docs/9.x/queues.md:588
#: ./docs/10.x/queues.md:604
#: ./docs/11.x/queues.md:601
#: ./docs/master/queues.md:604
msgid "Laravel includes a `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` middleware that allows you to throttle exceptions. Once the job throws a given number of exceptions, all further attempts to execute the job are delayed until a specified time interval lapses. This middleware is particularly useful for jobs that interact with third-party services that are unstable."
msgstr "Laravel 中隨附了一個 `Illuminate\\Queue\\Middleware\\ThrottlesExceptions` Middleware，能讓我們針對 Exception 做頻率限制。每當有 Job 擲回特定數量的 Exception 時，接下來要再次嘗試執行該 Job 前，必須要等待特定的時間過後才能繼續。對於一些使用了不穩定第三方服務的 Job 來說，特別適合使用這個功能。"

# P
#: ./docs/8.x/queues.md:537
#: ./docs/9.x/queues.md:590
#: ./docs/10.x/queues.md:606
#: ./docs/11.x/queues.md:603
#: ./docs/master/queues.md:606
msgid "For example, let's imagine a queued job that interacts with a third-party API that begins throwing exceptions. To throttle exceptions, you can return the `ThrottlesExceptions` middleware from your job's `middleware` method. Typically, this middleware should be paired with a job that implements [time based attempts](#time-based-attempts):"
msgstr "舉例來說，假設我們有個使用了第三方 API 的佇列 Job，而這個 Job 會擲回 Exception。若要對 Exception 做頻率限制，可以在 Job 的 `middleware` 方法內回傳 `ThrottlesExceptions` Middleware。一般來說，這個 Middleware 應放在實作[基於時間的 attempts](#time-based-attempts)之 Job 內："

# CODE
#: ./docs/8.x/queues.md:539
#: ./docs/9.x/queues.md:592
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new ThrottlesExceptions(10, 5)];\n"
"}\n"
"\n"
"/**\n"
" * Determine the time at which the job should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(5);\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:541
#: ./docs/11.x/queues.md:540
#: ./docs/master/queues.md:541
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->dontRelease()];\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:550
#: ./docs/10.x/queues.md:566
#: ./docs/11.x/queues.md:565
#: ./docs/master/queues.md:566
#~ msgid "<a name=\"sharing-lock-keys\"></a>"
#~ msgstr ""

# H4
#: ./docs/9.x/queues.md:551
#: ./docs/10.x/queues.md:567
#: ./docs/11.x/queues.md:566
#: ./docs/master/queues.md:567
msgid "Sharing Lock Keys Across Job Classes"
msgstr "在多個 Job 類別中共用 Lock 索引鍵"

# CODE
#: ./docs/10.x/queues.md:553
#: ./docs/11.x/queues.md:552
#: ./docs/master/queues.md:553
msgid ""
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new WithoutOverlapping($this->order->id))->expireAfter(180)];\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:553
#: ./docs/10.x/queues.md:569
#: ./docs/11.x/queues.md:568
#: ./docs/master/queues.md:569
msgid "By default, the `WithoutOverlapping` middleware will only prevent overlapping jobs of the same class. So, although two different job classes may use the same lock key, they will not be prevented from overlapping. However, you can instruct Laravel to apply the key across job classes using the `shared` method:"
msgstr "預設情況下，`WithoutOverlapping` Middleware 只會防止相同類別的重疊 Job。因此，即使某兩個不同的 Job 可能使用相同的 Lock 索引鍵，仍然無法防止 Job 重疊。不過，可以使用 `shared` 方法來指定讓 Laravel 在多個 Job 類別間套用同樣的索引鍵："

# CODE: php
#: ./docs/9.x/queues.md:555
msgid ""
"use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
"\n"
"class ProviderIsDown\n"
"{\n"
"    // ...\n"
"\n"
"\n"
"    public function middleware()\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}\n"
"\n"
"class ProviderIsUp\n"
"{\n"
"    // ...\n"
"\n"
"\n"
"    public function middleware()\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:561
#: ./docs/9.x/queues.md:614
#: ./docs/10.x/queues.md:629
#: ./docs/master/queues.md:629
msgid "The first constructor argument accepted by the middleware is the number of exceptions the job can throw before being throttled, while the second constructor argument is the number of minutes that should elapse before the job is attempted again once it has been throttled. In the code example above, if the job throws 10 exceptions within 5 minutes, we will wait 5 minutes before attempting the job again."
msgstr "Middleware 的第一個 Constructor 引數為 Exception 的數量，當 Job 擲回這個數量的 Exception 後就會被限制執行。第二個引數則是當被限制執行後，在繼續執行之前所要等待的分鐘數。在上述的範例中，若 Job 在 5 分鐘內擲回了 10 個 Exception，則 Laravel 會等待 5 分鐘，然後再繼續嘗試執行該 Job。"

# P
#: ./docs/8.x/queues.md:563
#: ./docs/9.x/queues.md:616
#: ./docs/10.x/queues.md:631
#: ./docs/11.x/queues.md:628
#: ./docs/master/queues.md:631
msgid "When a job throws an exception but the exception threshold has not yet been reached, the job will typically be retried immediately. However, you may specify the number of minutes such a job should be delayed by calling the `backoff` method when attaching the middleware to the job:"
msgstr "當 Job 擲回 Exception，但還未達到所設定的 Exception 閥值，則一般情況下會馬上重試 Job。不過，也可以在講 Middleware 附加到 Job 上時呼叫 `backoff` 方法來指定一個以分鐘為單位的數字，來指定 Job 所要延遲的時間："

# CODE
#: ./docs/8.x/queues.md:565
#: ./docs/9.x/queues.md:618
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 5))->backoff(5)];\n"
"}"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:570
msgid ""
"use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
"\n"
"class ProviderIsDown\n"
"{\n"
"    // ...\n"
"\n"
"    public function middleware(): array\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}\n"
"\n"
"class ProviderIsUp\n"
"{\n"
"    // ...\n"
"\n"
"    public function middleware(): array\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}"
msgstr ""

# CODE: php
#: ./docs/10.x/queues.md:571
#: ./docs/master/queues.md:571
msgid ""
"use Illuminate\\Queue\\Middleware\\WithoutOverlapping;\n"
"\n"
"class ProviderIsDown\n"
"{\n"
"    // ...\n"
"\n"
"\n"
"    public function middleware(): array\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}\n"
"\n"
"class ProviderIsUp\n"
"{\n"
"    // ...\n"
"\n"
"\n"
"    public function middleware(): array\n"
"    {\n"
"        return [\n"
"            (new WithoutOverlapping(\"status:{$this->provider}\"))->shared(),\n"
"        ];\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:577
#: ./docs/9.x/queues.md:630
#: ./docs/10.x/queues.md:645
#: ./docs/11.x/queues.md:642
#: ./docs/master/queues.md:645
msgid "Internally, this middleware uses Laravel's cache system to implement rate limiting, and the job's class name is utilized as the cache \"key\". You may override this key by calling the `by` method when attaching the middleware to your job. This may be useful if you have multiple jobs interacting with the same third-party service and you would like them to share a common throttling \"bucket\":"
msgstr "這個 Middleware 在內部使用了 Laravel 的快取系統來實作頻率限制，並使用了該 Job 的類別名稱來作為快取的「索引鍵」。可以在講 Middleware 附加到 Job 上時呼叫 `by` 方法來複寫這個索引鍵。當有多個 Job 都使用了同一個第三方服務時，就很適合使用這個方法來讓這些 Job 都共用相同的頻率限制："

# CODE
#: ./docs/8.x/queues.md:579
#: ./docs/9.x/queues.md:632
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10))->by('key')];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:591
#: ./docs/9.x/queues.md:645
#: ./docs/10.x/queues.md:660
#: ./docs/11.x/queues.md:691
#: ./docs/master/queues.md:660
msgid "If you are using Redis, you may use the `Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis` middleware, which is fine-tuned for Redis and more efficient than the basic exception throttling middleware."
msgstr "若使用 Redis，可使用 `Illuminate\\Queue\\Middleware\\ThrottlesExceptionsWithRedis` Middleware。該 Middleware 有為 Redis 最佳化，因此會比一般的 Exception 頻率限制 Middleware 還要有效率。"

# P
#: ./docs/8.x/queues.md:593
#: ./docs/9.x/queues.md:647
#: ./docs/10.x/queues.md:662
#: ./docs/11.x/queues.md:726
#: ./docs/master/queues.md:662
#~ msgid "<a name=\"dispatching-jobs\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:594
#: ./docs/9.x/queues.md:648
#: ./docs/10.x/queues.md:663
#: ./docs/11.x/queues.md:727
#: ./docs/master/queues.md:663
msgid "Dispatching Jobs"
msgstr "分派 Job"

# P
#: ./docs/8.x/queues.md:596
#: ./docs/9.x/queues.md:650
#: ./docs/10.x/queues.md:665
#: ./docs/11.x/queues.md:729
#: ./docs/master/queues.md:665
msgid "Once you have written your job class, you may dispatch it using the `dispatch` method on the job itself. The arguments passed to the `dispatch` method will be given to the job's constructor:"
msgstr "寫好 Job 類別後，就可以使用 Job 上的 `dispatch` 方法來分派該 Job。傳給 `dispatch` 方法的引數會被傳給 Job 的 Constructor："

# CODE
#: ./docs/8.x/queues.md:598
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast);\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:605
msgid ""
"use DateTime;\n"
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new ThrottlesExceptions(10, 5 * 60)];\n"
"}\n"
"\n"
"/**\n"
" * Determine the time at which the job should timeout.\n"
" */\n"
"public function retryUntil(): DateTime\n"
"{\n"
"    return now()->addMinutes(30);\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:608
#: ./docs/master/queues.md:608
msgid ""
"use DateTime;\n"
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new ThrottlesExceptions(10, 5)];\n"
"}\n"
"\n"
"/**\n"
" * Determine the time at which the job should timeout.\n"
" */\n"
"public function retryUntil(): DateTime\n"
"{\n"
"    return now()->addMinutes(5);\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:625
#: ./docs/9.x/queues.md:679
#: ./docs/10.x/queues.md:694
#: ./docs/11.x/queues.md:758
#: ./docs/master/queues.md:694
msgid "If you would like to conditionally dispatch a job, you may use the `dispatchIf` and `dispatchUnless` methods:"
msgstr "若想要有條件地分派 Job，可使用 `dispatchIf` 與` `dispatchUnless` 方法："

# P
#: ./docs/11.x/queues.md:626
msgid "The first constructor argument accepted by the middleware is the number of exceptions the job can throw before being throttled, while the second constructor argument is the number of seconds that should elapse before the job is attempted again once it has been throttled. In the code example above, if the job throws 10 consecutive exceptions, we will wait 5 minutes before attempting the job again, constrained by the 30-minute time limit."
msgstr ""

# CODE
#: ./docs/8.x/queues.md:627
#: ./docs/9.x/queues.md:681
#: ./docs/10.x/queues.md:696
#: ./docs/11.x/queues.md:760
#: ./docs/master/queues.md:696
msgid ""
"ProcessPodcast::dispatchIf($accountActive, $podcast);\n"
"\n"
"ProcessPodcast::dispatchUnless($accountSuspended, $podcast);"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:630
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 5 * 60))->backoff(5)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:631
#: ./docs/9.x/queues.md:687
#: ./docs/10.x/queues.md:702
#: ./docs/11.x/queues.md:766
#: ./docs/master/queues.md:702
#~ msgid "<a name=\"delayed-dispatching\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:632
#: ./docs/9.x/queues.md:688
#: ./docs/10.x/queues.md:703
#: ./docs/11.x/queues.md:767
#: ./docs/master/queues.md:703
msgid "Delayed Dispatching"
msgstr "延遲分派"

# CODE
#: ./docs/10.x/queues.md:633
#: ./docs/master/queues.md:633
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 5))->backoff(5)];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:634
#: ./docs/9.x/queues.md:690
#: ./docs/10.x/queues.md:705
#: ./docs/11.x/queues.md:769
#: ./docs/master/queues.md:705
msgid "If you would like to specify that a job should not be immediately available for processing by a queue worker, you may use the `delay` method when dispatching the job. For example, let's specify that a job should not be available for processing until 10 minutes after it has been dispatched:"
msgstr "若不想讓 Job 馬上被 Queue Worker 處理，可在分派 Job 時使用 `delay` 方法。舉例來說，我們來指定讓一個 Job 在分派的 10 分鐘後才被開始處理："

# CODE
#: ./docs/8.x/queues.md:636
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)\n"
"                    ->delay(now()->addMinutes(10));\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:644
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10 * 60))->by('key')];\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:647
#: ./docs/master/queues.md:647
msgid ""
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10))->by('key')];\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:652
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/11.x/queues.md:656
msgid "By default, this middleware will throttle every exception. You can modify this behaviour by invoking the `when` method when attaching the middleware to your job. The exception will then only be throttled if closure provided to the `when` method returns `true`:"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:658
msgid ""
"use Illuminate\\Http\\Client\\HttpClientException;\n"
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10 * 60))->when(\n"
"        fn (Throwable $throwable) => $throwable instanceof HttpClientException\n"
"    )];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:664
#: ./docs/9.x/queues.md:721
#: ./docs/10.x/queues.md:736
#: ./docs/11.x/queues.md:804
#: ./docs/master/queues.md:736
msgid "The Amazon SQS queue service has a maximum delay time of 15 minutes."
msgstr "Amazon SQS 佇列服務的延遲時間最多只能為 15 分鐘。"

# P
#: ./docs/8.x/queues.md:666
#: ./docs/9.x/queues.md:723
#: ./docs/10.x/queues.md:738
#: ./docs/11.x/queues.md:806
#: ./docs/master/queues.md:738
#~ msgid "<a name=\"dispatching-after-the-response-is-sent-to-browser\"></a>"
#~ msgstr ""

# CODE
#: ./docs/10.x/queues.md:667
#: ./docs/11.x/queues.md:731
#: ./docs/master/queues.md:667
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     */\n"
"    public function store(Request $request): RedirectResponse\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast);\n"
"\n"
"        return redirect('/podcasts');\n"
"    }\n"
"}"
msgstr ""

# H4
#: ./docs/8.x/queues.md:667
#: ./docs/9.x/queues.md:724
msgid "Dispatching After The Response Is Sent To Browser"
msgstr "在 Response 被傳送給瀏覽器後才進行分派"

# P
#: ./docs/8.x/queues.md:669
msgid "Alternatively, the `dispatchAfterResponse` method delays dispatching a job until after the HTTP response is sent to the user's browser. This will still allow the user to begin using the application even though a queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an email. Since they are processed within the current HTTP request, jobs dispatched in this fashion do not require a queue worker to be running in order for them to be processed:"
msgstr "`dispatchAfterResponse` 則是另一個分派 Job 的方法，該方法延遲分派 Job，直到 HTTP Response 被傳回使用者瀏覽器後才開始處理Job。這樣一來，在處理佇列 Job 的同時，使用者就能繼續使用我們的網站。一般來說，這種做法應只用於一些只需花費 1 秒鐘的 Job，如寄送 E-Mail 鄧。由於這些 Job 會在目前的 HTTP Request 中處理，因此使用這種方式分派 Job 就不需要執行 Queue Worker："

# CODE
#: ./docs/8.x/queues.md:671
#: ./docs/9.x/queues.md:728
#: ./docs/10.x/queues.md:743
#: ./docs/11.x/queues.md:811
#: ./docs/master/queues.md:743
msgid ""
"use App\\Jobs\\SendNotification;\n"
"\n"
"SendNotification::dispatchAfterResponse();"
msgstr ""

# P
#: ./docs/11.x/queues.md:673
msgid "If you would like to have the throttled exceptions reported to your application's exception handler, you can do so by invoking the `report` method when attaching the middleware to your job. Optionally, you may provide a closure to the `report` method and the exception will only be reported if the given closure returns `true`:"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:675
msgid ""
"use Illuminate\\Http\\Client\\HttpClientException;\n"
"use Illuminate\\Queue\\Middleware\\ThrottlesExceptions;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array<int, object>\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [(new ThrottlesExceptions(10, 10 * 60))->report(\n"
"        fn (Throwable $throwable) => $throwable instanceof HttpClientException\n"
"    )];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:675
#: ./docs/9.x/queues.md:732
#: ./docs/10.x/queues.md:747
#: ./docs/11.x/queues.md:815
#: ./docs/master/queues.md:747
msgid "You may also `dispatch` a closure and chain the `afterResponse` method onto the `dispatch` helper to execute a closure after the HTTP response has been sent to the browser:"
msgstr "也可以用 `dispatch` 分派一個閉包，然後在 `dispatch` 輔助函式後串上一個 `afterResponse` 方法來在 HTTP Response 被傳送給瀏覽器後執行這個閉包："

# CODE
#: ./docs/8.x/queues.md:677
#: ./docs/9.x/queues.md:734
#: ./docs/10.x/queues.md:749
#: ./docs/11.x/queues.md:817
#: ./docs/master/queues.md:749
msgid ""
"use App\\Mail\\WelcomeMessage;\n"
"use Illuminate\\Support\\Facades\\Mail;\n"
"\n"
"dispatch(function () {\n"
"    Mail::to('taylor@example.com')->send(new WelcomeMessage);\n"
"})->afterResponse();"
msgstr ""

# P
#: ./docs/8.x/queues.md:684
#: ./docs/9.x/queues.md:741
#: ./docs/10.x/queues.md:756
#: ./docs/11.x/queues.md:824
#: ./docs/master/queues.md:756
#~ msgid "<a name=\"synchronous-dispatching\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:685
#: ./docs/9.x/queues.md:742
#: ./docs/10.x/queues.md:757
#: ./docs/11.x/queues.md:825
#: ./docs/master/queues.md:757
msgid "Synchronous Dispatching"
msgstr "同步分派"

# P
#: ./docs/9.x/queues.md:685
#: ./docs/10.x/queues.md:700
#: ./docs/11.x/queues.md:764
#: ./docs/master/queues.md:700
msgid "In new Laravel applications, the `sync` driver is the default queue driver. This driver executes jobs synchronously in the foreground of the current request, which is often convenient during local development. If you would like to actually begin queueing jobs for background processing, you may specify a different queue driver within your application's `config/queue.php` configuration file."
msgstr "在新的 Laravel 專案中，預設的 Queue Driver 是 `sync` Driver。該 Driver 會在目前 Request 中的前景 (Foreground) 同步執行 Job。若想要讓 Job 被真正放進佇列中在背景執行，你需要在專案的 `config/queue.php` 設定檔中指定一個不同的 Queue Driver。"

# P
#: ./docs/8.x/queues.md:687
#: ./docs/9.x/queues.md:744
#: ./docs/10.x/queues.md:759
#: ./docs/11.x/queues.md:827
#: ./docs/master/queues.md:759
msgid "If you would like to dispatch a job immediately (synchronously), you may use the `dispatchSync` method. When using this method, the job will not be queued and will be executed immediately within the current process:"
msgstr "若想馬上分派 Job (即，^[同步](Synchronous))，則可使用 `dispatchSync` 方法。在使用這個方法時，所分派的 Job 不會被放入佇列，而會在目前的處理程序中馬上執行："

# CODE
#: ./docs/8.x/queues.md:689
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatchSync($podcast);\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:692
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)\n"
"                    ->delay(now()->addMinutes(10));\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/11.x/queues.md:693
#~ msgid "<a name=\"skipping-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/11.x/queues.md:694
msgid "Skipping Jobs"
msgstr ""

# P
#: ./docs/11.x/queues.md:696
msgid "The `Skip` middleware allows you to specify that a job should be skipped / deleted without needing to modify the job's logic. The `Skip::when` method will delete the job if the given condition evaluates to `true`, while the `Skip::unless` method will delete the job if the condition evaluates to `false`:"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:698
msgid ""
"use Illuminate\\Queue\\Middleware\\Skip;\n"
"\n"
"/**\n"
"* Get the middleware the job should pass through.\n"
"*/\n"
"public function middleware(): array\n"
"{\n"
"    return [\n"
"        Skip::when($someCondition),\n"
"    ];\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:707
#: ./docs/11.x/queues.md:771
#: ./docs/master/queues.md:707
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     */\n"
"    public function store(Request $request): RedirectResponse\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // ...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)\n"
"                    ->delay(now()->addMinutes(10));\n"
"\n"
"        return redirect('/podcasts');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/11.x/queues.md:710
msgid "You can also pass a `Closure` to the `when` and `unless` methods for more complex conditional evaluation:"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:712
msgid ""
"use Illuminate\\Queue\\Middleware\\Skip;\n"
"\n"
"/**\n"
"* Get the middleware the job should pass through.\n"
"*/\n"
"public function middleware(): array\n"
"{\n"
"    return [\n"
"        Skip::when(function (): bool {\n"
"            return $this->shouldSkip();\n"
"        }),\n"
"    ];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:716
#: ./docs/9.x/queues.md:773
#: ./docs/10.x/queues.md:788
#: ./docs/11.x/queues.md:856
#: ./docs/master/queues.md:788
#~ msgid "<a name=\"jobs-and-database-transactions\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:717
#: ./docs/9.x/queues.md:774
#: ./docs/10.x/queues.md:789
#: ./docs/11.x/queues.md:857
#: ./docs/master/queues.md:789
msgid "Jobs & Database Transactions"
msgstr "Job 與資料庫 Transaction"

# P
#: ./docs/8.x/queues.md:719
msgid "While it is perfectly fine to dispatch jobs within database transactions, you should take special care to ensure that your job will actually be able to execute successfully. When dispatching a job within a transaction, it is possible that the job will be processed by a worker before the transaction has committed. When this happens, any updates you have made to models or database records during the database transaction may not yet be reflected in the database. In addition, any models or database records created within the transaction may not exist in the database."
msgstr "雖然，在資料庫 Transaction 中分派 Job 是完全 OK 的，但應特別注意 Job 能否被正確執行。當我們在 Transaction 中分派 Job 後，這個 Job 很有可能會在 Transaction 被 Commit 前就被 Queue Worker 給執行了。這時候，我們在 Transaction 中對 Model 或資料庫記錄所做出的更改都還未反應到資料庫上。而且，在 Transaction 中做建立的 Model 或資料庫記錄也可能還未出現在資料庫中。"

# P
#: ./docs/8.x/queues.md:721
#: ./docs/9.x/queues.md:778
#: ./docs/10.x/queues.md:793
#: ./docs/11.x/queues.md:861
#: ./docs/master/queues.md:793
msgid "Thankfully, Laravel provides several methods of working around this problem. First, you may set the `after_commit` connection option in your queue connection's configuration array:"
msgstr "幸好，Laravel 提供了數種方法可解決這個狀況。第一種方法，我們可以在 Queue 連線的設定陣列中設定 `after_commit` 連線選項："

# CODE
#: ./docs/8.x/queues.md:723
#: ./docs/9.x/queues.md:780
#: ./docs/10.x/queues.md:795
#: ./docs/11.x/queues.md:863
#: ./docs/master/queues.md:795
msgid ""
"'redis' => [\n"
"    'driver' => 'redis',\n"
"    // ...\n"
"    'after_commit' => true,\n"
"],"
msgstr ""

# P
#: ./docs/9.x/queues.md:726
#: ./docs/10.x/queues.md:741
#: ./docs/11.x/queues.md:809
#: ./docs/master/queues.md:741
msgid "Alternatively, the `dispatchAfterResponse` method delays dispatching a job until after the HTTP response is sent to the user's browser if your web server is using FastCGI. This will still allow the user to begin using the application even though a queued job is still executing. This should typically only be used for jobs that take about a second, such as sending an email. Since they are processed within the current HTTP request, jobs dispatched in this fashion do not require a queue worker to be running in order for them to be processed:"
msgstr "如果你的網頁伺服器使用 FastCGI，則 `dispatchAfterResponse` 是另一個分派 Job 的方法。該方法會延遲分派 Job，直到 HTTP Response 被傳回使用者瀏覽器後才開始處理Job。這樣一來，在處理佇列 Job 的同時，使用者就能繼續使用我們的網站。一般來說，這種做法應只用於一些只需花費 1 秒鐘的 Job，如寄送 E-Mail 等。由於這些 Job 會在目前的 HTTP Request 中處理，因此使用這種方式分派 Job 就不需要執行 Queue Worker："

# P
#: ./docs/8.x/queues.md:729
msgid "When the `after_commit` option is `true`, you may dispatch jobs within database transactions; however, Laravel will wait until all open database transactions have been committed before actually dispatching the job. Of course, if no database transactions are currently open, the job will be dispatched immediately."
msgstr "當 `after_commit` 設為 `true` 後，我們就可以在資料庫 Transaction 中分派 Job 了。Laravel 會等到所有資料庫 Transaction 都被 Commit 後才將 Job 分派出去。不過，當然，若目前沒有正在處理的資料庫 Transaction，這個 Job 會馬上被分派。"

# P
#: ./docs/8.x/queues.md:731
msgid "If a transaction is rolled back due to an exception that occurs during the transaction, the dispatched jobs that were dispatched during that transaction will be discarded."
msgstr "若因為 Transaction 中發上 Exception 而造成 Transaction 被 ^[Roll Back](回滾)，則在這個 Transaction 間所分派的 Job 也會被取消。"

# P
#: ./docs/8.x/queues.md:733
#: ./docs/9.x/queues.md:791
#: ./docs/10.x/queues.md:806
#: ./docs/11.x/queues.md:874
#: ./docs/master/queues.md:806
msgid "Setting the `after_commit` configuration option to `true` will also cause any queued event listeners, mailables, notifications, and broadcast events to be dispatched after all open database transactions have been committed."
msgstr "將 `after_commit` 設定選項設為 `true` 後，所有放入佇列的 Listener、Maillable、Notification、廣播事件……等都會等待到所有資料庫 Transaciton 都 Commit 後才被分派。"

# P
#: ./docs/8.x/queues.md:735
#: ./docs/9.x/queues.md:793
#: ./docs/10.x/queues.md:808
#: ./docs/11.x/queues.md:876
#: ./docs/master/queues.md:808
#~ msgid "<a name=\"specifying-commit-dispatch-behavior-inline\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:736
#: ./docs/9.x/queues.md:794
#: ./docs/10.x/queues.md:809
#: ./docs/11.x/queues.md:877
#: ./docs/master/queues.md:809
msgid "Specifying Commit Dispatch Behavior Inline"
msgstr "內嵌指定 Commit 的分派行為"

# P
#: ./docs/8.x/queues.md:738
#: ./docs/9.x/queues.md:796
#: ./docs/10.x/queues.md:811
#: ./docs/11.x/queues.md:879
#: ./docs/master/queues.md:811
msgid "If you do not set the `after_commit` queue connection configuration option to `true`, you may still indicate that a specific job should be dispatched after all open database transactions have been committed. To accomplish this, you may chain the `afterCommit` method onto your dispatch operation:"
msgstr "若未將 `after_commit` 佇列連線選項設為 `true`，則我們還是可以指定讓某個特定的 Job 在所有已開啟的資料庫 Transaction 都被 Commit 後才被分派。若要這麼做，可在分派動作後串上 `afterCommit` 方法："

# H4
#: ./docs/10.x/queues.md:739
#: ./docs/11.x/queues.md:807
#: ./docs/master/queues.md:739
msgid "Dispatching After the Response is Sent to the Browser"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:740
#: ./docs/9.x/queues.md:798
#: ./docs/10.x/queues.md:813
#: ./docs/11.x/queues.md:881
#: ./docs/master/queues.md:813
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"\n"
"ProcessPodcast::dispatch($podcast)->afterCommit();"
msgstr ""

# P
#: ./docs/8.x/queues.md:744
#: ./docs/9.x/queues.md:802
#: ./docs/10.x/queues.md:817
#: ./docs/11.x/queues.md:885
#: ./docs/master/queues.md:817
msgid "Likewise, if the `after_commit` configuration option is set to `true`, you may indicate that a specific job should be dispatched immediately without waiting for any open database transactions to commit:"
msgstr "同樣地，若 `after_commit` 選項為 `true`，則我們也可以馬上分派某個特定的 Job，而不等待資料庫 Transaction 的 Commit："

# CODE
#: ./docs/8.x/queues.md:746
#: ./docs/9.x/queues.md:804
#: ./docs/10.x/queues.md:819
#: ./docs/11.x/queues.md:887
#: ./docs/master/queues.md:819
msgid "ProcessPodcast::dispatch($podcast)->beforeCommit();"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:746
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatchSync($podcast);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:748
#: ./docs/9.x/queues.md:806
#: ./docs/10.x/queues.md:821
#: ./docs/11.x/queues.md:889
#: ./docs/master/queues.md:821
#~ msgid "<a name=\"job-chaining\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:749
#: ./docs/9.x/queues.md:807
#: ./docs/10.x/queues.md:822
#: ./docs/11.x/queues.md:890
#: ./docs/master/queues.md:822
msgid "Job Chaining"
msgstr "Job 的串聯"

# P
#: ./docs/8.x/queues.md:751
#: ./docs/9.x/queues.md:809
#: ./docs/10.x/queues.md:824
#: ./docs/11.x/queues.md:892
#: ./docs/master/queues.md:824
msgid "Job chaining allows you to specify a list of queued jobs that should be run in sequence after the primary job has executed successfully. If one job in the sequence fails, the rest of the jobs will not be run. To execute a queued job chain, you may use the `chain` method provided by the `Bus` facade. Laravel's command bus is a lower level component that queued job dispatching is built on top of:"
msgstr "通過 Job 串聯，我們就可以指定一組佇列 Job 的清單，在主要 Job 執行成功後才依序執行這組 Job。若按照順序執行的其中一個 Job 執行失敗，則剩下的 Job 都將不被執行。若要執行佇列的 Job 串聯，可使用 `Bus` Facade 中的 `chain` 方法。Laravel 的 ^[Command Bus](指令匯流排) 是一個低階的原件，佇列 Job 的分派功能就是使用這個原件製作的："

# CODE
#: ./docs/8.x/queues.md:753
#: ./docs/9.x/queues.md:811
#: ./docs/10.x/queues.md:826
#: ./docs/11.x/queues.md:894
#: ./docs/master/queues.md:826
msgid ""
"use App\\Jobs\\OptimizePodcast;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Jobs\\ReleasePodcast;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->dispatch();"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:761
#: ./docs/11.x/queues.md:829
#: ./docs/master/queues.md:761
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     */\n"
"    public function store(Request $request): RedirectResponse\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatchSync($podcast);\n"
"\n"
"        return redirect('/podcasts');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:764
#: ./docs/9.x/queues.md:822
#: ./docs/10.x/queues.md:837
#: ./docs/11.x/queues.md:905
#: ./docs/master/queues.md:837
msgid "In addition to chaining job class instances, you may also chain closures:"
msgstr "除了串聯 Job 類別實體，我們也可以串聯閉包："

# CODE
#: ./docs/8.x/queues.md:766
msgid ""
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    function () {\n"
"        Podcast::update(...);\n"
"    },\n"
"])->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:774
#: ./docs/9.x/queues.md:833
#: ./docs/10.x/queues.md:848
#: ./docs/11.x/queues.md:916
#: ./docs/master/queues.md:848
msgid "Deleting jobs using the `$this->delete()` method within the job will not prevent chained jobs from being processed. The chain will only stop executing if a job in the chain fails."
msgstr "在 Job 中使用 `$this->delete()` 方法來刪除 Job 是沒有辦法讓串聯的 Job 不被執行的。只有當串聯中的 Job 失敗時才會停止執行。"

# P
#: ./docs/8.x/queues.md:776
#: ./docs/9.x/queues.md:835
#: ./docs/10.x/queues.md:850
#: ./docs/11.x/queues.md:918
#: ./docs/master/queues.md:850
#~ msgid "<a name=\"chain-connection-queue\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/queues.md:776
#: ./docs/10.x/queues.md:791
#: ./docs/11.x/queues.md:859
#: ./docs/master/queues.md:791
msgid "While it is perfectly fine to dispatch jobs within database transactions, you should take special care to ensure that your job will actually be able to execute successfully. When dispatching a job within a transaction, it is possible that the job will be processed by a worker before the parent transaction has committed. When this happens, any updates you have made to models or database records during the database transaction(s) may not yet be reflected in the database. In addition, any models or database records created within the transaction(s) may not exist in the database."
msgstr "雖然，在資料庫 Transaction 中分派 Job 是完全 OK 的，但應特別注意 Job 能否被正確執行。當我們在 Transaction 中分派 Job 後，這個 Job 很有可能會在上層 Transaction 被 Commit 前就被 Queue Worker 給執行了。這時候，我們在 Transaction 中對 Model 或資料庫記錄所做出的更改都還未反應到資料庫上。而且，在 Transaction 中做建立的 Model 或資料庫記錄也可能還未出現在資料庫中。"

# H4
#: ./docs/8.x/queues.md:777
#: ./docs/9.x/queues.md:836
msgid "Chain Connection & Queue"
msgstr "串聯的連線與佇列"

# P
#: ./docs/8.x/queues.md:779
#: ./docs/9.x/queues.md:838
#: ./docs/10.x/queues.md:853
#: ./docs/11.x/queues.md:921
#: ./docs/master/queues.md:853
msgid "If you would like to specify the connection and queue that should be used for the chained jobs, you may use the `onConnection` and `onQueue` methods. These methods specify the queue connection and queue name that should be used unless the queued job is explicitly assigned a different connection / queue:"
msgstr "若想指定串聯 Job 的連線與佇列，則可使用 `onConnection` 與 `onQueue` 方法。除非佇列 Job 有特別指定不同的連線或佇列，否則，這些方法可用來指定要使用的連線名稱與佇列名稱："

# CODE
#: ./docs/8.x/queues.md:781
#: ./docs/9.x/queues.md:840
#: ./docs/10.x/queues.md:855
#: ./docs/11.x/queues.md:923
#: ./docs/master/queues.md:855
msgid ""
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->onConnection('redis')->onQueue('podcasts')->dispatch();"
msgstr ""

# P
#: ./docs/9.x/queues.md:786
#: ./docs/10.x/queues.md:801
#: ./docs/11.x/queues.md:869
#: ./docs/master/queues.md:801
msgid "When the `after_commit` option is `true`, you may dispatch jobs within database transactions; however, Laravel will wait until the open parent database transactions have been committed before actually dispatching the job. Of course, if no database transactions are currently open, the job will be dispatched immediately."
msgstr "當 `after_commit` 設為 `true` 後，我們就可以在資料庫 Transaction 中分派 Job 了。Laravel 會等到未完成的上層資料庫 Transaction 都被 Commit 後才將 Job 分派出去。不過，當然，若目前沒有正在處理的資料庫 Transaction，這個 Job 會馬上被分派。"

# P
#: ./docs/8.x/queues.md:787
#: ./docs/9.x/queues.md:846
#: ./docs/10.x/queues.md:861
#: ./docs/11.x/queues.md:950
#: ./docs/master/queues.md:861
#~ msgid "<a name=\"chain-failures\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:788
#: ./docs/9.x/queues.md:847
#: ./docs/10.x/queues.md:862
#: ./docs/11.x/queues.md:951
#: ./docs/master/queues.md:862
msgid "Chain Failures"
msgstr "串聯失敗"

# P
#: ./docs/9.x/queues.md:788
#: ./docs/10.x/queues.md:803
#: ./docs/11.x/queues.md:871
#: ./docs/master/queues.md:803
msgid "If a transaction is rolled back due to an exception that occurs during the transaction, the jobs that were dispatched during that transaction will be discarded."
msgstr "若因為 Transaction 中發上 Exception 而造成 Transaction 被 ^[Roll Back](回溯)，則在這個 Transaction 間所分派的 Job 也會被取消。"

# P
#: ./docs/8.x/queues.md:790
#: ./docs/9.x/queues.md:849
#: ./docs/10.x/queues.md:864
#: ./docs/11.x/queues.md:953
#: ./docs/master/queues.md:864
msgid "When chaining jobs, you may use the `catch` method to specify a closure that should be invoked if a job within the chain fails. The given callback will receive the `Throwable` instance that caused the job failure:"
msgstr "將 Job 串聯起來後，可使用 `catch` 方法來指定當串聯中有 Job 失敗時要被叫用的閉包。給定的回呼會收到一個導致 Job 失敗的 `Throwable` 實體："

# CODE
#: ./docs/8.x/queues.md:792
#: ./docs/9.x/queues.md:851
#: ./docs/10.x/queues.md:866
#: ./docs/11.x/queues.md:955
#: ./docs/master/queues.md:866
msgid ""
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Throwable;\n"
"\n"
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"])->catch(function (Throwable $e) {\n"
"    // A job within the chain has failed...\n"
"})->dispatch();"
msgstr ""

# P
#: ./docs/11.x/queues.md:799
msgid "In some cases, jobs may have a default delay configured. If you need to bypass this delay and dispatch a job for immediate processing, you may use the `withoutDelay` method:"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:801
msgid "ProcessPodcast::dispatch($podcast)->withoutDelay();"
msgstr ""

# P
#: ./docs/8.x/queues.md:803
#: ./docs/9.x/queues.md:865
#: ./docs/10.x/queues.md:880
#: ./docs/11.x/queues.md:969
#: ./docs/master/queues.md:880
#~ msgid "<a name=\"customizing-the-queue-and-connection\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:804
#: ./docs/9.x/queues.md:866
msgid "Customizing The Queue & Connection"
msgstr "自定佇列與連線"

# P
#: ./docs/8.x/queues.md:806
#: ./docs/9.x/queues.md:868
#: ./docs/10.x/queues.md:883
#: ./docs/11.x/queues.md:972
#: ./docs/master/queues.md:883
#~ msgid "<a name=\"dispatching-to-a-particular-queue\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:807
#: ./docs/9.x/queues.md:869
msgid "Dispatching To A Particular Queue"
msgstr "分派至特定的佇列"

# P
#: ./docs/8.x/queues.md:809
#: ./docs/9.x/queues.md:871
#: ./docs/10.x/queues.md:886
#: ./docs/11.x/queues.md:975
#: ./docs/master/queues.md:886
msgid "By pushing jobs to different queues, you may \"categorize\" your queued jobs and even prioritize how many workers you assign to various queues. Keep in mind, this does not push jobs to different queue \"connections\" as defined by your queue configuration file, but only to specific queues within a single connection. To specify the queue, use the `onQueue` method when dispatching the job:"
msgstr "我們可以將 Job 分門別類放入不同的佇列中，進而分類管理這些 Job，甚至能針對不同佇列設定優先度、指定要有多少個 Worker。不過請記得，放入不同佇列不會將 Job 推送到佇列設定檔中所定義的不同佇列「連線」上，而只會將 Job 推入單一連線中指定的佇列。若要指定佇列，請在分派 Job 時使用 `onQueue` 方法："

# CODE
#: ./docs/8.x/queues.md:811
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:824
#: ./docs/10.x/queues.md:839
#: ./docs/11.x/queues.md:907
#: ./docs/master/queues.md:839
msgid ""
"Bus::chain([\n"
"    new ProcessPodcast,\n"
"    new OptimizePodcast,\n"
"    function () {\n"
"        Podcast::update(/* ... */);\n"
"    },\n"
"])->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:838
#: ./docs/9.x/queues.md:900
#: ./docs/10.x/queues.md:915
#: ./docs/11.x/queues.md:1004
#: ./docs/master/queues.md:915
msgid "Alternatively, you may specify the job's queue by calling the `onQueue` method within the job's constructor:"
msgstr "或者，也可以在 Job 的 Constructor 中呼叫 `onQueue` 方法來指定 Job 的佇列："

# CODE
#: ./docs/8.x/queues.md:840
#: ./docs/9.x/queues.md:902
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onQueue('processing');\n"
"    }\n"
"}"
msgstr ""

# H4
#: ./docs/10.x/queues.md:851
#: ./docs/11.x/queues.md:919
#: ./docs/master/queues.md:851
msgid "Chain Connection and Queue"
msgstr ""

# P
#: ./docs/9.x/queues.md:863
#: ./docs/10.x/queues.md:878
#: ./docs/11.x/queues.md:967
#: ./docs/master/queues.md:878
msgid "Since chain callbacks are serialized and executed at a later time by the Laravel queue, you should not use the `$this` variable within chain callbacks."
msgstr "由於串聯的回呼會被序列化並在稍後由 Laravel 的佇列執行，因此請不要在串聯的回呼中使用 `$this` 變數。"

# P
#: ./docs/8.x/queues.md:865
#: ./docs/9.x/queues.md:927
#: ./docs/10.x/queues.md:940
#: ./docs/11.x/queues.md:1026
#: ./docs/master/queues.md:940
#~ msgid "<a name=\"dispatching-to-a-particular-connection\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:866
#: ./docs/9.x/queues.md:928
msgid "Dispatching To A Particular Connection"
msgstr "分派至特定連線"

# P
#: ./docs/8.x/queues.md:868
#: ./docs/9.x/queues.md:930
#: ./docs/10.x/queues.md:943
#: ./docs/11.x/queues.md:1029
#: ./docs/master/queues.md:943
msgid "If your application interacts with multiple queue connections, you may specify which connection to push a job to using the `onConnection` method:"
msgstr "若專案有使用到多個佇列連線，則可以使用 `onConnection` 方法來指定要將 Job 推送到哪個連線："

# CODE
#: ./docs/8.x/queues.md:870
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(...);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:873
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"    }\n"
"}"
msgstr ""

# H3
#: ./docs/10.x/queues.md:881
msgid "Customizing The Queue a Connection"
msgstr ""

# H3
#: ./docs/master/queues.md:881
msgid "Customizing The Queue and Connection"
msgstr ""

# H4
#: ./docs/10.x/queues.md:884
#: ./docs/11.x/queues.md:973
#: ./docs/master/queues.md:884
msgid "Dispatching to a Particular Queue"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:888
#: ./docs/11.x/queues.md:977
#: ./docs/master/queues.md:888
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     */\n"
"    public function store(Request $request): RedirectResponse\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onQueue('processing');\n"
"\n"
"        return redirect('/podcasts');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:897
#: ./docs/9.x/queues.md:959
#: ./docs/10.x/queues.md:972
#: ./docs/11.x/queues.md:1058
#: ./docs/master/queues.md:972
msgid "You may chain the `onConnection` and `onQueue` methods together to specify the connection and the queue for a job:"
msgstr "也可以將 `onConnection` 與 `onQueue` 方法串聯在一起來指定 Job 的連線與佇列："

# CODE
#: ./docs/8.x/queues.md:899
#: ./docs/9.x/queues.md:961
#: ./docs/10.x/queues.md:974
#: ./docs/11.x/queues.md:1060
#: ./docs/master/queues.md:974
msgid ""
"ProcessPodcast::dispatch($podcast)\n"
"              ->onConnection('sqs')\n"
"              ->onQueue('processing');"
msgstr ""

# P
#: ./docs/8.x/queues.md:903
#: ./docs/9.x/queues.md:965
#: ./docs/10.x/queues.md:978
#: ./docs/11.x/queues.md:1064
#: ./docs/master/queues.md:978
msgid "Alternatively, you may specify the job's connection by calling the `onConnection` method within the job's constructor:"
msgstr "或者，也可以在 Job 的 Constructor 中呼叫 `onConnection` 來指定 Job 的連線："

# CODE
#: ./docs/8.x/queues.md:905
#: ./docs/9.x/queues.md:967
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onConnection('sqs');\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:917
#: ./docs/master/queues.md:917
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onQueue('processing');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/11.x/queues.md:929
#~ msgid "<a name=\"adding-jobs-to-the-chain\"></a>"
#~ msgstr ""

# H4
#: ./docs/11.x/queues.md:930
msgid "Adding Jobs to the Chain"
msgstr ""

# P
#: ./docs/8.x/queues.md:930
#: ./docs/9.x/queues.md:992
#: ./docs/10.x/queues.md:1003
#: ./docs/11.x/queues.md:1086
#: ./docs/master/queues.md:1003
#~ msgid "<a name=\"max-job-attempts-and-timeout\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:931
#: ./docs/9.x/queues.md:993
#: ./docs/10.x/queues.md:1004
#: ./docs/11.x/queues.md:1087
#: ./docs/master/queues.md:1004
msgid "Specifying Max Job Attempts / Timeout Values"
msgstr "指定最大嘗試次數與逾時"

# P
#: ./docs/11.x/queues.md:932
msgid "Occasionally, you may need to prepend or append a job to an existing job chain from within another job in that chain. You may accomplish this using the `prependToChain` and `appendToChain` methods:"
msgstr ""

# CODE
#: ./docs/9.x/queues.md:932
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:933
#: ./docs/9.x/queues.md:995
#: ./docs/10.x/queues.md:1006
#: ./docs/11.x/queues.md:1089
#: ./docs/master/queues.md:1006
#~ msgid "<a name=\"max-attempts\"></a>"
#~ msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:934
msgid ""
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    // ...\n"
"\n"
"    // Prepend to the current chain, run job immediately after current job...\n"
"    $this->prependToChain(new TranscribePodcast);\n"
"\n"
"    // Append to the current chain, run job at end of chain...\n"
"    $this->appendToChain(new TranscribePodcast);\n"
"}"
msgstr ""

# H4
#: ./docs/8.x/queues.md:934
#: ./docs/9.x/queues.md:996
#: ./docs/10.x/queues.md:1007
#: ./docs/11.x/queues.md:1090
#: ./docs/master/queues.md:1007
msgid "Max Attempts"
msgstr "最大嘗試次數"

# P
#: ./docs/8.x/queues.md:936
#: ./docs/9.x/queues.md:998
#: ./docs/10.x/queues.md:1009
#: ./docs/11.x/queues.md:1092
#: ./docs/master/queues.md:1009
msgid "If one of your queued jobs is encountering an error, you likely do not want it to keep retrying indefinitely. Therefore, Laravel provides various ways to specify how many times or for how long a job may be attempted."
msgstr "若有某個佇列 Job 遇到錯誤，我們通常不會想讓這個 Job 一直重試。因此，Laravel 提供了多種定義 Job 重試次數的方法。"

# P
#: ./docs/8.x/queues.md:938
msgid "One approach to specifying the maximum number of times a job may be attempted is via the `--tries` switch on the Artisan command line. This will apply to all jobs processed by the worker unless the job being processed specifies a more specific number of times it may be attempted:"
msgstr "其中一種指定 Job 最大嘗試次數的方法是在 Artisan 指令列中使用 `--tries` 開關。使用這種方式指定的嘗試次數會套用到所有該 Worker 處理的 Job，除非 Job 上有特別指定嘗試次數："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:940
#: ./docs/9.x/queues.md:1002
#: ./docs/10.x/queues.md:1013
#: ./docs/11.x/queues.md:1096
#: ./docs/master/queues.md:1013
msgid "php artisan queue:work --tries=3"
msgstr ""

# H4
#: ./docs/10.x/queues.md:941
#: ./docs/11.x/queues.md:1027
#: ./docs/master/queues.md:941
msgid "Dispatching to a Particular Connection"
msgstr ""

# P
#: ./docs/8.x/queues.md:942
msgid "If a job exceeds its maximum number of attempts, it will be considered a \"failed\" job. For more information on handling failed jobs, consult the [failed job documentation](#dealing-with-failed-jobs)."
msgstr "若 Job 嘗試了最大嘗試次數，則這個 Job 會被視為是「^[執行失敗](Failed)」。更多有關處理執行失敗 Job 的資訊，請參考 [執行失敗 Job 的說明文件](#dealing-with-failed-jobs)。"

# P
#: ./docs/8.x/queues.md:944
#: ./docs/9.x/queues.md:1008
#: ./docs/10.x/queues.md:1019
#: ./docs/11.x/queues.md:1102
#: ./docs/master/queues.md:1019
msgid "You may take a more granular approach by defining the maximum number of times a job may be attempted on the job class itself. If the maximum number of attempts is specified on the job, it will take precedence over the `--tries` value provided on the command line:"
msgstr "也可以用另一種更仔細的方法，就是在 Job 類別內定義這個 Job 的最大嘗試次數。若有在 Job 中指定最大嘗試次數，定義在 Job 類別內的次數會比指令列中 `--tries` 的值擁有更高的優先度："

# CODE
#: ./docs/10.x/queues.md:945
#: ./docs/11.x/queues.md:1031
#: ./docs/master/queues.md:945
msgid ""
"<?php\n"
"\n"
"namespace App\\Http\\Controllers;\n"
"\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Jobs\\ProcessPodcast;\n"
"use App\\Models\\Podcast;\n"
"use Illuminate\\Http\\RedirectResponse;\n"
"use Illuminate\\Http\\Request;\n"
"\n"
"class PodcastController extends Controller\n"
"{\n"
"    /**\n"
"     * Store a new podcast.\n"
"     */\n"
"    public function store(Request $request): RedirectResponse\n"
"    {\n"
"        $podcast = Podcast::create(/* ... */);\n"
"\n"
"        // Create podcast...\n"
"\n"
"        ProcessPodcast::dispatch($podcast)->onConnection('sqs');\n"
"\n"
"        return redirect('/podcasts');\n"
"    }\n"
"}"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:946
#: ./docs/9.x/queues.md:1010
#: ./docs/10.x/queues.md:1021
#: ./docs/11.x/queues.md:1104
#: ./docs/master/queues.md:1021
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of times the job may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 5;\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:960
#: ./docs/9.x/queues.md:1024
#: ./docs/10.x/queues.md:1045
#: ./docs/11.x/queues.md:1128
#: ./docs/master/queues.md:1045
#~ msgid "<a name=\"time-based-attempts\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:961
#: ./docs/9.x/queues.md:1025
#: ./docs/10.x/queues.md:1046
#: ./docs/11.x/queues.md:1129
#: ./docs/master/queues.md:1046
msgid "Time Based Attempts"
msgstr "基於時間的嘗試限制"

# P
#: ./docs/8.x/queues.md:963
#: ./docs/9.x/queues.md:1027
#: ./docs/10.x/queues.md:1048
#: ./docs/11.x/queues.md:1131
#: ./docs/master/queues.md:1048
msgid "As an alternative to defining how many times a job may be attempted before it fails, you may define a time at which the job should no longer be attempted. This allows a job to be attempted any number of times within a given time frame. To define the time at which a job should no longer be attempted, add a `retryUntil` method to your job class. This method should return a `DateTime` instance:"
msgstr "除了定義 Job 重試多少次要視為失敗以外，也可以限制 Job 嘗試執行的時間長度。這樣一來，在指定的時間範圍內，Job 就可以不斷重試。若要定義最長可重試時間，請在 Job 類別中定義一個 `retryUntil` 方法。該方法應回傳 `DateTime` 實體："

# CODE
#: ./docs/8.x/queues.md:965
#: ./docs/9.x/queues.md:1029
msgid ""
"/**\n"
" * Determine the time at which the job should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(10);\n"
"}"
msgstr ""

# H3
#: ./docs/11.x/queues.md:970
msgid "Customizing the Queue and Connection"
msgstr ""

# P
#: ./docs/8.x/queues.md:975
#: ./docs/9.x/queues.md:1040
#: ./docs/10.x/queues.md:1061
#: ./docs/11.x/queues.md:1144
#: ./docs/master/queues.md:1061
msgid "You may also define a `tries` property or `retryUntil` method on your [queued event listeners](/docs/{{version}}/events#queued-event-listeners)."
msgstr "也可以在[放入佇列的 Event Listener](/docs/{{version}}/events#queued-event-listeners) 中定義一個 `tries` 屬性或 `retryUntil` 方法。"

# P
#: ./docs/8.x/queues.md:977
#: ./docs/9.x/queues.md:1042
#: ./docs/10.x/queues.md:1063
#: ./docs/11.x/queues.md:1146
#: ./docs/master/queues.md:1063
#~ msgid "<a name=\"max-exceptions\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:978
#: ./docs/9.x/queues.md:1043
#: ./docs/10.x/queues.md:1064
#: ./docs/11.x/queues.md:1147
#: ./docs/master/queues.md:1064
msgid "Max Exceptions"
msgstr "最大 Exception 數"

# CODE
#: ./docs/10.x/queues.md:980
#: ./docs/master/queues.md:980
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Bus\\Queueable;\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
" use Illuminate\\Queue\\InteractsWithQueue;\n"
" use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onConnection('sqs');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:980
#: ./docs/9.x/queues.md:1045
#: ./docs/10.x/queues.md:1066
#: ./docs/11.x/queues.md:1149
#: ./docs/master/queues.md:1066
msgid "Sometimes you may wish to specify that a job may be attempted many times, but should fail if the retries are triggered by a given number of unhandled exceptions (as opposed to being released by the `release` method directly). To accomplish this, you may define a `maxExceptions` property on your job class:"
msgstr "有時候，我們可能會想讓 Job 可重試多次，但當出現指定數量的未處理 Exception 後，就視為執行失敗 (與直接使用 `release` 方法釋放 Job 不同)。若要指定未處理 Exception 數量，可在 Job 類別中定義一個 `maxExceptions` 屬性："

# CODE
#: ./docs/8.x/queues.md:982
#: ./docs/9.x/queues.md:1047
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of times the job may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 25;\n"
"\n"
"    /**\n"
"     * The maximum number of unhandled exceptions to allow before failing.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $maxExceptions = 3;\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        Redis::throttle('key')->allow(10)->every(60)->then(function () {\n"
"            // Lock obtained, process the podcast...\n"
"        }, function () {\n"
"            // Unable to obtain lock...\n"
"            return $this->release(10);\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:1000
#: ./docs/10.x/queues.md:1011
#: ./docs/11.x/queues.md:1094
#: ./docs/master/queues.md:1011
msgid "One approach to specifying the maximum number of times a job may be attempted is via the `--tries` switch on the Artisan command line. This will apply to all jobs processed by the worker unless the job being processed specifies the number of times it may be attempted:"
msgstr "其中一種指定 Job 最大嘗試次數的方法是在 Artisan 指令列中使用 `--tries` 開關。使用這種方式指定的嘗試次數會套用到所有該 Worker 處理的 Job，除非 Job 上有指定嘗試次數："

# CODE
#: ./docs/11.x/queues.md:1006
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Queue\\Queueable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Queueable;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onQueue('processing');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:1006
#: ./docs/10.x/queues.md:1017
#: ./docs/11.x/queues.md:1100
#: ./docs/master/queues.md:1017
msgid "If a job exceeds its maximum number of attempts, it will be considered a \"failed\" job. For more information on handling failed jobs, consult the [failed job documentation](#dealing-with-failed-jobs). If `--tries=0` is provided to the `queue:work` command, the job will be retried indefinitely."
msgstr "若 Job 嘗試了最大嘗試次數，則這個 Job 會被視為是「^[執行失敗](Failed)」。更多有關處理執行失敗 Job 的資訊，請參考 [執行失敗 Job 的說明文件](#dealing-with-failed-jobs)。若提供 `--tries=0` 給 `queue:work` 指令，則失敗的 Job 會被無限次數重試。"

# P
#: ./docs/8.x/queues.md:1020
#: ./docs/9.x/queues.md:1085
#: ./docs/10.x/queues.md:1104
#: ./docs/11.x/queues.md:1187
#: ./docs/master/queues.md:1104
msgid "In this example, the job is released for ten seconds if the application is unable to obtain a Redis lock and will continue to be retried up to 25 times. However, the job will fail if three unhandled exceptions are thrown by the job."
msgstr "在這個例子中，這個 Job 會在程式無法在 10 秒內取得 Redis Lock 時被釋放，而這個 Job 在此期間最多可嘗試 25 次。不過，若 Job 中有擲回未處理的 Exception，則會被視為是失敗的 Job。"

# P
#: ./docs/8.x/queues.md:1022
#: ./docs/9.x/queues.md:1087
#: ./docs/10.x/queues.md:1106
#: ./docs/11.x/queues.md:1189
#: ./docs/master/queues.md:1106
#~ msgid "<a name=\"timeout\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1023
#: ./docs/9.x/queues.md:1088
#: ./docs/10.x/queues.md:1107
#: ./docs/11.x/queues.md:1190
#: ./docs/master/queues.md:1107
msgid "Timeout"
msgstr "逾時"

# P
#: ./docs/8.x/queues.md:1025
#: ./docs/9.x/queues.md:1091
msgid "The `pcntl` PHP extension must be installed in order to specify job timeouts."
msgstr "必須安裝 `pcntl` PHP 擴充程式才可指定 Job 的逾時。"

# P
#: ./docs/8.x/queues.md:1027
msgid "Often, you know roughly how long you expect your queued jobs to take. For this reason, Laravel allows you to specify a \"timeout\" value. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration)."
msgstr "通常來說，我們知道某個佇列任務大約需要花多少時間執行。因此，在 Laravel 中，我們可以指定一個「逾時」值。若 Job 執行超過逾時值所指定的秒數後，負責處理該 Job 的 Worker 就會以錯誤終止執行。一般來說，Worker 會自動由 [Server 上設定的 Process Manager](#supervisor-configuration) 重新開啟。"

# P
#: ./docs/8.x/queues.md:1029
#: ./docs/9.x/queues.md:1095
#: ./docs/10.x/queues.md:1111
#: ./docs/11.x/queues.md:1194
#: ./docs/master/queues.md:1111
msgid "The maximum number of seconds that jobs can run may be specified using the `--timeout` switch on the Artisan command line:"
msgstr "可在 Artisan 指令列上使用 `--timeout` 開關來指定 Job 能執行的最大秒數："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1031
#: ./docs/9.x/queues.md:1097
#: ./docs/10.x/queues.md:1113
#: ./docs/11.x/queues.md:1196
#: ./docs/master/queues.md:1113
msgid "php artisan queue:work --timeout=30"
msgstr ""

# P
#: ./docs/8.x/queues.md:1033
#: ./docs/9.x/queues.md:1101
#: ./docs/10.x/queues.md:1117
#: ./docs/11.x/queues.md:1200
#: ./docs/master/queues.md:1117
msgid "If the job exceeds its maximum attempts by continually timing out, it will be marked as failed."
msgstr "若 Job 不斷執行逾時超過其最大重試次數，則該 Job 會被標記為執行失敗。"

# P
#: ./docs/10.x/queues.md:1035
#: ./docs/11.x/queues.md:1118
#: ./docs/master/queues.md:1035
msgid "If you need dynamic control over a particular job's maximum attempts, you may define a `tries` method on the job:"
msgstr ""

# P
#: ./docs/8.x/queues.md:1035
#: ./docs/9.x/queues.md:1103
#: ./docs/10.x/queues.md:1119
#: ./docs/11.x/queues.md:1202
#: ./docs/master/queues.md:1119
msgid "You may also define the maximum number of seconds a job should be allowed to run on the job class itself. If the timeout is specified on the job, it will take precedence over any timeout specified on the command line:"
msgstr "也可以在 Job 類別中定義該 Job 能執行的最大秒數。若有在 Job 上指定逾時，則在 Job 類別上定義的逾時比在指令列上指定的數字擁有更高的優先度："

# CODE
#: ./docs/10.x/queues.md:1037
#: ./docs/11.x/queues.md:1120
#: ./docs/master/queues.md:1037
msgid ""
"/**\n"
" * Determine number of times the job may be attempted.\n"
" */\n"
"public function tries(): int\n"
"{\n"
"    return 5;\n"
"}"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:1037
#: ./docs/9.x/queues.md:1105
#: ./docs/10.x/queues.md:1121
#: ./docs/11.x/queues.md:1204
#: ./docs/master/queues.md:1121
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of seconds the job can run before timing out.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $timeout = 120;\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1050
#: ./docs/11.x/queues.md:1133
#: ./docs/master/queues.md:1050
msgid ""
"use DateTime;\n"
"\n"
"/**\n"
" * Determine the time at which the job should timeout.\n"
" */\n"
"public function retryUntil(): DateTime\n"
"{\n"
"    return now()->addMinutes(10);\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1051
#: ./docs/9.x/queues.md:1119
#: ./docs/10.x/queues.md:1135
#: ./docs/11.x/queues.md:1218
#: ./docs/master/queues.md:1135
msgid "Sometimes, IO blocking processes such as sockets or outgoing HTTP connections may not respect your specified timeout. Therefore, when using these features, you should always attempt to specify a timeout using their APIs as well. For example, when using Guzzle, you should always specify a connection and request timeout value."
msgstr "有時候，如 Socket 或連外 HTTP 連線等的 IO Blocking Process 可能不適用所指定的逾時設定。因此，若有使用到這些功能，也請在這些功能的 API 上指定逾時。舉例來說，若使用 Guzzle，則可像這樣指定連線與 Request 的逾時值："

# P
#: ./docs/8.x/queues.md:1053
#: ./docs/9.x/queues.md:1121
#: ./docs/10.x/queues.md:1140
#: ./docs/11.x/queues.md:1223
#: ./docs/master/queues.md:1140
#~ msgid "<a name=\"failing-on-timeout\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1054
#: ./docs/9.x/queues.md:1122
msgid "Failing On Timeout"
msgstr "逾時後視為失敗"

# P
#: ./docs/8.x/queues.md:1056
#: ./docs/9.x/queues.md:1124
#: ./docs/10.x/queues.md:1143
#: ./docs/11.x/queues.md:1226
#: ./docs/master/queues.md:1143
msgid "If you would like to indicate that a job should be marked as [failed](#dealing-with-failed-jobs) on timeout, you may define the `$failOnTimeout` property on the job class:"
msgstr "若想讓 Job 在逾時後被標記為[執行失敗](#dealing-with-failed-jobs)，可在 Job 類別上定義 `$failOnTimeout` 屬性："

# CODE: php
#: ./docs/8.x/queues.md:1058
#: ./docs/9.x/queues.md:1126
#: ./docs/10.x/queues.md:1145
#: ./docs/11.x/queues.md:1228
#: ./docs/master/queues.md:1145
msgid ""
"/**\n"
" * Indicate if the job should be marked as failed on timeout.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $failOnTimeout = true;"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:1066
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
" use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
" use Illuminate\\Foundation\\Queue\\Queueable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Queueable;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        $this->onConnection('sqs');\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1067
#: ./docs/9.x/queues.md:1135
#: ./docs/10.x/queues.md:1154
#: ./docs/11.x/queues.md:1237
#: ./docs/master/queues.md:1154
#~ msgid "<a name=\"error-handling\"></a>"
#~ msgstr ""

# CODE
#: ./docs/10.x/queues.md:1068
#: ./docs/11.x/queues.md:1151
#: ./docs/master/queues.md:1068
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use Illuminate\\Support\\Facades\\Redis;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The number of times the job may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 25;\n"
"\n"
"    /**\n"
"     * The maximum number of unhandled exceptions to allow before failing.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $maxExceptions = 3;\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(): void\n"
"    {\n"
"        Redis::throttle('key')->allow(10)->every(60)->then(function () {\n"
"            // Lock obtained, process the podcast...\n"
"        }, function () {\n"
"            // Unable to obtain lock...\n"
"            return $this->release(10);\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# H3
#: ./docs/8.x/queues.md:1068
#: ./docs/9.x/queues.md:1136
#: ./docs/10.x/queues.md:1155
#: ./docs/11.x/queues.md:1238
#: ./docs/master/queues.md:1155
msgid "Error Handling"
msgstr "錯誤處理"

# P
#: ./docs/8.x/queues.md:1070
#: ./docs/9.x/queues.md:1138
#: ./docs/10.x/queues.md:1157
#: ./docs/11.x/queues.md:1240
#: ./docs/master/queues.md:1157
msgid "If an exception is thrown while the job is being processed, the job will automatically be released back onto the queue so it may be attempted again. The job will continue to be released until it has been attempted the maximum number of times allowed by your application. The maximum number of attempts is defined by the `--tries` switch used on the `queue:work` Artisan command. Alternatively, the maximum number of attempts may be defined on the job class itself. More information on running the queue worker [can be found below](#running-the-queue-worker)."
msgstr "若在處理 Job 時有擲回 Exception，則這個 Job 會被自動釋放回佇列中，好讓這個 Job 能被重新嘗試。被釋放會佇列的 Job 會繼續被重試，直到重試次數達到專案上所設定的最大次數。最大重試次數可使用 `queue:work` Artisan 指令上的 `--tries` 開關來定義。或者，也可以在 Job 類別上定義最大重試次數。更多有關如何執行 Queue Worker 的資訊[可在本文後方找到](#running-the-queue-worker)。"

# P
#: ./docs/8.x/queues.md:1072
#: ./docs/9.x/queues.md:1140
#: ./docs/10.x/queues.md:1159
#: ./docs/11.x/queues.md:1242
#: ./docs/master/queues.md:1159
#~ msgid "<a name=\"manually-releasing-a-job\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1073
#: ./docs/9.x/queues.md:1141
msgid "Manually Releasing A Job"
msgstr "手動釋放 Job"

# P
#: ./docs/8.x/queues.md:1075
#: ./docs/9.x/queues.md:1143
#: ./docs/10.x/queues.md:1162
#: ./docs/11.x/queues.md:1245
#: ./docs/master/queues.md:1162
msgid "Sometimes you may wish to manually release a job back onto the queue so that it can be attempted again at a later time. You may accomplish this by calling the `release` method:"
msgstr "有的時候，我們可能會想手動將 Job 釋放會佇列中，好讓這個 Job 能在稍後重試。若要手動釋放 Job，可以呼叫 `release` 方法："

# CODE
#: ./docs/8.x/queues.md:1077
#: ./docs/9.x/queues.md:1145
msgid ""
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    // ...\n"
"\n"
"    $this->release();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1089
#: ./docs/9.x/queues.md:1157
msgid "By default, the `release` method will release the job back onto the queue for immediate processing. However, by passing an integer to the `release` method you may instruct the queue to not make the job available for processing until a given number of seconds has elapsed:"
msgstr "預設情況下，`release` 方法會將 Job 釋放會佇列中並立即處理。不過，若傳入一個整數給 `release` 方法，就可以指定讓佇列等待給定秒數後才開始處理該 Job："

# CODE
#: ./docs/8.x/queues.md:1091
#: ./docs/9.x/queues.md:1159
msgid "$this->release(10);"
msgstr ""

# P
#: ./docs/8.x/queues.md:1093
#: ./docs/9.x/queues.md:1161
#: ./docs/10.x/queues.md:1180
#: ./docs/11.x/queues.md:1263
#: ./docs/master/queues.md:1180
#~ msgid "<a name=\"manually-failing-a-job\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/queues.md:1093
#: ./docs/10.x/queues.md:1109
#: ./docs/11.x/queues.md:1192
#: ./docs/master/queues.md:1109
msgid "Often, you know roughly how long you expect your queued jobs to take. For this reason, Laravel allows you to specify a \"timeout\" value. By default, the timeout value is 60 seconds. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration)."
msgstr "通常來說，我們知道某個佇列任務大約需要花多少時間執行。因此，在 Laravel 中，我們可以指定一個「逾時」值。預設情況下，逾時值為 60 秒。若 Job 執行超過逾時值所指定的秒數後，負責處理該 Job 的 Worker 就會以錯誤終止執行。一般來說，Worker 會自動由 [Server 上設定的 Process Manager](#supervisor-configuration) 重新開啟。"

# H4
#: ./docs/8.x/queues.md:1094
#: ./docs/9.x/queues.md:1162
msgid "Manually Failing A Job"
msgstr "手動讓 Job 失敗"

# P
#: ./docs/8.x/queues.md:1096
#: ./docs/9.x/queues.md:1164
#: ./docs/10.x/queues.md:1183
#: ./docs/11.x/queues.md:1266
#: ./docs/master/queues.md:1183
msgid "Occasionally you may need to manually mark a job as \"failed\". To do so, you may call the `fail` method:"
msgstr "有時候，我們可能需要手動將 Job 標記為「失敗」。若要手動將 Job 標記為失敗，可呼叫 `fail` 方法："

# CODE
#: ./docs/8.x/queues.md:1098
#: ./docs/9.x/queues.md:1166
msgid ""
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    // ...\n"
"\n"
"    $this->fail();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1110
msgid "If you would like to mark your job as failed because of an exception that you have caught, you may pass the exception to the `fail` method:"
msgstr "若要在 Catch 到 Exception 時將 Job 標記為失敗，可將這個 Exception 傳給 `fail` 方法："

# CODE
#: ./docs/8.x/queues.md:1112
msgid "$this->fail($exception);"
msgstr ""

# P
#: ./docs/8.x/queues.md:1114
#: ./docs/9.x/queues.md:1185
#: ./docs/10.x/queues.md:1202
#: ./docs/11.x/queues.md:1285
#: ./docs/master/queues.md:1202
msgid "For more information on failed jobs, check out the [documentation on dealing with job failures](#dealing-with-failed-jobs)."
msgstr "有關失敗 Job 的更多資訊，請參考[有關處理失敗 Job 的說明文件](#dealing-with-failed-jobs)。"

# P
#: ./docs/8.x/queues.md:1116
#: ./docs/9.x/queues.md:1187
#: ./docs/10.x/queues.md:1204
#: ./docs/11.x/queues.md:1287
#: ./docs/master/queues.md:1204
#~ msgid "<a name=\"job-batching\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1117
#: ./docs/9.x/queues.md:1188
#: ./docs/10.x/queues.md:1205
#: ./docs/11.x/queues.md:1288
#: ./docs/master/queues.md:1205
msgid "Job Batching"
msgstr "批次 Job"

# P
#: ./docs/8.x/queues.md:1119
#: ./docs/9.x/queues.md:1190
msgid "Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table to contain meta information about your job batches, such as their completion percentage. This migration may be generated using the `queue:batches-table` Artisan command:"
msgstr "使用 Laravel 的批次 Job 功能，就可以輕鬆地批次執行多個 Job，並在批次 Job 執行完成後進行一些動作。在開始使用批次 Job 之前，我們需要先建立一個資料庫 Migration，以建立用來保存有關批次 Job ^[詮釋資訊](Meta Information)的資料表，如批次 Job 的完成度等。可以使用 `queue:batches-table` Artisan 指令來建立這個 Migration："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1121
#: ./docs/9.x/queues.md:1192
#: ./docs/10.x/queues.md:1209
msgid ""
"php artisan queue:batches-table\n"
"\n"
"php artisan migrate"
msgstr ""

# P
#: ./docs/8.x/queues.md:1125
#: ./docs/9.x/queues.md:1198
#: ./docs/10.x/queues.md:1215
#: ./docs/11.x/queues.md:1298
#: ./docs/master/queues.md:1215
#~ msgid "<a name=\"defining-batchable-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1126
#: ./docs/9.x/queues.md:1199
#: ./docs/10.x/queues.md:1216
#: ./docs/11.x/queues.md:1299
#: ./docs/master/queues.md:1216
msgid "Defining Batchable Jobs"
msgstr "定義可批次處理的 Job"

# P
#: ./docs/8.x/queues.md:1128
#: ./docs/9.x/queues.md:1201
#: ./docs/10.x/queues.md:1218
#: ./docs/11.x/queues.md:1301
#: ./docs/master/queues.md:1218
msgid "To define a batchable job, you should [create a queueable job](#creating-jobs) as normal; however, you should add the `Illuminate\\Bus\\Batchable` trait to the job class. This trait provides access to a `batch` method which may be used to retrieve the current batch that the job is executing within:"
msgstr "若要定義可批次處理的 Job，請先像平常一樣[建立可放入佇列的 Job](#creating-jobs)。不過，我們還需要在這個 Job 類別中加上 `Illuminate\\Bus\\Batchable` Trait。這個 Trait 提供了一個 `batch` 方法，可使用該方法來取得該 Job 所在的批次："

# CODE
#: ./docs/8.x/queues.md:1130
#: ./docs/9.x/queues.md:1203
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use Illuminate\\Bus\\Batchable;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ImportCsv implements ShouldQueue\n"
"{\n"
"    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function handle()\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            // Determine if the batch has been cancelled...\n"
"\n"
"            return;\n"
"        }\n"
"\n"
"        // Import a portion of the CSV file...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:1138
#: ./docs/11.x/queues.md:1221
#: ./docs/master/queues.md:1138
msgid "The `pcntl` PHP extension must be installed in order to specify job timeouts. In addition, a job's \"timeout\" value should always be less than its [\"retry after\"](#job-expiration) value. Otherwise, the job may be re-attempted before it has actually finished executing or timed out."
msgstr ""

# H4
#: ./docs/10.x/queues.md:1141
#: ./docs/11.x/queues.md:1224
#: ./docs/master/queues.md:1141
msgid "Failing on Timeout"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1160
#: ./docs/11.x/queues.md:1243
#: ./docs/master/queues.md:1160
msgid "Manually Releasing a Job"
msgstr ""

# P
#: ./docs/8.x/queues.md:1162
#: ./docs/9.x/queues.md:1235
#: ./docs/10.x/queues.md:1250
#: ./docs/11.x/queues.md:1330
#: ./docs/master/queues.md:1250
#~ msgid "<a name=\"dispatching-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1163
#: ./docs/9.x/queues.md:1236
#: ./docs/10.x/queues.md:1251
#: ./docs/11.x/queues.md:1331
#: ./docs/master/queues.md:1251
msgid "Dispatching Batches"
msgstr "分派批次"

# CODE
#: ./docs/10.x/queues.md:1164
#: ./docs/11.x/queues.md:1247
#: ./docs/master/queues.md:1164
msgid ""
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    // ...\n"
"\n"
"    $this->release();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1165
#: ./docs/9.x/queues.md:1238
#: ./docs/10.x/queues.md:1253
#: ./docs/11.x/queues.md:1333
#: ./docs/master/queues.md:1253
msgid "To dispatch a batch of jobs, you should use the `batch` method of the `Bus` facade. Of course, batching is primarily useful when combined with completion callbacks. So, you may use the `then`, `catch`, and `finally` methods to define completion callbacks for the batch. Each of these callbacks will receive an `Illuminate\\Bus\\Batch` instance when they are invoked. In this example, we will imagine we are queueing a batch of jobs that each process a given number of rows from a CSV file:"
msgstr "若要分派一批次的 Job，可使用 `Bus` Facade 的 `batch` 方法。當然，批次功能與完成回呼一起使用時是最有用。因此，可以使用 `then`, `catch` 與 `finally` 方法來為該批次定義完成回呼。這些回呼都會在被叫用時收到 `Illuminate\\Bus\\Batch` 實體。在這個範例中，我們先假設我們正在處理一批次的任務，用來在 CSV 檔中處理給定數量的行："

# CODE
#: ./docs/8.x/queues.md:1167
#: ./docs/9.x/queues.md:1240
msgid ""
"use App\\Jobs\\ImportCsv;\n"
"use Illuminate\\Bus\\Batch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Throwable;\n"
"\n"
"$batch = Bus::batch([\n"
"    new ImportCsv(1, 100),\n"
"    new ImportCsv(101, 200),\n"
"    new ImportCsv(201, 300),\n"
"    new ImportCsv(301, 400),\n"
"    new ImportCsv(401, 500),\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->catch(function (Batch $batch, Throwable $e) {\n"
"    // First batch job failure detected...\n"
"})->finally(function (Batch $batch) {\n"
"    // The batch has finished executing...\n"
"})->dispatch();\n"
"\n"
"return $batch->id;"
msgstr ""

# P
#: ./docs/10.x/queues.md:1174
#: ./docs/11.x/queues.md:1257
#: ./docs/master/queues.md:1174
msgid "By default, the `release` method will release the job back onto the queue for immediate processing. However, you may instruct the queue to not make the job available for processing until a given number of seconds has elapsed by passing an integer or date instance to the `release` method:"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1176
#: ./docs/11.x/queues.md:1259
#: ./docs/master/queues.md:1176
msgid ""
"$this->release(10);\n"
"\n"
"$this->release(now()->addSeconds(10));"
msgstr ""

# P
#: ./docs/9.x/queues.md:1178
#: ./docs/10.x/queues.md:1195
#: ./docs/11.x/queues.md:1278
#: ./docs/master/queues.md:1195
msgid "If you would like to mark your job as failed because of an exception that you have caught, you may pass the exception to the `fail` method. Or, for convenience, you may pass a string error message which will be converted to an exception for you:"
msgstr "若想以所 Catch 到的 Exception 來將 Job 標記為失敗，可將該 Exception 傳入 `fail` 方法。或者，為了讓開發起來更方便，也可以傳入一個錯誤訊息字串，而該字串會自動被轉為 Exception："

# CODE
#: ./docs/9.x/queues.md:1180
#: ./docs/10.x/queues.md:1197
#: ./docs/11.x/queues.md:1280
#: ./docs/master/queues.md:1197
msgid ""
"$this->fail($exception);\n"
"\n"
"$this->fail('Something went wrong.');"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1181
#: ./docs/11.x/queues.md:1264
#: ./docs/master/queues.md:1181
msgid "Manually Failing a Job"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1185
#: ./docs/11.x/queues.md:1268
#: ./docs/master/queues.md:1185
msgid ""
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    // ...\n"
"\n"
"    $this->fail();\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1188
#: ./docs/9.x/queues.md:1261
#: ./docs/10.x/queues.md:1280
#: ./docs/11.x/queues.md:1360
#: ./docs/master/queues.md:1280
msgid "The batch's ID, which may be accessed via the `$batch->id` property, may be used to [query the Laravel command bus](#inspecting-batches) for information about the batch after it has been dispatched."
msgstr "可使用 `$batch->id` 屬性來取得該批次的 ID。在該批次被分派後，可使用這個 ID 來[向 Laravel 的 Command Bus 查詢](#inspecting-batches)有關該批次的資訊。"

# P
#: ./docs/8.x/queues.md:1190
#: ./docs/9.x/queues.md:1264
#: ./docs/10.x/queues.md:1283
msgid "Since batch callbacks are serialized and executed at a later time by the Laravel queue, you should not use the `$this` variable within the callbacks."
msgstr "由於批次的回呼會被序列化並在稍後由 Laravel 的佇列執行，因此請不要在回呼中使用 `$this` 變數。"

# P
#: ./docs/8.x/queues.md:1192
#: ./docs/9.x/queues.md:1266
#: ./docs/10.x/queues.md:1285
#: ./docs/11.x/queues.md:1365
#: ./docs/master/queues.md:1285
#~ msgid "<a name=\"naming-batches\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1193
#: ./docs/9.x/queues.md:1267
#: ./docs/10.x/queues.md:1286
#: ./docs/11.x/queues.md:1366
#: ./docs/master/queues.md:1286
msgid "Naming Batches"
msgstr "為批次命名"

# P
#: ./docs/8.x/queues.md:1195
#: ./docs/9.x/queues.md:1269
#: ./docs/10.x/queues.md:1288
#: ./docs/11.x/queues.md:1368
#: ./docs/master/queues.md:1288
msgid "Some tools such as Laravel Horizon and Laravel Telescope may provide more user-friendly debug information for batches if batches are named. To assign an arbitrary name to a batch, you may call the `name` method while defining the batch:"
msgstr "若為批次命名，則一些像是 Laravel Horizon 與 Laravel Telescope 之類的工具就可為該批次提供對使用者更友善的偵錯資訊。若要為批次指定任意名稱，可在定義批次時呼叫 `name` 方法："

# CODE
#: ./docs/8.x/queues.md:1197
#: ./docs/9.x/queues.md:1271
#: ./docs/10.x/queues.md:1290
#: ./docs/11.x/queues.md:1370
#: ./docs/master/queues.md:1290
msgid ""
"$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->name('Import CSV')->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1203
#: ./docs/9.x/queues.md:1277
#: ./docs/10.x/queues.md:1296
#: ./docs/11.x/queues.md:1376
#: ./docs/master/queues.md:1296
#~ msgid "<a name=\"batch-connection-queue\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1204
#: ./docs/9.x/queues.md:1278
msgid "Batch Connection & Queue"
msgstr "批次的連線與佇列"

# P
#: ./docs/8.x/queues.md:1206
#: ./docs/9.x/queues.md:1280
#: ./docs/10.x/queues.md:1299
#: ./docs/11.x/queues.md:1379
#: ./docs/master/queues.md:1299
msgid "If you would like to specify the connection and queue that should be used for the batched jobs, you may use the `onConnection` and `onQueue` methods. All batched jobs must execute within the same connection and queue:"
msgstr "若想指定批次 Job 的連線與佇列，可使用 `onConnection` 與 `onQueue` 方法。所有的批次 Job 都必須要相同的連線與佇列中執行："

# P
#: ./docs/10.x/queues.md:1207
msgid "Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table which will contain meta information about your job batches, such as their completion percentage. This migration may be generated using the `queue:batches-table` Artisan command:"
msgstr ""

# CODE
#: ./docs/8.x/queues.md:1208
#: ./docs/9.x/queues.md:1282
#: ./docs/10.x/queues.md:1301
#: ./docs/11.x/queues.md:1381
#: ./docs/master/queues.md:1301
msgid ""
"$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->onConnection('redis')->onQueue('imports')->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1214
#: ./docs/9.x/queues.md:1288
#~ msgid "<a name=\"chains-within-batches\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1215
#: ./docs/9.x/queues.md:1289
msgid "Chains Within Batches"
msgstr "在批次中串聯"

# P
#: ./docs/8.x/queues.md:1217
#: ./docs/9.x/queues.md:1291
#: ./docs/10.x/queues.md:1310
#: ./docs/11.x/queues.md:1390
#: ./docs/master/queues.md:1310
msgid "You may define a set of [chained jobs](#job-chaining) within a batch by placing the chained jobs within an array. For example, we may execute two job chains in parallel and execute a callback when both job chains have finished processing:"
msgstr "只要將串聯的 Job 放在陣列中，就可以在批次中定義一組[串聯的 Job](#job-chaining)。舉例來說，我們可以平行執行兩個 Job 串聯，並在這兩個 Job 串聯都處理完畢後執行回呼："

# CODE
#: ./docs/8.x/queues.md:1219
#: ./docs/9.x/queues.md:1293
#: ./docs/10.x/queues.md:1312
#: ./docs/11.x/queues.md:1392
#: ./docs/master/queues.md:1312
msgid ""
"use App\\Jobs\\ReleasePodcast;\n"
"use App\\Jobs\\SendPodcastReleaseNotification;\n"
"use Illuminate\\Bus\\Batch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::batch([\n"
"    [\n"
"        new ReleasePodcast(1),\n"
"        new SendPodcastReleaseNotification(1),\n"
"    ],\n"
"    [\n"
"        new ReleasePodcast(2),\n"
"        new SendPodcastReleaseNotification(2),\n"
"    ],\n"
"])->then(function (Batch $batch) {\n"
"    // ...\n"
"})->dispatch();"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1220
#: ./docs/master/queues.md:1220
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use Illuminate\\Bus\\Batchable;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Bus\\Dispatchable;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"\n"
"class ImportCsv implements ShouldQueue\n"
"{\n"
"    use Batchable, Dispatchable, InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(): void\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            // Determine if the batch has been cancelled...\n"
"\n"
"            return;\n"
"        }\n"
"\n"
"        // Import a portion of the CSV file...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1237
#: ./docs/9.x/queues.md:1311
#: ./docs/10.x/queues.md:1349
#: ./docs/11.x/queues.md:1429
#: ./docs/master/queues.md:1349
#~ msgid "<a name=\"adding-jobs-to-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1238
#: ./docs/9.x/queues.md:1312
msgid "Adding Jobs To Batches"
msgstr "將 Job 加入批次"

# P
#: ./docs/8.x/queues.md:1240
#: ./docs/9.x/queues.md:1314
#: ./docs/10.x/queues.md:1352
#: ./docs/11.x/queues.md:1432
#: ./docs/master/queues.md:1352
msgid "Sometimes it may be useful to add additional jobs to a batch from within a batched job. This pattern can be useful when you need to batch thousands of jobs which may take too long to dispatch during a web request. So, instead, you may wish to dispatch an initial batch of \"loader\" jobs that hydrate the batch with even more jobs:"
msgstr "有時候，若能在批次 Job 中新增其他額外的 Job 會很實用。特別是當我們要在一個 Web Request 中批次處理數千筆 Job 時，會讓 Job 的分派過程變得很耗時。因此，比起直接分派數千筆 Job，我們可以先分派一個初始化的批次，用來作為 Job 的「載入程式」，然後讓這個載入程式再向批次內填入更多的 Job："

# CODE
#: ./docs/8.x/queues.md:1242
#: ./docs/9.x/queues.md:1316
#: ./docs/10.x/queues.md:1354
#: ./docs/11.x/queues.md:1434
#: ./docs/master/queues.md:1354
msgid ""
"$batch = Bus::batch([\n"
"    new LoadImportBatch,\n"
"    new LoadImportBatch,\n"
"    new LoadImportBatch,\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->name('Import Contacts')->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1250
#: ./docs/9.x/queues.md:1324
#: ./docs/10.x/queues.md:1362
#: ./docs/11.x/queues.md:1442
#: ./docs/master/queues.md:1362
msgid "In this example, we will use the `LoadImportBatch` job to hydrate the batch with additional jobs. To accomplish this, we may use the `add` method on the batch instance that may be accessed via the job's `batch` method:"
msgstr "在這個例子中，我們可以使用 `LoadImportBatch` Job 來填入其他額外的 Job。若要填入其他 Job，我們可以使用批次實體上的 `add` 方法。批次實體可使用 Job 的 `batch` 方法來取得："

# CODE
#: ./docs/8.x/queues.md:1252
#: ./docs/9.x/queues.md:1326
msgid ""
"use App\\Jobs\\ImportContacts;\n"
"use Illuminate\\Support\\Collection;\n"
"\n"
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"\n"
"    $this->batch()->add(Collection::times(1000, function () {\n"
"        return new ImportContacts;\n"
"    }));\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1255
#: ./docs/11.x/queues.md:1335
#: ./docs/master/queues.md:1255
msgid ""
"use App\\Jobs\\ImportCsv;\n"
"use Illuminate\\Bus\\Batch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Throwable;\n"
"\n"
"$batch = Bus::batch([\n"
"    new ImportCsv(1, 100),\n"
"    new ImportCsv(101, 200),\n"
"    new ImportCsv(201, 300),\n"
"    new ImportCsv(301, 400),\n"
"    new ImportCsv(401, 500),\n"
"])->before(function (Batch $batch) {\n"
"    // The batch has been created but no jobs have been added...\n"
"})->progress(function (Batch $batch) {\n"
"    // A single job has completed successfully...\n"
"})->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->catch(function (Batch $batch, Throwable $e) {\n"
"    // First batch job failure detected...\n"
"})->finally(function (Batch $batch) {\n"
"    // The batch has finished executing...\n"
"})->dispatch();\n"
"\n"
"return $batch->id;"
msgstr ""

# P
#: ./docs/8.x/queues.md:1271
#: ./docs/9.x/queues.md:1346
#: ./docs/10.x/queues.md:1382
#: ./docs/11.x/queues.md:1462
#: ./docs/master/queues.md:1382
msgid "You may only add jobs to a batch from within a job that belongs to the same batch."
msgstr "我們只能向目前 Job 正在執行的批次新增 Job。"

# P
#: ./docs/8.x/queues.md:1273
#: ./docs/9.x/queues.md:1348
#: ./docs/10.x/queues.md:1384
#: ./docs/11.x/queues.md:1464
#: ./docs/master/queues.md:1384
#~ msgid "<a name=\"inspecting-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1274
#: ./docs/9.x/queues.md:1349
#: ./docs/10.x/queues.md:1385
#: ./docs/11.x/queues.md:1465
#: ./docs/master/queues.md:1385
msgid "Inspecting Batches"
msgstr "檢查批次"

# P
#: ./docs/8.x/queues.md:1276
#: ./docs/9.x/queues.md:1351
#: ./docs/10.x/queues.md:1387
#: ./docs/11.x/queues.md:1467
#: ./docs/master/queues.md:1387
msgid "The `Illuminate\\Bus\\Batch` instance that is provided to batch completion callbacks has a variety of properties and methods to assist you in interacting with and inspecting a given batch of jobs:"
msgstr "提供給批次處理完成回呼的 `Illuminate\\Bus\\Batch` 實體有許多的屬性與方法，可以讓我們處理與取得給定 Job 批次的資訊："

# CODE
#: ./docs/8.x/queues.md:1278
#: ./docs/9.x/queues.md:1353
#: ./docs/10.x/queues.md:1389
#: ./docs/11.x/queues.md:1469
#: ./docs/master/queues.md:1389
msgid ""
"// The UUID of the batch...\n"
"$batch->id;\n"
"\n"
"// The name of the batch (if applicable)...\n"
"$batch->name;\n"
"\n"
"// The number of jobs assigned to the batch...\n"
"$batch->totalJobs;\n"
"\n"
"// The number of jobs that have not been processed by the queue...\n"
"$batch->pendingJobs;\n"
"\n"
"// The number of jobs that have failed...\n"
"$batch->failedJobs;\n"
"\n"
"// The number of jobs that have been processed thus far...\n"
"$batch->processedJobs();\n"
"\n"
"// The completion percentage of the batch (0-100)...\n"
"$batch->progress();\n"
"\n"
"// Indicates if the batch has finished executing...\n"
"$batch->finished();\n"
"\n"
"// Cancel the execution of the batch...\n"
"$batch->cancel();\n"
"\n"
"// Indicates if the batch has been cancelled...\n"
"$batch->cancelled();"
msgstr ""

# P
#: ./docs/11.x/queues.md:1290
#: ./docs/master/queues.md:1207
msgid "Laravel's job batching feature allows you to easily execute a batch of jobs and then perform some action when the batch of jobs has completed executing. Before getting started, you should create a database migration to build a table which will contain meta information about your job batches, such as their completion percentage. This migration may be generated using the `make:queue-batches-table` Artisan command:"
msgstr ""

# CODE: shell
#: ./docs/11.x/queues.md:1292
#: ./docs/master/queues.md:1209
msgid ""
"php artisan make:queue-batches-table\n"
"\n"
"php artisan migrate"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1297
#: ./docs/11.x/queues.md:1377
#: ./docs/master/queues.md:1297
msgid "Batch Connection and Queue"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:1303
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use Illuminate\\Bus\\Batchable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Queue\\Queueable;\n"
"\n"
"class ImportCsv implements ShouldQueue\n"
"{\n"
"    use Batchable, Queueable;\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(): void\n"
"    {\n"
"        if ($this->batch()->cancelled()) {\n"
"            // Determine if the batch has been cancelled...\n"
"\n"
"            return;\n"
"        }\n"
"\n"
"        // Import a portion of the CSV file...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:1307
#: ./docs/11.x/queues.md:1387
#: ./docs/master/queues.md:1307
#~ msgid "<a name=\"chains-and-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/10.x/queues.md:1308
#: ./docs/11.x/queues.md:1388
#: ./docs/master/queues.md:1308
msgid "Chains and Batches"
msgstr ""

# P
#: ./docs/8.x/queues.md:1308
#: ./docs/9.x/queues.md:1383
#: ./docs/10.x/queues.md:1419
#: ./docs/11.x/queues.md:1499
#: ./docs/master/queues.md:1419
#~ msgid "<a name=\"returning-batches-from-routes\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1309
#: ./docs/9.x/queues.md:1384
#: ./docs/10.x/queues.md:1420
#: ./docs/11.x/queues.md:1500
#: ./docs/master/queues.md:1420
msgid "Returning Batches From Routes"
msgstr "從 Route 上回傳批次"

# P
#: ./docs/8.x/queues.md:1311
#: ./docs/9.x/queues.md:1386
#: ./docs/10.x/queues.md:1422
#: ./docs/11.x/queues.md:1502
#: ./docs/master/queues.md:1422
msgid "All `Illuminate\\Bus\\Batch` instances are JSON serializable, meaning you can return them directly from one of your application's routes to retrieve a JSON payload containing information about the batch, including its completion progress. This makes it convenient to display information about the batch's completion progress in your application's UI."
msgstr "所有的 `Illuminate\\Bus\\Batch` 實體都可被序列化為 JSON，因此我們可以直接在專案的 Route 中回傳批次實體來取得有關該批次資訊的 JSON Payload，其中也包含該批次的完成度。如此一來，我們就能方便地在專案的 UI 上顯示該批次完成度的資訊。"

# P
#: ./docs/8.x/queues.md:1313
#: ./docs/9.x/queues.md:1388
#: ./docs/10.x/queues.md:1424
#: ./docs/11.x/queues.md:1504
#: ./docs/master/queues.md:1424
msgid "To retrieve a batch by its ID, you may use the `Bus` facade's `findBatch` method:"
msgstr "若要使用 ID 來取得批次，可使用 `Bus` Facade 的 `findBatch` 方法："

# CODE
#: ./docs/8.x/queues.md:1315
#: ./docs/9.x/queues.md:1390
#: ./docs/10.x/queues.md:1426
#: ./docs/11.x/queues.md:1506
#: ./docs/master/queues.md:1426
msgid ""
"use Illuminate\\Support\\Facades\\Bus;\n"
"use Illuminate\\Support\\Facades\\Route;\n"
"\n"
"Route::get('/batch/{batchId}', function (string $batchId) {\n"
"    return Bus::findBatch($batchId);\n"
"});"
msgstr ""

# P
#: ./docs/8.x/queues.md:1322
#: ./docs/9.x/queues.md:1397
#: ./docs/10.x/queues.md:1433
#: ./docs/11.x/queues.md:1513
#: ./docs/master/queues.md:1433
#~ msgid "<a name=\"cancelling-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1323
#: ./docs/9.x/queues.md:1398
#: ./docs/10.x/queues.md:1434
#: ./docs/11.x/queues.md:1514
#: ./docs/master/queues.md:1434
msgid "Cancelling Batches"
msgstr "取消批次"

# P
#: ./docs/8.x/queues.md:1325
#: ./docs/9.x/queues.md:1400
#: ./docs/10.x/queues.md:1436
#: ./docs/11.x/queues.md:1516
#: ./docs/master/queues.md:1436
msgid "Sometimes you may need to cancel a given batch's execution. This can be accomplished by calling the `cancel` method on the `Illuminate\\Bus\\Batch` instance:"
msgstr "有時候，我們會需要取消給定批次的執行。若要取消執行批次，可在 `Illuminate\\Bus\\Batch` 實體上呼叫 `cancel` 方法："

# CODE
#: ./docs/8.x/queues.md:1327
#: ./docs/9.x/queues.md:1402
msgid ""
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->user->exceedsImportLimit()) {\n"
"        return $this->batch()->cancel();\n"
"    }\n"
"\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:1330
#: ./docs/11.x/queues.md:1410
#: ./docs/master/queues.md:1330
msgid "Conversely, you may run batches of jobs within a [chain](#job-chaining) by defining batches within the chain. For example, you could first run a batch of jobs to release multiple podcasts then a batch of jobs to send the release notifications:"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1332
#: ./docs/11.x/queues.md:1412
#: ./docs/master/queues.md:1332
msgid ""
"use App\\Jobs\\FlushPodcastCache;\n"
"use App\\Jobs\\ReleasePodcast;\n"
"use App\\Jobs\\SendPodcastReleaseNotification;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::chain([\n"
"    new FlushPodcastCache,\n"
"    Bus::batch([\n"
"        new ReleasePodcast(1),\n"
"        new ReleasePodcast(2),\n"
"    ]),\n"
"    Bus::batch([\n"
"        new SendPodcastReleaseNotification(1),\n"
"        new SendPodcastReleaseNotification(2),\n"
"    ]),\n"
"])->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1343
msgid "As you may have noticed in previous examples, batched jobs should typically check to see if the batch has been cancelled at the beginning of their `handle` method:"
msgstr "雖然讀者可能已經在前面的範例中注意到了，不過，批次 Job 一般都應在其 `handle` 方法的最前方檢查該批次是否已被取消："

# CODE
#: ./docs/8.x/queues.md:1345
msgid ""
"/**\n"
" * Execute the job.\n"
" *\n"
" * @return void\n"
" */\n"
"public function handle()\n"
"{\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"\n"
"    // Continue processing...\n"
"}"
msgstr ""

# H3
#: ./docs/10.x/queues.md:1350
#: ./docs/11.x/queues.md:1430
#: ./docs/master/queues.md:1350
msgid "Adding Jobs to Batches"
msgstr ""

# P
#: ./docs/8.x/queues.md:1359
#: ./docs/9.x/queues.md:1432
#: ./docs/10.x/queues.md:1464
#: ./docs/11.x/queues.md:1544
#: ./docs/master/queues.md:1464
#~ msgid "<a name=\"batch-failures\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1360
#: ./docs/9.x/queues.md:1433
#: ./docs/10.x/queues.md:1465
#: ./docs/11.x/queues.md:1545
#: ./docs/master/queues.md:1465
msgid "Batch Failures"
msgstr "批次失敗"

# P
#: ./docs/8.x/queues.md:1362
#: ./docs/9.x/queues.md:1435
#: ./docs/10.x/queues.md:1467
#: ./docs/11.x/queues.md:1547
#: ./docs/master/queues.md:1467
msgid "When a batched job fails, the `catch` callback (if assigned) will be invoked. This callback is only invoked for the first job that fails within the batch."
msgstr "若批次中的 Job 執行失敗，則會叫用 `catch` 回呼 (若有指定的話)。只有在批次中第一個失敗的 Job 才會叫用該回呼。"

# P
#: ./docs/11.x/queues.md:1363
#: ./docs/master/queues.md:1283
msgid "Since batch callbacks are serialized and executed at a later time by the Laravel queue, you should not use the `$this` variable within the callbacks. In addition, since batched jobs are wrapped within database transactions, database statements that trigger implicit commits should not be executed within the jobs."
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1364
#: ./docs/11.x/queues.md:1444
#: ./docs/master/queues.md:1364
msgid ""
"use App\\Jobs\\ImportContacts;\n"
"use Illuminate\\Support\\Collection;\n"
"\n"
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"\n"
"    $this->batch()->add(Collection::times(1000, function () {\n"
"        return new ImportContacts;\n"
"    }));\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1364
#: ./docs/9.x/queues.md:1437
#: ./docs/10.x/queues.md:1469
#: ./docs/11.x/queues.md:1549
#: ./docs/master/queues.md:1469
#~ msgid "<a name=\"allowing-failures\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1365
#: ./docs/9.x/queues.md:1438
#: ./docs/10.x/queues.md:1470
#: ./docs/11.x/queues.md:1550
#: ./docs/master/queues.md:1470
msgid "Allowing Failures"
msgstr "允許失敗"

# P
#: ./docs/8.x/queues.md:1367
#: ./docs/9.x/queues.md:1440
#: ./docs/10.x/queues.md:1472
#: ./docs/11.x/queues.md:1552
#: ./docs/master/queues.md:1472
msgid "When a job within a batch fails, Laravel will automatically mark the batch as \"cancelled\". If you wish, you may disable this behavior so that a job failure does not automatically mark the batch as cancelled. This may be accomplished by calling the `allowFailures` method while dispatching the batch:"
msgstr "若在批次中的 Job 執行失敗，Laravel 會自動將該批次標記為「^[已取消](Cancelled)」。若有需要的話，我們可以禁用這個行為，好讓 Job 失敗是不要自動將批次標記為取消。若要禁用此行為，可在分派批次時呼叫 `allowFailures` 方法："

# CODE
#: ./docs/8.x/queues.md:1369
#: ./docs/9.x/queues.md:1442
#: ./docs/10.x/queues.md:1474
#: ./docs/11.x/queues.md:1554
#: ./docs/master/queues.md:1474
msgid ""
"$batch = Bus::batch([\n"
"    // ...\n"
"])->then(function (Batch $batch) {\n"
"    // All jobs completed successfully...\n"
"})->allowFailures()->dispatch();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1375
#: ./docs/9.x/queues.md:1448
#: ./docs/10.x/queues.md:1480
#: ./docs/11.x/queues.md:1560
#: ./docs/master/queues.md:1480
#~ msgid "<a name=\"retrying-failed-batch-jobs\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1376
#: ./docs/9.x/queues.md:1449
#: ./docs/10.x/queues.md:1481
#: ./docs/11.x/queues.md:1561
#: ./docs/master/queues.md:1481
msgid "Retrying Failed Batch Jobs"
msgstr "重試失敗的批次 Job"

# P
#: ./docs/8.x/queues.md:1378
#: ./docs/9.x/queues.md:1451
#: ./docs/10.x/queues.md:1483
#: ./docs/11.x/queues.md:1563
#: ./docs/master/queues.md:1483
msgid "For convenience, Laravel provides a `queue:retry-batch` Artisan command that allows you to easily retry all of the failed jobs for a given batch. The `queue:retry-batch` command accepts the UUID of the batch whose failed jobs should be retried:"
msgstr "Laravel 提供了一個方便的 `queue:retry-batch` Artisan 指令，能讓我們輕鬆重試給定批次中所有失敗的 Job。`queue:retry-batch` 指令的參數為要重試 Job 之批次的 UUID："

# CODE: bash
# CODE: shell
#: ./docs/8.x/queues.md:1380
#: ./docs/9.x/queues.md:1453
#: ./docs/10.x/queues.md:1485
#: ./docs/11.x/queues.md:1565
#: ./docs/master/queues.md:1485
msgid "php artisan queue:retry-batch 32dbc76c-4f82-4749-b610-a639fe0099b5"
msgstr ""

# P
#: ./docs/8.x/queues.md:1384
#: ./docs/9.x/queues.md:1457
#: ./docs/10.x/queues.md:1489
#: ./docs/11.x/queues.md:1569
#: ./docs/master/queues.md:1489
#~ msgid "<a name=\"pruning-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1385
#: ./docs/9.x/queues.md:1458
#: ./docs/10.x/queues.md:1490
#: ./docs/11.x/queues.md:1570
#: ./docs/master/queues.md:1490
msgid "Pruning Batches"
msgstr "修建批次"

# P
#: ./docs/8.x/queues.md:1387
#: ./docs/9.x/queues.md:1460
#: ./docs/10.x/queues.md:1492
#: ./docs/11.x/queues.md:1572
#: ./docs/master/queues.md:1492
msgid "Without pruning, the `job_batches` table can accumulate records very quickly. To mitigate this, you should [schedule](/docs/{{version}}/scheduling) the `queue:prune-batches` Artisan command to run daily:"
msgstr "若未^[修建](Prune)批次，則 `job_batches` 資料表很快就會變得很大。為了避免這個狀況，應[定期](/docs/{{version}}/scheduling)每日執行 `queue:prune-batches` Artisan 指令："

# CODE
#: ./docs/8.x/queues.md:1389
#: ./docs/9.x/queues.md:1462
#: ./docs/10.x/queues.md:1494
msgid "$schedule->command('queue:prune-batches')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1391
#: ./docs/9.x/queues.md:1464
#: ./docs/10.x/queues.md:1496
#: ./docs/11.x/queues.md:1578
#: ./docs/master/queues.md:1498
msgid "By default, all finished batches that are more than 24 hours old will be pruned. You may use the `hours` option when calling the command to determine how long to retain batch data. For example, the following command will delete all batches that finished over 48 hours ago:"
msgstr "預設情況下，完成超過 24 小時的批次會被修建掉。可以在呼叫該指令時使用 `hours` 選項來指定批次資料要保留多久。舉例來說，下列指令會刪除完成超過 48 小時前的所有批次："

# CODE
#: ./docs/8.x/queues.md:1393
#: ./docs/9.x/queues.md:1466
#: ./docs/10.x/queues.md:1498
msgid "$schedule->command('queue:prune-batches --hours=48')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1395
#: ./docs/9.x/queues.md:1468
#: ./docs/10.x/queues.md:1500
#: ./docs/11.x/queues.md:1584
#: ./docs/master/queues.md:1504
msgid "Sometimes, your `jobs_batches` table may accumulate batch records for batches that never completed successfully, such as batches where a job failed and that job was never retried successfully. You may instruct the `queue:prune-batches` command to prune these unfinished batch records using the `unfinished` option:"
msgstr "有時候，`jobs_batches` 資料表可能會有一些從未成功完成的批次記錄，如批次中有 Job 失敗且從每次嘗試都失敗的批次。可以在 `queue:prune-batxhes` 指令的使用 `unfinished` 選項來修剪這些未完成的批次："

# CODE
#: ./docs/8.x/queues.md:1397
#: ./docs/9.x/queues.md:1470
#: ./docs/10.x/queues.md:1502
msgid "$schedule->command('queue:prune-batches --hours=48 --unfinished=72')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1399
#: ./docs/9.x/queues.md:1476
#: ./docs/10.x/queues.md:1562
#: ./docs/11.x/queues.md:1650
#: ./docs/master/queues.md:1570
#~ msgid "<a name=\"queueing-closures\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1400
#: ./docs/9.x/queues.md:1477
#: ./docs/10.x/queues.md:1563
#: ./docs/11.x/queues.md:1651
#: ./docs/master/queues.md:1571
msgid "Queueing Closures"
msgstr "將閉包放入佇列"

# P
#: ./docs/8.x/queues.md:1402
#: ./docs/9.x/queues.md:1479
#: ./docs/10.x/queues.md:1565
#: ./docs/master/queues.md:1573
msgid "Instead of dispatching a job class to the queue, you may also dispatch a closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle. When dispatching closures to the queue, the closure's code content is cryptographically signed so that it can not be modified in transit:"
msgstr "除了將 Job 類別分派進佇列外，我們也可以分派閉包。分派閉包對於一些要在目前 Request 週期外執行的快速、簡單任務來說很好用。把閉包放入佇列時，該閉包的程式碼內容會以密碼學的方式進行簽署，以避免其程式碼在傳輸過程中遭到篡改："

# CODE
#: ./docs/8.x/queues.md:1404
#: ./docs/9.x/queues.md:1481
#: ./docs/10.x/queues.md:1567
#: ./docs/11.x/queues.md:1655
#: ./docs/master/queues.md:1575
msgid ""
"$podcast = App\\Podcast::find(1);\n"
"\n"
"dispatch(function () use ($podcast) {\n"
"    $podcast->publish();\n"
"});"
msgstr ""

# P
#: ./docs/8.x/queues.md:1410
#: ./docs/9.x/queues.md:1487
#: ./docs/10.x/queues.md:1573
#: ./docs/11.x/queues.md:1661
#: ./docs/master/queues.md:1581
msgid "Using the `catch` method, you may provide a closure that should be executed if the queued closure fails to complete successfully after exhausting all of your queue's [configured retry attempts](#max-job-attempts-and-timeout):"
msgstr "使用 `catch` 方法，就能為佇列閉包提供一組要在所有[重試次數](#max-job-attempts-and-timeout)都失敗的時候執行的閉包："

# CODE
#: ./docs/8.x/queues.md:1412
#: ./docs/9.x/queues.md:1489
#: ./docs/10.x/queues.md:1575
#: ./docs/11.x/queues.md:1663
#: ./docs/master/queues.md:1583
msgid ""
"use Throwable;\n"
"\n"
"dispatch(function () use ($podcast) {\n"
"    $podcast->publish();\n"
"})->catch(function (Throwable $e) {\n"
"    // This job has failed...\n"
"});"
msgstr ""

# P
#: ./docs/9.x/queues.md:1418
#: ./docs/10.x/queues.md:1452
#: ./docs/11.x/queues.md:1532
#: ./docs/master/queues.md:1452
msgid "As you may have noticed in the previous examples, batched jobs should typically determine if their corresponding batch has been cancelled before continuing execution. However, for convenience, you may assign the `SkipIfBatchCancelled` [middleware](#job-middleware) to the job instead. As its name indicates, this middleware will instruct Laravel to not process the job if its corresponding batch has been cancelled:"
msgstr "讀者可能已經從上面的範例中注意到，批次的 Job 一般都應該在繼續執行前先判斷自己所在的批次是否已被取消。不過，為了讓開發過程更方便，也可以在 Job 上指定 `SkipIfBatchCancelled` [Middleware](#job-middleware)，這樣就不需要手動檢查批次是否已被取消。就像該 Middleware 的名稱一樣，這個 Middleware 會告訴 Laravel，當 Job 對應的批次被取消時，就不要在繼續處理 Job："

# P
#: ./docs/8.x/queues.md:1420
#: ./docs/9.x/queues.md:1500
#: ./docs/10.x/queues.md:1586
#: ./docs/11.x/queues.md:1674
#: ./docs/master/queues.md:1594
#~ msgid "<a name=\"running-the-queue-worker\"></a>"
#~ msgstr ""

# CODE
#: ./docs/9.x/queues.md:1420
msgid ""
"use Illuminate\\Queue\\Middleware\\SkipIfBatchCancelled;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" *\n"
" * @return array\n"
" */\n"
"public function middleware()\n"
"{\n"
"    return [new SkipIfBatchCancelled];\n"
"}"
msgstr ""

# H2
#: ./docs/8.x/queues.md:1421
#: ./docs/9.x/queues.md:1501
msgid "Running The Queue Worker"
msgstr "執行 Queue Worker"

# P
#: ./docs/8.x/queues.md:1423
#: ./docs/9.x/queues.md:1503
#: ./docs/10.x/queues.md:1589
#: ./docs/11.x/queues.md:1677
#: ./docs/master/queues.md:1597
#~ msgid "<a name=\"the-queue-work-command\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1424
#: ./docs/9.x/queues.md:1504
#: ./docs/10.x/queues.md:1590
#: ./docs/11.x/queues.md:1678
#: ./docs/master/queues.md:1598
msgid "The `queue:work` Command"
msgstr "使用 `queue:work` 指令"

# P
#: ./docs/8.x/queues.md:1426
#: ./docs/9.x/queues.md:1506
#: ./docs/10.x/queues.md:1592
#: ./docs/11.x/queues.md:1680
#: ./docs/master/queues.md:1600
msgid "Laravel includes an Artisan command that will start a queue worker and process new jobs as they are pushed onto the queue. You may run the worker using the `queue:work` Artisan command. Note that once the `queue:work` command has started, it will continue to run until it is manually stopped or you close your terminal:"
msgstr "Laravel 中隨附了一個 Artisan 指令，可用來開啟 ^[Queue Worker](佇列背景工作角色)，以在 Job 被推入佇列後處理這些 Job。可以使用 `queue:work` Artisan 指令來執行 Queue Worker。請注意，當執行 `queue:work` 指令後，該指令會持續執行，直到我們手動停止該指令或關閉終端機為止："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1428
#: ./docs/9.x/queues.md:1508
#: ./docs/10.x/queues.md:1594
#: ./docs/11.x/queues.md:1682
#: ./docs/master/queues.md:1602
msgid "php artisan queue:work"
msgstr ""

# P
#: ./docs/8.x/queues.md:1430
#: ./docs/9.x/queues.md:1513
#: ./docs/10.x/queues.md:1599
#: ./docs/11.x/queues.md:1687
#: ./docs/master/queues.md:1607
msgid "To keep the `queue:work` process running permanently in the background, you should use a process monitor such as [Supervisor](#supervisor-configuration) to ensure that the queue worker does not stop running."
msgstr "若要讓 `queue:work` 處理程序在背景持續執行，請使用如 [Supervisor](#supervisor-configuration) 等的 ^[Process Monitor](處理程序監看程式)，以確保 Queue Worker 持續執行。"

# P
#: ./docs/8.x/queues.md:1432
msgid "Remember, queue workers, are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to [restart your queue workers](#queue-workers-and-deployment). In addition, remember that any static state created or modified by your application will not be automatically reset between jobs."
msgstr "請記得，Queue Worker 是會持續執行的處理程序，且會將已開啟的程式狀態保存在記憶體中。因此，Queue Worker 開始執行後若有更改程式碼，這些 Worker 將不會知道有這些修改。所以，在部署過程中，請確保有[重新啟動 Queue Worker](#queue-workers-and-deployment)。此外，也請注意，在各個 Job 間，也不會自動重設程式所建立或修改的任何^[靜態狀態](Static State)。"

# P
#: ./docs/8.x/queues.md:1434
#: ./docs/9.x/queues.md:1523
#: ./docs/10.x/queues.md:1609
#: ./docs/11.x/queues.md:1697
#: ./docs/master/queues.md:1617
msgid "Alternatively, you may run the `queue:listen` command. When using the `queue:listen` command, you don't have to manually restart the worker when you want to reload your updated code or reset the application state; however, this command is significantly less efficient than the `queue:work` command:"
msgstr "或者，我們也可以執行 `queue:listen` 指令。使用 `queue:listen` 指令時，若有更新程式碼或重設程式的狀態，就不需手動重新啟動 Queue Worker。不過，這個指令比起 `queue:work` 指令來說比較沒有效率："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1436
#: ./docs/9.x/queues.md:1525
#: ./docs/10.x/queues.md:1611
#: ./docs/11.x/queues.md:1699
#: ./docs/master/queues.md:1619
msgid "php artisan queue:listen"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1438
#: ./docs/11.x/queues.md:1518
#: ./docs/master/queues.md:1438
msgid ""
"/**\n"
" * Execute the job.\n"
" */\n"
"public function handle(): void\n"
"{\n"
"    if ($this->user->exceedsImportLimit()) {\n"
"        return $this->batch()->cancel();\n"
"    }\n"
"\n"
"    if ($this->batch()->cancelled()) {\n"
"        return;\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1438
#: ./docs/9.x/queues.md:1529
#: ./docs/10.x/queues.md:1615
#: ./docs/11.x/queues.md:1703
#: ./docs/master/queues.md:1623
#~ msgid "<a name=\"running-multiple-queue-workers\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1439
#: ./docs/9.x/queues.md:1530
#: ./docs/10.x/queues.md:1616
#: ./docs/11.x/queues.md:1704
#: ./docs/master/queues.md:1624
msgid "Running Multiple Queue Workers"
msgstr "執行多個 Queue Worker"

# P
#: ./docs/8.x/queues.md:1441
#: ./docs/9.x/queues.md:1532
#: ./docs/10.x/queues.md:1618
#: ./docs/11.x/queues.md:1706
#: ./docs/master/queues.md:1626
msgid "To assign multiple workers to a queue and process jobs concurrently, you should simply start multiple `queue:work` processes. This can either be done locally via multiple tabs in your terminal or in production using your process manager's configuration settings. [When using Supervisor](#supervisor-configuration), you may use the `numprocs` configuration value."
msgstr "若要指派多個 Worker 給某個 Queue 並同時處理多個 Job，只需要啟動多個 `queue:work` 處理程序即可。若要啟動多個 `queue:work`，在本機上，我們可以開啟多個終端機分頁來執行；若是在正是環境上，則可以使用 Process Manager 的設定來啟動多個 `queue:work`。[使用 Supervisor 時](#supervisor-configuration)，可使用 `numprocs` 設定值。"

# P
#: ./docs/8.x/queues.md:1443
#: ./docs/9.x/queues.md:1534
#: ./docs/10.x/queues.md:1620
#: ./docs/11.x/queues.md:1708
#: ./docs/master/queues.md:1628
#~ msgid "<a name=\"specifying-the-connection-queue\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1444
#: ./docs/9.x/queues.md:1535
msgid "Specifying The Connection & Queue"
msgstr "指定連線與佇列"

# P
#: ./docs/8.x/queues.md:1446
#: ./docs/9.x/queues.md:1537
#: ./docs/10.x/queues.md:1623
#: ./docs/11.x/queues.md:1711
#: ./docs/master/queues.md:1631
msgid "You may also specify which queue connection the worker should utilize. The connection name passed to the `work` command should correspond to one of the connections defined in your `config/queue.php` configuration file:"
msgstr "也可以指定 Worker 要使用的佇列連線。傳給 `work` 指令的連線名稱應對影到 `config/queue.php` 設定檔中所定義的其中一個連線："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1448
#: ./docs/9.x/queues.md:1539
#: ./docs/10.x/queues.md:1625
#: ./docs/11.x/queues.md:1713
#: ./docs/master/queues.md:1633
msgid "php artisan queue:work redis"
msgstr ""

# P
#: ./docs/8.x/queues.md:1450
#: ./docs/9.x/queues.md:1543
#: ./docs/10.x/queues.md:1629
#: ./docs/11.x/queues.md:1717
#: ./docs/master/queues.md:1637
msgid "By default, the `queue:work` command only processes jobs for the default queue on a given connection. However, you may customize your queue worker even further by only processing particular queues for a given connection. For example, if all of your emails are processed in an `emails` queue on your `redis` queue connection, you may issue the following command to start a worker that only processes that queue:"
msgstr "預設情況下，`queue:work` 指令擲回處理給定連線上預設佇列的 Job。不過，我們也可以自定 Queue Worker，以處理給定連線上的特定佇列。舉例來說，若我們把所有的電子郵件都放在 `redis` 連線的 `emails` 佇列中執行，則我們可以執行下列指令來啟動一個處理該佇列的 Worker："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1452
#: ./docs/9.x/queues.md:1545
#: ./docs/10.x/queues.md:1631
#: ./docs/11.x/queues.md:1719
#: ./docs/master/queues.md:1639
msgid "php artisan queue:work redis --queue=emails"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1454
#: ./docs/11.x/queues.md:1534
#: ./docs/master/queues.md:1454
msgid ""
"use Illuminate\\Queue\\Middleware\\SkipIfBatchCancelled;\n"
"\n"
"/**\n"
" * Get the middleware the job should pass through.\n"
" */\n"
"public function middleware(): array\n"
"{\n"
"    return [new SkipIfBatchCancelled];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1454
#: ./docs/9.x/queues.md:1549
#: ./docs/10.x/queues.md:1635
#: ./docs/11.x/queues.md:1723
#: ./docs/master/queues.md:1643
#~ msgid "<a name=\"processing-a-specified-number-of-jobs\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1455
#: ./docs/9.x/queues.md:1550
msgid "Processing A Specified Number Of Jobs"
msgstr "處理指定數量的 Job"

# P
#: ./docs/8.x/queues.md:1457
#: ./docs/9.x/queues.md:1552
#: ./docs/10.x/queues.md:1638
#: ./docs/11.x/queues.md:1726
#: ./docs/master/queues.md:1646
msgid "The `--once` option may be used to instruct the worker to only process a single job from the queue:"
msgstr "可使用 `--once` 選項來讓 Worker 一次只處理佇列中的一個 Job："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1459
#: ./docs/9.x/queues.md:1554
#: ./docs/10.x/queues.md:1640
#: ./docs/11.x/queues.md:1728
#: ./docs/master/queues.md:1648
msgid "php artisan queue:work --once"
msgstr ""

# P
#: ./docs/8.x/queues.md:1461
#: ./docs/9.x/queues.md:1558
#: ./docs/10.x/queues.md:1644
#: ./docs/11.x/queues.md:1732
#: ./docs/master/queues.md:1652
msgid "The `--max-jobs` option may be used to instruct the worker to process the given number of jobs and then exit. This option may be useful when combined with [Supervisor](#supervisor-configuration) so that your workers are automatically restarted after processing a given number of jobs, releasing any memory they may have accumulated:"
msgstr "可使用 `--max-jobs` 選項來讓 Worker 只處理特定數量的 Job，然後就終止執行。該選項適合與 [Supervisor](#supervisor-configuration) 搭配使用，這樣我們就能讓 Worker 在處理特定數量的 Job 後自動重新執行，以釋出該 Worker 所積累的記憶體："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1463
#: ./docs/9.x/queues.md:1560
#: ./docs/10.x/queues.md:1646
#: ./docs/11.x/queues.md:1734
#: ./docs/master/queues.md:1654
msgid "php artisan queue:work --max-jobs=1000"
msgstr ""

# P
#: ./docs/8.x/queues.md:1465
#: ./docs/9.x/queues.md:1564
#: ./docs/10.x/queues.md:1650
#: ./docs/11.x/queues.md:1738
#: ./docs/master/queues.md:1658
#~ msgid "<a name=\"processing-all-queued-jobs-then-exiting\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1466
#: ./docs/9.x/queues.md:1565
msgid "Processing All Queued Jobs & Then Exiting"
msgstr "處理所有放入佇列的 Job 然後終止執行"

# P
#: ./docs/8.x/queues.md:1468
#: ./docs/9.x/queues.md:1567
#: ./docs/10.x/queues.md:1653
#: ./docs/11.x/queues.md:1741
#: ./docs/master/queues.md:1661
msgid "The `--stop-when-empty` option may be used to instruct the worker to process all jobs and then exit gracefully. This option can be useful when processing Laravel queues within a Docker container if you wish to shutdown the container after the queue is empty:"
msgstr "可使用 `--stop-when-empty` 選項來讓 Worker 處理所有的 Job 然後終止執行。在 Docker Container 中處理 Laravel 佇列時，若在佇列為空時停止關閉 Container，就適合使用該選項："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1470
#: ./docs/9.x/queues.md:1569
#: ./docs/10.x/queues.md:1655
#: ./docs/11.x/queues.md:1743
#: ./docs/master/queues.md:1663
msgid "php artisan queue:work --stop-when-empty"
msgstr ""

# P
#: ./docs/8.x/queues.md:1472
#: ./docs/9.x/queues.md:1573
#: ./docs/10.x/queues.md:1659
#: ./docs/11.x/queues.md:1747
#: ./docs/master/queues.md:1667
#~ msgid "<a name=\"processing-jobs-for-a-given-number-of-seconds\"></a>"
#~ msgstr ""

# P
#: ./docs/9.x/queues.md:1472
#: ./docs/10.x/queues.md:1504
#: ./docs/11.x/queues.md:1590
#: ./docs/master/queues.md:1510
msgid "Likewise, your `jobs_batches` table may also accumulate batch records for cancelled batches. You may instruct the `queue:prune-batches` command to prune these cancelled batch records using the `cancelled` option:"
msgstr "類似的，`jobs_batches` 資料表可能會累積一些已取消批次的批次記錄。可以在 `queue:prune-batxhes` 指令上使用 `cancelled` 選項來修剪這些已取消的批次："

# H4
#: ./docs/8.x/queues.md:1473
#: ./docs/9.x/queues.md:1574
msgid "Processing Jobs For A Given Number Of Seconds"
msgstr "在給定秒數內處理 Job"

# CODE
#: ./docs/9.x/queues.md:1474
#: ./docs/10.x/queues.md:1506
msgid "$schedule->command('queue:prune-batches --hours=48 --cancelled=72')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1475
#: ./docs/9.x/queues.md:1576
#: ./docs/10.x/queues.md:1662
#: ./docs/11.x/queues.md:1750
#: ./docs/master/queues.md:1670
msgid "The `--max-time` option may be used to instruct the worker to process jobs for the given number of seconds and then exit. This option may be useful when combined with [Supervisor](#supervisor-configuration) so that your workers are automatically restarted after processing jobs for a given amount of time, releasing any memory they may have accumulated:"
msgstr "`--max-time` 選項可用來讓 Worker 處理給定秒數的 Job，然後終止執行。該選項是何與 [Supervisor](#supervisor-configuration) 搭配使用，以在處理 Job 給定時間後自動重新啟動 Worker，並釋放期間可能積累的記憶體："

# CODE
#: ./docs/8.x/queues.md:1477
msgid ""
"// Process jobs for one hour and then exit...\n"
"php artisan queue:work --max-time=3600"
msgstr ""

# P
#: ./docs/8.x/queues.md:1480
#: ./docs/9.x/queues.md:1583
#: ./docs/10.x/queues.md:1669
#: ./docs/11.x/queues.md:1757
#: ./docs/master/queues.md:1677
#~ msgid "<a name=\"worker-sleep-duration\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1481
#: ./docs/9.x/queues.md:1584
#: ./docs/10.x/queues.md:1670
#: ./docs/11.x/queues.md:1758
#: ./docs/master/queues.md:1678
msgid "Worker Sleep Duration"
msgstr "Worker 的休眠期間"

# P
#: ./docs/8.x/queues.md:1483
msgid "When jobs are available on the queue, the worker will keep processing jobs with no delay in between them. However, the `sleep` option determines how many seconds the worker will \"sleep\" if there are no new jobs available. While sleeping, the worker will not process any new jobs - the jobs will be processed after the worker wakes up again."
msgstr "若佇列中有 Job，則 Worker 會不間斷地處理這些 Job。不過，使用 `sleep` 選項可用來讓 Worker 判斷當沒有新 Job 時要「休眠」多少秒。在休眠期間，Worker 不會處理任何新的 Job。當 Worker 喚醒後，才會開始處理這些 Job。"

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1485
#: ./docs/9.x/queues.md:1588
#: ./docs/10.x/queues.md:1674
#: ./docs/11.x/queues.md:1762
#: ./docs/master/queues.md:1682
msgid "php artisan queue:work --sleep=3"
msgstr ""

# P
#: ./docs/8.x/queues.md:1487
#: ./docs/9.x/queues.md:1592
#: ./docs/10.x/queues.md:1689
#: ./docs/11.x/queues.md:1777
#: ./docs/master/queues.md:1697
#~ msgid "<a name=\"resource-considerations\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1488
#: ./docs/9.x/queues.md:1593
#: ./docs/10.x/queues.md:1690
#: ./docs/11.x/queues.md:1778
#: ./docs/master/queues.md:1698
msgid "Resource Considerations"
msgstr "資源上的考量"

# P
#: ./docs/8.x/queues.md:1490
#: ./docs/9.x/queues.md:1595
#: ./docs/10.x/queues.md:1692
#: ./docs/11.x/queues.md:1780
#: ./docs/master/queues.md:1700
msgid "Daemon queue workers do not \"reboot\" the framework before processing each job. Therefore, you should release any heavy resources after each job completes. For example, if you are doing image manipulation with the GD library, you should free the memory with `imagedestroy` when you are done processing the image."
msgstr "Daemon 型的 Queue Worker 並不會在每個 Job 處理後「重新啟動」Laravel。因此，在每個 Job 處理完畢後，請務必釋放任何吃資源的功能。舉例來說，若我們使用了 GD 函式庫來進行圖片處理，則應在處理完圖片後使用 `imagedestroy` 來釋放記憶體。"

# P
#: ./docs/8.x/queues.md:1492
#: ./docs/9.x/queues.md:1597
#: ./docs/10.x/queues.md:1694
#: ./docs/11.x/queues.md:1782
#: ./docs/master/queues.md:1702
#~ msgid "<a name=\"queue-priorities\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1493
#: ./docs/9.x/queues.md:1598
#: ./docs/10.x/queues.md:1695
#: ./docs/11.x/queues.md:1783
#: ./docs/master/queues.md:1703
msgid "Queue Priorities"
msgstr "佇列的優先度"

# P
#: ./docs/8.x/queues.md:1495
#: ./docs/9.x/queues.md:1600
#: ./docs/10.x/queues.md:1697
#: ./docs/11.x/queues.md:1785
#: ./docs/master/queues.md:1705
msgid "Sometimes you may wish to prioritize how your queues are processed. For example, in your `config/queue.php` configuration file, you may set the default `queue` for your `redis` connection to `low`. However, occasionally you may wish to push a job to a `high` priority queue like so:"
msgstr "有時候，我們可能會向調整各個佇列的處理優先度。舉例來說，在 `config/queue.php` 設定檔中，我們可以把 `redis` 連線上的預設 `queue` 設為 `low` (低)。不過，有時候，我們可能會想像這樣把 Job 推入 `high` (高) 優先度的佇列："

# CODE
#: ./docs/8.x/queues.md:1497
#: ./docs/9.x/queues.md:1602
#: ./docs/10.x/queues.md:1699
#: ./docs/11.x/queues.md:1787
#: ./docs/master/queues.md:1707
msgid "dispatch((new Job)->onQueue('high'));"
msgstr ""

# P
#: ./docs/9.x/queues.md:1498
#: ./docs/10.x/queues.md:1584
#: ./docs/11.x/queues.md:1672
#: ./docs/master/queues.md:1592
msgid "Since `catch` callbacks are serialized and executed at a later time by the Laravel queue, you should not use the `$this` variable within `catch` callbacks."
msgstr "由於 `catch` 的回呼會被序列化並在稍後由 Laravel 的佇列執行，因此請不要在 `catch` 的回呼中使用 `$this` 變數。"

# P
#: ./docs/8.x/queues.md:1499
#: ./docs/9.x/queues.md:1604
#: ./docs/10.x/queues.md:1701
#: ./docs/11.x/queues.md:1789
#: ./docs/master/queues.md:1709
msgid "To start a worker that verifies that all of the `high` queue jobs are processed before continuing to any jobs on the `low` queue, pass a comma-delimited list of queue names to the `work` command:"
msgstr "若要啟動 Worker 以驗證是否所有 `high` 佇列上的 Job 都比 `low` 佇列上的 Job 還要早被處理，只需要傳入一組以逗號分隔的佇列名稱列表給 `work` 指令即可："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1501
#: ./docs/9.x/queues.md:1606
#: ./docs/10.x/queues.md:1703
#: ./docs/11.x/queues.md:1791
#: ./docs/master/queues.md:1711
msgid "php artisan queue:work --queue=high,low"
msgstr ""

# P
#: ./docs/8.x/queues.md:1503
#: ./docs/9.x/queues.md:1610
#: ./docs/10.x/queues.md:1707
#: ./docs/11.x/queues.md:1795
#: ./docs/master/queues.md:1715
#~ msgid "<a name=\"queue-workers-and-deployment\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1504
#: ./docs/9.x/queues.md:1611
msgid "Queue Workers & Deployment"
msgstr "Queue Worker 與部署"

# P
#: ./docs/8.x/queues.md:1506
#: ./docs/9.x/queues.md:1613
#: ./docs/10.x/queues.md:1710
#: ./docs/11.x/queues.md:1798
#: ./docs/master/queues.md:1718
msgid "Since queue workers are long-lived processes, they will not notice changes to your code without being restarted. So, the simplest way to deploy an application using queue workers is to restart the workers during your deployment process. You may gracefully restart all of the workers by issuing the `queue:restart` command:"
msgstr "由於 Queue Worker 時持續執行的處理程序，因此除非重啟啟動 Queue Worker，否則 Queue Worker 不會知道程式碼有被修改過。要部署有使用 Queue Worker 的專案，最簡單的做法就是在部署過程中重新啟動 Queue Worker。我們可以執行 `queue:restart` 指令來重新啟動所有的 Worker："

# P
#: ./docs/10.x/queues.md:1508
#: ./docs/11.x/queues.md:1596
#: ./docs/master/queues.md:1516
#~ msgid "<a name=\"storing-batches-in-dynamodb\"></a>"
#~ msgstr ""

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1508
#: ./docs/9.x/queues.md:1615
#: ./docs/10.x/queues.md:1712
#: ./docs/11.x/queues.md:1800
#: ./docs/master/queues.md:1720
msgid "php artisan queue:restart"
msgstr ""

# H3
#: ./docs/10.x/queues.md:1509
#: ./docs/11.x/queues.md:1597
#: ./docs/master/queues.md:1517
msgid "Storing Batches in DynamoDB"
msgstr ""

# P
#: ./docs/8.x/queues.md:1510
#: ./docs/9.x/queues.md:1619
#: ./docs/10.x/queues.md:1716
#: ./docs/11.x/queues.md:1804
#: ./docs/master/queues.md:1724
msgid "This command will instruct all queue workers to gracefully exit after they finish processing their current job so that no existing jobs are lost. Since the queue workers will exit when the `queue:restart` command is executed, you should be running a process manager such as [Supervisor](#supervisor-configuration) to automatically restart the queue workers."
msgstr "該指令會通知所有的 Queue Worker，讓所有的 Worker 在處理完目前 Job 且在現有 Job 不遺失的情況下終止執行 Worker。由於 Queue Worker 會在 `queue:restart` 指令執行後終止執行，因此請務必使用如 [Supervisor](#supervisor-configuration) 這樣的 Process Manager 來自動重新啟動 Queue Worker。"

# P
#: ./docs/10.x/queues.md:1511
#: ./docs/11.x/queues.md:1599
#: ./docs/master/queues.md:1519
msgid "Laravel also provides support for storing batch meta information in [DynamoDB](https://aws.amazon.com/dynamodb) instead of a relational database. However, you will need to manually create a DynamoDB table to store all of the batch records."
msgstr ""

# P
#: ./docs/8.x/queues.md:1512
#: ./docs/9.x/queues.md:1622
#: ./docs/10.x/queues.md:1719
#: ./docs/11.x/queues.md:1807
#: ./docs/master/queues.md:1727
msgid "The queue uses the [cache](/docs/{{version}}/cache) to store restart signals, so you should verify that a cache driver is properly configured for your application before using this feature."
msgstr "佇列會使用[快取](/docs/{{version}}/cache)來儲存重新啟動訊號，因此在使用此功能前請先確認專案上是否有設定好正確的快取 Driver。"

# P
#: ./docs/10.x/queues.md:1513
#: ./docs/11.x/queues.md:1601
#: ./docs/master/queues.md:1521
msgid "Typically, this table should be named `job_batches`, but you should name the table based on the value of the `queue.batching.table` configuration value within your application's `queue` configuration file."
msgstr ""

# P
#: ./docs/8.x/queues.md:1514
#: ./docs/9.x/queues.md:1624
#: ./docs/10.x/queues.md:1721
#: ./docs/11.x/queues.md:1809
#: ./docs/master/queues.md:1729
#~ msgid "<a name=\"job-expirations-and-timeouts\"></a>"
#~ msgstr ""

# P
#: ./docs/10.x/queues.md:1515
#: ./docs/11.x/queues.md:1603
#: ./docs/master/queues.md:1523
#~ msgid "<a name=\"dynamodb-batch-table-configuration\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1515
#: ./docs/9.x/queues.md:1625
msgid "Job Expirations & Timeouts"
msgstr "Job 的有效期限與逾時"

# P
#: ./docs/9.x/queues.md:1515
#: ./docs/10.x/queues.md:1601
#: ./docs/11.x/queues.md:1689
#: ./docs/master/queues.md:1609
msgid "You may include the `-v` flag when invoking the `queue:work` command if you would like the processed job IDs to be included in the command's output:"
msgstr "若想將 Job ID 包含在 `queue:work` 指令的輸出，則可在呼叫該指令時加上 `-v` 旗標："

# H4
#: ./docs/10.x/queues.md:1516
#: ./docs/11.x/queues.md:1604
#: ./docs/master/queues.md:1524
msgid "DynamoDB Batch Table Configuration"
msgstr ""

# P
#: ./docs/8.x/queues.md:1517
#: ./docs/9.x/queues.md:1627
#: ./docs/10.x/queues.md:1724
#: ./docs/11.x/queues.md:1812
#: ./docs/master/queues.md:1732
#~ msgid "<a name=\"job-expiration\"></a>"
#~ msgstr ""

# CODE: shell
#: ./docs/9.x/queues.md:1517
#: ./docs/10.x/queues.md:1603
#: ./docs/11.x/queues.md:1691
#: ./docs/master/queues.md:1611
msgid "php artisan queue:work -v"
msgstr ""

# P
#: ./docs/10.x/queues.md:1518
#: ./docs/11.x/queues.md:1606
#: ./docs/master/queues.md:1526
msgid "The `job_batches` table should have a string primary partition key named `application` and a string primary sort key named `id`. The `application` portion of the key will contain your application's name as defined by the `name` configuration value within your application's `app` configuration file. Since the application name is part of the DynamoDB table's key, you can use the same table to store job batches for multiple Laravel applications."
msgstr ""

# H4
#: ./docs/8.x/queues.md:1518
#: ./docs/9.x/queues.md:1628
#: ./docs/10.x/queues.md:1725
#: ./docs/11.x/queues.md:1813
#: ./docs/master/queues.md:1733
msgid "Job Expiration"
msgstr "Job 的有效期限"

# P
#: ./docs/10.x/queues.md:1520
#: ./docs/11.x/queues.md:1608
#: ./docs/master/queues.md:1528
msgid "In addition, you may define `ttl` attribute for your table if you would like to take advantage of [automatic batch pruning](#pruning-batches-in-dynamodb)."
msgstr ""

# P
#: ./docs/8.x/queues.md:1520
#: ./docs/9.x/queues.md:1630
#: ./docs/10.x/queues.md:1727
#: ./docs/11.x/queues.md:1815
#: ./docs/master/queues.md:1735
msgid "In your `config/queue.php` configuration file, each queue connection defines a `retry_after` option. This option specifies how many seconds the queue connection should wait before retrying a job that is being processed. For example, if the value of `retry_after` is set to `90`, the job will be released back onto the queue if it has been processing for 90 seconds without being released or deleted. Typically, you should set the `retry_after` value to the maximum number of seconds your jobs should reasonably take to complete processing."
msgstr "在 `config/queue.php` 設定檔中，每個佇列連線都有定義一個 `retry_after` 選項。這個選項用來指定在重新嘗試目前處理的 Job 前需要等待多少秒。舉例來說，若 `retry_after` 設為 `90`，則若某個 Job 已被處理 90 秒，且期間沒有被釋放或刪除，則該 Job 會被釋放回佇列中。一般來說，應將 `retry_after` 的值設為 Job 在合理情況下要完成執行所需的最大秒數。"

# P
#: ./docs/9.x/queues.md:1521
#: ./docs/10.x/queues.md:1607
#: ./docs/11.x/queues.md:1695
#: ./docs/master/queues.md:1615
msgid "Remember, queue workers are long-lived processes and store the booted application state in memory. As a result, they will not notice changes in your code base after they have been started. So, during your deployment process, be sure to [restart your queue workers](#queue-workers-and-deployment). In addition, remember that any static state created or modified by your application will not be automatically reset between jobs."
msgstr "請記得，Queue Worker 是會持續執行的處理程序，且會將已開啟的程式狀態保存在記憶體中。因此，Queue Worker 開始執行後若有更改程式碼，這些 Worker 將不會知道有這些修改。所以，在部署過程中，請確保有[重新啟動 Queue Worker](#queue-workers-and-deployment)。此外，也請注意，在各個 Job 間，也不會自動重設程式所建立或修改的任何^[靜態狀態](Static State)。"

# P
#: ./docs/10.x/queues.md:1522
#: ./docs/11.x/queues.md:1610
#: ./docs/master/queues.md:1530
#~ msgid "<a name=\"dynamodb-configuration\"></a>"
#~ msgstr ""

# P
#: ./docs/8.x/queues.md:1522
#: ./docs/9.x/queues.md:1633
#: ./docs/10.x/queues.md:1730
#: ./docs/11.x/queues.md:1818
#: ./docs/master/queues.md:1738
msgid "The only queue connection which does not contain a `retry_after` value is Amazon SQS. SQS will retry the job based on the [Default Visibility Timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) which is managed within the AWS console."
msgstr " 唯一一個不含 `retry_after` 值的佇列連線是 Amazon SQS。SQS 會使用[預設的 Visibility Timeout](https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/AboutVT.html) 來重試 Job。Visibility Timeout 的值由 AWS Console 中控制。"

# H4
#: ./docs/10.x/queues.md:1523
#: ./docs/11.x/queues.md:1611
#: ./docs/master/queues.md:1531
msgid "DynamoDB Configuration"
msgstr ""

# P
#: ./docs/8.x/queues.md:1524
#: ./docs/9.x/queues.md:1635
#: ./docs/10.x/queues.md:1732
#: ./docs/11.x/queues.md:1820
#: ./docs/master/queues.md:1740
#~ msgid "<a name=\"worker-timeouts\"></a>"
#~ msgstr ""

# P
#: ./docs/10.x/queues.md:1525
#: ./docs/11.x/queues.md:1613
#: ./docs/master/queues.md:1533
msgid "Next, install the AWS SDK so that your Laravel application can communicate with Amazon DynamoDB:"
msgstr ""

# H4
#: ./docs/8.x/queues.md:1525
#: ./docs/9.x/queues.md:1636
#: ./docs/10.x/queues.md:1733
#: ./docs/11.x/queues.md:1821
#: ./docs/master/queues.md:1741
msgid "Worker Timeouts"
msgstr "Worker 的逾時"

# P
#: ./docs/8.x/queues.md:1527
msgid "The `queue:work` Artisan command exposes a `--timeout` option. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration):"
msgstr "`queue:work` Aritsan 指令有一個 `--timeout` 選項。若 Job 執行超過逾時值所指定的秒數後，負責處理該 Job 的 Worker 就會以錯誤終止執行。一般來說，Worker 會自動由 [Server 上設定的 Process Manager](#supervisor-configuration) 重新開啟："

# CODE: bash
# CODE: shell
#: ./docs/8.x/queues.md:1529
#: ./docs/9.x/queues.md:1640
#: ./docs/10.x/queues.md:1737
#: ./docs/11.x/queues.md:1825
#: ./docs/master/queues.md:1745
msgid "php artisan queue:work --timeout=60"
msgstr ""

# P
#: ./docs/10.x/queues.md:1531
#: ./docs/11.x/queues.md:1619
#: ./docs/master/queues.md:1539
msgid "Then, set the `queue.batching.driver` configuration option's value to `dynamodb`. In addition, you should define `key`, `secret`, and `region` configuration options within the `batching` configuration array. These options will be used to authenticate with AWS. When using the `dynamodb` driver, the `queue.batching.database` configuration option is unnecessary:"
msgstr ""

# CODE: php
#: ./docs/10.x/queues.md:1533
#: ./docs/master/queues.md:1541
msgid ""
"'batching' => [\n"
"    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'job_batches',\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:1533
#: ./docs/9.x/queues.md:1644
#: ./docs/10.x/queues.md:1741
#: ./docs/11.x/queues.md:1829
#: ./docs/master/queues.md:1749
msgid "The `retry_after` configuration option and the `--timeout` CLI option are different, but work together to ensure that jobs are not lost and that jobs are only successfully processed once."
msgstr "雖然 `retry_after` 設定選項與 `--timeout` CLI 選項並不相同，不過這兩個選項會互相配合使用，以確保 Job 不遺失，且 Job 只會成功執行一次。"

# P
#: ./docs/8.x/queues.md:1535
#: ./docs/9.x/queues.md:1647
#: ./docs/10.x/queues.md:1744
#: ./docs/11.x/queues.md:1832
#: ./docs/master/queues.md:1752
msgid "The `--timeout` value should always be at least several seconds shorter than your `retry_after` configuration value. This will ensure that a worker processing a frozen job is always terminated before the job is retried. If your `--timeout` option is longer than your `retry_after` configuration value, your jobs may be processed twice."
msgstr "`--timeout` 的值必須至少比 `retry_after` 設定選項短個幾秒，以確保 Worker 在處理到當掉的 Job 時會在重試 Job 前先終止該 Job。若 `--timeout` 選項比 `retry_after` 設定值還要長的話，則 Job 就有可能會被處理兩次。"

# P
#: ./docs/8.x/queues.md:1537
#: ./docs/9.x/queues.md:1649
#: ./docs/10.x/queues.md:1746
#: ./docs/11.x/queues.md:1834
#: ./docs/master/queues.md:1754
#~ msgid "<a name=\"supervisor-configuration\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1538
#: ./docs/9.x/queues.md:1650
#: ./docs/10.x/queues.md:1747
#: ./docs/11.x/queues.md:1835
#: ./docs/master/queues.md:1755
msgid "Supervisor Configuration"
msgstr "Supervisor 設定"

# P
#: ./docs/8.x/queues.md:1540
#: ./docs/9.x/queues.md:1652
#: ./docs/10.x/queues.md:1749
#: ./docs/11.x/queues.md:1837
#: ./docs/master/queues.md:1757
msgid "In production, you need a way to keep your `queue:work` processes running. A `queue:work` process may stop running for a variety of reasons, such as an exceeded worker timeout or the execution of the `queue:restart` command."
msgstr "在正式環境中，我們會需要一種能讓 `queue:work` 處理程序持續執行的方法。`queue:work` 可能會因為各種原因而停止執行，如 Worker 執行達到逾時值，或是在執行了 `queue:restart` 指令後等。"

# P
#: ./docs/8.x/queues.md:1542
#: ./docs/9.x/queues.md:1654
#: ./docs/10.x/queues.md:1751
#: ./docs/11.x/queues.md:1839
#: ./docs/master/queues.md:1759
msgid "For this reason, you need to configure a process monitor that can detect when your `queue:work` processes exit and automatically restart them. In addition, process monitors can allow you to specify how many `queue:work` processes you would like to run concurrently. Supervisor is a process monitor commonly used in Linux environments and we will discuss how to configure it in the following documentation."
msgstr "因此，我們需要設定一個能偵測到 `queue:work` 處理程序終止執行，並能自動重新啟動這些 Worker 的 Process Monitor。此外，使用 Process Monitor 還能讓我們指定要同時執行多少個 `queue:work` 處理程序。Supervisor 時一個常見用於 Linux 環境的 Process Monitor，在本文中接下來的部分我們會來看看要如何設定 Supervisor。"

# P
#: ./docs/10.x/queues.md:1543
#: ./docs/11.x/queues.md:1631
#: ./docs/master/queues.md:1551
#~ msgid "<a name=\"pruning-batches-in-dynamodb\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/queues.md:1544
#: ./docs/11.x/queues.md:1632
#: ./docs/master/queues.md:1552
msgid "Pruning Batches in DynamoDB"
msgstr ""

# P
#: ./docs/8.x/queues.md:1544
#: ./docs/9.x/queues.md:1656
#: ./docs/10.x/queues.md:1753
#: ./docs/11.x/queues.md:1841
#: ./docs/master/queues.md:1761
#~ msgid "<a name=\"installing-supervisor\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1545
#: ./docs/9.x/queues.md:1657
#: ./docs/10.x/queues.md:1754
#: ./docs/11.x/queues.md:1842
#: ./docs/master/queues.md:1762
msgid "Installing Supervisor"
msgstr "安裝 Supervisor"

# P
#: ./docs/10.x/queues.md:1546
#: ./docs/11.x/queues.md:1634
#: ./docs/master/queues.md:1554
msgid "When utilizing [DynamoDB](https://aws.amazon.com/dynamodb) to store job batch information, the typical pruning commands used to prune batches stored in a relational database will not work. Instead, you may utilize [DynamoDB's native TTL functionality](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/TTL.html) to automatically remove records for old batches."
msgstr ""

# P
#: ./docs/8.x/queues.md:1547
#: ./docs/9.x/queues.md:1659
#: ./docs/10.x/queues.md:1756
#: ./docs/11.x/queues.md:1844
#: ./docs/master/queues.md:1764
msgid "Supervisor is a process monitor for the Linux operating system, and will automatically restart your `queue:work` processes if they fail. To install Supervisor on Ubuntu, you may use the following command:"
msgstr "Supervisor 是一個用於 Linux 作業系統的 Process Monitor，使用 Supervisor 就可以在 `queue:work` 處理程序執行失敗時自動重新啟動。若要在 Ubuntu 上安裝 Supervisor，可使用下列指令："

# P
#: ./docs/10.x/queues.md:1548
#: ./docs/11.x/queues.md:1636
#: ./docs/master/queues.md:1556
msgid "If you defined your DynamoDB table with a `ttl` attribute, you may define configuration parameters to instruct Laravel how to prune batch records. The `queue.batching.ttl_attribute` configuration value defines the name of the attribute holding the TTL, while the `queue.batching.ttl` configuration value defines the number of seconds after which a batch record can be removed from the DynamoDB table, relative to the last time the record was updated:"
msgstr ""

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1549
#: ./docs/9.x/queues.md:1661
#: ./docs/10.x/queues.md:1758
#: ./docs/11.x/queues.md:1846
#: ./docs/master/queues.md:1766
msgid "sudo apt-get install supervisor"
msgstr ""

# CODE: php
#: ./docs/10.x/queues.md:1550
#: ./docs/11.x/queues.md:1638
#: ./docs/master/queues.md:1558
msgid ""
"'batching' => [\n"
"    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'job_batches',\n"
"    'ttl_attribute' => 'ttl',\n"
"    'ttl' => 60 * 60 * 24 * 7, // 7 days...\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:1551
#: ./docs/9.x/queues.md:1666
#: ./docs/10.x/queues.md:1763
#: ./docs/11.x/queues.md:1851
#: ./docs/master/queues.md:1771
msgid "If configuring and managing Supervisor yourself sounds overwhelming, consider using [Laravel Forge](https://forge.laravel.com), which will automatically install and configure Supervisor for your production Laravel projects."
msgstr "如果你覺得要設定並管理 Supervisor 太難、太複雜的話，可以考慮使用 [Laravel Forge](https://forge.laravel.com)。Laravel Forge 會幫你在 Laravel 專案的正式環境上自動安裝並設定 Supervisor。"

# P
#: ./docs/8.x/queues.md:1553
#: ./docs/9.x/queues.md:1668
#: ./docs/10.x/queues.md:1765
#: ./docs/11.x/queues.md:1853
#: ./docs/master/queues.md:1773
#~ msgid "<a name=\"configuring-supervisor\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1554
#: ./docs/9.x/queues.md:1669
#: ./docs/10.x/queues.md:1766
#: ./docs/11.x/queues.md:1854
#: ./docs/master/queues.md:1774
msgid "Configuring Supervisor"
msgstr "設定 Supervisor"

# P
#: ./docs/8.x/queues.md:1556
#: ./docs/9.x/queues.md:1671
#: ./docs/10.x/queues.md:1768
#: ./docs/11.x/queues.md:1856
#: ./docs/master/queues.md:1776
msgid "Supervisor configuration files are typically stored in the `/etc/supervisor/conf.d` directory. Within this directory, you may create any number of configuration files that instruct supervisor how your processes should be monitored. For example, let's create a `laravel-worker.conf` file that starts and monitors `queue:work` processes:"
msgstr "Supervisor 設定檔一般都存放在 `/etc/supervisor/conf.d` 目錄下。在該目錄中，我們可以建立任意數量的設定檔，以告訴 Supervisor 要如何監看這些處理程序。舉例來說，我們先建立一個用於啟動並監看 `queue:work` 處理程序的 `laravel-worker.conf` 檔案："

# CODE: ini
#: ./docs/8.x/queues.md:1558
#: ./docs/9.x/queues.md:1673
#: ./docs/10.x/queues.md:1770
#: ./docs/11.x/queues.md:1858
#: ./docs/master/queues.md:1778
msgid ""
"[program:laravel-worker]\n"
"process_name=%(program_name)s_%(process_num)02d\n"
"command=php /home/forge/app.com/artisan queue:work sqs --sleep=3 --tries=3 --max-time=3600\n"
"autostart=true\n"
"autorestart=true\n"
"stopasgroup=true\n"
"killasgroup=true\n"
"user=forge\n"
"numprocs=8\n"
"redirect_stderr=true\n"
"stdout_logfile=/home/forge/app.com/worker.log\n"
"stopwaitsecs=3600"
msgstr ""

# P
#: ./docs/8.x/queues.md:1573
#: ./docs/9.x/queues.md:1688
#: ./docs/10.x/queues.md:1785
#: ./docs/11.x/queues.md:1873
#: ./docs/master/queues.md:1793
msgid "In this example, the `numprocs` directive will instruct Supervisor to run eight `queue:work` processes and monitor all of them, automatically restarting them if they fail. You should change the `command` directive of the configuration to reflect your desired queue connection and worker options."
msgstr "在這個範例中，`numprocs` 指示詞用於告訴 Supervisor 要執行 8 個 `queue:work` 處理程序，並監看這 8 個處理程序，然後當這些處理程序執行失敗時自動重新啟動。我們可以更改該設定檔中的 `command` 指示詞，以調整為所需的佇列連線與 Worker 選項。"

# CODE
#: ./docs/11.x/queues.md:1574
#: ./docs/master/queues.md:1494
msgid ""
"use Illuminate\\Support\\Facades\\Schedule;\n"
"\n"
"Schedule::command('queue:prune-batches')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1575
#: ./docs/9.x/queues.md:1691
#: ./docs/10.x/queues.md:1788
#: ./docs/11.x/queues.md:1876
#: ./docs/master/queues.md:1796
msgid "You should ensure that the value of `stopwaitsecs` is greater than the number of seconds consumed by your longest running job. Otherwise, Supervisor may kill the job before it is finished processing."
msgstr "請務必確保 `stopwaitsecs` 值比花費時間最多的 Job 所需執行的秒數還要大。若該值設定不對，可能會讓 Supervisor 在 Job 處理完成前就終止該 Job。"

# P
#: ./docs/8.x/queues.md:1577
#: ./docs/9.x/queues.md:1693
#: ./docs/10.x/queues.md:1790
#: ./docs/11.x/queues.md:1878
#: ./docs/master/queues.md:1798
#~ msgid "<a name=\"starting-supervisor\"></a>"
#~ msgstr ""

# H4
#: ./docs/8.x/queues.md:1578
#: ./docs/9.x/queues.md:1694
#: ./docs/10.x/queues.md:1791
#: ./docs/11.x/queues.md:1879
#: ./docs/master/queues.md:1799
msgid "Starting Supervisor"
msgstr "開啟 Supervisor"

# CODE: shell
#: ./docs/9.x/queues.md:1578
#: ./docs/10.x/queues.md:1664
#: ./docs/11.x/queues.md:1752
#: ./docs/master/queues.md:1672
msgid ""
"# Process jobs for one hour and then exit...\n"
"php artisan queue:work --max-time=3600"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:1580
#: ./docs/master/queues.md:1500
msgid ""
"use Illuminate\\Support\\Facades\\Schedule;\n"
"\n"
"Schedule::command('queue:prune-batches --hours=48')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1580
#: ./docs/9.x/queues.md:1696
#: ./docs/10.x/queues.md:1793
#: ./docs/11.x/queues.md:1881
#: ./docs/master/queues.md:1801
msgid "Once the configuration file has been created, you may update the Supervisor configuration and start the processes using the following commands:"
msgstr "建立好設定檔後，我們就可以使用下列指令更新 Supervisor 設定並開啟我們設定好的處理程序："

# CODE: bash
# CODE: shell
#: ./docs/8.x/queues.md:1582
#: ./docs/9.x/queues.md:1698
msgid ""
"sudo supervisorctl reread\n"
"\n"
"sudo supervisorctl update\n"
"\n"
"sudo supervisorctl start laravel-worker:*"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:1586
#: ./docs/master/queues.md:1506
msgid ""
"use Illuminate\\Support\\Facades\\Schedule;\n"
"\n"
"Schedule::command('queue:prune-batches --hours=48 --unfinished=72')->daily();"
msgstr ""

# P
#: ./docs/9.x/queues.md:1586
#: ./docs/10.x/queues.md:1672
#: ./docs/11.x/queues.md:1760
#: ./docs/master/queues.md:1680
msgid "When jobs are available on the queue, the worker will keep processing jobs with no delay in between jobs. However, the `sleep` option determines how many seconds the worker will \"sleep\" if there are no jobs available. Of course, while sleeping, the worker will not process any new jobs:"
msgstr "若佇列中有 Job，則 Worker 會不間斷地處理這些 Job。不過，使用 `sleep` 選項可用來讓 Worker 判斷當沒有 Job 時要「休眠」多少秒。當然，在休眠期間，Worker 就不會處理任何新的 Job："

# H2
#: ./docs/10.x/queues.md:1587
#: ./docs/11.x/queues.md:1675
#: ./docs/master/queues.md:1595
msgid "Running the Queue Worker"
msgstr ""

# P
#: ./docs/8.x/queues.md:1590
#: ./docs/9.x/queues.md:1706
#: ./docs/10.x/queues.md:1803
#: ./docs/11.x/queues.md:1891
#: ./docs/master/queues.md:1811
msgid "For more information on Supervisor, consult the [Supervisor documentation](http://supervisord.org/index.html)."
msgstr "更多有關 Supervisor 的資訊，請參考 [Supervisor 的說明文件](http://supervisord.org/index.html)。"

# CODE
#: ./docs/11.x/queues.md:1592
#: ./docs/master/queues.md:1512
msgid ""
"use Illuminate\\Support\\Facades\\Schedule;\n"
"\n"
"Schedule::command('queue:prune-batches --hours=48 --cancelled=72')->daily();"
msgstr ""

# P
#: ./docs/8.x/queues.md:1592
#: ./docs/9.x/queues.md:1708
#: ./docs/10.x/queues.md:1805
#: ./docs/11.x/queues.md:1893
#: ./docs/master/queues.md:1813
#~ msgid "<a name=\"dealing-with-failed-jobs\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1593
#: ./docs/9.x/queues.md:1709
#: ./docs/10.x/queues.md:1806
#: ./docs/11.x/queues.md:1894
#: ./docs/master/queues.md:1814
msgid "Dealing With Failed Jobs"
msgstr "處理失敗的 Job"

# P
#: ./docs/8.x/queues.md:1595
msgid "Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to [specify the maximum number of times a job should be attempted](#max-job-attempts-and-timeout). After a job has exceeded this number of attempts, it will be inserted into the `failed_jobs` database table. Of course, we will need to create that table if it does not already exist. To create a migration for the `failed_jobs` table, you may use the `queue:failed-table` command:"
msgstr "有時候，放入佇列的 Job 可能會執行失敗。請別擔心，計劃永遠趕不上變化！Laravel 中內建了一個方便的方法，可用來[指定 Job 要重試的最大次數](#max-job-attempts-and-timeout)。若某個 Job 已經達到重試次數的最大限制，則該 Job 就會被插入 `failed_jobs` 資料庫資料表中。當然，若沒有這個資料表的話，我們需要先建立該資料表。若要為 `failed_jobs` 資料表建立 Migration，可使用 `queue:failed-tables` 指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1597
#: ./docs/9.x/queues.md:1715
#: ./docs/10.x/queues.md:1812
msgid ""
"php artisan queue:failed-table\n"
"\n"
"php artisan migrate"
msgstr ""

# P
#: ./docs/8.x/queues.md:1601
#: ./docs/9.x/queues.md:1721
#: ./docs/10.x/queues.md:1818
#: ./docs/11.x/queues.md:1906
#: ./docs/master/queues.md:1826
msgid "When running a [queue worker](#running-the-queue-worker) process, you may specify the maximum number of times a job should be attempted using the `--tries` switch on the `queue:work` command. If you do not specify a value for the `--tries` option, jobs will only be attempted once or as many times as specified by the job class' `$tries` property:"
msgstr "在執行 [Queue Worker] 處理程序時，我們可以使用 `queue:work` 指令上的 `--tries` 開關來指定某個 Job 所要嘗試執行的最大次數。若為指定 `--tries` 選項的值，則 Job 就只會嘗試執行一次，或是依照 Job 類別中 `$tries` 屬性所設定的值作為最大嘗試次數："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1603
#: ./docs/9.x/queues.md:1723
#: ./docs/10.x/queues.md:1820
#: ./docs/11.x/queues.md:1908
#: ./docs/master/queues.md:1828
msgid "php artisan queue:work redis --tries=3"
msgstr ""

# P
#: ./docs/8.x/queues.md:1605
#: ./docs/9.x/queues.md:1727
#: ./docs/10.x/queues.md:1824
#: ./docs/11.x/queues.md:1912
#: ./docs/master/queues.md:1832
msgid "Using the `--backoff` option, you may specify how many seconds Laravel should wait before retrying a job that has encountered an exception. By default, a job is immediately released back onto the queue so that it may be attempted again:"
msgstr "使用 `--backoff` 選項，就可指定當 Job 遇到 Exception 時，Laravel 要等待多少秒才重新嘗試該 Job。預設情況下，Job 會馬上被釋放回佇列中，以便重新嘗試該 Job："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1607
#: ./docs/9.x/queues.md:1729
#: ./docs/10.x/queues.md:1826
#: ./docs/11.x/queues.md:1914
#: ./docs/master/queues.md:1834
msgid "php artisan queue:work redis --tries=3 --backoff=3"
msgstr ""

# P
#: ./docs/8.x/queues.md:1609
#: ./docs/9.x/queues.md:1733
#: ./docs/10.x/queues.md:1830
#: ./docs/11.x/queues.md:1918
#: ./docs/master/queues.md:1838
msgid "If you would like to configure how many seconds Laravel should wait before retrying a job that has encountered an exception on a per-job basis, you may do so by defining a `backoff` property on your job class:"
msgstr "若想以 Job 為單位來設定當 Job 遇到 Exception 時 Laravel 要等待多少秒才重新嘗試該 Job，則可在 Job 類別上定義 `backoff` 屬性："

# CODE
#: ./docs/8.x/queues.md:1611
#: ./docs/9.x/queues.md:1735
#: ./docs/10.x/queues.md:1832
#: ./docs/11.x/queues.md:1920
#: ./docs/master/queues.md:1840
msgid ""
"/**\n"
" * The number of seconds to wait before retrying the job.\n"
" *\n"
" * @var int\n"
" */\n"
"public $backoff = 3;"
msgstr ""

# P
#: ./docs/8.x/queues.md:1618
#: ./docs/9.x/queues.md:1742
#: ./docs/10.x/queues.md:1839
#: ./docs/11.x/queues.md:1927
#: ./docs/master/queues.md:1847
msgid "If you require more complex logic for determining the job's backoff time, you may define a `backoff` method on your job class:"
msgstr "若需要使用更複雜的邏輯來判斷 Job 的 Backoff 時間，可在 Job 類別上定義 `backoff` 方法："

# CODE
#: ./docs/8.x/queues.md:1620
#: ./docs/9.x/queues.md:1744
msgid ""
"/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*\n"
"* @return int\n"
"*/\n"
"public function backoff()\n"
"{\n"
"    return 3;\n"
"}"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1621
#: ./docs/11.x/queues.md:1709
#: ./docs/master/queues.md:1629
msgid "Specifying the Connection and Queue"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:1621
msgid ""
"'batching' => [\n"
"    'driver' => env('QUEUE_BATCHING_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'job_batches',\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:1630
#: ./docs/9.x/queues.md:1754
msgid "You may easily configure \"exponential\" backoffs by returning an array of backoff values from the `backoff` method. In this example, the retry delay will be 1 second for the first retry, 5 seconds for the second retry, and 10 seconds for the third retry:"
msgstr "只要在 `backoff` 方法中回傳一組包含 Backoff 值的陣列，就能輕鬆地設定「指數級」的 Backoff。在這個例子中，第一次重試的延遲為 1 秒，第二次重試為 5 秒，第三次重試為 10 秒："

# CODE
#: ./docs/8.x/queues.md:1632
#: ./docs/9.x/queues.md:1756
msgid ""
"/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*\n"
"* @return array\n"
"*/\n"
"public function backoff()\n"
"{\n"
"    return [1, 5, 10];\n"
"}"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1636
#: ./docs/11.x/queues.md:1724
#: ./docs/master/queues.md:1644
msgid "Processing a Specified Number of Jobs"
msgstr ""

# P
#: ./docs/9.x/queues.md:1638
#: ./docs/10.x/queues.md:1735
#: ./docs/11.x/queues.md:1823
#: ./docs/master/queues.md:1743
msgid "The `queue:work` Artisan command exposes a `--timeout` option. By default, the `--timeout` value is 60 seconds. If a job is processing for longer than the number of seconds specified by the timeout value, the worker processing the job will exit with an error. Typically, the worker will be restarted automatically by a [process manager configured on your server](#supervisor-configuration):"
msgstr "`queue:work` Aritsan 指令有一個 `--timeout` 選項。預設情況下，`--timeout` 值為 60 秒。若 Job 執行超過逾時值所指定的秒數後，負責處理該 Job 的 Worker 就會以錯誤終止執行。一般來說，Worker 會自動由 [Server 上設定的 Process Manager](#supervisor-configuration) 重新開啟："

# P
#: ./docs/8.x/queues.md:1642
#: ./docs/9.x/queues.md:1766
#: ./docs/10.x/queues.md:1861
#: ./docs/11.x/queues.md:1949
#: ./docs/master/queues.md:1869
#~ msgid "<a name=\"cleaning-up-after-failed-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1643
#: ./docs/9.x/queues.md:1767
#: ./docs/10.x/queues.md:1862
#: ./docs/11.x/queues.md:1950
#: ./docs/master/queues.md:1870
msgid "Cleaning Up After Failed Jobs"
msgstr "當 Job 執行失敗後進行清理"

# P
#: ./docs/8.x/queues.md:1645
#: ./docs/9.x/queues.md:1769
#: ./docs/10.x/queues.md:1864
#: ./docs/11.x/queues.md:1952
#: ./docs/master/queues.md:1872
msgid "When a particular job fails, you may want to send an alert to your users or revert any actions that were partially completed by the job. To accomplish this, you may define a `failed` method on your job class. The `Throwable` instance that caused the job to fail will be passed to the `failed` method:"
msgstr "若某個特定的 Job 失敗後，我們可能會想傳送通知給使用者，或是恢復這個 Job 中所部分完成的一些動作。為此，我們可以在 Job 類別中定義一個 `failed` 方法。導致該 Job 失敗的 `Throwable` 實體會傳入給 `failed` 方法："

# CODE
#: ./docs/8.x/queues.md:1647
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"use Throwable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Podcast\n"
"     */\n"
"    protected $podcast;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  \\App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"\n"
"    /**\n"
"     * Handle a job failure.\n"
"     *\n"
"     * @param  \\Throwable  $exception\n"
"     * @return void\n"
"     */\n"
"    public function failed(Throwable $exception)\n"
"    {\n"
"        // Send user notification of failure, etc...\n"
"    }\n"
"}"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1651
#: ./docs/11.x/queues.md:1739
#: ./docs/master/queues.md:1659
msgid "Processing All Queued Jobs and Then Exiting"
msgstr ""

# P
#: ./docs/11.x/queues.md:1653
msgid "Instead of dispatching a job class to the queue, you may also dispatch a closure. This is great for quick, simple tasks that need to be executed outside of the current request cycle. When dispatching closures to the queue, the closure's code content is cryptographically signed so that it cannot be modified in transit:"
msgstr ""

# H4
#: ./docs/10.x/queues.md:1660
#: ./docs/11.x/queues.md:1748
#: ./docs/master/queues.md:1668
msgid "Processing Jobs for a Given Number of Seconds"
msgstr ""

# P
#: ./docs/10.x/queues.md:1678
#: ./docs/11.x/queues.md:1766
#: ./docs/master/queues.md:1686
#~ msgid "<a name=\"maintenance-mode-queues\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/queues.md:1679
#: ./docs/11.x/queues.md:1767
#: ./docs/master/queues.md:1687
msgid "Maintenance Mode and Queues"
msgstr ""

# P
#: ./docs/10.x/queues.md:1681
#: ./docs/11.x/queues.md:1769
#: ./docs/master/queues.md:1689
msgid "While your application is in [maintenance mode](/docs/{{version}}/configuration#maintenance-mode), no queued jobs will be handled. The jobs will continue to be handled as normal once the application is out of maintenance mode."
msgstr ""

# P
#: ./docs/10.x/queues.md:1683
#: ./docs/11.x/queues.md:1771
#: ./docs/master/queues.md:1691
msgid "To force your queue workers to process jobs even if maintenance mode is enabled, you may use `--force` option:"
msgstr ""

# CODE: shell
#: ./docs/10.x/queues.md:1685
#: ./docs/11.x/queues.md:1773
#: ./docs/master/queues.md:1693
msgid "php artisan queue:work --force"
msgstr ""

# P
#: ./docs/8.x/queues.md:1704
#: ./docs/9.x/queues.md:1829
#: ./docs/10.x/queues.md:1907
#: ./docs/11.x/queues.md:1993
#: ./docs/master/queues.md:1915
msgid "A new instance of the job is instantiated before invoking the `failed` method; therefore, any class property modifications that may have occurred within the `handle` method will be lost."
msgstr "叫用 `failed` 方法前會先初始化該 Job 的一個新。因此，在 `handle` 方法中對類別屬性做出的更改都將遺失。"

# P
#: ./docs/8.x/queues.md:1706
#: ./docs/9.x/queues.md:1831
#: ./docs/10.x/queues.md:1909
#: ./docs/11.x/queues.md:1995
#: ./docs/master/queues.md:1917
#~ msgid "<a name=\"retrying-failed-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1707
#: ./docs/9.x/queues.md:1832
#: ./docs/10.x/queues.md:1910
#: ./docs/11.x/queues.md:1996
#: ./docs/master/queues.md:1918
msgid "Retrying Failed Jobs"
msgstr "重試失敗的 Job"

# H3
#: ./docs/10.x/queues.md:1708
#: ./docs/11.x/queues.md:1796
#: ./docs/master/queues.md:1716
msgid "Queue Workers and Deployment"
msgstr ""

# P
#: ./docs/8.x/queues.md:1709
#: ./docs/9.x/queues.md:1834
#: ./docs/10.x/queues.md:1912
#: ./docs/11.x/queues.md:1998
#: ./docs/master/queues.md:1920
msgid "To view all of the failed jobs that have been inserted into your `failed_jobs` database table, you may use the `queue:failed` Artisan command:"
msgstr "若要檢視所有已插入 `failed_jobs` 資料表中失敗的 Job，可使用 `queue:failed` Artisan 指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1711
#: ./docs/9.x/queues.md:1836
#: ./docs/10.x/queues.md:1914
#: ./docs/11.x/queues.md:2000
#: ./docs/master/queues.md:1922
msgid "php artisan queue:failed"
msgstr ""

# P
#: ./docs/9.x/queues.md:1711
#: ./docs/10.x/queues.md:1808
#: ./docs/11.x/queues.md:1896
#: ./docs/master/queues.md:1816
msgid "Sometimes your queued jobs will fail. Don't worry, things don't always go as planned! Laravel includes a convenient way to [specify the maximum number of times a job should be attempted](#max-job-attempts-and-timeout). After an asynchronous job has exceeded this number of attempts, it will be inserted into the `failed_jobs` database table. [Synchronously dispatched jobs](/docs/{{version}}/queues#synchronous-dispatching) that fail are not stored in this table and their exceptions are immediately handled by the application."
msgstr "有時候，放入佇列的 Job 可能會執行失敗。請別擔心，計劃永遠趕不上變化！Laravel 中內建了一個方便的方法，可用來[指定 Job 要重試的最大次數](#max-job-attempts-and-timeout)。若^[非同步](Asynchronous)執行的 Job 超過最大嘗試執行次數，則該 Job 會被插入到 `failed_jobs` 資料庫資料表中。[同步分派的 Job](/docs/{{version}}/queues#synchronous-dispatching) 若執行失敗，則不會被保存在該資料表中，而我們的專案則會馬上收到 Job 產生的 Exception。"

# P
#: ./docs/8.x/queues.md:1713
#: ./docs/9.x/queues.md:1840
#: ./docs/10.x/queues.md:1918
#: ./docs/11.x/queues.md:2004
#: ./docs/master/queues.md:1926
msgid "The `queue:failed` command will list the job ID, connection, queue, failure time, and other information about the job. The job ID may be used to retry the failed job. For instance, to retry a failed job that has an ID of `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece`, issue the following command:"
msgstr "`queue:failed` 指令會列出 Job ID、連線、佇列、失敗時間……等，以及其他有關該 Job 的資訊。可使用 Job ID 來重試失敗的 Job。舉例來說，若要重試 ID 為 `ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece` 的失敗 Job，請執行下列指令："

# P
#: ./docs/9.x/queues.md:1713
#: ./docs/10.x/queues.md:1810
msgid "A migration to create the `failed_jobs` table is typically already present in new Laravel applications. However, if your application does not contain a migration for this table, you may use the `queue:failed-table` command to create the migration:"
msgstr "在新安裝的 Laravel 專案中，通常已包含了一個建立 `failed_jobs` 資料表的 Migration。不過，若專案未包含該資料表的 Migration，則可使用 `queue:failed-table` 指令來建立該 Migration："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1715
#: ./docs/9.x/queues.md:1842
#: ./docs/10.x/queues.md:1920
#: ./docs/11.x/queues.md:2006
#: ./docs/master/queues.md:1928
msgid "php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece"
msgstr ""

# P
#: ./docs/8.x/queues.md:1717
#: ./docs/9.x/queues.md:1846
#: ./docs/10.x/queues.md:1924
#: ./docs/11.x/queues.md:2010
#: ./docs/master/queues.md:1932
msgid "If necessary, you may pass multiple IDs to the command:"
msgstr "若有需要，可傳入多個 ID 給該指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1719
#: ./docs/9.x/queues.md:1848
#: ./docs/10.x/queues.md:1926
#: ./docs/11.x/queues.md:2012
#: ./docs/master/queues.md:1934
msgid "php artisan queue:retry ce7bb17c-cdd8-41f0-a8ec-7b4fef4e5ece 91401d2c-0784-4f43-824c-34f94a33c24d"
msgstr ""

# P
#: ./docs/8.x/queues.md:1721
#: ./docs/9.x/queues.md:1852
#: ./docs/10.x/queues.md:1930
#: ./docs/11.x/queues.md:2016
#: ./docs/master/queues.md:1938
msgid "You may also retry all of the failed jobs for a particular queue:"
msgstr "也可以嘗試特定佇列中所有失敗的 Job："

# H3
#: ./docs/10.x/queues.md:1722
#: ./docs/11.x/queues.md:1810
#: ./docs/master/queues.md:1730
msgid "Job Expirations and Timeouts"
msgstr ""

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1723
#: ./docs/9.x/queues.md:1854
#: ./docs/10.x/queues.md:1932
#: ./docs/11.x/queues.md:2018
#: ./docs/master/queues.md:1940
msgid "php artisan queue:retry --queue=name"
msgstr ""

# P
#: ./docs/8.x/queues.md:1725
#: ./docs/9.x/queues.md:1858
#: ./docs/10.x/queues.md:1936
#: ./docs/11.x/queues.md:2022
#: ./docs/master/queues.md:1944
msgid "To retry all of your failed jobs, execute the `queue:retry` command and pass `all` as the ID:"
msgstr "若要重試所有失敗的 Job，請執行 `queue:retry` 指令，並傳入 `all` 作為 ID："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1727
#: ./docs/9.x/queues.md:1860
#: ./docs/10.x/queues.md:1938
#: ./docs/11.x/queues.md:2024
#: ./docs/master/queues.md:1946
msgid "php artisan queue:retry all"
msgstr ""

# P
#: ./docs/8.x/queues.md:1729
#: ./docs/9.x/queues.md:1864
#: ./docs/10.x/queues.md:1942
#: ./docs/11.x/queues.md:2028
#: ./docs/master/queues.md:1950
msgid "If you would like to delete a failed job, you may use the `queue:forget` command:"
msgstr "若想刪除失敗的 Job，可使用 `queue:forget` 指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1731
#: ./docs/9.x/queues.md:1866
#: ./docs/10.x/queues.md:1944
#: ./docs/11.x/queues.md:2030
#: ./docs/master/queues.md:1952
msgid "php artisan queue:forget 91401d2c-0784-4f43-824c-34f94a33c24d"
msgstr ""

# P
#: ./docs/8.x/queues.md:1733
#: ./docs/9.x/queues.md:1871
#: ./docs/10.x/queues.md:1949
#: ./docs/11.x/queues.md:2035
#: ./docs/master/queues.md:1957
msgid "When using [Horizon](/docs/{{version}}/horizon), you should use the `horizon:forget` command to delete a failed job instead of the `queue:forget` command."
msgstr "使用 [Horizon](/docs/{{version}}/horizon)，請不要使用 `queue:forget` 指令，請使用 `horizon:forget` 指令來刪除失敗的 Job。"

# P
#: ./docs/8.x/queues.md:1735
#: ./docs/9.x/queues.md:1873
#: ./docs/10.x/queues.md:1951
#: ./docs/11.x/queues.md:2037
#: ./docs/master/queues.md:1959
msgid "To delete all of your failed jobs from the `failed_jobs` table, you may use the `queue:flush` command:"
msgstr "若要從 `failed_jobs` 資料表中刪除所有失敗的 Job，可使用 `queue:flush` 指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1737
#: ./docs/9.x/queues.md:1875
#: ./docs/10.x/queues.md:1953
#: ./docs/11.x/queues.md:2039
#: ./docs/master/queues.md:1961
msgid "php artisan queue:flush"
msgstr ""

# P
#: ./docs/8.x/queues.md:1739
#: ./docs/9.x/queues.md:1879
#: ./docs/10.x/queues.md:1957
#: ./docs/11.x/queues.md:2043
#: ./docs/master/queues.md:1965
#~ msgid "<a name=\"ignoring-missing-models\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1740
#: ./docs/9.x/queues.md:1880
#: ./docs/10.x/queues.md:1958
#: ./docs/11.x/queues.md:2044
#: ./docs/master/queues.md:1966
msgid "Ignoring Missing Models"
msgstr "忽略不存在的 Model"

# P
#: ./docs/8.x/queues.md:1742
#: ./docs/9.x/queues.md:1882
#: ./docs/10.x/queues.md:1960
#: ./docs/11.x/queues.md:2046
#: ./docs/master/queues.md:1968
msgid "When injecting an Eloquent model into a job, the model is automatically serialized before being placed on the queue and re-retrieved from the database when the job is processed. However, if the model has been deleted while the job was waiting to be processed by a worker, your job may fail with a `ModelNotFoundException`."
msgstr "將 Eloquent Model 插入進 Job 時，該 Model 會自動被序列化再放入佇列中，並在要處理該 Job 時再重新從資料庫中取出。不過，若在該 Job 等待被 Worker 處理的期間刪除了該 Model，則 Job 可能會遇到 `ModelNotFoundException` 而失敗。"

# P
#: ./docs/8.x/queues.md:1744
#: ./docs/9.x/queues.md:1884
#: ./docs/10.x/queues.md:1962
#: ./docs/11.x/queues.md:2048
#: ./docs/master/queues.md:1970
msgid "For convenience, you may choose to automatically delete jobs with missing models by setting your job's `deleteWhenMissingModels` property to `true`. When this property is set to `true`, Laravel will quietly discard the job without raising an exception:"
msgstr "為了方便起見，可將 Job 的 `deleteWhenMissingModels` 屬性設為 `true`，就可以自動刪除有遺失 Model 的 Job。若該選項設為 `true`，則 Laravel 會自動默默地在不產生 Exception 的情況下取消該 Job："

# CODE
#: ./docs/8.x/queues.md:1746
#: ./docs/9.x/queues.md:1886
#: ./docs/10.x/queues.md:1964
#: ./docs/11.x/queues.md:2050
#: ./docs/master/queues.md:1972
msgid ""
"/**\n"
" * Delete the job if its models no longer exist.\n"
" *\n"
" * @var bool\n"
" */\n"
"public $deleteWhenMissingModels = true;"
msgstr ""

# P
#: ./docs/8.x/queues.md:1753
#: ./docs/9.x/queues.md:1893
#: ./docs/10.x/queues.md:1971
#: ./docs/11.x/queues.md:2057
#: ./docs/master/queues.md:1979
#~ msgid "<a name=\"pruning-failed-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1754
#: ./docs/9.x/queues.md:1894
#: ./docs/10.x/queues.md:1972
#: ./docs/11.x/queues.md:2058
#: ./docs/master/queues.md:1980
msgid "Pruning Failed Jobs"
msgstr "修剪失敗的 Job"

# P
#: ./docs/8.x/queues.md:1756
msgid "You may delete all of the records in your application's `failed_jobs` table by invoking the `queue:prune-failed` Artisan command:"
msgstr "可以呼叫 `queue:prune-failed` Artisan 指令來刪除專案中所有 `failed_jobs` 資料表中的記錄："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1758
#: ./docs/9.x/queues.md:1898
#: ./docs/10.x/queues.md:1976
#: ./docs/11.x/queues.md:2062
#: ./docs/master/queues.md:1984
msgid "php artisan queue:prune-failed"
msgstr ""

# P
#: ./docs/8.x/queues.md:1760
msgid "If you provide the `--hours` option to the command, only the failed job records that were inserted within the last N number of hours will be retained. For example, the following command will delete all of the failed job records that were inserted more than 48 hours ago:"
msgstr "若有提供 `--hours` 選項給該指令，則只會保留過去 N 小時中所插入的失敗 Job 記錄。舉例來說，下列指令會刪除所有插入超過 48 小時的失敗 Job 記錄："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1762
#: ./docs/9.x/queues.md:1904
#: ./docs/10.x/queues.md:1982
#: ./docs/11.x/queues.md:2068
#: ./docs/master/queues.md:1990
msgid "php artisan queue:prune-failed --hours=48"
msgstr ""

# P
#: ./docs/8.x/queues.md:1764
#: ./docs/9.x/queues.md:1908
#: ./docs/10.x/queues.md:1986
#: ./docs/11.x/queues.md:2072
#: ./docs/master/queues.md:1994
#~ msgid "<a name=\"storing-failed-jobs-in-dynamodb\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1765
#: ./docs/9.x/queues.md:1909
msgid "Storing Failed Jobs In DynamoDB"
msgstr "排序 DynamoDB 中的失敗 Job"

# P
#: ./docs/8.x/queues.md:1767
#: ./docs/9.x/queues.md:1911
msgid "Laravel also provides support for storing your failed job records in [DynamoDB](https://aws.amazon.com/dynamodb) instead of a relational database table. However, you must create a DynamoDB table to store all of the failed job records. Typically, this table should be named `failed_jobs`, but you should name the table based on the value of the `queue.failed.table` configuration value within your application's `queue` configuration file."
msgstr "出了將失敗 Job 記錄保存在關聯式資料庫資料表意外，在 Laravel 中，也支援將失敗 Job 記錄保存在 [DynamoDB](https://aws.amazon.com/dynamodb) 中。不過，若要保存在 DynamoDB 資料表中，我們需要先建立一個 DynamoDB 資料表來保存失敗的 Job 記錄。一般來說，這個資料表的名稱應為 `failed_jobs`，不過，請依照專案的 `queue` 設定檔中 `queue.failed.table` 設定值來命名資料表。"

# P
#: ./docs/8.x/queues.md:1769
#: ./docs/9.x/queues.md:1913
#: ./docs/10.x/queues.md:1991
#: ./docs/11.x/queues.md:2077
#: ./docs/master/queues.md:1999
msgid "The `failed_jobs` table should have a string primary partition key named `application` and a string primary sort key named `uuid`. The `application` portion of the key will contain your application's name as defined by the `name` configuration value within your application's `app` configuration file. Since the application name is part of the DynamoDB table's key, you can use the same table to store failed jobs for multiple Laravel applications."
msgstr "`failed_jobs` 資料表應有一個名為 `application` 的字串^[主分區索引鍵](Primary Partition Key)，以及一個名為 `uuid` 的字串^[主排序索引鍵](Primary Sort Key)。索引鍵的 `application` 這個部分會包含專案的名稱，即 `app` 設定檔中的 `name` 設定值。由於專案名稱會是 DynamoDB 資料表中索引鍵的一部分，因此，我們可以使用相同的資料表來保存多個 Laravel 專案中的失敗 Job。"

# P
#: ./docs/8.x/queues.md:1771
#: ./docs/9.x/queues.md:1915
#: ./docs/10.x/queues.md:1993
#: ./docs/11.x/queues.md:2079
#: ./docs/master/queues.md:2001
msgid "In addition, ensure that you install the AWS SDK so that your Laravel application can communicate with Amazon DynamoDB:"
msgstr "此外，也請確保有安裝 AWS SDK，好讓 Laravel 專案能與 Amazon DynamoDB 溝通："

# CODE
#: ./docs/9.x/queues.md:1771
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"use Throwable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * The podcast instance.\n"
"     *\n"
"     * @var \\App\\Podcast\n"
"     */\n"
"    public $podcast;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Podcast  $podcast\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Podcast $podcast)\n"
"    {\n"
"        $this->podcast = $podcast;\n"
"    }\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     *\n"
"     * @param  \\App\\Services\\AudioProcessor  $processor\n"
"     * @return void\n"
"     */\n"
"    public function handle(AudioProcessor $processor)\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"\n"
"    /**\n"
"     * Handle a job failure.\n"
"     *\n"
"     * @param  \\Throwable  $exception\n"
"     * @return void\n"
"     */\n"
"    public function failed(Throwable $exception)\n"
"    {\n"
"        // Send user notification of failure, etc...\n"
"    }\n"
"}"
msgstr ""

# CODE: nothing
# CODE: shell
#: ./docs/8.x/queues.md:1773
#: ./docs/9.x/queues.md:1917
#: ./docs/10.x/queues.md:1527
#: ./docs/10.x/queues.md:1995
#: ./docs/11.x/queues.md:1615
#: ./docs/11.x/queues.md:2081
#: ./docs/master/queues.md:1535
#: ./docs/master/queues.md:2003
msgid "composer require aws/aws-sdk-php"
msgstr ""

# P
#: ./docs/8.x/queues.md:1777
#: ./docs/9.x/queues.md:1921
#: ./docs/10.x/queues.md:1999
#: ./docs/11.x/queues.md:2085
#: ./docs/master/queues.md:2007
msgid "Next, set the `queue.failed.driver` configuration option's value to `dynamodb`. In addition, you should define `key`, `secret`, and `region` configuration options within the failed job configuration array. These options will be used to authenticate with AWS. When using the `dynamodb` driver, the `queue.failed.database` configuration option is unnecessary:"
msgstr "接著，請設定 `queue.failed.driver` 設定選項值為 `dynamodb`。此外，也請在失敗 Job 設定陣列中定義 `key`、`secret`、`region` 等設定選項。這些選項會用來向 AWS 進行身份驗證。使用 `dynamodb` Driver 時，就不需要 `queue.failed.database` 設定選項："

# CODE: php
#: ./docs/8.x/queues.md:1779
#: ./docs/9.x/queues.md:1923
#: ./docs/10.x/queues.md:2001
#: ./docs/11.x/queues.md:2087
#: ./docs/master/queues.md:2009
msgid ""
"'failed' => [\n"
"    'driver' => env('QUEUE_FAILED_DRIVER', 'dynamodb'),\n"
"    'key' => env('AWS_ACCESS_KEY_ID'),\n"
"    'secret' => env('AWS_SECRET_ACCESS_KEY'),\n"
"    'region' => env('AWS_DEFAULT_REGION', 'us-east-1'),\n"
"    'table' => 'failed_jobs',\n"
"],"
msgstr ""

# P
#: ./docs/8.x/queues.md:1789
#: ./docs/9.x/queues.md:1933
#: ./docs/10.x/queues.md:2011
#: ./docs/11.x/queues.md:2097
#: ./docs/master/queues.md:2019
#~ msgid "<a name=\"disabling-failed-job-storage\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1790
#: ./docs/9.x/queues.md:1934
#: ./docs/10.x/queues.md:2012
#: ./docs/11.x/queues.md:2098
#: ./docs/master/queues.md:2020
msgid "Disabling Failed Job Storage"
msgstr "不保存失敗的 Job"

# P
#: ./docs/8.x/queues.md:1792
#: ./docs/9.x/queues.md:1936
#: ./docs/10.x/queues.md:2014
#: ./docs/11.x/queues.md:2100
#: ./docs/master/queues.md:2022
msgid "You may instruct Laravel to discard failed jobs without storing them by setting the `queue.failed.driver` configuration option's value to `null`. Typically, this may be accomplished via the `QUEUE_FAILED_DRIVER` environment variable:"
msgstr "只要將 `queue.failed.driver` 設定值設為 `null`，就可以讓 Laravel 不保存失敗的 Job 以忽略這些 Job。一般來說，可使用  `QUEUE_FAILED_DRIVER` 環境變數來調整這個值："

# CODE
# CODE: ini
#: ./docs/8.x/queues.md:1794
#: ./docs/9.x/queues.md:1938
#: ./docs/10.x/queues.md:2016
#: ./docs/11.x/queues.md:2102
#: ./docs/master/queues.md:2024
msgid "QUEUE_FAILED_DRIVER=null"
msgstr ""

# CODE: shell
#: ./docs/10.x/queues.md:1795
#: ./docs/11.x/queues.md:1883
#: ./docs/master/queues.md:1803
msgid ""
"sudo supervisorctl reread\n"
"\n"
"sudo supervisorctl update\n"
"\n"
"sudo supervisorctl start \"laravel-worker:*\""
msgstr ""

# P
#: ./docs/8.x/queues.md:1796
#: ./docs/9.x/queues.md:1942
#: ./docs/10.x/queues.md:2020
#: ./docs/11.x/queues.md:2106
#: ./docs/master/queues.md:2028
#~ msgid "<a name=\"failed-job-events\"></a>"
#~ msgstr ""

# H3
#: ./docs/8.x/queues.md:1797
#: ./docs/9.x/queues.md:1943
#: ./docs/10.x/queues.md:2021
#: ./docs/11.x/queues.md:2107
#: ./docs/master/queues.md:2029
msgid "Failed Job Events"
msgstr "失敗 Job 的事件"

# P
#: ./docs/8.x/queues.md:1799
#: ./docs/9.x/queues.md:1945
#: ./docs/10.x/queues.md:2023
#: ./docs/11.x/queues.md:2109
#: ./docs/master/queues.md:2031
msgid "If you would like to register an event listener that will be invoked when a job fails, you may use the `Queue` facade's `failing` method. For example, we may attach a closure to this event from the `boot` method of the `AppServiceProvider` that is included with Laravel:"
msgstr "若想註冊一個會在每次 Job 失敗時叫用的 Event Listener，可使用 `Queue` Facade 的 `failing` 方法。舉例來說，我們可以在 Laravel 中內建的 `AppServiceProvider` 中 `boot` 方法內將一個閉包附加至該事件上："

# CODE
#: ./docs/8.x/queues.md:1801
#: ./docs/9.x/queues.md:1947
msgid ""
"<?php\n"
"\n"
"namespace App\\Providers;\n"
"\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobFailed;\n"
"\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function register()\n"
"    {\n"
"        //\n"
"    }\n"
"\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        Queue::failing(function (JobFailed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->exception\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1836
#: ./docs/9.x/queues.md:1982
#: ./docs/10.x/queues.md:2056
#: ./docs/11.x/queues.md:2142
#: ./docs/master/queues.md:2064
#~ msgid "<a name=\"clearing-jobs-from-queues\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1837
#: ./docs/9.x/queues.md:1983
#: ./docs/10.x/queues.md:2057
#: ./docs/11.x/queues.md:2143
#: ./docs/master/queues.md:2065
msgid "Clearing Jobs From Queues"
msgstr "在佇列中清理 Job"

# P
#: ./docs/8.x/queues.md:1839
#: ./docs/9.x/queues.md:1986
#: ./docs/10.x/queues.md:2060
#: ./docs/11.x/queues.md:2146
#: ./docs/master/queues.md:2068
msgid "When using [Horizon](/docs/{{version}}/horizon), you should use the `horizon:clear` command to clear jobs from the queue instead of the `queue:clear` command."
msgstr "使用 [Horizon](/docs/{{version}}/horizon)，請不要使用 `queue:clear` 指令，請使用 `horizon:clear` 指令來清理佇列中的 Job。"

# CODE
#: ./docs/10.x/queues.md:1841
#: ./docs/11.x/queues.md:1929
#: ./docs/master/queues.md:1849
msgid ""
"/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*/\n"
"public function backoff(): int\n"
"{\n"
"    return 3;\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1841
#: ./docs/9.x/queues.md:1988
#: ./docs/10.x/queues.md:2062
#: ./docs/11.x/queues.md:2148
#: ./docs/master/queues.md:2070
msgid "If you would like to delete all jobs from the default queue of the default connection, you may do so using the `queue:clear` Artisan command:"
msgstr "若想從預設連線的預設佇列中刪除所有 Job，可使用 `queue:clear` Artisan 指令："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1843
#: ./docs/9.x/queues.md:1990
#: ./docs/10.x/queues.md:2064
#: ./docs/11.x/queues.md:2150
#: ./docs/master/queues.md:2072
msgid "php artisan queue:clear"
msgstr ""

# P
#: ./docs/8.x/queues.md:1845
#: ./docs/9.x/queues.md:1994
#: ./docs/10.x/queues.md:2068
#: ./docs/11.x/queues.md:2154
#: ./docs/master/queues.md:2076
msgid "You may also provide the `connection` argument and `queue` option to delete jobs from a specific connection and queue:"
msgstr "可以提供 `connection` 引數與 `queue` 選項來刪除特定連線與佇列中的 Job："

# CODE
# CODE: shell
#: ./docs/8.x/queues.md:1847
#: ./docs/9.x/queues.md:1996
#: ./docs/10.x/queues.md:2070
#: ./docs/11.x/queues.md:2156
#: ./docs/master/queues.md:2078
msgid "php artisan queue:clear redis --queue=emails"
msgstr ""

# P
#: ./docs/10.x/queues.md:1849
#: ./docs/11.x/queues.md:1937
#: ./docs/master/queues.md:1857
msgid "You may easily configure \"exponential\" backoffs by returning an array of backoff values from the `backoff` method. In this example, the retry delay will be 1 second for the first retry, 5 seconds for the second retry, 10 seconds for the third retry, and 10 seconds for every subsequent retry if there are more attempts remaining:"
msgstr ""

# P
#: ./docs/8.x/queues.md:1849
#: ./docs/9.x/queues.md:2001
#: ./docs/10.x/queues.md:2075
#: ./docs/11.x/queues.md:2161
#: ./docs/master/queues.md:2083
msgid "Clearing jobs from queues is only available for the SQS, Redis, and database queue drivers. In addition, the SQS message deletion process takes up to 60 seconds, so jobs sent to the SQS queue up to 60 seconds after you clear the queue might also be deleted."
msgstr " 目前，只有 SQS、Redis、資料庫等佇列 Driver 能支援清除佇列中的 Job。此外，刪除 SQS Message 可能會需要至多 60 秒的時間，因此在清理佇列的 60 秒後所傳送給 SQS 佇列的 Job 也可能會被刪除。"

# CODE
#: ./docs/10.x/queues.md:1851
#: ./docs/11.x/queues.md:1939
#: ./docs/master/queues.md:1859
msgid ""
"/**\n"
"* Calculate the number of seconds to wait before retrying the job.\n"
"*\n"
"* @return array<int, int>\n"
"*/\n"
"public function backoff(): array\n"
"{\n"
"    return [1, 5, 10];\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1851
#: ./docs/9.x/queues.md:2003
#: ./docs/10.x/queues.md:2077
#: ./docs/11.x/queues.md:2163
#: ./docs/master/queues.md:2085
#~ msgid "<a name=\"monitoring-your-queues\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1852
#: ./docs/9.x/queues.md:2004
#: ./docs/10.x/queues.md:2078
#: ./docs/11.x/queues.md:2164
#: ./docs/master/queues.md:2086
msgid "Monitoring Your Queues"
msgstr "監控佇列"

# P
#: ./docs/8.x/queues.md:1854
#: ./docs/9.x/queues.md:2006
#: ./docs/10.x/queues.md:2080
#: ./docs/11.x/queues.md:2166
#: ./docs/master/queues.md:2088
msgid "If your queue receives a sudden influx of jobs, it could become overwhelmed, leading to a long wait time for jobs to complete. If you wish, Laravel can alert you when your queue job count exceeds a specified threshold."
msgstr "若佇列突然收到大量的 Job，則佇列可能會有來不及處理，造成 Job 需要更長的等待時間才能完成。若有需要的話，Laravel 可以在佇列 Job 遇到特定閥值時傳送通知。"

# P
#: ./docs/8.x/queues.md:1856
#: ./docs/9.x/queues.md:2008
#: ./docs/10.x/queues.md:2082
#: ./docs/11.x/queues.md:2168
#: ./docs/master/queues.md:2090
msgid "To get started, you should schedule the `queue:monitor` command to [run every minute](/docs/{{version}}/scheduling). The command accepts the names of the queues you wish to monitor as well as your desired job count threshold:"
msgstr "若要開始監控佇列，請排程設定[每 10 分鐘執行](/docs/{{version}}/scheduling) `queue:monitor` 指令。這個指令接受要監控的佇列名稱，以及所要設定的 Job 數量閥值："

# CODE: bash
# CODE: shell
#: ./docs/8.x/queues.md:1858
#: ./docs/9.x/queues.md:2010
#: ./docs/10.x/queues.md:2084
#: ./docs/11.x/queues.md:2170
#: ./docs/master/queues.md:2092
msgid "php artisan queue:monitor redis:default,redis:deployments --max=100"
msgstr ""

# P
#: ./docs/8.x/queues.md:1862
#: ./docs/9.x/queues.md:2014
#: ./docs/10.x/queues.md:2088
msgid "Scheduling this command alone is not enough to trigger a notification alerting you of the queue's overwhelmed status. When the command encounters a queue that has a job count exceeding your threshold, an `Illuminate\\Queue\\Events\\QueueBusy` event will be dispatched. You may listen for this event within your application's `EventServiceProvider` in order to send a notification to you or your development team:"
msgstr "若只排程執行這個指令，當佇列的負載過高時還不會觸發通知。當這個指令遇到有佇列超過指定閥值量的 Job 數時，會分派一個 `Illuminate\\Queue\\Events\\QueueBusy` 事件。我們可以在專案的 `EventServiceProvider` 內監聽這個事件，以傳送通知給開發團隊："

# CODE: php
#: ./docs/8.x/queues.md:1864
#: ./docs/9.x/queues.md:2016
msgid ""
"use App\\Notifications\\QueueHasLongWaitTime;\n"
"use Illuminate\\Queue\\Events\\QueueBusy;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(function (QueueBusy $event) {\n"
"        Notification::route('mail', 'dev@example.com')\n"
"                ->notify(new QueueHasLongWaitTime(\n"
"                    $event->connection,\n"
"                    $event->queue,\n"
"                    $event->size\n"
"                ));\n"
"    });\n"
"}"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:1866
#: ./docs/master/queues.md:1874
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Bus\\Queueable;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n"
"use Illuminate\\Queue\\SerializesModels;\n"
"use Throwable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue, Queueable, SerializesModels;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct(\n"
"        public Podcast $podcast,\n"
"    ) {}\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(AudioProcessor $processor): void\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"\n"
"    /**\n"
"     * Handle a job failure.\n"
"     */\n"
"    public function failed(?Throwable $exception): void\n"
"    {\n"
"        // Send user notification of failure, etc...\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/8.x/queues.md:1888
#: ./docs/9.x/queues.md:2040
#: ./docs/10.x/queues.md:2273
#: ./docs/11.x/queues.md:2453
#: ./docs/master/queues.md:2350
#~ msgid "<a name=\"job-events\"></a>"
#~ msgstr ""

# H2
#: ./docs/8.x/queues.md:1889
#: ./docs/9.x/queues.md:2041
#: ./docs/10.x/queues.md:2274
#: ./docs/11.x/queues.md:2454
#: ./docs/master/queues.md:2351
msgid "Job Events"
msgstr "Job 事件"

# P
#: ./docs/8.x/queues.md:1891
#: ./docs/9.x/queues.md:2043
#: ./docs/10.x/queues.md:2276
#: ./docs/11.x/queues.md:2456
#: ./docs/master/queues.md:2353
msgid "Using the `before` and `after` methods on the `Queue` [facade](/docs/{{version}}/facades), you may specify callbacks to be executed before or after a queued job is processed. These callbacks are a great opportunity to perform additional logging or increment statistics for a dashboard. Typically, you should call these methods from the `boot` method of a [service provider](/docs/{{version}}/providers). For example, we may use the `AppServiceProvider` that is included with Laravel:"
msgstr "在 `Queue` [Facade](/docs/{{version}}/facades) 上使用 `before` 與 `after` 方法，就可以指定要在佇列 Job 處理前後所要執行的回呼。在這些回呼中，我們就有機會能進行記錄額外的日誌、增加主控台上統計數字等動作。一般來說，應在某個 [Service Provider](/docs/{{version}}/providers) 中 `boot` 方法內呼叫這些方法。舉例來說，我們可以使用 Laravel 中內建的 `AppServiceProvider`："

# CODE
#: ./docs/8.x/queues.md:1893
#: ./docs/9.x/queues.md:2045
msgid ""
"<?php\n"
"\n"
"namespace App\\Providers;\n"
"\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobProcessed;\n"
"use Illuminate\\Queue\\Events\\JobProcessing;\n"
"\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function register()\n"
"    {\n"
"        //\n"
"    }\n"
"\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function boot()\n"
"    {\n"
"        Queue::before(function (JobProcessing $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n"
"\n"
"        Queue::after(function (JobProcessed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/9.x/queues.md:1896
#: ./docs/10.x/queues.md:1974
#: ./docs/11.x/queues.md:2060
#: ./docs/master/queues.md:1982
msgid "You may prune the records in your application's `failed_jobs` table by invoking the `queue:prune-failed` Artisan command:"
msgstr "可以呼叫 `queue:prune-failed` Artisan 指令來修剪專案中所有 `failed_jobs` 資料表中的記錄："

# P
#: ./docs/11.x/queues.md:1898
#: ./docs/master/queues.md:1818
msgid "A migration to create the `failed_jobs` table is typically already present in new Laravel applications. However, if your application does not contain a migration for this table, you may use the `make:queue-failed-table` command to create the migration:"
msgstr ""

# CODE: shell
#: ./docs/11.x/queues.md:1900
#: ./docs/master/queues.md:1820
msgid ""
"php artisan make:queue-failed-table\n"
"\n"
"php artisan migrate"
msgstr ""

# P
#: ./docs/9.x/queues.md:1902
#: ./docs/10.x/queues.md:1980
#: ./docs/11.x/queues.md:2066
#: ./docs/master/queues.md:1988
msgid "By default, all the failed job records that are more than 24 hours old will be pruned. If you provide the `--hours` option to the command, only the failed job records that were inserted within the last N number of hours will be retained. For example, the following command will delete all the failed job records that were inserted more than 48 hours ago:"
msgstr "預設情況下，所有超過 24 小時的失敗 Job 記錄都會被修剪。若有提供 `--hours` 選項給該指令，則只會保留過去 N 小時中所插入的失敗 Job 記錄。舉例來說，下列指令會刪除所有插入超過 48 小時的失敗 Job 記錄："

# P
#: ./docs/8.x/queues.md:1935
#: ./docs/9.x/queues.md:2087
#: ./docs/10.x/queues.md:2316
#: ./docs/11.x/queues.md:2496
#: ./docs/master/queues.md:2393
msgid "Using the `looping` method on the `Queue` [facade](/docs/{{version}}/facades), you may specify callbacks that execute before the worker attempts to fetch a job from a queue. For example, you might register a closure to rollback any transactions that were left open by a previously failed job:"
msgstr "使用 `Queue` [Facade](/docs/{{version}}/facades) 的 `looping` 方法，我們就能指定要在 Worker 嘗試從佇列中取得 Job 前執行的回呼。舉例來說，我們可以註冊一個閉包來回溯前一個失敗 Job 中未關閉的 Transaction："

# CODE
#: ./docs/8.x/queues.md:1937
#: ./docs/9.x/queues.md:2089
#: ./docs/10.x/queues.md:2318
#: ./docs/11.x/queues.md:2498
#: ./docs/master/queues.md:2395
msgid ""
"use Illuminate\\Support\\Facades\\DB;\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"\n"
"Queue::looping(function () {\n"
"    while (DB::transactionLevel() > 0) {\n"
"        DB::rollBack();\n"
"    }\n"
"});"
msgstr ""

# CODE
#: ./docs/11.x/queues.md:1954
msgid ""
"<?php\n"
"\n"
"namespace App\\Jobs;\n"
"\n"
"use App\\Models\\Podcast;\n"
"use App\\Services\\AudioProcessor;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Foundation\\Queue\\Queueable;\n"
"use Throwable;\n"
"\n"
"class ProcessPodcast implements ShouldQueue\n"
"{\n"
"    use Queueable;\n"
"\n"
"    /**\n"
"     * Create a new job instance.\n"
"     */\n"
"    public function __construct(\n"
"        public Podcast $podcast,\n"
"    ) {}\n"
"\n"
"    /**\n"
"     * Execute the job.\n"
"     */\n"
"    public function handle(AudioProcessor $processor): void\n"
"    {\n"
"        // Process uploaded podcast...\n"
"    }\n"
"\n"
"    /**\n"
"     * Handle a job failure.\n"
"     */\n"
"    public function failed(?Throwable $exception): void\n"
"    {\n"
"        // Send user notification of failure, etc...\n"
"    }\n"
"}"
msgstr ""

# H3
#: ./docs/10.x/queues.md:1987
#: ./docs/11.x/queues.md:2073
#: ./docs/master/queues.md:1995
msgid "Storing Failed Jobs in DynamoDB"
msgstr ""

# P
#: ./docs/10.x/queues.md:1989
#: ./docs/11.x/queues.md:2075
#: ./docs/master/queues.md:1997
msgid "Laravel also provides support for storing your failed job records in [DynamoDB](https://aws.amazon.com/dynamodb) instead of a relational database table. However, you must manually create a DynamoDB table to store all of the failed job records. Typically, this table should be named `failed_jobs`, but you should name the table based on the value of the `queue.failed.table` configuration value within your application's `queue` configuration file."
msgstr ""

# CODE
#: ./docs/10.x/queues.md:2025
#: ./docs/11.x/queues.md:2111
#: ./docs/master/queues.md:2033
msgid ""
"<?php\n"
"\n"
"namespace App\\Providers;\n"
"\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobFailed;\n"
"\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     */\n"
"    public function register(): void\n"
"    {\n"
"        // ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Queue::failing(function (JobFailed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->exception\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# CODE: php
#: ./docs/10.x/queues.md:2090
msgid ""
"use App\\Notifications\\QueueHasLongWaitTime;\n"
"use Illuminate\\Queue\\Events\\QueueBusy;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"\n"
"/**\n"
" * Register any other events for your application.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Event::listen(function (QueueBusy $event) {\n"
"        Notification::route('mail', 'dev@example.com')\n"
"                ->notify(new QueueHasLongWaitTime(\n"
"                    $event->connection,\n"
"                    $event->queue,\n"
"                    $event->size\n"
"                ));\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:2112
#: ./docs/11.x/queues.md:2198
#: ./docs/master/queues.md:2120
#~ msgid "<a name=\"testing\"></a>"
#~ msgstr ""

# H2
#: ./docs/10.x/queues.md:2113
#: ./docs/11.x/queues.md:2199
#: ./docs/master/queues.md:2121
msgid "Testing"
msgstr "測試"

# P
#: ./docs/10.x/queues.md:2115
#: ./docs/11.x/queues.md:2201
#: ./docs/master/queues.md:2123
msgid "When testing code that dispatches jobs, you may wish to instruct Laravel to not actually execute the job itself, since the job's code can be tested directly and separately of the code that dispatches it. Of course, to test the job itself, you may instantiate a job instance and invoke the `handle` method directly in your test."
msgstr "在測試會分派 Job 的程式時，可以讓 Laravel 不要真的執行該 Job。因為我們可以直接測試 Job，將 Job 與分派該 Job 的程式碼測試分開。當然，若要測試 Job 本身，需要在測試中先初始化一個 Job 實體，並直接呼叫 `handle` 方法。"

# P
#: ./docs/10.x/queues.md:2117
#: ./docs/11.x/queues.md:2203
#: ./docs/master/queues.md:2125
msgid "You may use the `Queue` facade's `fake` method to prevent queued jobs from actually being pushed to the queue. After calling the `Queue` facade's `fake` method, you may then assert that the application attempted to push jobs to the queue:"
msgstr ""

# CODE
# CODE: php tab=PHPUnit
#: ./docs/10.x/queues.md:2119
#: ./docs/11.x/queues.md:2238
#: ./docs/master/queues.md:2160
msgid ""
"<?php\n"
"\n"
"namespace Tests\\Feature;\n"
"\n"
"use App\\Jobs\\AnotherJob;\n"
"use App\\Jobs\\FinalJob;\n"
"use App\\Jobs\\ShipOrder;\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Tests\\TestCase;\n"
"\n"
"class ExampleTest extends TestCase\n"
"{\n"
"    public function test_orders_can_be_shipped(): void\n"
"    {\n"
"        Queue::fake();\n"
"\n"
"        // Perform order shipping...\n"
"\n"
"        // Assert that no jobs were pushed...\n"
"        Queue::assertNothingPushed();\n"
"\n"
"        // Assert a job was pushed to a given queue...\n"
"        Queue::assertPushedOn('queue-name', ShipOrder::class);\n"
"\n"
"        // Assert a job was pushed twice...\n"
"        Queue::assertPushed(ShipOrder::class, 2);\n"
"\n"
"        // Assert a job was not pushed...\n"
"        Queue::assertNotPushed(AnotherJob::class);\n"
"\n"
"        // Assert that a Closure was pushed to the queue...\n"
"        Queue::assertClosurePushed();\n"
"\n"
"        // Assert the total number of jobs that were pushed...\n"
"        Queue::assertCount(3);\n"
"    }\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:2157
#: ./docs/11.x/queues.md:2278
#: ./docs/master/queues.md:2200
msgid "You may pass a closure to the `assertPushed` or `assertNotPushed` methods in order to assert that a job was pushed that passes a given \"truth test\". If at least one job was pushed that passes the given truth test then the assertion will be successful:"
msgstr "可以傳入一個閉包給 `assertPushed` 或 `assertNotPushed` 方法，來判斷某個 Job 是否通過給定的「真值測試 (Truth Test)」。若被推入的 Job 中至少有一個 Job 通過給定的真值測試，則該 Assertion 會被視為成功："

# CODE
#: ./docs/10.x/queues.md:2159
#: ./docs/11.x/queues.md:2280
#: ./docs/master/queues.md:2202
msgid ""
"Queue::assertPushed(function (ShipOrder $job) use ($order) {\n"
"    return $job->order->id === $order->id;\n"
"});"
msgstr ""

# P
#: ./docs/10.x/queues.md:2163
#: ./docs/11.x/queues.md:2284
#: ./docs/master/queues.md:2206
#~ msgid "<a name=\"faking-a-subset-of-jobs\"></a>"
#~ msgstr ""

# H3
#: ./docs/10.x/queues.md:2164
#: ./docs/11.x/queues.md:2285
#: ./docs/master/queues.md:2207
msgid "Faking a Subset of Jobs"
msgstr ""

# P
#: ./docs/10.x/queues.md:2166
#: ./docs/11.x/queues.md:2287
#: ./docs/master/queues.md:2209
msgid "If you only need to fake specific jobs while allowing your other jobs to execute normally, you may pass the class names of the jobs that should be faked to the `fake` method:"
msgstr "若只想模擬特定的 Job，並讓其他 Job 都被正常執行，可以傳入要被模擬的 Job 類別名稱給 `fake` 方法："

# CODE
# CODE: php tab=PHPUnit
#: ./docs/10.x/queues.md:2168
#: ./docs/11.x/queues.md:2302
#: ./docs/master/queues.md:2224
msgid ""
"public function test_orders_can_be_shipped(): void\n"
"{\n"
"    Queue::fake([\n"
"        ShipOrder::class,\n"
"    ]);\n"
"\n"
"    // Perform order shipping...\n"
"\n"
"    // Assert a job was pushed twice...\n"
"    Queue::assertPushed(ShipOrder::class, 2);\n"
"}"
msgstr ""

# P
#: ./docs/11.x/queues.md:2174
#: ./docs/master/queues.md:2096
msgid "Scheduling this command alone is not enough to trigger a notification alerting you of the queue's overwhelmed status. When the command encounters a queue that has a job count exceeding your threshold, an `Illuminate\\Queue\\Events\\QueueBusy` event will be dispatched. You may listen for this event within your application's `AppServiceProvider` in order to send a notification to you or your development team:"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:2176
#: ./docs/master/queues.md:2098
msgid ""
"use App\\Notifications\\QueueHasLongWaitTime;\n"
"use Illuminate\\Queue\\Events\\QueueBusy;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Illuminate\\Support\\Facades\\Notification;\n"
"\n"
"/**\n"
" * Bootstrap any application services.\n"
" */\n"
"public function boot(): void\n"
"{\n"
"    Event::listen(function (QueueBusy $event) {\n"
"        Notification::route('mail', 'dev@example.com')\n"
"                ->notify(new QueueHasLongWaitTime(\n"
"                    $event->connection,\n"
"                    $event->queue,\n"
"                    $event->size\n"
"                ));\n"
"    });\n"
"}"
msgstr ""

# P
#: ./docs/10.x/queues.md:2180
#: ./docs/11.x/queues.md:2316
#: ./docs/master/queues.md:2238
msgid "You may fake all jobs except for a set of specified jobs using the `except` method:"
msgstr "也可以使用 `fakeExcept` 方法來 Fake 除了一組特定 Job 外的所有 Event："

# CODE
#: ./docs/10.x/queues.md:2182
#: ./docs/11.x/queues.md:2318
#: ./docs/master/queues.md:2240
msgid ""
"Queue::fake()->except([\n"
"    ShipOrder::class,\n"
"]);"
msgstr ""

# P
#: ./docs/10.x/queues.md:2186
#: ./docs/11.x/queues.md:2322
#: ./docs/master/queues.md:2244
#~ msgid "<a name=\"testing-job-chains\"></a>"
#~ msgstr ""

# H3
#: ./docs/10.x/queues.md:2187
#: ./docs/11.x/queues.md:2323
#: ./docs/master/queues.md:2245
msgid "Testing Job Chains"
msgstr "測試串連的 Job"

# P
#: ./docs/10.x/queues.md:2189
#: ./docs/11.x/queues.md:2325
#: ./docs/master/queues.md:2247
msgid "To test job chains, you will need to utilize the `Bus` facade's faking capabilities. The `Bus` facade's `assertChained` method may be used to assert that a [chain of jobs](/docs/{{version}}/queues#job-chaining) was dispatched. The `assertChained` method accepts an array of chained jobs as its first argument:"
msgstr "若要測試串連的 Job，我們需要使用到 `Bus` Facade 的模擬功能。`Bus` Facade 的 `assertChained` 方法可用來判斷是否有分派某個[串聯的 Job](/docs/{{version}}/queues#job-chaining)。`assertChained` 方法接受一組串聯 Job 的陣列作為其第一個引數："

# CODE
#: ./docs/10.x/queues.md:2191
#: ./docs/11.x/queues.md:2327
#: ./docs/master/queues.md:2249
msgid ""
"use App\\Jobs\\RecordShipment;\n"
"use App\\Jobs\\ShipOrder;\n"
"use App\\Jobs\\UpdateInventory;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::fake();\n"
"\n"
"// ...\n"
"\n"
"Bus::assertChained([\n"
"    ShipOrder::class,\n"
"    RecordShipment::class,\n"
"    UpdateInventory::class\n"
"]);"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/queues.md:2205
#: ./docs/master/queues.md:2127
msgid ""
"<?php\n"
"\n"
"use App\\Jobs\\AnotherJob;\n"
"use App\\Jobs\\FinalJob;\n"
"use App\\Jobs\\ShipOrder;\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"\n"
"test('orders can be shipped', function () {\n"
"    Queue::fake();\n"
"\n"
"    // Perform order shipping...\n"
"\n"
"    // Assert that no jobs were pushed...\n"
"    Queue::assertNothingPushed();\n"
"\n"
"    // Assert a job was pushed to a given queue...\n"
"    Queue::assertPushedOn('queue-name', ShipOrder::class);\n"
"\n"
"    // Assert a job was pushed twice...\n"
"    Queue::assertPushed(ShipOrder::class, 2);\n"
"\n"
"    // Assert a job was not pushed...\n"
"    Queue::assertNotPushed(AnotherJob::class);\n"
"\n"
"    // Assert that a Closure was pushed to the queue...\n"
"    Queue::assertClosurePushed();\n"
"\n"
"    // Assert the total number of jobs that were pushed...\n"
"    Queue::assertCount(3);\n"
"});"
msgstr ""

# P
#: ./docs/10.x/queues.md:2206
#: ./docs/11.x/queues.md:2342
#: ./docs/master/queues.md:2264
msgid "As you can see in the example above, the array of chained jobs may be an array of the job's class names. However, you may also provide an array of actual job instances. When doing so, Laravel will ensure that the job instances are of the same class and have the same property values of the chained jobs dispatched by your application:"
msgstr "就像上述範例中可看到的一樣，串聯 Job 的陣列就是一組包含 Job 類別名稱的陣列。不過，也可以提供一組實際 Job 實體的陣列。當提供的陣列為 Job 實體的陣列時，Laravel 會確保程式所分派的串聯 Job 都具是相同的類別，且擁有相同的屬性值："

# CODE
#: ./docs/10.x/queues.md:2208
#: ./docs/11.x/queues.md:2344
#: ./docs/master/queues.md:2266
msgid ""
"Bus::assertChained([\n"
"    new ShipOrder,\n"
"    new RecordShipment,\n"
"    new UpdateInventory,\n"
"]);"
msgstr ""

# P
#: ./docs/10.x/queues.md:2214
#: ./docs/11.x/queues.md:2350
#: ./docs/master/queues.md:2272
msgid "You may use the `assertDispatchedWithoutChain` method to assert that a job was pushed without a chain of jobs:"
msgstr "可以使用 `assertDispatchedWithoutChain ` 方法來判斷 Job 被推入 Queue 但未包含串聯 Job："

# CODE
#: ./docs/10.x/queues.md:2216
#: ./docs/11.x/queues.md:2352
#: ./docs/master/queues.md:2274
msgid "Bus::assertDispatchedWithoutChain(ShipOrder::class);"
msgstr ""

# P
#: ./docs/10.x/queues.md:2218
#: ./docs/11.x/queues.md:2377
#: ./docs/master/queues.md:2276
#~ msgid "<a name=\"testing-chained-batches\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/queues.md:2219
#: ./docs/11.x/queues.md:2378
#: ./docs/master/queues.md:2277
msgid "Testing Chained Batches"
msgstr ""

# P
#: ./docs/10.x/queues.md:2221
#: ./docs/11.x/queues.md:2380
#: ./docs/master/queues.md:2279
msgid "If your job chain [contains a batch of jobs](#chains-and-batches), you may assert that the chained batch matches your expectations by inserting a `Bus::chainedBatch` definition within your chain assertion:"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:2223
#: ./docs/11.x/queues.md:2382
#: ./docs/master/queues.md:2281
msgid ""
"use App\\Jobs\\ShipOrder;\n"
"use App\\Jobs\\UpdateInventory;\n"
"use Illuminate\\Bus\\PendingBatch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::assertChained([\n"
"    new ShipOrder,\n"
"    Bus::chainedBatch(function (PendingBatch $batch) {\n"
"        return $batch->jobs->count() === 3;\n"
"    }),\n"
"    new UpdateInventory,\n"
"]);"
msgstr ""

# P
#: ./docs/10.x/queues.md:2236
#: ./docs/11.x/queues.md:2395
#: ./docs/master/queues.md:2294
#~ msgid "<a name=\"testing-job-batches\"></a>"
#~ msgstr ""

# H3
#: ./docs/10.x/queues.md:2237
#: ./docs/11.x/queues.md:2396
#: ./docs/master/queues.md:2295
msgid "Testing Job Batches"
msgstr "測試 Job 批次"

# P
#: ./docs/10.x/queues.md:2239
#: ./docs/11.x/queues.md:2398
#: ./docs/master/queues.md:2297
msgid "The `Bus` facade's `assertBatched` method may be used to assert that a [batch of jobs](/docs/{{version}}/queues#job-batching) was dispatched. The closure given to the `assertBatched` method receives an instance of `Illuminate\\Bus\\PendingBatch`, which may be used to inspect the jobs within the batch:"
msgstr "`Bus` Facade 的 `assertBatched` 方法可用來判斷是否有分派[Job 批次]。提供給 `assertBatched` 方法的閉包會收到 `Illuminate\\Bus\\PendingBatch` 的實體，該實體可用來檢查批次中的 Job："

# CODE
#: ./docs/10.x/queues.md:2241
#: ./docs/11.x/queues.md:2400
#: ./docs/master/queues.md:2299
msgid ""
"use Illuminate\\Bus\\PendingBatch;\n"
"use Illuminate\\Support\\Facades\\Bus;\n"
"\n"
"Bus::fake();\n"
"\n"
"// ...\n"
"\n"
"Bus::assertBatched(function (PendingBatch $batch) {\n"
"    return $batch->name == 'import-csv' &&\n"
"           $batch->jobs->count() === 10;\n"
"});"
msgstr ""

# P
#: ./docs/10.x/queues.md:2253
#: ./docs/11.x/queues.md:2412
#: ./docs/master/queues.md:2311
msgid "You may use the `assertBatchCount` method to assert that a given number of batches were dispatched:"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:2255
#: ./docs/11.x/queues.md:2414
#: ./docs/master/queues.md:2313
msgid "Bus::assertBatchCount(3);"
msgstr ""

# P
#: ./docs/10.x/queues.md:2257
#: ./docs/11.x/queues.md:2416
#: ./docs/master/queues.md:2315
msgid "You may use `assertNothingBatched` to assert that no batches were dispatched:"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:2259
#: ./docs/11.x/queues.md:2418
#: ./docs/master/queues.md:2317
msgid "Bus::assertNothingBatched();"
msgstr ""

# P
#: ./docs/10.x/queues.md:2261
#: ./docs/11.x/queues.md:2420
#: ./docs/master/queues.md:2319
#~ msgid "<a name=\"testing-job-batch-interaction\"></a>"
#~ msgstr ""

# H4
#: ./docs/10.x/queues.md:2262
#: ./docs/11.x/queues.md:2421
#: ./docs/master/queues.md:2320
msgid "Testing Job / Batch Interaction"
msgstr "測試 Job 或批次行為"

# P
#: ./docs/10.x/queues.md:2264
#: ./docs/11.x/queues.md:2423
#: ./docs/master/queues.md:2322
msgid "In addition, you may occasionally need to test an individual job's interaction with its underlying batch. For example, you may need to test if a job cancelled further processing for its batch. To accomplish this, you need to assign a fake batch to the job via the `withFakeBatch` method. The `withFakeBatch` method returns a tuple containing the job instance and the fake batch:"
msgstr "除此之外，我們有時候也需要測試個別 Job 與其底層批次的互動。舉例來說，我們可能需要測試某個 Job 是否取消了批次中剩下的流程。這時，我們需要使用 `withFakeBatch` 方法來將一個模擬的 Batch 指派給該 Job。`withFakeBatch` 方法會回傳一個包含 Job 實體與模擬 Batch 的陣列："

# CODE
#: ./docs/10.x/queues.md:2266
#: ./docs/11.x/queues.md:2425
#: ./docs/master/queues.md:2324
msgid ""
"[$job, $batch] = (new ShipOrder)->withFakeBatch();\n"
"\n"
"$job->handle();\n"
"\n"
"$this->assertTrue($batch->cancelled());\n"
"$this->assertEmpty($batch->added);"
msgstr ""

# CODE
#: ./docs/10.x/queues.md:2278
#: ./docs/11.x/queues.md:2458
#: ./docs/master/queues.md:2355
msgid ""
"<?php\n"
"\n"
"namespace App\\Providers;\n"
"\n"
"use Illuminate\\Support\\Facades\\Queue;\n"
"use Illuminate\\Support\\ServiceProvider;\n"
"use Illuminate\\Queue\\Events\\JobProcessed;\n"
"use Illuminate\\Queue\\Events\\JobProcessing;\n"
"\n"
"class AppServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * Register any application services.\n"
"     */\n"
"    public function register(): void\n"
"    {\n"
"        // ...\n"
"    }\n"
"\n"
"    /**\n"
"     * Bootstrap any application services.\n"
"     */\n"
"    public function boot(): void\n"
"    {\n"
"        Queue::before(function (JobProcessing $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n"
"\n"
"        Queue::after(function (JobProcessed $event) {\n"
"            // $event->connectionName\n"
"            // $event->job\n"
"            // $event->job->payload()\n"
"        });\n"
"    }\n"
"}"
msgstr ""

# CODE: php tab=Pest
#: ./docs/11.x/queues.md:2289
#: ./docs/master/queues.md:2211
msgid ""
"test('orders can be shipped', function () {\n"
"    Queue::fake([\n"
"        ShipOrder::class,\n"
"    ]);\n"
"\n"
"    // Perform order shipping...\n"
"\n"
"    // Assert a job was pushed twice...\n"
"    Queue::assertPushed(ShipOrder::class, 2);\n"
"});"
msgstr ""

# P
#: ./docs/master/queues.md:2336
msgid "Once the job's queue interactions have been faked, you may invoke the `handle` method on the job. After invoking the job, the `assetReleased`, `assertDeleted`, and `assertFailed` methods may be used to make assertions against the job's queue interactions:"
msgstr ""

# CODE: php
#: ./docs/master/queues.md:2338
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"\n"
"$job = (new ProcessPodcast)->withFakeQueueInteractions();\n"
"\n"
"$job->handle();\n"
"\n"
"$job->assertReleased(delay: 30);\n"
"$job->assertDeleted();\n"
"$job->assertFailed();"
msgstr ""

# P
#: ./docs/11.x/queues.md:2354
#~ msgid "<a name=\"testing-chain-modifications\"></a>"
#~ msgstr ""

# H4
#: ./docs/11.x/queues.md:2355
msgid "Testing Chain Modifications"
msgstr ""

# P
#: ./docs/11.x/queues.md:2357
msgid "If a chained job [prepends or appends jobs to an existing chain](#adding-jobs-to-the-chain), you may use the job's `assertHasChain` method to assert that the job has the expected chain of remaining jobs:"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:2359
msgid ""
"$job = new ProcessPodcast;\n"
"\n"
"$job->handle();\n"
"\n"
"$job->assertHasChain([\n"
"    new TranscribePodcast,\n"
"    new OptimizePodcast,\n"
"    new ReleasePodcast,\n"
"]);"
msgstr ""

# P
#: ./docs/11.x/queues.md:2371
msgid "The `assertDoesntHaveChain` method may be used to assert that the job's remaining chain is empty:"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:2373
msgid "$job->assertDoesntHaveChain();"
msgstr ""

# P
#: ./docs/11.x/queues.md:2432
#: ./docs/master/queues.md:2331
#~ msgid "<a name=\"testing-job-queue-interactions\"></a>"
#~ msgstr ""

# H3
#: ./docs/11.x/queues.md:2433
#: ./docs/master/queues.md:2332
msgid "Testing Job / Queue Interactions"
msgstr ""

# P
#: ./docs/11.x/queues.md:2435
#: ./docs/master/queues.md:2334
msgid "Sometimes, you may need to test that a queued job [releases itself back onto the queue](#manually-releasing-a-job). Or, you may need to test that the job deleted itself. You may test these queue interactions by instantiating the job and invoking the `withFakeQueueInteractions` method."
msgstr ""

# P
#: ./docs/11.x/queues.md:2437
msgid "Once the job's queue interactions have been faked, you may invoke the `handle` method on the job. After invoking the job, the `assertReleased`, `assertDeleted`, `assertNotDeleted`, `assertFailed`, and `assertNotFailed` methods may be used to make assertions against the job's queue interactions:"
msgstr ""

# CODE: php
#: ./docs/11.x/queues.md:2439
msgid ""
"use App\\Jobs\\ProcessPodcast;\n"
"\n"
"$job = (new ProcessPodcast)->withFakeQueueInteractions();\n"
"\n"
"$job->handle();\n"
"\n"
"$job->assertReleased(delay: 30);\n"
"$job->assertDeleted();\n"
"$job->assertNotDeleted();\n"
"$job->assertFailed();\n"
"$job->assertNotFailed();"
msgstr ""
