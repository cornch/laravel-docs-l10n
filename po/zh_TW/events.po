msgid ""
msgstr ""
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Crowdin-Project: laravel-docs\n"
"X-Crowdin-Project-ID: 447952\n"
"X-Crowdin-Language: zh-TW\n"
"X-Crowdin-File: /main/templates/events.pot\n"
"X-Crowdin-File-ID: 69\n"
"Project-Id-Version: laravel-docs\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Language-Team: Chinese Traditional\n"
"Language: zh_TW\n"
"PO-Revision-Date: 2022-08-09 12:03\n"

#: docs/8.x/events.md:block 1 (header)
msgid "Events"
msgstr "事件 - Event"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Introduction](#introduction)"
msgstr "[簡介](#introduction)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Registering Events & Listeners](#registering-events-and-listeners)"
msgstr "[註冊 Event 與 Listener](#registering-events-and-listeners)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Generating Events & Listeners](#generating-events-and-listeners)"
msgstr "[產生 Event 與 Listener](#generating-events-and-listeners)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Manually Registering Events](#manually-registering-events)"
msgstr "[手動註冊 Event](#manually-registering-events)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Event Discovery](#event-discovery)"
msgstr "[Event Discovery](#event-discovery)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Defining Events](#defining-events)"
msgstr "[定義 Event](#defining-events)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Defining Listeners](#defining-listeners)"
msgstr "[定義 Listener](#defining-listeners)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Queued Event Listeners](#queued-event-listeners)"
msgstr "[在佇列中處理的 Event Listener](#queued-event-listeners)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Manually Interacting With The Queue](#manually-interacting-with-the-queue)"
msgstr "[手動使用佇列](#manually-interacting-with-the-queue)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Queued Event Listeners & Database Transactions](#queued-event-listeners-and-database-transactions)"
msgstr "[在佇列中執行的 Event Listener 與資料庫 Transaction](#queued-event-listeners-and-database-transactions)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Handling Failed Jobs](#handling-failed-jobs)"
msgstr "[處理失敗的任務](#handling-failed-jobs)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Dispatching Events](#dispatching-events)"
msgstr "[分派 Event](#dispatching-events)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Event Subscribers](#event-subscribers)"
msgstr "[Event Subscriber](#event-subscribers)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Writing Event Subscribers](#writing-event-subscribers)"
msgstr "[撰寫 Event Subscriber](#writing-event-subscribers)"

#: docs/8.x/events.md:block 2 (unordered list)
msgid "[Registering Event Subscribers](#registering-event-subscribers)"
msgstr "[註冊 Event Subscriber](#registering-event-subscribers)"

#: docs/8.x/events.md:block 4 (header)
msgid "Introduction"
msgstr "簡介"

#: docs/8.x/events.md:block 5 (paragraph)
msgid "Laravel's events provide a simple observer pattern implementation, allowing you to subscribe and listen for various events that occur within your application. Event classes are typically stored in the `app/Events` directory, while their listeners are stored in `app/Listeners`. Don't worry if you don't see these directories in your application as they will be created for you as you generate events and listeners using Artisan console commands."
msgstr "Laravel 的 ^[Event](事件) 提供了一種簡單的 Observer 設計模式實作，能讓你^[註冊](Subscribe)與^[監聽](Listen)程式內發生的多種事件。Event 類別一般儲存在 `app/Events` 目錄下，而 ^[Listener](監聽程式) 則一般儲存在 `app/Listeners` 目錄。若在專案內沒看到這些目錄的話請別擔心，在使用 Artisan 指令產生 Event 跟 Listener 的時候會自動建立。"

#: docs/8.x/events.md:block 6 (paragraph)
msgid "Events serve as a great way to decouple various aspects of your application, since a single event can have multiple listeners that do not depend on each other. For example, you may wish to send a Slack notification to your user each time an order has shipped. Instead of coupling your order processing code to your Slack notification code, you can raise an `App\\Events\\OrderShipped` event which a listener can receive and use to dispatch a Slack notification."
msgstr "Event 是以各種層面^[解耦](Decouple)程式的好方法，因為一個 Event 可以由多個不互相依賴的 Listener。舉例來說，我們可能會想在訂單出貨的時候傳送 Slack 通知給使用者。除了耦合訂單處理的程式碼跟 Slack 通知的程式碼外，我們可以產生一個 `App\\Events\\OrderShipped` 事件，然後使用一個 Listener 來接收並分派 Slack 通知。"

#: docs/8.x/events.md:block 8 (header)
msgid "Registering Events & Listeners"
msgstr "註冊 Event 與 Listener"

#: docs/8.x/events.md:block 9 (paragraph)
msgid "The `App\\Providers\\EventServiceProvider` included with your Laravel application provides a convenient place to register all of your application's event listeners. The `listen` property contains an array of all events (keys) and their listeners (values). You may add as many events to this array as your application requires. For example, let's add an `OrderShipped` event:"
msgstr "在你的 Laravel 專案中有個 `App\\Providers\\EventServiceProvider`，這個 Service Provider 是可以註冊所有 Event Listener 的好所在。`listen` 屬性是一個陣列，其中包含了所有的 Event (索引鍵) 即其 Listener (陣列值)。可以按照專案需求隨意增加 Event 到這個陣列。舉例來說，我們來新增一個 `OrderShipped` Event："

#: docs/8.x/events.md:block 10 (code)
msgid "use App\\Events\\OrderShipped;\n"
"use App\\Listeners\\SendShipmentNotification;\n\n"
"/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    OrderShipped::class => [\n"
"        SendShipmentNotification::class,\n"
"    ],\n"
"];\n"
msgstr "use App\\Events\\OrderShipped;\n"
"use App\\Listeners\\SendShipmentNotification;\n\n"
"/**\n"
" * The event listener mappings for the application.\n"
" *\n"
" * @var array\n"
" */\n"
"protected $listen = [\n"
"    OrderShipped::class => [\n"
"        SendShipmentNotification::class,\n"
"    ],\n"
"];\n"

#: docs/8.x/events.md:block 11 (quote)
msgid "{tip} The `event:list` command may be used to display a list of all events and listeners registered by your application."
msgstr "{tip} 可以使用 `event:list` 指令來顯示程式中註冊的所有 Event 與 Listener 列表。"

#: docs/8.x/events.md:block 13 (header)
msgid "Generating Events & Listeners"
msgstr "產生 Event 與 Listener"

#: docs/8.x/events.md:block 14 (paragraph)
msgid "Of course, manually creating the files for each event and listener is cumbersome. Instead, add listeners and events to your `EventServiceProvider` and use the `event:generate` Artisan command. This command will generate any events or listeners that are listed in your `EventServiceProvider` that do not already exist:"
msgstr "當然，手動為每個 Event 跟 Listener 建立檔案有點麻煩。我們不需要手動建立，只需要在 `EventServiceProvider` 中加上 Listener 與 Event，然後使用 `event:generate` Artisan 指令即可。這個指令會產生所有列在 `EventServiceProvider` 中不存在的 Event 與 Listener："

#: docs/8.x/events.md:block 15 (code)
msgid "php artisan event:generate\n"
msgstr "php artisan event:generate\n"

#: docs/8.x/events.md:block 16 (paragraph)
msgid "Alternatively, you may use the `make:event` and `make:listener` Artisan commands to generate individual events and listeners:"
msgstr "或者，也可以使用 `make:event` 與 `make:listener` Artisan 指令來產生個別的 Event 與 Listener："

#: docs/8.x/events.md:block 17 (code)
msgid "php artisan make:event PodcastProcessed\n\n"
"php artisan make:listener SendPodcastNotification --event=PodcastProcessed\n"
msgstr "php artisan make:event PodcastProcessed\n\n"
"php artisan make:listener SendPodcastNotification --event=PodcastProcessed\n"

#: docs/8.x/events.md:block 19 (header)
msgid "Manually Registering Events"
msgstr "手動註冊 Event"

#: docs/8.x/events.md:block 20 (paragraph)
msgid "Typically, events should be registered via the `EventServiceProvider` `$listen` array; however, you may also register class or closure based event listeners manually in the `boot` method of your `EventServiceProvider`:"
msgstr "一般來說，Event 應在 `EventServiceProvider` 的 `$listen` 陣列中註冊。不過，也可以在 `EventServiceProvider` 的 `boot` 方法中手動註冊基於類別或閉包的 Listener："

#: docs/8.x/events.md:block 21 (code)
msgid "use App\\Events\\PodcastProcessed;\n"
"use App\\Listeners\\SendPodcastNotification;\n"
"use Illuminate\\Support\\Facades\\Event;\n\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(\n"
"        PodcastProcessed::class,\n"
"        [SendPodcastNotification::class, 'handle']\n"
"    );\n\n"
"    Event::listen(function (PodcastProcessed $event) {\n"
"        //\n"
"    });\n"
"}\n"
msgstr "use App\\Events\\PodcastProcessed;\n"
"use App\\Listeners\\SendPodcastNotification;\n"
"use Illuminate\\Support\\Facades\\Event;\n\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(\n"
"        PodcastProcessed::class,\n"
"        [SendPodcastNotification::class, 'handle']\n"
"    );\n\n"
"    Event::listen(function (PodcastProcessed $event) {\n"
"        //\n"
"    });\n"
"}\n"

#: docs/8.x/events.md:block 23 (header)
msgid "Queueable Anonymous Event Listeners"
msgstr "可放入佇列的匿名 Event Listener"

#: docs/8.x/events.md:block 24 (paragraph)
msgid "When registering closure based event listeners manually, you may wrap the listener closure within the `Illuminate\\Events\\queueable` function to instruct Laravel to execute the listener using the [queue](/docs/{{version}}/queues):"
msgstr "在註冊基於閉包的 Event Listener 時，可以將該 Listener 閉包以 `Illuminate\\Events\\queueable` 函式^[包裝](Wrap)起來，以指示 Laravel 使用 [Queue](/docs/{{version}}/queues) 來執行這個 Listener："

#: docs/8.x/events.md:block 25 (code)
msgid "use App\\Events\\PodcastProcessed;\n"
"use function Illuminate\\Events\\queueable;\n"
"use Illuminate\\Support\\Facades\\Event;\n\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(queueable(function (PodcastProcessed $event) {\n"
"        //\n"
"    }));\n"
"}\n"
msgstr "use App\\Events\\PodcastProcessed;\n"
"use function Illuminate\\Events\\queueable;\n"
"use Illuminate\\Support\\Facades\\Event;\n\n"
"/**\n"
" * Register any other events for your application.\n"
" *\n"
" * @return void\n"
" */\n"
"public function boot()\n"
"{\n"
"    Event::listen(queueable(function (PodcastProcessed $event) {\n"
"        //\n"
"    }));\n"
"}\n"

#: docs/8.x/events.md:block 26 (paragraph)
msgid "Like queued jobs, you may use the `onConnection`, `onQueue`, and `delay` methods to customize the execution of the queued listener:"
msgstr "就像佇列任務一樣，可以使用 `onConnection`、`onQueue`、`delay` 等方法來自訂放入佇列之 Listener 的執行："

#: docs/8.x/events.md:block 27 (code)
msgid "Event::listen(queueable(function (PodcastProcessed $event) {\n"
"    //\n"
"})->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));\n"
msgstr "Event::listen(queueable(function (PodcastProcessed $event) {\n"
"    //\n"
"})->onConnection('redis')->onQueue('podcasts')->delay(now()->addSeconds(10)));\n"

#: docs/8.x/events.md:block 28 (paragraph)
msgid "If you would like to handle anonymous queued listener failures, you may provide a closure to the `catch` method while defining the `queueable` listener. This closure will receive the event instance and the `Throwable` instance that caused the listener's failure:"
msgstr "若想處理執行失敗的匿名佇列 Listener，可在定義 `queueable` Listener` 時提供一個閉包給 `catch` 方法。這個閉包會收到 Event 實體以及一個導致 Listener 失敗的 `Throwable` 實體："

#: docs/8.x/events.md:block 29 (code)
msgid "use App\\Events\\PodcastProcessed;\n"
"use function Illuminate\\Events\\queueable;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Throwable;\n\n"
"Event::listen(queueable(function (PodcastProcessed $event) {\n"
"    //\n"
"})->catch(function (PodcastProcessed $event, Throwable $e) {\n"
"    // The queued listener failed...\n"
"}));\n"
msgstr "use App\\Events\\PodcastProcessed;\n"
"use function Illuminate\\Events\\queueable;\n"
"use Illuminate\\Support\\Facades\\Event;\n"
"use Throwable;\n\n"
"Event::listen(queueable(function (PodcastProcessed $event) {\n"
"    //\n"
"})->catch(function (PodcastProcessed $event, Throwable $e) {\n"
"    // 在佇列中執行的 Listener 執行失敗了...\n"
"}));\n"

#: docs/8.x/events.md:block 31 (header)
msgid "Wildcard Event Listeners"
msgstr "萬用字元 Event Listener"

#: docs/8.x/events.md:block 32 (paragraph)
msgid "You may even register listeners using the `*` as a wildcard parameter, allowing you to catch multiple events on the same listener. Wildcard listeners receive the event name as their first argument and the entire event data array as their second argument:"
msgstr "可以使用 `*` 作為^[萬用字元](Wildcard)參數來註冊 Listener，這樣我們就可以在同一個 Listener 上處理多個 Event。萬用字元 Listener 會🉑️事件名稱作為其第一個引數，而整個 Event 資料陣列則為其第二個引數："

#: docs/8.x/events.md:block 33 (code)
msgid "Event::listen('event.*', function ($eventName, array $data) {\n"
"    //\n"
"});\n"
msgstr "Event::listen('event.*', function ($eventName, array $data) {\n"
"    //\n"
"});\n"

#: docs/8.x/events.md:block 35 (header)
msgid "Event Discovery"
msgstr "Event Discovery"

#: docs/8.x/events.md:block 36 (paragraph)
msgid "Instead of registering events and listeners manually in the `$listen` array of the `EventServiceProvider`, you can enable automatic event discovery. When event discovery is enabled, Laravel will automatically find and register your events and listeners by scanning your application's `Listeners` directory. In addition, any explicitly defined events listed in the `EventServiceProvider` will still be registered."
msgstr "除了在 `EventServiceProvider` 的 `$listen` 陣列中手動指定 Listener 以外，還可以啟用 ^[Event Discovery](Event 發現)。當啟用 Event Discovery 時，Laravel 會搜尋專案的 `Listeners` 目錄來自動找到並註冊你的 Event 與 Listener。此外，列在 `EventServiceProvider` 中顯式定義的 Event 還是會被註冊。"

#: docs/8.x/events.md:block 37 (paragraph)
msgid "Laravel finds event listeners by scanning the listener classes using PHP's reflection services. When Laravel finds any listener class method that begins with `handle`, Laravel will register those methods as event listeners for the event that is type-hinted in the method's signature:"
msgstr "Laravel 會使用 PHP 的 Reflection 服務來搜尋 Listener 類別以尋找 Event Listener。當 Laravel 找到名稱以 `handle` 開頭的 Listener 類別方法時，Laravel 會從該方法^[簽章](Signature)上的^[型別提示](Type-Hint)中取得 Event，並將該方法註冊為該 Event 的 Listener："

#: docs/8.x/events.md:block 38 (code)
msgid "use App\\Events\\PodcastProcessed;\n\n"
"class SendPodcastNotification\n"
"{\n"
"    /**\n"
"     * Handle the given event.\n"
"     *\n"
"     * @param  \\App\\Events\\PodcastProcessed  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(PodcastProcessed $event)\n"
"    {\n"
"        //\n"
"    }\n"
"}\n"
msgstr "use App\\Events\\PodcastProcessed;\n\n"
"class SendPodcastNotification\n"
"{\n"
"    /**\n"
"     * Handle the given event.\n"
"     *\n"
"     * @param  \\App\\Events\\PodcastProcessed  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(PodcastProcessed $event)\n"
"    {\n"
"        //\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 39 (paragraph)
msgid "Event discovery is disabled by default, but you can enable it by overriding the `shouldDiscoverEvents` method of your application's `EventServiceProvider`:"
msgstr "Event Discovery 預設是關閉的，但可以在 `EventServiceProvider` 上複寫 `shouldDiscoverEvents` 方法來啟用："

#: docs/8.x/events.md:block 40 (code)
msgid "/**\n"
" * Determine if events and listeners should be automatically discovered.\n"
" *\n"
" * @return bool\n"
" */\n"
"public function shouldDiscoverEvents()\n"
"{\n"
"    return true;\n"
"}\n"
msgstr "/**\n"
" * Determine if events and listeners should be automatically discovered.\n"
" *\n"
" * @return bool\n"
" */\n"
"public function shouldDiscoverEvents()\n"
"{\n"
"    return true;\n"
"}\n"

#: docs/8.x/events.md:block 41 (paragraph)
msgid "By default, all listeners within your application's `app/Listeners` directory will be scanned. If you would like to define additional directories to scan, you may override the `discoverEventsWithin` method in your `EventServiceProvider`:"
msgstr "預設情況下，會掃描專案 `app/Listeners` 目錄下的所有 Listener。若想定義其他要掃描的目錄，可在 `EventServiceProvider` 上複寫 `discoverEventsWithin` 方法："

#: docs/8.x/events.md:block 42 (code)
msgid "/**\n"
" * Get the listener directories that should be used to discover events.\n"
" *\n"
" * @return array\n"
" */\n"
"protected function discoverEventsWithin()\n"
"{\n"
"    return [\n"
"        $this->app->path('Listeners'),\n"
"    ];\n"
"}\n"
msgstr "/**\n"
" * Get the listener directories that should be used to discover events.\n"
" *\n"
" * @return array\n"
" */\n"
"protected function discoverEventsWithin()\n"
"{\n"
"    return [\n"
"        $this->app->path('Listeners'),\n"
"    ];\n"
"}\n"

#: docs/8.x/events.md:block 44 (header)
msgid "Event Discovery In Production"
msgstr "在正式環境下使用 Event Discovery"

#: docs/8.x/events.md:block 45 (paragraph)
msgid "In production, it is not efficient for the framework to scan all of your listeners on every request. Therefore, during your deployment process, you should run the `event:cache` Artisan command to cache a manifest of all of your application's events and listeners. This manifest will be used by the framework to speed up the event registration process. The `event:clear` command may be used to destroy the cache."
msgstr "在^[正式環境](Production)中，讓 Laravel 在每個 Request 上都掃描所有 Listener 很沒效率。因此，在部署過程，請記得執行 `event:cache` Artisan 指令來為專案的所有 Event 與 Listener 建立一個^[快取資訊清單](Cache Manifest)。Laravel 會使用這個資訊清單來加快 Event 的註冊流程。可使用 `event:clear` 來清除該快取。"

#: docs/8.x/events.md:block 47 (header)
msgid "Defining Events"
msgstr "定義 Event"

#: docs/8.x/events.md:block 48 (paragraph)
msgid "An event class is essentially a data container which holds the information related to the event. For example, let's assume an `App\\Events\\OrderShipped` event receives an [Eloquent ORM](/docs/{{version}}/eloquent) object:"
msgstr "Event 類別基本上就是一個資料容器，用來保存與該 Event 有關的資訊。舉例來說，假設有個會接收 [Eloquent ORM](/docs/{{version}}/eloquent) 物件的 `App\\Events\\OrderShipped` Event："

#: docs/8.x/events.md:block 49 (code)
msgid "<?php\n\n"
"namespace App\\Events;\n\n"
"use App\\Models\\Order;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Foundation\\Events\\Dispatchable;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class OrderShipped\n"
"{\n"
"    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n"
"    /**\n"
"     * The order instance.\n"
"     *\n"
"     * @var \\App\\Models\\Order\n"
"     */\n"
"    public $order;\n\n"
"    /**\n"
"     * Create a new event instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Order  $order\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Order $order)\n"
"    {\n"
"        $this->order = $order;\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Events;\n\n"
"use App\\Models\\Order;\n"
"use Illuminate\\Broadcasting\\InteractsWithSockets;\n"
"use Illuminate\\Foundation\\Events\\Dispatchable;\n"
"use Illuminate\\Queue\\SerializesModels;\n\n"
"class OrderShipped\n"
"{\n"
"    use Dispatchable, InteractsWithSockets, SerializesModels;\n\n"
"    /**\n"
"     * The order instance.\n"
"     *\n"
"     * @var \\App\\Models\\Order\n"
"     */\n"
"    public $order;\n\n"
"    /**\n"
"     * Create a new event instance.\n"
"     *\n"
"     * @param  \\App\\Models\\Order  $order\n"
"     * @return void\n"
"     */\n"
"    public function __construct(Order $order)\n"
"    {\n"
"        $this->order = $order;\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 50 (paragraph)
msgid "As you can see, this event class contains no logic. It is a container for the `App\\Models\\Order` instance that was purchased. The `SerializesModels` trait used by the event will gracefully serialize any Eloquent models if the event object is serialized using PHP's `serialize` function, such as when utilizing [queued listeners](#queued-event-listeners)."
msgstr "就像這樣，這個 Event 類別中並不包含邏輯。這個類別只是已付款訂單 `App\\Models\\Order` 實體的容器而已。若要使用 PHP 的 `serialize` 方法序列化這個 Event 物件時 (如：[佇列 Listener] 會序列化 Event)，這個 Event 使用的 `SerializesModels` Trait 會妥善序列化所有的 Eloquent Model。"

#: docs/8.x/events.md:block 52 (header)
msgid "Defining Listeners"
msgstr "定義 Listener"

#: docs/8.x/events.md:block 53 (paragraph)
msgid "Next, let's take a look at the listener for our example event. Event listeners receive event instances in their `handle` method. The `event:generate` and `make:listener` Artisan commands will automatically import the proper event class and type-hint the event on the `handle` method. Within the `handle` method, you may perform any actions necessary to respond to the event:"
msgstr "接著，來看看要給我們的範例 Event 使用的 Listener。Event Listener 會在 `handle` 方法中接收 Event 實體。`event:generate` 與 `make:listener` Artisan 指令會自動載入適當的 Event 類別，並在 `handle` 方法上型別提示這個 Event。在 `handle` 方法中，我們就可以針對該 Event 回應適當的動作："

#: docs/8.x/events.md:block 54 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n\n"
"class SendShipmentNotification\n"
"{\n"
"    /**\n"
"     * Create the event listener.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        // Access the order using $event->order...\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n\n"
"class SendShipmentNotification\n"
"{\n"
"    /**\n"
"     * Create the event listener.\n"
"     *\n"
"     * @return void\n"
"     */\n"
"    public function __construct()\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        // Access the order using $event->order...\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 55 (quote)
msgid "{tip} Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Laravel [service container](/docs/{{version}}/container), so dependencies will be injected automatically."
msgstr "{tip} 也可以在 Event Listener 的 ^[Constructor](建構函式) 中型別提示任何的相依性。所有的 Event Listener 都會使用 Laravel [Service Provider](/docs/{{version}}/container) 解析，所以這些相依性也會自動被插入。"

#: docs/8.x/events.md:block 57 (header)
msgid "Stopping The Propagation Of An Event"
msgstr "停止 Event 的^[傳播](Propagation)"

#: docs/8.x/events.md:block 58 (paragraph)
msgid "Sometimes, you may wish to stop the propagation of an event to other listeners. You may do so by returning `false` from your listener's `handle` method."
msgstr "有時候，我們可能會想停止將某個 Event ^[傳播](Propagation)到另一個 Listener 上。若要停止傳播，只要在 Listener 的 `handle` 方法上回傳 `false` 即可。"

#: docs/8.x/events.md:block 60 (header)
msgid "Queued Event Listeners"
msgstr "放入佇列的 Event Listener"

#: docs/8.x/events.md:block 61 (paragraph)
msgid "Queueing listeners can be beneficial if your listener is going to perform a slow task such as sending an email or making an HTTP request. Before using queued listeners, make sure to [configure your queue](/docs/{{version}}/queues) and start a queue worker on your server or local development environment."
msgstr "若你的 Listener 要處理一些很慢的任務 (如寄送 E-Mail 或產生 HTTP Request)，則 Listener 放入佇列可獲得許多好處。在使用佇列 Listener 前，請先確定已[設定佇列](/docs/{{version}}/queues)，並在伺服器或本機開發環境上開啟一個 ^[Queue Worker](佇列背景工作程式)。"

#: docs/8.x/events.md:block 62 (paragraph)
msgid "To specify that a listener should be queued, add the `ShouldQueue` interface to the listener class. Listeners generated by the `event:generate` and `make:listener` Artisan commands already have this interface imported into the current namespace so you can use it immediately:"
msgstr "要將 Listener 指定為放在佇列裡執行，請在該 Listener 類別上加上 `ShouldQueue` 介面。由 `event:generate` 與 `make:listener` Artisan 指令產生的 Listener 都已先將這個介面匯入到目前的 ^[Namespace](命名空間) 下了，因此我們可以直接使用該介面："

#: docs/8.x/events.md:block 63 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    //\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    //\n"
"}\n"

#: docs/8.x/events.md:block 64 (paragraph)
msgid "That's it! Now, when an event handled by this listener is dispatched, the listener will automatically be queued by the event dispatcher using Laravel's [queue system](/docs/{{version}}/queues). If no exceptions are thrown when the listener is executed by the queue, the queued job will automatically be deleted after it has finished processing."
msgstr "就這樣！之後，當這個 Listener 要處理的 Event 被^[分派](Dispatch)後，Event ^[Dispatcher](分派程式) 就會自動使用 Laravel 的[佇列系統](/docs/{{version}}/queues)來將這個 Listener 放入佇列。若佇列在執行該 Listener 時沒有^[擲回](Throw)任何 Exception，則該佇列任務會在執行完畢後自動刪除。"

#: docs/8.x/events.md:block 66 (header)
msgid "Customizing The Queue Connection & Queue Name"
msgstr "自訂佇列連線與佇列名稱"

#: docs/8.x/events.md:block 67 (paragraph)
msgid "If you would like to customize the queue connection, queue name, or queue delay time of an event listener, you may define the `$connection`, `$queue`, or `$delay` properties on your listener class:"
msgstr "若想自訂 Event Listener 的佇列連線、佇列名稱、或是佇列^[延遲時間](Delay Time)，可在 Listener 類別上定義 `$connection`、`$queue`、`$delay` 等屬性："

#: docs/8.x/events.md:block 68 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The name of the connection the job should be sent to.\n"
"     *\n"
"     * @var string|null\n"
"     */\n"
"    public $connection = 'sqs';\n\n"
"    /**\n"
"     * The name of the queue the job should be sent to.\n"
"     *\n"
"     * @var string|null\n"
"     */\n"
"    public $queue = 'listeners';\n\n"
"    /**\n"
"     * The time (seconds) before the job should be processed.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $delay = 60;\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * The name of the connection the job should be sent to.\n"
"     *\n"
"     * @var string|null\n"
"     */\n"
"    public $connection = 'sqs';\n\n"
"    /**\n"
"     * The name of the queue the job should be sent to.\n"
"     *\n"
"     * @var string|null\n"
"     */\n"
"    public $queue = 'listeners';\n\n"
"    /**\n"
"     * The time (seconds) before the job should be processed.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $delay = 60;\n"
"}\n"

#: docs/8.x/events.md:block 69 (paragraph)
msgid "If you would like to define the listener's queue connection or queue name at runtime, you may define `viaConnection` or `viaQueue` methods on the listener:"
msgstr "若想在執行階段定義 Listener 的佇列連線或佇列名稱，可以在 Listener 上定義 `viaConnection` 或 `viaQueue` 方法："

#: docs/8.x/events.md:block 70 (code)
msgid "/**\n"
" * Get the name of the listener's queue connection.\n"
" *\n"
" * @return string\n"
" */\n"
"public function viaConnection()\n"
"{\n"
"    return 'sqs';\n"
"}\n\n"
"/**\n"
" * Get the name of the listener's queue.\n"
" *\n"
" * @return string\n"
" */\n"
"public function viaQueue()\n"
"{\n"
"    return 'listeners';\n"
"}\n"
msgstr "/**\n"
" * Get the name of the listener's queue connection.\n"
" *\n"
" * @return string\n"
" */\n"
"public function viaConnection()\n"
"{\n"
"    return 'sqs';\n"
"}\n\n"
"/**\n"
" * Get the name of the listener's queue.\n"
" *\n"
" * @return string\n"
" */\n"
"public function viaQueue()\n"
"{\n"
"    return 'listeners';\n"
"}\n"

#: docs/8.x/events.md:block 72 (header)
msgid "Conditionally Queueing Listeners"
msgstr "有條件地將 Listener 放入佇列"

#: docs/8.x/events.md:block 73 (paragraph)
msgid "Sometimes, you may need to determine whether a listener should be queued based on some data that are only available at runtime. To accomplish this, a `shouldQueue` method may be added to a listener to determine whether the listener should be queued. If the `shouldQueue` method returns `false`, the listener will not be executed:"
msgstr "有時候，我們可能需要依據一些只有在執行階段才能取得的資料來判斷是否要將 Listener 放入佇列。若要在執行階段判斷是否將 Listner 放入佇列，可在 Listner 中新增一個 `shouldQueue` 方法來判斷。若 `shouldQueue` 方法回傳 `false`，則該 Listener 不會被執行："

#: docs/8.x/events.md:block 74 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderCreated;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class RewardGiftCard implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * Reward a gift card to the customer.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderCreated  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderCreated $event)\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Determine whether the listener should be queued.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderCreated  $event\n"
"     * @return bool\n"
"     */\n"
"    public function shouldQueue(OrderCreated $event)\n"
"    {\n"
"        return $event->order->subtotal >= 5000;\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderCreated;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n\n"
"class RewardGiftCard implements ShouldQueue\n"
"{\n"
"    /**\n"
"     * Reward a gift card to the customer.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderCreated  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderCreated $event)\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Determine whether the listener should be queued.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderCreated  $event\n"
"     * @return bool\n"
"     */\n"
"    public function shouldQueue(OrderCreated $event)\n"
"    {\n"
"        return $event->order->subtotal >= 5000;\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 76 (header)
msgid "Manually Interacting With The Queue"
msgstr "手動使用佇列"

#: docs/8.x/events.md:block 77 (paragraph)
msgid "If you need to manually access the listener's underlying queue job's `delete` and `release` methods, you may do so using the `Illuminate\\Queue\\InteractsWithQueue` trait. This trait is imported by default on generated listeners and provides access to these methods:"
msgstr "若有需要手動存取某個 Listener 底層佇列任務的 `delete` 與 `release` 方法，可使用 `Illuminate\\Queue\\InteractsWithQueue` Trait。在產生的 Listener 上已預設匯入了這個 Trait。有了 `InteractsWithQueue` 就可以存取這些方法："

#: docs/8.x/events.md:block 78 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        if (true) {\n"
"            $this->release(30);\n"
"        }\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        if (true) {\n"
"            $this->release(30);\n"
"        }\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 80 (header)
msgid "Queued Event Listeners & Database Transactions"
msgstr "佇列的 Event Listener 與資料庫 Transaction"

#: docs/8.x/events.md:block 81 (paragraph)
msgid "When queued listeners are dispatched within database transactions, they may be processed by the queue before the database transaction has committed. When this happens, any updates you have made to models or database records during the database transaction may not yet be reflected in the database. In addition, any models or database records created within the transaction may not exist in the database. If your listener depends on these models, unexpected errors can occur when the job that dispatches the queued listener is processed."
msgstr "當 Event Listener 是在資料庫 Transaction 內^[分派](Dispatch)的時候，這個 Listner 可能會在資料庫 Transaction 被 Commit 前就被佇列進行處理了。發生這種情況時，在資料庫 Transaction 期間對 Model 或資料庫記錄所做出的更新可能都還未反應到資料庫內。另外，所有在 Transaction 期間新增的 Model 或資料庫記錄也可能還未出現在資料庫內。若 Listner 有依賴這些 Model 的話，在處理分派該佇列 Listener 的任務時可能會出現未預期的錯誤。"

#: docs/8.x/events.md:block 82 (paragraph)
msgid "If your queue connection's `after_commit` configuration option is set to `false`, you may still indicate that a particular queued listener should be dispatched after all open database transactions have been committed by defining an `$afterCommit` property on the listener class:"
msgstr "若佇列連線的 `after_commit` 設定選項是 `false`，則我們還是可以通過在 Listner 類別上定義 `$afterCommit` 屬性來標示出這個佇列 Listener 應在資料庫 Transaction 被 Commit 後才可進行分派："

#: docs/8.x/events.md:block 83 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    public $afterCommit = true;\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    public $afterCommit = true;\n"
"}\n"

#: docs/8.x/events.md:block 84 (quote)
msgid "{tip} To learn more about working around these issues, please review the documentation regarding [queued jobs and database transactions](/docs/{{version}}/queues#jobs-and-database-transactions)."
msgstr "{tip} 要瞭解更多有關這類問題的解決方法，請參考有關[佇列任務與資料庫 Transaction](/docs/{{version}}/queues#jobs-and-database-transactions) 有關的說明文件。"

#: docs/8.x/events.md:block 86 (header)
msgid "Handling Failed Jobs"
msgstr "處理失敗的任務"

#: docs/8.x/events.md:block 87 (paragraph)
msgid "Sometimes your queued event listeners may fail. If queued listener exceeds the maximum number of attempts as defined by your queue worker, the `failed` method will be called on your listener. The `failed` method receives the event instance and the `Throwable` that caused the failure:"
msgstr "有時候，放入佇列的 Listener 可能會執行失敗。若佇列的 Listener 達到最大 Queue Worker 所定義的最大嘗試次數，就會呼叫 Listener 上的 `failed` 方法。`failed` 方法會接收一個 Event 實體，以及導致失敗的 `Throwable`："

#: docs/8.x/events.md:block 88 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Handle a job failure.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @param  \\Throwable  $exception\n"
"     * @return void\n"
"     */\n"
"    public function failed(OrderShipped $event, $exception)\n"
"    {\n"
"        //\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * Handle the event.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @return void\n"
"     */\n"
"    public function handle(OrderShipped $event)\n"
"    {\n"
"        //\n"
"    }\n\n"
"    /**\n"
"     * Handle a job failure.\n"
"     *\n"
"     * @param  \\App\\Events\\OrderShipped  $event\n"
"     * @param  \\Throwable  $exception\n"
"     * @return void\n"
"     */\n"
"    public function failed(OrderShipped $event, $exception)\n"
"    {\n"
"        //\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 90 (header)
msgid "Specifying Queued Listener Maximum Attempts"
msgstr "指定佇列 Listener 的最大嘗試次數"

#: docs/8.x/events.md:block 91 (paragraph)
msgid "If one of your queued listeners is encountering an error, you likely do not want it to keep retrying indefinitely. Therefore, Laravel provides various ways to specify how many times or for how long a listener may be attempted."
msgstr "若有某個佇列 Listener 遇到錯誤，我們通常不會想讓這個 Listener 一直重試。因此，Laravel 提供了多種定義 Listener 重試次數的方法。"

#: docs/8.x/events.md:block 92 (paragraph)
msgid "You may define `$tries` property on your listener class to specify how many times the listener may be attempted before it is considered to have failed:"
msgstr "可以在 Listener 類別中定義 `$tries` 屬性來指定要嘗試多少次後才將其視為執行失敗："

#: docs/8.x/events.md:block 93 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * The number of times the queued listener may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 5;\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use App\\Events\\OrderShipped;\n"
"use Illuminate\\Contracts\\Queue\\ShouldQueue;\n"
"use Illuminate\\Queue\\InteractsWithQueue;\n\n"
"class SendShipmentNotification implements ShouldQueue\n"
"{\n"
"    use InteractsWithQueue;\n\n"
"    /**\n"
"     * The number of times the queued listener may be attempted.\n"
"     *\n"
"     * @var int\n"
"     */\n"
"    public $tries = 5;\n"
"}\n"

#: docs/8.x/events.md:block 94 (paragraph)
msgid "As an alternative to defining how many times a listener may be attempted before it fails, you may define a time at which the listener should no longer be attempted. This allows a listener to be attempted any number of times within a given time frame. To define the time at which a listener should no longer be attempted, add a `retryUntil` method to your listener class. This method should return a `DateTime` instance:"
msgstr "除了定義 Listener 重試多少次要視為失敗以外，也可以限制 Listener 嘗試執行的時間長度。這樣一來，在指定的時間範圍內，Listener 就可以不斷重試。若要定義最長可重試時間，請在 Listener 類別中定義一個 `retryUntil` 方法。該方法應回傳 `DateTime` 實體："

#: docs/8.x/events.md:block 95 (code)
msgid "/**\n"
" * Determine the time at which the listener should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(5);\n"
"}\n"
msgstr "/**\n"
" * Determine the time at which the listener should timeout.\n"
" *\n"
" * @return \\DateTime\n"
" */\n"
"public function retryUntil()\n"
"{\n"
"    return now()->addMinutes(5);\n"
"}\n"

#: docs/8.x/events.md:block 97 (header)
msgid "Dispatching Events"
msgstr "分派 Event"

#: docs/8.x/events.md:block 98 (paragraph)
msgid "To dispatch an event, you may call the static `dispatch` method on the event. This method is made available on the event by the `Illuminate\\Foundation\\Events\\Dispatchable` trait. Any arguments passed to the `dispatch` method will be passed to the event's constructor:"
msgstr "若要分派 Event，可呼叫該 Event 上的靜態 `dispatch` 方法。這個方法由 `Illuminate\\Foundation\\Events\\Dispatchable` Trait 提供。任何傳入 `dispatch` 方法的引數會被傳給 Event 的 Constructor："

#: docs/8.x/events.md:block 99 (code)
msgid "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Events\\OrderShipped;\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Models\\Order;\n"
"use Illuminate\\Http\\Request;\n\n"
"class OrderShipmentController extends Controller\n"
"{\n"
"    /**\n"
"     * Ship the given order.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $order = Order::findOrFail($request->order_id);\n\n"
"        // Order shipment logic...\n\n"
"        OrderShipped::dispatch($order);\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Http\\Controllers;\n\n"
"use App\\Events\\OrderShipped;\n"
"use App\\Http\\Controllers\\Controller;\n"
"use App\\Models\\Order;\n"
"use Illuminate\\Http\\Request;\n\n"
"class OrderShipmentController extends Controller\n"
"{\n"
"    /**\n"
"     * Ship the given order.\n"
"     *\n"
"     * @param  \\Illuminate\\Http\\Request  $request\n"
"     * @return \\Illuminate\\Http\\Response\n"
"     */\n"
"    public function store(Request $request)\n"
"    {\n"
"        $order = Order::findOrFail($request->order_id);\n\n"
"        // Order shipment logic...\n\n"
"        OrderShipped::dispatch($order);\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 100 (quote)
msgid "{tip} When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Laravel's [built-in testing helpers](/docs/{{version}}/mocking#event-fake) makes it a cinch."
msgstr "{tip} 在測試時，若能在不實際觸發 Listener 的情況下判斷是否有分派特定 Event 會很實用。Laravel 的[內建測試輔助函式](/docs/{{version}}/mocking#event-fake)就能讓我們在不實際觸發 Listener 的情況下分派 Event。"

#: docs/8.x/events.md:block 102 (header)
msgid "Event Subscribers"
msgstr "Event Subscriber"

#: docs/8.x/events.md:block 104 (header)
msgid "Writing Event Subscribers"
msgstr "撰寫 Event Subscriber"

#: docs/8.x/events.md:block 105 (paragraph)
msgid "Event subscribers are classes that may subscribe to multiple events from within the subscriber class itself, allowing you to define several event handlers within a single class. Subscribers should define a `subscribe` method, which will be passed an event dispatcher instance. You may call the `listen` method on the given dispatcher to register event listeners:"
msgstr "Event Subscriber 是一種類別，在 Subscriber 類別內可以^[訂閱](Subscribe)多個 Event，讓我們能在單一類別中定義多個 Event 的^[處理程式](Handler)。Subscriber 應定義 `subscribe` 方法，會傳入一個 Event Dispatcher 實體給該方法。我們可以在給定的 Dispatcher 上呼叫 `listen` 方法來註冊 Event Listener："

#: docs/8.x/events.md:block 106 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Auth\\Events\\Login;\n"
"use Illuminate\\Auth\\Events\\Logout;\n\n"
"class UserEventSubscriber\n"
"{\n"
"    /**\n"
"     * Handle user login events.\n"
"     */\n"
"    public function handleUserLogin($event) {}\n\n"
"    /**\n"
"     * Handle user logout events.\n"
"     */\n"
"    public function handleUserLogout($event) {}\n\n"
"    /**\n"
"     * Register the listeners for the subscriber.\n"
"     *\n"
"     * @param  \\Illuminate\\Events\\Dispatcher  $events\n"
"     * @return void\n"
"     */\n"
"    public function subscribe($events)\n"
"    {\n"
"        $events->listen(\n"
"            Login::class,\n"
"            [UserEventSubscriber::class, 'handleUserLogin']\n"
"        );\n\n"
"        $events->listen(\n"
"            Logout::class,\n"
"            [UserEventSubscriber::class, 'handleUserLogout']\n"
"        );\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Auth\\Events\\Login;\n"
"use Illuminate\\Auth\\Events\\Logout;\n\n"
"class UserEventSubscriber\n"
"{\n"
"    /**\n"
"     * Handle user login events.\n"
"     */\n"
"    public function handleUserLogin($event) {}\n\n"
"    /**\n"
"     * Handle user logout events.\n"
"     */\n"
"    public function handleUserLogout($event) {}\n\n"
"    /**\n"
"     * Register the listeners for the subscriber.\n"
"     *\n"
"     * @param  \\Illuminate\\Events\\Dispatcher  $events\n"
"     * @return void\n"
"     */\n"
"    public function subscribe($events)\n"
"    {\n"
"        $events->listen(\n"
"            Login::class,\n"
"            [UserEventSubscriber::class, 'handleUserLogin']\n"
"        );\n\n"
"        $events->listen(\n"
"            Logout::class,\n"
"            [UserEventSubscriber::class, 'handleUserLogout']\n"
"        );\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 107 (paragraph)
msgid "If your event listener methods are defined within the subscriber itself, you may find it more convenient to return an array of events and method names from the subscriber's `subscribe` method. Laravel will automatically determine the subscriber's class name when registering the event listeners:"
msgstr "在 Subscriber 內可以定義 Event Listener 方法，但比起這麼做，在 Subscriber 的 `subscribe` 方法內回傳一組包含 Event 與方法名稱的陣列應該會更方便。在註冊 Event Listener 時，Laravel 會自動判斷該 Subscriber 的類別名稱："

#: docs/8.x/events.md:block 108 (code)
msgid "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Auth\\Events\\Login;\n"
"use Illuminate\\Auth\\Events\\Logout;\n\n"
"class UserEventSubscriber\n"
"{\n"
"    /**\n"
"     * Handle user login events.\n"
"     */\n"
"    public function handleUserLogin($event) {}\n\n"
"    /**\n"
"     * Handle user logout events.\n"
"     */\n"
"    public function handleUserLogout($event) {}\n\n"
"    /**\n"
"     * Register the listeners for the subscriber.\n"
"     *\n"
"     * @param  \\Illuminate\\Events\\Dispatcher  $events\n"
"     * @return array\n"
"     */\n"
"    public function subscribe($events)\n"
"    {\n"
"        return [\n"
"            Login::class => 'handleUserLogin',\n"
"            Logout::class => 'handleUserLogout',\n"
"        ];\n"
"    }\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Listeners;\n\n"
"use Illuminate\\Auth\\Events\\Login;\n"
"use Illuminate\\Auth\\Events\\Logout;\n\n"
"class UserEventSubscriber\n"
"{\n"
"    /**\n"
"     * Handle user login events.\n"
"     */\n"
"    public function handleUserLogin($event) {}\n\n"
"    /**\n"
"     * Handle user logout events.\n"
"     */\n"
"    public function handleUserLogout($event) {}\n\n"
"    /**\n"
"     * Register the listeners for the subscriber.\n"
"     *\n"
"     * @param  \\Illuminate\\Events\\Dispatcher  $events\n"
"     * @return array\n"
"     */\n"
"    public function subscribe($events)\n"
"    {\n"
"        return [\n"
"            Login::class => 'handleUserLogin',\n"
"            Logout::class => 'handleUserLogout',\n"
"        ];\n"
"    }\n"
"}\n"

#: docs/8.x/events.md:block 110 (header)
msgid "Registering Event Subscribers"
msgstr "註冊 Event Subscriber"

#: docs/8.x/events.md:block 111 (paragraph)
msgid "After writing the subscriber, you are ready to register it with the event dispatcher. You may register subscribers using the `$subscribe` property on the `EventServiceProvider`. For example, let's add the `UserEventSubscriber` to the list:"
msgstr "寫好 Subscriber 後，就可以將 Subscriber 註冊到 Dispatcher 上了。可以使用 `EventServiceProvider` 的 `$subscribe` 屬性來註冊 Subscriber。舉例來說，我們來將 `UserEventSubscriber` 加到這個列表上："

#: docs/8.x/events.md:block 112 (code)
msgid "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Listeners\\UserEventSubscriber;\n"
"use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\n\n"
"class EventServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * The event listener mappings for the application.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $listen = [\n"
"        //\n"
"    ];\n\n"
"    /**\n"
"     * The subscriber classes to register.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $subscribe = [\n"
"        UserEventSubscriber::class,\n"
"    ];\n"
"}\n"
msgstr "<?php\n\n"
"namespace App\\Providers;\n\n"
"use App\\Listeners\\UserEventSubscriber;\n"
"use Illuminate\\Foundation\\Support\\Providers\\EventServiceProvider as ServiceProvider;\n\n"
"class EventServiceProvider extends ServiceProvider\n"
"{\n"
"    /**\n"
"     * The event listener mappings for the application.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $listen = [\n"
"        //\n"
"    ];\n\n"
"    /**\n"
"     * The subscriber classes to register.\n"
"     *\n"
"     * @var array\n"
"     */\n"
"    protected $subscribe = [\n"
"        UserEventSubscriber::class,\n"
"    ];\n"
"}\n"

#: docs/9.x/events.md:block 11 (quote)
msgid "**Note** The `event:list` command may be used to display a list of all events and listeners registered by your application."
msgstr "**Note** 可以使用 `event:list` 指令來顯示程式中註冊的所有 Event 與 Listener 列表。"

#: docs/9.x/events.md:block 37 (paragraph)
msgid "Laravel finds event listeners by scanning the listener classes using PHP's reflection services. When Laravel finds any listener class method that begins with `handle` or `__invoke`, Laravel will register those methods as event listeners for the event that is type-hinted in the method's signature:"
msgstr "Laravel 會使用 PHP 的 Reflection 服務來搜尋 Listener 類別以尋找 Event Listener。當 Laravel 找到名稱以 `handle` 或 `__invoke` 開頭的 Listener 類別方法時，Laravel 會從該方法^[簽章](Signature)上的^[型別提示](Type-Hint)中取得 Event，並將該方法註冊為該 Event 的 Listener："

#: docs/9.x/events.md:block 55 (quote)
msgid "**Note** Your event listeners may also type-hint any dependencies they need on their constructors. All event listeners are resolved via the Laravel [service container](/docs/{{version}}/container), so dependencies will be injected automatically."
msgstr "**Note** 也可以在 Event Listener 的 ^[Constructor](建構函式) 中型別提示任何的相依性。所有的 Event Listener 都會使用 Laravel [Service Provider](/docs/{{version}}/container) 解析，所以這些相依性也會自動被插入。"

#: docs/9.x/events.md:block 84 (quote)
msgid "**Note** To learn more about working around these issues, please review the documentation regarding [queued jobs and database transactions](/docs/{{version}}/queues#jobs-and-database-transactions)."
msgstr "**Note** 要瞭解更多有關這類問題的解決方法，請參考有關[佇列任務與資料庫 Transaction](/docs/{{version}}/queues#jobs-and-database-transactions) 有關的說明文件。"

#: docs/9.x/events.md:block 87 (paragraph)
msgid "Sometimes your queued event listeners may fail. If the queued listener exceeds the maximum number of attempts as defined by your queue worker, the `failed` method will be called on your listener. The `failed` method receives the event instance and the `Throwable` that caused the failure:"
msgstr "有時候，放入佇列的 Listener 可能會執行失敗。若該佇列的 Listener 達到最大 Queue Worker 所定義的最大嘗試次數，就會呼叫 Listener 上的 `failed` 方法。`failed` 方法會接收一個 Event 實體，以及導致失敗的 `Throwable`："

#: docs/9.x/events.md:block 92 (paragraph)
msgid "You may define a `$tries` property on your listener class to specify how many times the listener may be attempted before it is considered to have failed:"
msgstr "可以在 Listener 類別中定義 `$tries` 屬性來指定要嘗試多少次後才將其視為執行失敗："

#: docs/9.x/events.md:block 100 (paragraph)
msgid "If you would like to conditionally dispatch an event, you may use the `dispatchIf` and `dispatchUnless` methods:"
msgstr "若想要有條件地分派 Event，可使用 `dispatchIf` 與` `dispatchUnless` 方法："

#: docs/9.x/events.md:block 101 (code)
msgid "OrderShipped::dispatchIf($condition, $order);\n\n"
"OrderShipped::dispatchUnless($condition, $order);\n"
msgstr "OrderShipped::dispatchIf($condition, $order);\n\n"
"OrderShipped::dispatchUnless($condition, $order);\n"

#: docs/9.x/events.md:block 102 (quote)
msgid "**Note** When testing, it can be helpful to assert that certain events were dispatched without actually triggering their listeners. Laravel's [built-in testing helpers](/docs/{{version}}/mocking#event-fake) makes it a cinch."
msgstr "**Note** 在測試時，若能在不實際觸發 Listener 的情況下判斷是否有分派特定 Event 會很實用。Laravel 的[內建測試輔助函式](/docs/{{version}}/mocking#event-fake)就能讓我們在不實際觸發 Listener 的情況下分派 Event。"

